/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthClient {
  constructor(private pictureparkApiUrl: string, private customerAlias?: string) {
  }

  getBaseUrl(defaultUrl: string) {
    return this.pictureparkApiUrl;
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.customerAlias) {
      (<Headers>options.headers).set('Picturepark-CustomerAlias', this.customerAlias);
    }

    return Promise.resolve(options);
  }
}

export class PictureparkClientBase {
  constructor(private authClient: AuthClient) {

  }

  getBaseUrl(defaultUrl: string) {
    return this.authClient ? this.authClient.getBaseUrl(defaultUrl) : defaultUrl;
  }

  transformOptions(options: RequestInit): Promise<RequestInit> {
    return this.authClient ? this.authClient.transformHttpRequestOptions(options) : Promise.resolve(options);
  }
}

export class BusinessProcessClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param businessProcessSearchRequest The business process request
     * @return BusinessProcessSearchResult
     */
    search(businessProcessSearchRequest: BusinessProcessSearchRequest): Promise<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<BusinessProcessSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessSearchResult>(<any>null);
    }

    /**
     * Wait for lifeCycles
     * @param processId The process id
     * @param lifeCycleIds (optional) Business process lifeCycle to wait for
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitForLifeCycleResult
     */
    waitForLifeCycles(processId: string, lifeCycleIds?: BusinessProcessLifeCycle[] | null | undefined, timeout?: string | null | undefined): Promise<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitLifeCycles?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (lifeCycleIds !== undefined)
            lifeCycleIds && lifeCycleIds.forEach(item => { url_ += "lifeCycleIds=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForLifeCycles(_response);
        });
    }

    protected processWaitForLifeCycles(response: Response): Promise<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitForLifeCycleResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Wait for states
     * @param processId The process id
     * @param states (optional) Business process states to wait for
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states?: string[] | null | undefined, timeout?: string | null | undefined): Promise<BusinessProcessWaitForStateResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitStates?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForStates(_response);
        });
    }

    protected processWaitForStates(response: Response): Promise<BusinessProcessWaitForStateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitForStateResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitForStateResult>(<any>null);
    }

    /**
     * Wait for completion
     * @param processId The process id
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(processId: string, timeout?: string | null | undefined): Promise<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitCompletion?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForCompletion(_response);
        });
    }

    protected processWaitForCompletion(response: Response): Promise<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitForLifeCycleResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Get details
     * @param processId The process id
     * @return BusinessProcessDetails
     */
    getDetails(processId: string): Promise<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/details";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDetails(_response);
        });
    }

    protected processGetDetails(response: Response): Promise<BusinessProcessDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessDetails>(<any>null);
    }
}

export class ChannelClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get list of channels
     */
    getChannels(): Promise<Channel[]> {
        let url_ = this.baseUrl + "/v1/channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetChannels(_response);
        });
    }

    protected processGetChannels(response: Response): Promise<Channel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Channel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Channel[]>(<any>null);
    }
}

export class ContentClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get detail - single
     * @param contentId The content id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @return ContentDetail
     */
    get(contentId: string, resolveBehaviours?: ContentResolveBehaviour[] | null | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Delete - single
     * @param contentId the id of the content to delete
     * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     */
    delete(contentId: string, forceReferenceRemoval?: boolean | null | undefined, timeout?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get detail - many
     * @param ids List of contentIds
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @return List of ContentDetail
     */
    getMany(ids: string[] | null, resolveBehaviours?: ContentResolveBehaviour[] | null | undefined): Promise<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<ContentDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @param contentCreateRequest The content create request.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @param allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     */
    create(contentCreateRequest: ContentCreateRequest, resolveBehaviours?: ContentResolveBehaviour[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Search
     * @param contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    search(contentSearchRequest: ContentSearchRequest): Promise<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ContentSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param contentAggregationRequest The aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Aggregate on channel
     * @param contentAggregationOnChannelRequest The content aggregation on channel request.
     * @return ObjectAggregationResult
     */
    aggregateOnChannel(contentAggregationOnChannelRequest: ContentAggregationOnChannelRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregateonchannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationOnChannelRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregateOnChannel(_response);
        });
    }

    protected processAggregateOnChannel(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Get references
     * @return ContentReferencesResult
     */
    getReferences(contentId: string, contentReferencesRequest: ContentReferencesRequest): Promise<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/references";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentReferencesRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferences(_response);
        });
    }

    protected processGetReferences(response: Response): Promise<ContentReferencesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentReferencesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentReferencesResult>(<any>null);
    }

    /**
     * Get references - many
     * @return ContentReferencesResult
     */
    getReferencesMany(contentManyReferencesRequest: ContentManyReferencesRequest): Promise<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/many/references";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentManyReferencesRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferencesMany(_response);
        });
    }

    protected processGetReferencesMany(response: Response): Promise<ContentReferencesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentReferencesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentReferencesResult>(<any>null);
    }

    /**
     * Create download link
     * @param request The content download link request
     * @return ContentBatchDonloadItem
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest): Promise<DownloadLink> {
        let url_ = this.baseUrl + "/v1/contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDownloadLink(_response);
        });
    }

    protected processCreateDownloadLink(response: Response): Promise<DownloadLink> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DownloadLink>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DownloadLink>(<any>null);
    }

    /**
     * Download output
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(contentId: string, outputFormatId: string, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download thumbnail
     * @param contentId The Content id
     * @param size Thumbnail size. Either small, medium or large
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @return HttpResponseMessage
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, width?: number | null | undefined, height?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/thumbnails/{contentId}/{size}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadThumbnail(_response);
        });
    }

    protected processDownloadThumbnail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Create - many
     * @param contentCreateManyRequest The content create many request.
     */
    createMany(contentCreateManyRequest: ContentCreateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete - many
     * @param deleteManyRequest The delete many request
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ContentDeleteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Restore - single
     * @param contentId The content id.
     * @param allowMissingDependencies (optional) Allow restoring contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return Void
     */
    restore(contentId: string, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/restore?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Restore - many
     * @param restoreManyRequest The content restore many request.
     * @return BusinessProcess
     */
    restoreMany(restoreManyRequest: ContentRestoreManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestoreMany(_response);
        });
    }

    protected processRestoreMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update file - single
     * @param contentId The id of the content to replace
     * @param updateRequest Update request
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/file";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update metadata - single
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @param allowMissingDependencies (optional) Allow storing references to missing list items
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return ContentDetail
     */
    updateMetadata(contentId: string, updateRequest: ContentMetadataUpdateRequest, resolveBehaviours?: ContentResolveBehaviour[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/metadata?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadata(_response);
        });
    }

    protected processUpdateMetadata(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Update permissions - single
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return ContentDetail
     */
    updatePermissions(contentId: string, updateRequest: ContentPermissionsUpdateRequest, resolveBehaviours?: ContentResolveBehaviour[] | null | undefined, timeout?: string | null | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermissions(_response);
        });
    }

    protected processUpdatePermissions(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Update metadata - many
     * @param updateRequest The metadata update requests.
     * @return BusinessProcess
     */
    updateMetadataMany(updateRequest: ContentMetadataUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadataMany(_response);
        });
    }

    protected processUpdateMetadataMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update permissions - many
     * @param updateManyRequest The permissions update many request.
     * @return BusinessProcess
     */
    updatePermissionsMany(updateManyRequest: ContentPermissionsUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermissionsMany(_response);
        });
    }

    protected processUpdatePermissionsMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Transfer ownership - single
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return ContentDetail
     */
    transferOwnership(contentId: string, updateRequest: ContentOwnershipTransferRequest, timeout?: string | null | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/ownership?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnership(_response);
        });
    }

    protected processTransferOwnership(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Transfer ownership - many
     * @param contentOwnershipTransferManyRequest The content ownership transfer many request.
     * @return BusinessProcess
     */
    transferOwnershipMany(contentOwnershipTransferManyRequest: ContentOwnershipTransferManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentOwnershipTransferManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnershipMany(_response);
        });
    }

    protected processTransferOwnershipMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by ids
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByIds(updateRequest: ContentFieldsBatchUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByIds(_response);
        });
    }

    protected processBatchUpdateFieldsByIds(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByFilter(updateRequest: ContentFieldsBatchUpdateFilterRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByFilter(_response);
        });
    }

    protected processBatchUpdateFieldsByFilter(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }
}

export class ContentPermissionSetClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param request The permission search request.
     * @return PermissionSetSearchResult
     */
    search(request: PermissionSetSearchRequest): Promise<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PermissionSetSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetSearchResult>(<any>null);
    }

    /**
     * Get detail - single
     * @param permissionSetId The content permission set id.
     * @return ContentPermissionSetDetail
     */
    get(permissionSetId: string): Promise<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContentPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentPermissionSetDetail>(<any>null);
    }
}

export class DocumentHistoryClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param documentHistorySearchRequest The document history search request
     * @return DocumentHistorySearchResult
     */
    search(documentHistorySearchRequest: DocumentHistorySearchRequest): Promise<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<DocumentHistorySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistorySearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistorySearchResult>(<any>null);
    }

    /**
     * Get latest
     * @param id The id of the document (e.g. ContentId)
     * @return DocumentHistory
     */
    get(id: string): Promise<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DocumentHistory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistory>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistory>(<any>null);
    }

    /**
     * Get latest by version
     * @param id The id of the document (e.g. ContentId)
     * @param version The version
     * @return DocumentHistory
     */
    getVersion(id: string, version: string): Promise<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{id}/{version}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<DocumentHistory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistory>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistory>(<any>null);
    }

    /**
     * Get latest difference
     * @param id The id of the document (e.g. ContentId)
     * @param oldVersion The old version
     * @return DocumentHistoryDifference
     */
    getDifferenceLatest(id: string, oldVersion: number): Promise<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{id}/difference/{oldVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{oldVersion}", encodeURIComponent("" + oldVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDifferenceLatest(_response);
        });
    }

    protected processGetDifferenceLatest(response: Response): Promise<DocumentHistoryDifference> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistoryDifference>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Get difference
     * @param id The id of the document (e.g. ContentId)
     * @param oldVersion The old version
     * @param newVersion The new version
     * @return DocumentHistoryDifference
     */
    getDifference(id: string, oldVersion: number, newVersion: number): Promise<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{id}/difference/{oldVersion}/{newVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{oldVersion}", encodeURIComponent("" + oldVersion)); 
        if (newVersion === undefined || newVersion === null)
            throw new Error("The parameter 'newVersion' must be defined.");
        url_ = url_.replace("{newVersion}", encodeURIComponent("" + newVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDifference(_response);
        });
    }

    protected processGetDifference(response: Response): Promise<DocumentHistoryDifference> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistoryDifference>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistoryDifference>(<any>null);
    }
}

export class InfoClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get info
     * @return CustomerInfo
     */
    get(): Promise<CustomerInfo> {
        let url_ = this.baseUrl + "/v1/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CustomerInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerInfo>(<any>null);
    }
}

export class JsonSchemaClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Json Schema
     * @param schemaId Schema Id
     * @return JsonSchemaViewItem
     */
    get(schemaId: string): Promise<any> {
        let url_ = this.baseUrl + "/v1/jsonSchemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class ListItemClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get detail - single
     * @param listItemId The list item id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the list item are resolved and returned
     * @return List item detail
     */
    get(listItemId: string, resolveBehaviours?: ListItemResolveBehaviour[] | null | undefined): Promise<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ListItemDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail>(<any>null);
    }

    /**
     * Update - single
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolveBehaviours (optional) List of enum that control which parts of the list item are resolved and returned
     * @param allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return ListItemDetail
     */
    update(listItemId: string, updateRequest: ListItemUpdateRequest, resolveBehaviours?: ListItemResolveBehaviour[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined): Promise<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ListItemDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail>(<any>null);
    }

    /**
     * Delete - single
     * @param listItemId The id of the list item to delete
     * @param forceReferenceRemoval (optional) A value indicating whether references to the listitem should be removed.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return Void
     */
    delete(listItemId: string, forceReferenceRemoval?: boolean | null | undefined, timeout?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get detail - many
     * @param ids List of list item ids
     * @param resolveBehaviours (optional) List of enum that control which parts of the list items are resolved and returned
     * @return List of list item details
     */
    getMany(ids: string[] | null, resolveBehaviours?: ListItemResolveBehaviour[] | null | undefined): Promise<ListItemDetail[]> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<ListItemDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @param listItemCreateRequest List item create request.
     * @param resolveBehaviours (optional) List of enum that control which parts of the list item are resolved and returned
     * @param allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return ListItemDetail
     */
    create(listItemCreateRequest: ListItemCreateRequest, resolveBehaviours?: ListItemResolveBehaviour[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined): Promise<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ListItemDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail>(<any>null);
    }

    /**
     * Search
     * @param listItemSearchRequest The list item search request.
     * @return List item result set.
     */
    search(listItemSearchRequest: ListItemSearchRequest): Promise<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/listItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ListItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param listItemAggregationRequest The list item aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/listItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create - many
     * @param listItemCreateManyRequest List item create many request.
     * @return BusinessProcess
     */
    createMany(listItemCreateManyRequest: ListItemCreateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update - many
     * @param listItemUpdateManyRequest List item update many request.
     * @return BusinessProcess
     */
    updateMany(listItemUpdateManyRequest: ListItemUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemUpdateManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete - many
     * @param deleteManyRequest The list items delete many request
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ListItemDeleteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Restore - single
     * @param listItemId The list item id.
     * @param allowMissingDependencies (optional) Allow restoring list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return Void
     */
    restore(listItemId: string, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/restore?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Restore - many
     * @param restoreManyRequest The list items restore many request.
     * @return BusinessProcess
     */
    restoreMany(restoreManyRequest: ListItemRestoreManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestoreMany(_response);
        });
    }

    protected processRestoreMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by ids
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByIds(updateRequest: ListItemFieldsBatchUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByIds(_response);
        });
    }

    protected processBatchUpdateFieldsByIds(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByFilter(updateRequest: ListItemFieldsBatchUpdateFilterRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByFilter(_response);
        });
    }

    protected processBatchUpdateFieldsByFilter(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Gets the references to a list item.
     * @param listItemId The ID of the list item.
     * @return MetadataReferences
     */
    getReferencesToListItem(listItemId: string): Promise<ListItemReferences> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/references";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferencesToListItem(_response);
        });
    }

    protected processGetReferencesToListItem(response: Response): Promise<ListItemReferences> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemReferences>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemReferences>(<any>null);
    }

    /**
     * Gets the references to the specified list items.
     * @param ids The IDs of the list items.
     * @return A MetadataReferences per list item id.
     */
    getReferencesToListItems(ids: string[] | null): Promise<ListItemReferences[]> {
        let url_ = this.baseUrl + "/v1/listItems/many/references?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferencesToListItems(_response);
        });
    }

    protected processGetReferencesToListItems(response: Response): Promise<ListItemReferences[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemReferences[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemReferences[]>(<any>null);
    }
}

export class LiveStreamClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search LiveStream
     * @param liveStreamSearchRequest The livestream search request
     * @return ObjectSearchResult
     */
    search(liveStreamSearchRequest: LiveStreamSearchRequest): Promise<ObjectSearchResult> {
        let url_ = this.baseUrl + "/v1/liveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(liveStreamSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ObjectSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSearchResult>(<any>null);
    }
}

export class OutputClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search output documents
     * @param outputSearchRequest The output search request.
     * @return Output result set.
     */
    search(outputSearchRequest: OutputSearchRequest): Promise<OutputSearchResult> {
        let url_ = this.baseUrl + "/v1/outputs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(outputSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<OutputSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputSearchResult>(<any>null);
    }

    /**
     * Get - single
     * @param outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Promise<OutputDetail> {
        let url_ = this.baseUrl + "/v1/outputs/{outputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{outputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OutputDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkBusinessException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputDetail>(<any>null);
    }
}

export class ProfileClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return UserProfile
     */
    get(): Promise<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfile>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(<any>null);
    }

    /**
     * Update
     * @return UserProfile
     */
    update(updateRequest: UserProfileUpdateRequest): Promise<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfile>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(<any>null);
    }
}

export class PublicAccessClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Version
     * @return VersionInfo
     */
    getVersion(): Promise<VersionInfo> {
        let url_ = this.baseUrl + "/v1/publicAccess/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<VersionInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VersionInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionInfo>(<any>null);
    }

    /**
     * Get Share
     * @param token The token
     * @return ShareBaseDetail
     */
    getShare(token: string): Promise<ShareDetail> {
        let url_ = this.baseUrl + "/v1/publicAccess/shares/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetShare(_response);
        });
    }

    protected processGetShare(response: Response): Promise<ShareDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareDetail>(<any>null);
    }
}

export class SchemaClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @param schemaId The schema id.
     * @return SchemaDetail
     */
    get(schemaId: string): Promise<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SchemaDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail>(<any>null);
    }

    /**
     * Update - single
     * @param schemaId The schema id.
     * @param schema The schema update request.
     * @param timeout (optional) Maximum time to wait for the operation to complete.
     * @return SchemaUpdateResult containing the updated schema
     */
    update(schemaId: string, schema: SchemaUpdateRequest, timeout?: string | null | undefined): Promise<SchemaUpdateResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<SchemaUpdateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaUpdateResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaUpdateResult>(<any>null);
    }

    /**
     * Delete - single
     * @param schemaId The schema id.
     * @param timeout (optional) Maximum time to wait for the operation to complete.
     * @return SchemaDeleteResult
     */
    delete(schemaId: string, timeout?: string | null | undefined): Promise<SchemaDeleteResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<SchemaDeleteResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDeleteResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDeleteResult>(<any>null);
    }

    /**
     * Get - many
     * @param ids (optional) Comma separated list of schema ids
     * @return SchemaDetail
     */
    getMany(ids?: string[] | null | undefined): Promise<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<SchemaDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @param schema The schema create request.
     * @param timeout (optional) Maximum time to wait for the operation to complete.
     * @return SchemaCreateResult containing the created schema.
     */
    create(schema: SchemaCreateRequest, timeout?: string | null | undefined): Promise<SchemaCreateResult> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<SchemaCreateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaCreateResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaCreateResult>(<any>null);
    }

    /**
     * Search
     * @param schemaSearchRequest The schema search request.
     * @return Schema result set.
     */
    search(schemaSearchRequest: SchemaSearchRequest): Promise<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<SchemaSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaSearchResult>(<any>null);
    }

    /**
     * Get index fields
     * @param request The get request.
     * @return Indexed fields
     */
    getIndexFields(request: IndexFieldsSearchBySchemaIdsRequest): Promise<IndexField[]> {
        let url_ = this.baseUrl + "/v1/schemas/indexFields/searchBySchemaIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetIndexFields(_response);
        });
    }

    protected processGetIndexFields(response: Response): Promise<IndexField[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IndexField[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexField[]>(<any>null);
    }

    /**
     * Exists
     * @param schemaId The schema id.
     * @param fieldId (optional) The optional field id.
     * @return ExistsResponse
     */
    exists(schemaId: string, fieldId?: string | null | undefined): Promise<ExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/exists?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<ExistsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExistsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExistsResponse>(<any>null);
    }
}

export class SchemaPermissionSetClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param request The permission search request.
     * @return PermissionSetSearchResult
     */
    search(request: PermissionSetSearchRequest): Promise<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PermissionSetSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetSearchResult>(<any>null);
    }

    /**
     * Get detail - single
     * @param permissionSetId The schema permission set id.
     * @return SchemaPermissionSetDetail
     */
    get(permissionSetId: string): Promise<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SchemaPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaPermissionSetDetail>(<any>null);
    }
}

export class SchemaTransferClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Import schemas
     * @param schemaImportRequest The schema import request.
     * @return Transfer
     */
    import(schemaImportRequest: SchemaImportRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/schematransfers/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaImportRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkBusinessException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }
}

export class ServiceProviderClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get configuration
     */
    getConfiguration(serviceProviderId: string): Promise<CustomerServiceProviderConfiguration> {
        let url_ = this.baseUrl + "/v1/serviceProviders/{serviceProviderId}/configuration";
        if (serviceProviderId === undefined || serviceProviderId === null)
            throw new Error("The parameter 'serviceProviderId' must be defined.");
        url_ = url_.replace("{serviceProviderId}", encodeURIComponent("" + serviceProviderId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: Response): Promise<CustomerServiceProviderConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerServiceProviderConfiguration>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerServiceProviderConfiguration>(<any>null);
    }

    /**
     * Update configuration
     */
    updateConfiguration(serviceProviderId: string, configuration: ServiceProviderConfigurationUpdateRequest): Promise<CustomerServiceProviderConfiguration> {
        let url_ = this.baseUrl + "/v1/serviceProviders/{serviceProviderId}/configuration";
        if (serviceProviderId === undefined || serviceProviderId === null)
            throw new Error("The parameter 'serviceProviderId' must be defined.");
        url_ = url_.replace("{serviceProviderId}", encodeURIComponent("" + serviceProviderId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configuration);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateConfiguration(_response);
        });
    }

    protected processUpdateConfiguration(response: Response): Promise<CustomerServiceProviderConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerServiceProviderConfiguration>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerServiceProviderConfiguration>(<any>null);
    }
}

export class ShareAccessClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Share json
     * @param token The token
     * @return ShareDetail
     */
    getShareJson(token: string): Promise<any> {
        let url_ = this.baseUrl + "/v1/shareAccess/json/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetShareJson(_response);
        });
    }

    protected processGetShareJson(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Download Shared outputs
     * @param token The token
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(token: string, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/shareAccess/d/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download Shared outputs
     * @param token The token
     * @param contentId The content id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithContentId(token: string, contentId: string, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/shareAccess/d/{token}/{contentId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadWithContentId(_response);
        });
    }

    protected processDownloadWithContentId(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download Shared outputs
     * @param token The token
     * @param contentId The content id
     * @param outputFormatId The output format id+
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithOutputFormatId(token: string, contentId: string, outputFormatId: string, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/shareAccess/d/{token}/{contentId}/{outputFormatId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadWithOutputFormatId(_response);
        });
    }

    protected processDownloadWithOutputFormatId(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class ShareClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @param id Share Id (not token, use PublicAccess to get share by token)
     * @return Polymorph share
     */
    get(id: string): Promise<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ShareDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareDetail>(<any>null);
    }

    /**
     * Update - single
     * @param id The share id.
     * @param updateRequest The share update request.
     * @return Share
     */
    update(id: string, updateRequest: ShareBaseUpdateRequest): Promise<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ShareDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareDetail>(<any>null);
    }

    /**
     * Search
     * @param request Search request
     * @return Share search result
     */
    search(request: ShareSearchRequest): Promise<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ShareSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param request Aggregation request
     * @return AggregationResult
     */
    aggregate(request: ShareAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create - single
     * @param request Polymorph create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest): Promise<CreateShareResult> {
        let url_ = this.baseUrl + "/v1/shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<CreateShareResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : <PermissionValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CreateShareResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateShareResult>(<any>null);
    }

    /**
     * Delete - many
     * @param deleteManyRequest A delete many request containing the ids of the shares to delete.
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ShareDeleteManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/shares/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }
}

export class TransferClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get transfer details
     * @param transferId ID of transfer.
     * @return TransferDetail
     */
    get(transferId: string): Promise<TransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TransferDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransferDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferDetail>(<any>null);
    }

    /**
     * Delete transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    delete(transferId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search
     * @param request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest): Promise<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<TransferSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransferSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferSearchResult>(<any>null);
    }

    /**
     * Cancel transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    cancelTransfer(transferId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelTransfer(_response);
        });
    }

    protected processCancelTransfer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create transfer
     * @param request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }

    /**
     * Get file
     * @param fileTransferId ID of filetransfer.
     * @return FileTransferDetail
     */
    getFile(fileTransferId: string): Promise<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/files/{fileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{fileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: Response): Promise<FileTransferDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileTransferDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileTransferDetail>(<any>null);
    }

    /**
     * Search for files
     * @param request The filetransfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest): Promise<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchFiles(_response);
        });
    }

    protected processSearchFiles(response: Response): Promise<FileTransferSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileTransferSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileTransferSearchResult>(<any>null);
    }

    /**
     * Get blacklist
     * @return Blacklist
     */
    getBlacklist(): Promise<Blacklist> {
        let url_ = this.baseUrl + "/v1/transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBlacklist(_response);
        });
    }

    protected processGetBlacklist(response: Response): Promise<Blacklist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Blacklist>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Blacklist>(<any>null);
    }

    /**
     * Delete files
     * @param request The filetransfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteFiles(_response);
        });
    }

    protected processDeleteFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Import transfer
     * @param transferId ID of transfer.
     * @param request The ImportTransfer request.
     * @return Transfer
     */
    importTransfer(transferId: string, request: ImportTransferRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportTransfer(_response);
        });
    }

    protected processImportTransfer(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }

    /**
     * Import transfer partially
     * @param transferId ID of transfer.
     * @param request The ImportTransferPartial request.
     * @return Transfer
     */
    partialImport(transferId: string, request: ImportTransferPartialRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/partialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPartialImport(_response);
        });
    }

    protected processPartialImport(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }

    /**
     * Upload file
     * @param relativePath Relative path of the uploading file.
     * @param chunkNumber Current chunk number. Starts at 1.
     * @param currentChunkSize Size in bytes of the current chunk.
     * @param totalSize Total size in bytes of the uploading file.
     * @param totalChunks Total chunks of the uploading file.
     * @param transferId ID of transfer.
     * @param identifier Identifier of file.
     * @param formFile (optional) Gets or sets the form file.
     * @return OK
     */
    uploadFile(relativePath: string | null, chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string, identifier: string, formFile?: FileParameter | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/files/{identifier}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier)); 
        if (relativePath === undefined)
            throw new Error("The parameter 'relativePath' must be defined.");
        else
            url_ += "relativePath=" + encodeURIComponent("" + relativePath) + "&"; 
        if (chunkNumber === undefined || chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
        else
            url_ += "chunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === undefined || currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
        else
            url_ += "currentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === undefined || totalSize === null)
            throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
        else
            url_ += "totalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === undefined || totalChunks === null)
            throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
        else
            url_ += "totalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create a new user (without inviting him)
     */
    create(request: UserCreateRequest): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Get by id
     * @param userId The user id
     * @return UserDetail
     */
    get(userId: string): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Updates one or more users
     */
    update(userId: string, userUpdatableDetail: UserUpdateRequest): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userUpdatableDetail);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Search for users
     * @param searchRequest The user search request
     * @return UserSearchResult
     */
    search(searchRequest: UserSearchRequest): Promise<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<UserSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSearchResult>(<any>null);
    }

    /**
     * Get by owner token
     * @param tokenId The token id
     * @return UserDetail
     */
    getByOwnerToken(tokenId: string): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByOwnerToken(_response);
        });
    }

    protected processGetByOwnerToken(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Get multiple user details by supplying their ID's
     * @param ids The user ID's
     * @return IEnumerable&lt;UserDetail&gt;
     */
    getMany(ids: string[] | null): Promise<UserDetail[]> {
        let url_ = this.baseUrl + "/v1/users/many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<UserDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail[]>(<any>null);
    }

    /**
     * Searches and aggregates users by different attributes
     */
    aggregate(userAggregationRequest: UserAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/users/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userAggregationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Locks or unlocks one or more users
     */
    lock(userId: string, userLockRequest: UserLockRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/lock";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userLockRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLock(_response);
        });
    }

    protected processLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Sets one or more users as reviewed or under review
     */
    review(userId: string, userReviewRequest: UserReviewRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/review";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userReviewRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReview(_response);
        });
    }

    protected processReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Invites (or creates) new users
     */
    invite(userId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/invite";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processInvite(_response);
        });
    }

    protected processInvite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deletes a user
     */
    delete(userId: string, userDeactivateRequest: UserDeleteRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/delete";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDeactivateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Restores a previously deleted user
     */
    restore(userId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/restore";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserRoleClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get all roles
     * @return UserDetail
     */
    getAll(): Promise<UserRole[]> {
        let url_ = this.baseUrl + "/v1/userRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<UserRole[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRole[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole[]>(<any>null);
    }

    /**
     * Create a new user role
     * @param request Create request
     */
    create(request: UserRoleCreateRequest): Promise<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRole>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole>(<any>null);
    }

    /**
     * Get by id
     * @param userRoleId The user role id
     * @return UserDetail
     */
    get(userRoleId: string): Promise<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles/{userRoleId}";
        if (userRoleId === undefined || userRoleId === null)
            throw new Error("The parameter 'userRoleId' must be defined.");
        url_ = url_.replace("{userRoleId}", encodeURIComponent("" + userRoleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRole>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole>(<any>null);
    }

    /**
     * Search for user roles
     * @param searchRequest The user role search request
     * @return UserRoleSearchResult
     */
    search(searchRequest: UserRoleSearchRequest): Promise<UserRoleSearchResult> {
        let url_ = this.baseUrl + "/v1/userRoles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<UserRoleSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleSearchResult>(<any>null);
    }

    /**
     * Create multiple new user roles
     * @param request Create request
     */
    createMany(request: UserRoleCreateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Update multiple user roles
     * @param request Update request
     */
    updateMany(request: UserRoleUpdateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Deletes multiple user roles
     * @param request Delete request
     */
    deleteMany(request: UserRoleDeleteManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }
}

export interface BusinessProcessSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
}

/** The FilterBase is the base class for all filters. */
export interface FilterBase {
}

/** The AndFilter&gt; is a compound filter and returns documents that match all of the specified filters. */
export interface AndFilter extends FilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[];
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export interface OrFilter extends FilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[];
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export interface NotFilter extends FilterBase {
    /** Limits the result set. */
    filter?: FilterBase;
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export interface DateRangeFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange;
}

/** The date range class used in aggregators and filters. */
export interface DateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string;
}

/** A custom dictionary type to distinguish language specific class properties. */
export interface TranslatedStringDictionary {

    [key: string]: string | any; 
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export interface ExistsFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export interface GeoBoundingBoxFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation;
}

export interface GeoLocation {
    lat: number;
    lon: number;
}

/** The GeoDistanceFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export interface GeoDistanceFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation;
    /** The range distance in meters. */
    distance: number;
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export interface NestedFilter extends FilterBase {
    /** The path pointing to the nested object. */
    path?: string;
    /** Limits the result set. */
    filter?: FilterBase;
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export interface NumericRangeFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The numeric range with from and to properties. */
    range?: NumericRange;
}

export interface NumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value. */
    from?: number;
    /** The to value. */
    to?: number;
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export interface PrefixFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The prefix term to filter on. */
    prefix?: string;
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export interface TermFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The term to filter on. */
    term?: string;
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export interface TermsFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** A list of OR combined terms. */
    terms?: string[];
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export interface AggregationFilter extends FilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter, GeoDistanceFilter and NestedFilter. */
    filter?: FilterBase;
    temporaryAggregatorRequestId?: string;
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export interface ChildFilter extends FilterBase {
    /** The elastic search index type to filter as a child. */
    childType?: string;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase;
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export interface ParentFilter extends FilterBase {
    /** The elastic search index type to filter as a parent. */
    parentType?: string;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase;
}

export enum SearchBehaviour {
    DropInvalidCharactersOnFailure = <any>"DropInvalidCharactersOnFailure", 
    WildcardOnSingleTerm = <any>"WildcardOnSingleTerm", 
}

export interface BaseResultOfBusinessProcess {
    totalResults: number;
    results: BusinessProcess[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface BusinessProcessSearchResult extends SearchBehaviourBaseResultOfBusinessProcess {
    elapsedMilliseconds: number;
}

export interface BusinessProcess {
    id?: string;
    processDefinitionId?: string;
    referenceId?: string;
    referenceDocType?: string;
    supportsCancellation: boolean;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCycle;
    startDate: Date;
    endDate: Date;
    finished: boolean;
    stateHistory?: BusinessProcessState[];
    currentState?: string;
    processDefinitionName?: string;
}

export enum BusinessProcessScope {
    System = <any>"System", 
    User = <any>"User", 
}

export enum BusinessProcessLifeCycle {
    Draft = <any>"Draft", 
    InProgress = <any>"InProgress", 
    Succeeded = <any>"Succeeded", 
    Cancelled = <any>"Cancelled", 
    CancellationInProgress = <any>"CancellationInProgress", 
    Failed = <any>"Failed", 
    SucceededWithErrors = <any>"SucceededWithErrors", 
}

export interface BusinessProcessState {
    state?: string;
    timestamp: Date;
    error?: ErrorResponse;
}

export interface ErrorResponse {
    exception?: string;
    traceId?: string;
    traceJobId?: string;
}

export interface BusinessProcessBulkResponse extends BusinessProcess {
    response?: BulkResponse;
}

export interface BulkResponse {
    rows?: BulkResponseRow[];
}

export interface BulkResponseRow {
    id?: string;
    version: number;
    error?: string;
    succeeded: boolean;
    status: number;
}

export interface QueryDebugInformation {
    general?: string;
    auditTrail?: string;
    request?: any;
    response?: any;
}

export interface Exception {
    message?: string;
    innerException?: Exception;
    stackTrace?: string;
    source?: string;
}

export interface PictureparkException extends Exception {
    traceLevel: TraceLevel;
    traceId?: string;
    traceJobId?: string;
    httpStatusCode: number;
}

export enum TraceLevel {
    Critical = <any>"Critical", 
    Error = <any>"Error", 
    Warning = <any>"Warning", 
    Information = <any>"Information", 
    Verbose = <any>"Verbose", 
}

export interface PictureparkBusinessException extends PictureparkException {
    customerId?: string;
    customerAlias?: string;
    userId?: string;
}

export interface PictureparkValidationException extends PictureparkBusinessException {
}

export interface PictureparkConflictException extends PictureparkBusinessException {
    reference?: string;
}

export interface PictureparkTimeoutException extends PictureparkValidationException {
}

export interface PictureparkForbiddenException extends PictureparkBusinessException {
}

export interface UserEmailAlreadyExistsException extends PictureparkValidationException {
    email?: string;
}

export interface UserRoleAssignedException extends PictureparkValidationException {
    userRoleId?: string;
}

export interface UserNotFoundException extends PictureparkBusinessException {
    missingUserId?: string;
}

export interface UserInactiveOrDeletedException extends PictureparkForbiddenException {
}

export interface TermsOfServiceNotNewestException extends PictureparkBusinessException {
}

export interface RenderingException extends PictureparkBusinessException {
}

export interface ServiceProviderDeleteException extends PictureparkException {
    serviceProviderId?: string;
    detailedErrorMessage?: string;
}

export interface ServiceProviderCreateException extends PictureparkException {
    userId?: string;
    externalId?: string;
    virtualHost?: string;
    detailErrorMessage?: string;
}

export interface ServiceProviderNotFoundException extends PictureparkException {
    missingServiceProviderId?: string;
}

export interface PictureparkNotFoundException extends PictureparkBusinessException {
    reference?: string;
}

export interface DocumentVersionNotFoundException extends PictureparkNotFoundException {
    documentId?: string;
    documentVersion?: string;
}

export interface DefaultChannelDeleteException extends PictureparkValidationException {
}

export interface ElasticVersionUpdateException extends PictureparkException {
    expectedVersion?: string;
    actualVersion?: string;
}

export interface InvalidVersionException extends PictureparkException {
    component?: string;
    version?: string;
}

export interface EnvironmentNotDeactivatedException extends PictureparkException {
}

export interface EnvironmentNotFoundException extends PictureparkException {
}

export interface EnvironmentDeactivationException extends PictureparkException {
    deactivationMessage?: string;
}

export interface ShareNotFoundException extends PictureparkNotFoundException {
    shareId?: string;
}

export interface ShareByTokenNotFoundException extends PictureparkNotFoundException {
    token?: string;
}

export interface TokenGenerationException extends PictureparkBusinessException {
    retries: number;
}

export interface ShareExpiredException extends PictureparkBusinessException {
    token?: string;
}

export interface OutputIdNotFoundException extends PictureparkNotFoundException {
    outputId?: string;
}

export interface OutputNotFoundException extends PictureparkBusinessException {
    contentId?: string;
    outputFormatId?: string;
}

export interface LeaseNotAcquiredException extends PictureparkBusinessException {
    resourceId?: string;
}

export interface OperationInProgressException extends PictureparkBusinessException {
    leaseResourceType: LeaseResourceType;
}

export enum LeaseResourceType {
    SchemaEditing = <any>"SchemaEditing", 
}

export interface RetryException extends PictureparkBusinessException {
    retries: number;
    innerExceptionDetail?: string;
}

export interface OwnerTokenNotFoundException extends PictureparkNotFoundException {
    ownerTokenUserIds?: string[];
}

export interface InvalidStateException extends PictureparkValidationException {
    resourceId?: string;
    state?: string;
}

export interface PictureparkArgumentNullException extends PictureparkValidationException {
    argumentName?: string;
}

export interface ObjectTypeMismatchException extends PictureparkBusinessException {
    type?: string;
}

export interface InvalidStateTransitionException extends InvalidStateException {
    transition?: string;
}

export interface FailedToLockException extends PictureparkBusinessException {
    resourceId?: string;
}

export interface PictureparkOperationCanceledException extends PictureparkBusinessException {
}

export interface PictureparkApplicationException extends PictureparkBusinessException {
}

export interface MissingCustomerDefaultLanguageException extends PictureparkValidationException {
    customerDefaultLanguage?: string;
}

export interface InvalidArgumentException extends PictureparkValidationException {
    argumentName?: string;
    argumentValue?: string;
}

export interface UnknownException extends PictureparkBusinessException {
    exceptionDetail?: string;
}

export interface OwnerTokenInUseException extends PictureparkValidationException {
    ownerTokenUserId?: string;
}

export interface CustomerViolationException extends PictureparkException {
    expectedCustomerId?: string;
    currentCustomerId?: string;
}

export interface CustomerAliasNotFoundException extends PictureparkException {
    customerAlias?: string;
}

export interface CustomerAliasInUseException extends PictureparkBusinessException {
    existingCustomerId?: string;
    alias?: string;
}

export interface CustomerNotDeactivatedException extends PictureparkException {
    customerId?: string;
}

export interface CustomerDeactivationException extends PictureparkException {
    customerId?: string;
    deactivationMessage?: string;
}

export interface CustomerHostNotFoundException extends PictureparkException {
    hostName?: string;
}

export interface CustomerNotFoundException extends PictureparkException {
    customerId?: string;
}

export interface CustomerNotActiveException extends PictureparkException {
    customerId?: string;
}

export interface ConfigurationIndexNotFoundException extends PictureparkException {
    configurationIndex?: string;
}

export interface DuplicateSearchIndexDocException extends PictureparkBusinessException {
    searchIndexDocId?: string;
}

export interface SearchIndexDocNotFoundException extends PictureparkBusinessException {
    searchIndexDocId?: string;
}

export interface IndexDocumentNotFoundException extends PictureparkBusinessException {
    indexId?: string;
}

export interface DuplicateAliasException extends PictureparkException {
    indexAlias?: string;
}

export interface SearchIndexNotFoundException extends PictureparkBusinessException {
    searchIndexId?: string;
}

export interface DefaultSearchIndexDeleteException extends PictureparkBusinessException {
}

export interface SearchIndexInUseException extends PictureparkBusinessException {
    searchIndex?: string;
}

export interface IndexException extends PictureparkBusinessException {
    indexName?: string;
    debugInformation?: string;
}

export interface IndexMappingException extends PictureparkBusinessException {
    indexName?: string;
    debugInformation?: string;
}

export interface DuplicatedSearchBehaviourException extends PictureparkValidationException {
    duplicatedSearchBehaviours?: string;
}

export interface SearchStringLeadingWildcardException extends PictureparkValidationException {
}

export interface DuplicateAggregatorException extends PictureparkValidationException {
    aggregatorName?: string;
}

export interface InvalidDateTimeFormatException extends PictureparkValidationException {
    value?: string;
    expectedFormat?: string;
}

export interface InvalidSortFieldException extends PictureparkValidationException {
    fieldName?: string;
}

export interface DocumentVersionConflictException extends PictureparkConflictException {
    documentId?: string;
    documentType?: string;
    documentVersion: number;
}

export interface RedisDatabaseExceededException extends PictureparkException {
    customerId?: string;
    customerCount: number;
    maxCount: number;
    startIndex: number;
    redisDatabaseCount: number;
}

export interface DuplicateDocumentException extends PictureparkValidationException {
    documentId?: string;
    documentType?: string;
}

export interface ObjectStoreResponseException extends PictureparkBusinessException {
    rowErrorMessages?: string;
    message?: string;
}

export interface ObjectStoreException extends PictureparkBusinessException {
    rowErrorMessages?: string;
    errorMessage?: string;
}

export interface QueryException extends PictureparkBusinessException {
    debugInformation?: string;
    serverError?: StorageServerError;
}

export interface StorageServerError {
    error?: StorageError;
    status: number;
}

export interface StorageError {
    index?: string;
    reason?: string;
    resourceId?: string;
    resourceType?: string;
    type?: string;
    rootCause?: StorageRootCause[];
    causedBy?: StorageCausedBy;
}

export interface StorageRootCause {
    index?: string;
    reason?: string;
    resourceId?: string;
    resourceType?: string;
    type?: string;
}

export interface StorageCausedBy {
    reason?: string;
    type?: string;
    innerCausedBy?: StorageCausedBy;
}

export interface PermissionOwnershipTransferException extends PictureparkValidationException {
    transferUserId?: string;
    missingUserRight: UserRight;
}

export enum UserRight {
    ManageContent = <any>"ManageContent", 
    ManageSharings = <any>"ManageSharings", 
    ManageTransfer = <any>"ManageTransfer", 
    ManageChannels = <any>"ManageChannels", 
    ManageSchemas = <any>"ManageSchemas", 
    ManageUsers = <any>"ManageUsers", 
    ManageUserRoles = <any>"ManageUserRoles", 
    ManagePermissions = <any>"ManagePermissions", 
    ManageSearchIndexes = <any>"ManageSearchIndexes", 
    ManageCollections = <any>"ManageCollections", 
    ManageListItems = <any>"ManageListItems", 
    ManageServiceProviders = <any>"ManageServiceProviders", 
    ManageEmbeds = <any>"ManageEmbeds", 
    ManageTemplates = <any>"ManageTemplates", 
    ManageTermsOfService = <any>"ManageTermsOfService", 
}

export interface PermissionSetNotFoundException extends PictureparkNotFoundException {
    permissionSetIds?: string[];
}

export interface DuplicateRightException extends PictureparkValidationException {
    permissionSetId?: string;
}

export interface PermissionValidationException extends PictureparkValidationException {
    permission?: string;
    operation?: string;
}

export interface UnsupportedListItemChangeCommandException extends PictureparkValidationException {
    commandType?: string;
}

export interface ListItemLayerException extends PictureparkValidationException {
    listItemId?: string;
}

export interface ListItemNotFoundException extends PictureparkNotFoundException {
    listItemIds?: string[];
}

export interface ListItemCyclicDependencyException extends PictureparkBusinessException {
    listItemIds?: string[];
}

export interface DeleteListItemsWithReferencesException extends PictureparkValidationException {
    referencesList?: string[];
    references?: string;
}

export interface ListItemUpdateManyException extends PictureparkBusinessException {
    failedItemsCount: number;
    totalItemsCount: number;
}

export interface TransferInfoNotFoundException extends PictureparkNotFoundException {
    transferInfoId?: string;
}

export interface FileTransferNotFoundException extends PictureparkNotFoundException {
    fileTransferId?: string;
}

export interface InvalidTransferTypeException extends PictureparkBusinessException {
    transferType: TransferType;
}

export enum TransferType {
    FileUpload = <any>"FileUpload", 
    FileUploadAutoImport = <any>"FileUploadAutoImport", 
    WebDownload = <any>"WebDownload", 
    SchemaImport = <any>"SchemaImport", 
}

export interface TransferNotFoundException extends PictureparkNotFoundException {
    transferId?: string;
}

export interface WrongChunkSizeException extends PictureparkValidationException {
    actual: number;
    expected: number;
}

export interface MissingDependenciesException extends PictureparkValidationException {
    itemIds?: string;
}

export interface RelationSelfReferencingException extends PictureparkValidationException {
    itemId?: string;
    itemType?: string;
}

export interface InvalidChangeCommandFieldTypeInvalidException extends PictureparkValidationException {
    commandType?: string;
    fieldId?: string;
    schemaId?: string;
    fieldActualType?: string;
    fieldExpectedType?: string;
}

export interface InvalidChangeCommandFieldNotFoundException extends PictureparkValidationException {
    commandTypeName?: string;
    fieldId?: string;
    schemaId?: string;
}

export interface InvalidChangeCommandSchemaChangeInvalidException extends PictureparkValidationException {
    commandTypeName?: string;
    schemaId?: string;
}

export interface InvalidMetadataException extends PictureparkValidationException {
    metadataErrors?: MetadataError[];
}

export interface MetadataError {
    errorType?: string;
    lineNumber: number;
    linePosition: number;
    path?: string;
    message?: string;
    schemaId?: string;
}

export interface RelationNotFoundException extends PictureparkBusinessException {
    relationId?: string;
}

export interface RelationTypeNotFoundException extends PictureparkBusinessException {
    relationType?: string;
}

export interface RelationTypeTargetDocTypeMismatchException extends PictureparkBusinessException {
    relationType?: string;
    targetDocType?: string;
    expectedTargetDocType?: string;
}

export interface AggregationNameInvalidException extends PictureparkValidationException {
    aggregationName?: string;
    aggregationPrefix?: string;
}

export interface SchemaFieldOverwriteTypeMismatchException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    fieldOverwriteType?: string;
    fieldType?: string;
}

export interface SchemaFieldOverwriteIdException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export interface SchemaFieldIdDuplicatedException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export interface SchemaFieldSchemaIndexInfoSimpleSearchNestingException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relatedFieldId?: string;
    relatedOuterFieldId?: string;
}

export interface SchemaFieldSchemaIndexInfoNestingException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relatedFieldId?: string;
    relatedOuterFieldId?: string;
}

export interface SchemaFieldIdUppercaseException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export interface SchemaIdLowercaseException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaInfoNotFoundException extends PictureparkNotFoundException {
    schemaId?: string;
}

export interface IndexedFieldThresholdExceededException extends PictureparkValidationException {
    schemaId?: string;
    indexedFieldCount: number;
    indexedFieldThreshold: number;
}

export interface SortableFieldThresholdExceededException extends PictureparkValidationException {
    schemaId?: string;
    sortableFieldCount: number;
    sortableFieldThreshold: number;
}

export interface DuplicateSchemaInfoException extends PictureparkBusinessException {
    schemaId?: string;
}

export interface SchemaFieldNumberRangeException extends PictureparkValidationException {
    fieldId?: string;
    propertyName?: string;
    minValue: number;
    maxValue: number;
}

export interface SchemaInUseContentSchemaException extends PictureparkValidationException {
    schemaId?: string;
    contentSchemaIds?: string[];
}

export interface SchemaInUseListItemException extends PictureparkValidationException {
    schemaId?: string;
    listItemCount: number;
}

export interface SchemaInUseContentException extends PictureparkValidationException {
    schemaId?: string;
    contentCount: number;
}

export interface SchemaInUseFieldException extends PictureparkValidationException {
    schemaId?: string;
    fieldNamespaces?: string[];
}

export interface SchemaNotFoundInSearchIndexException extends PictureparkValidationException {
    searchIndexId?: string;
    schemaId?: string;
}

export interface DuplicateMetadataDisplayPatternException extends PictureparkValidationException {
    schemaId?: string;
    displayPatternId?: string;
}

export interface DuplicateSchemaException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaImportEmptyException extends PictureparkValidationException {
}

export interface SchemaImportVersionMismatchException extends PictureparkValidationException {
    providedVersion?: string;
    expectedVersion?: string;
}

export interface SchemaCyclicDependencyException extends PictureparkValidationException {
    schemaIds?: string[];
}

export interface SchemaInheritanceFieldIndexDeviationException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaInheritanceTypeDeviationException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaValidationException extends PictureparkValidationException {
    schemaId?: string;
    exceptions?: PictureparkBusinessException[];
}

export interface SchemaSortFieldException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export interface SchemaFieldIdException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export interface SchemaFieldTypeChangeException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    oldTypeName?: string;
    newTypeName?: string;
}

export interface SchemaFieldIndexException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export interface SchemaFieldNotSortableException extends PictureparkValidationException {
    fieldId?: string;
    schemaId?: string;
}

export interface SchemaFieldNotSearchableException extends PictureparkValidationException {
    fieldId?: string;
    schemaId?: string;
}

export interface SchemaNoContentException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaParentChangeException extends PictureparkValidationException {
    schemaId?: string;
    oldSchemaParentId?: string;
    newSchemaParentId?: string;
}

export interface SchemaMissingTypeException extends PictureparkValidationException {
    schemaId?: string;
    expectedSchemaTypes?: SchemaType[];
}

export enum SchemaType {
    Content = <any>"Content", 
    Layer = <any>"Layer", 
    List = <any>"List", 
    Struct = <any>"Struct", 
}

export interface SchemaPermissionException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaNoLayerException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaIdException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaInUseException extends PictureparkValidationException {
    schemaId?: string;
    exceptions?: PictureparkBusinessException[];
}

export interface SchemaNotFoundException extends PictureparkNotFoundException {
    schemaId?: string;
}

export interface SystemSchemaInvalidModificationException extends PictureparkValidationException {
    schemaId?: string;
}

export interface SchemaFieldRelationSchemaSystemSchemaException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relationSchemaId?: string;
}

export interface SchemaFieldRelationSchemaTypeUnsupportedException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relationSchemaId?: string;
}

export interface SchemaMultipleTypesException extends PictureparkValidationException {
    schemaId?: string;
    schemaTypes?: string[];
}

export interface MissingDisplayPatternForCustomerDefaultLanguageException extends PictureparkValidationException {
    schemaId?: string;
    missingTypes?: DisplayPatternType[];
}

export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail", 
    List = <any>"List", 
    Detail = <any>"Detail", 
    Name = <any>"Name", 
}

export interface DeleteContentsWithRelationsException extends PictureparkValidationException {
    relationList?: string[];
    relations?: string;
}

export interface ContentMetadataUpdateManyException extends PictureparkBusinessException {
    failedItemsCount: number;
    totalItemsCount: number;
}

export interface ContentNotFoundException extends PictureparkNotFoundException {
    contentIds?: string[];
}

export interface ContentLayerInvalidException extends PictureparkValidationException {
    contentId?: string;
    layerIds?: string;
}

export interface ContentFileReplaceTypeMismatchException extends PictureparkValidationException {
    contentId?: string;
    originalContentType: ContentType;
    newContentType: ContentType;
}

export enum ContentType {
    Unknown = <any>"Unknown", 
    Bitmap = <any>"Bitmap", 
    VectorGraphic = <any>"VectorGraphic", 
    RawImage = <any>"RawImage", 
    InterchangeDocument = <any>"InterchangeDocument", 
    WordProcessingDocument = <any>"WordProcessingDocument", 
    TextDocument = <any>"TextDocument", 
    DesktopPublishingDocument = <any>"DesktopPublishingDocument", 
    Presentation = <any>"Presentation", 
    Spreadsheet = <any>"Spreadsheet", 
    Archive = <any>"Archive", 
    Audio = <any>"Audio", 
    Video = <any>"Video", 
    Font = <any>"Font", 
    Multimedia = <any>"Multimedia", 
    Application = <any>"Application", 
    SourceCode = <any>"SourceCode", 
    Database = <any>"Database", 
    Cad = <any>"Cad", 
    Model3d = <any>"Model3d", 
    ContentItem = <any>"ContentItem", 
}

export interface BusinessProcessWaitTimeoutException extends PictureparkTimeoutException {
    businessProcessId?: string;
}

export interface BusinessProcessEngineRequestException extends PictureparkBusinessException {
    businessProcessId?: string;
    engineError?: string;
}

export interface BusinessProcessNotFoundException extends PictureparkNotFoundException {
    businessProcessId?: string;
}

export interface BusinessProcessDefinitionNotFoundException extends PictureparkNotFoundException {
    processDefinitionId?: string;
}

export interface BusinessProcessDefinitionCreateException extends PictureparkBusinessException {
    processDefinitionIds?: string[];
}

export interface SchemaFieldImportMismatchException extends PictureparkValidationException {
    schemaId?: string;
    importingFieldIds?: string;
    existingFieldIds?: string;
}

export interface SchemaFieldImportRelatedSchemaMismatchException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    importingRelatedSchemaId?: string;
    existingRelatedSchemaId?: string;
}

export interface SchemaFieldImportTypeMismatchException extends PictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    importingFieldType?: string;
    existingFieldType?: string;
}

export interface SnapshotTimeoutException extends PictureparkTimeoutException {
}

export interface SnapshotFailedException extends PictureparkBusinessException {
}

export interface AddMetadataLanguageTimeoutException extends PictureparkTimeoutException {
    environmentProcessId?: string;
}

export interface EnvironmentProcessAlreadyRunningException extends PictureparkValidationException {
    environmentProcessType: EnvironmentProcessType;
}

export enum EnvironmentProcessType {
    AddMetadataLanguage = <any>"AddMetadataLanguage", 
    CustomerUpdate = <any>"CustomerUpdate", 
    EnvironmentUpdate = <any>"EnvironmentUpdate", 
}

export interface EnvironmentProcessNotFoundException extends PictureparkNotFoundException {
    environmentProcessId?: string;
}

export interface EnvironmentProcessWaitTimeoutException extends PictureparkTimeoutException {
    environmentProcessId?: string;
    waitedLifecycles?: string;
}

export interface NoTermsOfServiceDefinedException extends PictureparkBusinessException {
}

export interface AtLeastOneActiveTermsOfServiceMustExistException extends PictureparkValidationException {
}

export interface ForbiddenHtmlElementsUsedException extends PictureparkValidationException {
}

export interface BusinessProcessStateNotHitException extends PictureparkTimeoutException {
    businessProcessId?: string;
    expected?: string[];
    actual?: string;
}

export interface BusinessProcessLifeCycleNotHitException extends PictureparkTimeoutException {
    businessProcessId?: string;
    expected?: BusinessProcessLifeCycle[];
    actual: BusinessProcessLifeCycle;
}

export interface BusinessProcessWaitForLifeCycleResult {
    lifeCycleHit?: BusinessProcessLifeCycle;
    businessProcess?: BusinessProcess;
}

export interface BusinessProcessWaitForStateResult {
    stateHit?: string;
    businessProcess?: BusinessProcess;
}

export interface BusinessProcessDetails extends BusinessProcess {
    details?: BusinessProcessDetailsDataBase;
}

export interface BusinessProcessDetailsDataBase {
}

export interface BusinessProcessDetailsDataBatchResponse extends BusinessProcessDetailsDataBase {
    docType?: string;
    response?: BatchResponse;
}

export interface BatchResponse {
    rows?: BatchResponseRow[];
}

export interface BatchResponseRow {
    id?: string;
    succeeded: boolean;
    status: number;
    version: number;
    error?: ErrorResponse;
}

/** Business process detailed information regarding Schema / ListItems import operation */
export interface BusinessProcessDetailsDataSchemaImport extends BusinessProcessDetailsDataBase {
    /** Result information of a schema import operation */
    schemaImportResult?: SchemaImportResult;
    /** Result information of a list item import operation */
    listItemImportResult?: ListItemImportResult;
}

/** Result information of a schema import operation */
export interface SchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[];
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[];
}

/** Result information of a list item import operation */
export interface ListItemImportResult {
    /** Number of list items imported */
    importedListItemCount: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount: number;
    /** Total number of list items requested to be imported */
    totalListItemCount: number;
    /** Ids of the list items that were not imported because already found in the system */
    skippedListItemIds?: string[];
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[];
}

export interface BusinessProcessDetailsDataCdnPurge extends BusinessProcessDetailsDataBase {
    serializedCdnConfiguration?: string;
    jobs?: CdnPurgeJobBase[];
}

export interface CdnPurgeJobBase {
    success: boolean;
    retriesLeft: number;
}

export interface CdnPurgeJobByTag extends CdnPurgeJobBase {
    tag?: string;
}

export interface CdnPurgeJobByUri extends CdnPurgeJobBase {
    uri?: string;
}

export interface BusinessProcessDetailsDataContentImport extends BusinessProcessDetailsDataBase {
    items?: ContentImportResult[];
}

export interface ContentImportResult {
    fileTransferId?: string;
    contentId?: string;
    state?: string;
    succeeded: boolean;
    error?: ErrorResponse;
}

export interface Channel {
    id?: string;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[];
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase;
    /** Language specific names. */
    names?: TranslatedStringDictionary;
    sort?: SortInfo[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary;
    audit?: UserAudit;
}

export interface SortInfo {
    /** The elastic search index field to sort on. */
    field?: string;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;
}

export enum SortDirection {
    Asc = <any>"Asc", 
    Desc = <any>"Desc", 
}

/** The AggregatorBase is the base class for all aggregators. */
export interface AggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[];
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export interface DateRangeAggregator extends AggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRangeForAggregator[];
}

/** The date range class used in aggregators. */
export interface DateRangeForAggregator {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string;
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export interface GeoDistanceAggregator extends AggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation;
    /** A list of numeric ranges in meter. */
    ranges?: GeoDistance[];
}

export interface GeoDistance {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The to value. */
    distance: number;
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export interface NestedAggregator extends AggregatorBase {
    /** The path pointing to the nested object. */
    path?: string;
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export interface NumericRangeAggregator extends AggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** A list of numeric ranges. */
    ranges?: NumericRangeForAggregator[];
}

export interface NumericRangeForAggregator {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value. */
    from?: number;
    /** The to value. */
    to?: number;
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export interface TermsAggregator extends AggregatorBase {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[];
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[];
    /** Search string to be used to search within possible aggregation values */
    searchString?: string;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used */
    searchFields?: string[];
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export interface TermsRelationAggregator extends TermsAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    Schema = <any>"Schema", 
    User = <any>"User", 
    ContentPermissionSet = <any>"ContentPermissionSet", 
    Owner = <any>"Owner", 
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export interface TermsEnumAggregator extends TermsAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string;
}

export interface UserAudit {
    creationDate: Date;
    modificationDate: Date;
    createdByUser?: string;
    modifiedByUser?: string;
}

export enum ContentResolveBehaviour {
    Content = <any>"Content", 
    LinkedListItems = <any>"LinkedListItems", 
    Metadata = <any>"Metadata", 
    Outputs = <any>"Outputs", 
    InnerDisplayValueThumbnail = <any>"InnerDisplayValueThumbnail", 
    InnerDisplayValueList = <any>"InnerDisplayValueList", 
    InnerDisplayValueDetail = <any>"InnerDisplayValueDetail", 
    InnerDisplayValueName = <any>"InnerDisplayValueName", 
}

/** A content detail. */
export interface ContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit;
    /** The content data */
    content?: any;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
    /** The id of the content schema */
    contentSchemaId?: string;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: DisplayValueDictionary;
    /** The content id. */
    id?: string;
    /** An optional list of layer schemas ids */
    layerSchemaIds?: string[];
    /** The metadata dictionary */
    metadata?: DataDictionary;
    /** A list of rendering ouputs for underlying digital file. */
    outputs?: Output[];
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string;
    /** The trashed flag. */
    trashed: boolean;
}

export interface DisplayValueDictionary {

    [key: string]: string | any; 
}

export interface DataDictionary {

    [key: string]: any; 
}

export interface Output {
    id?: string;
    outputFormatId?: string;
    contentId?: string;
    renderingState: OutputRenderingState;
    detail?: OutputDataBase;
    backupTimestamp?: Date;
}

export enum OutputRenderingState {
    InProgress = <any>"InProgress", 
    Completed = <any>"Completed", 
    Failed = <any>"Failed", 
    Skipped = <any>"Skipped", 
}

export interface OutputDataBase {
    fileExtension?: string;
    fileName?: string;
    filePath?: string;
    fileSizeInBytes?: number;
    sha1Hash?: string;
}

export interface OutputDataImage extends OutputDataBase {
    width: number;
    height: number;
}

export interface OutputDataAudio extends OutputDataBase {
    durationInSeconds?: number;
}

export interface OutputDataVideo extends OutputDataBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[];
}

export interface Sprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;
}

export interface OutputDataDocument extends OutputDataBase {
    pageCount: number;
}

export interface OutputDataDefault extends OutputDataBase {
}

export interface OutputDetail extends Output {
}

export interface ContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** The collection id. */
    collectionId?: string;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied in the specified order. */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the returned contents that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[];
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly", 
    All = <any>"All", 
    InactiveOnly = <any>"InactiveOnly", 
    ActiveInactiveOnly = <any>"ActiveInactiveOnly", 
}

export enum BrokenDependenciesFilter {
    All = <any>"All", 
    NotBrokenOnly = <any>"NotBrokenOnly", 
    BrokenOnly = <any>"BrokenOnly", 
}

export enum ContentRight {
    View = <any>"View", 
    AccessOriginal = <any>"AccessOriginal", 
    Edit = <any>"Edit", 
    Update = <any>"Update", 
    Manage = <any>"Manage", 
    Trash = <any>"Trash", 
}

export enum ContentSearchType {
    Metadata = <any>"Metadata", 
    FullText = <any>"FullText", 
    MetadataAndFullText = <any>"MetadataAndFullText", 
}

export interface BaseResultOfContent {
    totalResults: number;
    results: Content[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfContent extends BaseResultOfContent {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface ContentSearchResult extends SearchBehaviourBaseResultOfContent {
    elapsedMilliseconds: number;
}

export interface Content {
    audit?: UserAudit;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; };
    id?: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[];
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[];
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[];
}

export interface ContentAggregationOnChannelRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[];
    /** Limits the simple search fields to the fields available in the specified channel and retrieve the existing aggregation for it. */
    channelId?: string;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[];
    /** The collection id. */
    collectionId?: string;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
}

export interface ContentAggregationRequest extends ContentAggregationOnChannelRequest {
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[];
}

export interface ObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[];
    /** The search string used to query the data */
    searchString?: string;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten: boolean;
}

export interface AggregationResult {
    name?: string;
    sumOtherDocCount?: number;
    aggregationResultItems?: AggregationResultItem[];
}

export interface AggregationResultItem {
    name?: string;
    count: number;
    filter?: AggregationFilter;
    active: boolean;
    aggregationResults?: AggregationResult[];
}

export interface ContentReferencesRequest {
    shares?: PagingRequest;
}

export interface PagingRequest {
    start: number;
    limit: number;
}

export interface ContentReferencesResult {
    metadataReferences?: ContentReferences[];
    shareReferences?: ContentShareReferenceResult;
}

export interface ReferencesBase {
    targetMetadataItemId?: string;
    references?: MetadataReference[];
    isReferencedByRestrictedItem: boolean;
}

export interface ContentReferences extends ReferencesBase {
    relations?: MetadataReference[];
}

export interface MetadataReference {
    targetDocType?: string;
    sourceId?: string;
    sourceDocType?: string;
}

export interface BaseResultOfContentShareReference {
    totalResults: number;
    results: ContentShareReference[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface ContentShareReferenceResult extends BaseResultOfContentShareReference {
}

export interface ContentShareReference {
    id?: string;
    name?: string;
    audit?: UserAudit;
    shareType: ShareType;
    emailAddress?: string;
}

export enum ShareType {
    Basic = <any>"Basic", 
    Embed = <any>"Embed", 
}

export interface ContentManyReferencesRequest {
    contentIds?: string[];
    shares?: PagingRequest;
}

export interface ContentDownloadLinkCreateRequest {
    contents?: ContentDownloadRequestItem[];
}

export interface ContentDownloadRequestItem {
    contentId?: string;
    outputFormatId?: string;
}

export interface DownloadLink {
    downloadToken?: string;
    downloadUrl?: string;
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = <any>"Small", 
    Medium = <any>"Medium", 
    Large = <any>"Large", 
}

/** A request structure for creating a content document. */
export interface ContentCreateRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** The content data of the content document. */
    content?: any;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[];
}

/** A request structure for creating multiple content documents. */
export interface ContentCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: ContentCreateRequest[];
}

export interface ContentDeleteManyRequest {
    contentIds?: string[];
    forceReferenceRemoval: boolean;
}

export interface ContentRestoreManyRequest {
    contentIds?: string[];
    allowMissingDependencies: boolean;
}

export interface ContentFileUpdateRequest {
    fileTransferId?: string;
}

export interface ContentMetadataUpdateRequest {
    /** An id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** The dynamic data structure matching the field schematics of the content schema (ContentSchemaId). */
    content?: DataDictionary;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds). */
    metadata?: DataDictionary;
    /** Options to modify the behavior for updating schemas. */
    layerSchemasUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas. */
    schemaFieldsUpdateOptions: UpdateOption;
}

export enum UpdateOption {
    Merge = <any>"Merge", 
    Replace = <any>"Replace", 
}

export interface ContentPermissionsUpdateRequest {
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
}

/** Update many contents metadata */
export interface ContentMetadataUpdateManyRequest {
    /** Allow storing references to missing list items */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: ContentMetadataUpdateItem[];
}

export interface ContentMetadataUpdateItem extends ContentMetadataUpdateRequest {
    /** The content id. */
    id?: string;
}

export interface ContentPermissionsUpdateManyRequest {
    /** List of Content Permissions update items */
    items?: ContentPermissionsUpdateItem[];
}

export interface ContentPermissionsUpdateItem extends ContentPermissionsUpdateRequest {
    /** The content id. */
    contentId?: string;
}

export interface ContentOwnershipTransferRequest {
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string;
}

export interface ContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer requests */
    items?: ContentOwnershipTransferItem[];
}

export interface ContentOwnershipTransferItem extends ContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string;
}

export interface MetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;
}

export interface ContentFieldsBatchUpdateRequest extends MetadataValuesChangeRequestBase {
    /** The ids of the content documents. */
    contentIds?: string[];
}

/** The base class for metadata value change commands. */
export interface MetadataValuesChangeCommandBase {
    /** The id of the schema to which the operation scope is addressed. */
    schemaId?: string;
}

/** Updates schema values. */
export interface MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary;
}

/** Adds or updates schema values. */
export interface MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary;
}

/** Removes schema values. */
export interface MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase {
}

/** Replaces schema values. */
export interface MetadataValuesSchemaReplaceCommand extends MetadataValuesChangeCommandBase {
    /** The metadata values containing the new values for the schema. All old values will be overwritten. */
    value?: DataDictionary;
}

/** Removes a field and its value from the schema values. */
export interface MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The path of the field to be removed (within tha data structure), e.g. "data.schemaId.fieldId" */
    fieldPath?: string;
}

/** Adds a list item id reference to a multi tagbox. */
export interface MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string;
    /** The field namespace */
    fieldNamespace?: string;
    /** The id of the list item to be added. */
    referenceId?: string;
}

/** Removes a list item id reference from a multi tagbox. */
export interface MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string;
    /** The field namespace */
    fieldNamespace?: string;
    /** The id of the list item to be removed. */
    referenceId?: string;
}

export interface ContentFieldsBatchUpdateFilterRequest extends MetadataValuesChangeRequestBase {
    filterRequest?: ContentFilterRequest;
}

export interface ContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[];
}

export interface PermissionSetSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    rightFilter?: PermissionSetRight;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];
}

export enum PermissionSetRight {
    Apply = <any>"Apply", 
    Manage = <any>"Manage", 
}

export interface BaseResultOfPermissionSet {
    totalResults: number;
    results: PermissionSet[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfPermissionSet extends BaseResultOfPermissionSet {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface PermissionSetSearchResult extends SearchBehaviourBaseResultOfPermissionSet {
    elapsedMilliseconds: number;
}

export interface PermissionSet {
    /** The permission set id. */
    id?: string;
    /** When true this permission set will derogate all other configured permission sets. */
    exclusive: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary;
}

export interface PermissionSetDetailOfContentRight {
    id?: string;
    names?: TranslatedStringDictionary;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[];
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[];
    exclusive: boolean;
    ownerTokenId?: string;
}

export interface ContentPermissionSetDetail extends PermissionSetDetailOfContentRight {
}

export interface PermissionUserRoleRightsOfContentRight {
    userRoleId?: string;
    names?: TranslatedStringDictionary;
    rights?: ContentRight[];
}

export interface PermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string;
    names?: TranslatedStringDictionary;
    rights?: PermissionSetRight[];
}

export interface DocumentHistorySearchRequest {
    /** Limits the start date of the search request. Default to last 1 year. */
    from: Date;
    /** Limits the end date of the search request. Default to now. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string;
    /** Limits the search to a specific document id. E.g. ContentId */
    documentId?: string;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specifc document type. */
    documentType?: string;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo;
}

export interface DocumentHistorySearchResult {
    totalResults: number;
    results?: DocumentHistory[];
    pageToken?: string;
    elapsedMilliseconds: number;
}

export interface DocumentHistory {
    id?: string;
    documentId?: string;
    documentVersion: number;
    documentType?: string;
    documentTypeContract?: string;
    documentDate: Date;
    document?: string;
    timestamp: Date;
    audit?: UserAuditHistory;
    deleted: boolean;
    action: DocumentChangeAction;
}

export interface UserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string;
}

export enum DocumentChangeAction {
    Create = <any>"Create", 
    Update = <any>"Update", 
    Delete = <any>"Delete", 
    Activate = <any>"Activate", 
    Deactivate = <any>"Deactivate", 
}

export interface DocumentHistoryDifference {
    documentId?: string;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any;
    newValues?: any;
}

export interface CustomerInfo {
    customerId?: string;
    name?: string;
    customerAlias?: string;
    identityServerUrl?: string;
    enableQueryDetails: boolean;
    languageConfiguration?: LanguageConfiguration;
    languages?: Language[];
    outputFormats?: OutputFormatInfo[];
}

export interface LanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages?: string[];
    /** A list of languages serving as metadata languages. */
    metadataLanguages?: string[];
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage?: string;
}

export interface Language {
    name?: TranslatedStringDictionary;
    ietf?: string;
    twoLetterISOLanguageName?: string;
    threeLetterISOLanguageName?: string;
    regionCode?: string;
}

export interface OutputFormatInfo {
    id?: string;
    names?: TranslatedStringDictionary;
}

export enum ListItemResolveBehaviour {
    Content = <any>"Content", 
    LinkedListItems = <any>"LinkedListItems", 
    InnerDisplayValueThumbnail = <any>"InnerDisplayValueThumbnail", 
    InnerDisplayValueList = <any>"InnerDisplayValueList", 
    InnerDisplayValueDetail = <any>"InnerDisplayValueDetail", 
    InnerDisplayValueName = <any>"InnerDisplayValueName", 
}

/** The detail view item for the list item. */
export interface ListItemDetail {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary;
    /** The list item id. */
    id?: string;
}

export interface ListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[];
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[];
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Define the display values included in the search response for the referenced fields. Defaults to no display value. */
    referencedFieldsDisplayPatternIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** When set to true the content data is included in the result items. */
    includeContentData: boolean;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

export interface BaseResultOfListItem {
    totalResults: number;
    results: ListItem[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

/** Encapsulates the result of a list item search. */
export interface ListItemSearchResult extends BaseResultOfListItem {
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export interface ListItem {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary;
    /** The list item id. */
    id?: string;
}

export interface ListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[];
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[];
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Filter the list items document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** A request structure for creating a list item document. */
export interface ListItemCreateRequest {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string;
}

/** A request structure for creating multiple list items. */
export interface ListItemCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: ListItemCreateRequest[];
}

/** A request structure for updating a list item. */
export interface ListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any;
}

/** A request structure for updating multiple list items. */
export interface ListItemUpdateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: ListItemUpdateItem[];
}

export interface ListItemUpdateItem extends ListItemUpdateRequest {
    /** The list item id. */
    id?: string;
}

export interface ListItemDeleteManyRequest {
    listItemIds?: string[];
    forceReferenceRemoval: boolean;
}

export interface ListItemRestoreManyRequest {
    listItemIds?: string[];
    allowMissingDependencies: boolean;
}

export interface ListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated */
    listItemIds?: string[];
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;
}

/** ListItemFieldsFilterUpdateRequest class */
export interface ListItemFieldsBatchUpdateFilterRequest {
    /** The search request used to filter the list items on which the change commands must be applied */
    filterRequest?: ListItemFilterRequest;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;
}

export interface ListItemFilterRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
}

export interface ListItemReferences extends ReferencesBase {
}

export interface LiveStreamSearchRequest {
    /** Limits the start date of the search request. */
    from: Date;
    /** Limits the end date of the search request. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string;
}

export interface BaseResultOfObject {
    totalResults: number;
    results: any[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfObject extends BaseResultOfObject {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface ObjectSearchResult extends SearchBehaviourBaseResultOfObject {
    elapsedMilliseconds: number;
}

export interface OutputSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[];
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[];
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[];
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[];
}

export interface BaseResultOfOutput {
    totalResults: number;
    results: Output[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface OutputSearchResult extends BaseResultOfOutput {
}

export interface UserProfile {
    id?: string;
    emailAddress?: string;
    firstName?: string;
    lastName?: string;
    languageCode?: string;
    address?: UserAddress;
    authorizationState: AuthorizationState;
    userRights?: UserRight[];
    userRoleIds?: string[];
    termsConsentExpired: boolean;
    systemUserRoles?: SystemUserRole[];
    isDeveloper: boolean;
}

export interface UserAddress {
    company?: string;
    address?: string;
    alternativeAddress?: string;
    department?: string;
    zip?: string;
    city?: string;
    phone?: string;
    countryCode?: string;
}

export enum AuthorizationState {
    Reviewed = <any>"Reviewed", 
    ToBeReviewed = <any>"ToBeReviewed", 
    Locked = <any>"Locked", 
    Invited = <any>"Invited", 
}

export enum SystemUserRole {
    Administrator = <any>"Administrator", 
}

export interface UserProfileUpdateRequest {
    id?: string;
    emailAddress?: string;
    firstName?: string;
    lastName?: string;
    languageCode?: string;
    address?: UserAddress;
}

/** The version view item for the environment. */
export interface VersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string;
}

export interface ShareDetail {
    id?: string;
    name?: string;
    description?: string;
    creator?: ShareUser;
    audit?: UserAudit;
    contentSelections?: ShareContentDetail[];
    layerSchemaIds?: string[];
    data?: ShareDataBase;
    mailTemplateId?: string;
    expirationDate?: Date;
    expired: boolean;
    template?: TemplateBase;
    outputAccess: OutputAccess;
    shareType: ShareType;
}

/** Reduced set of user information used for shares */
export interface ShareUser {
    /** Name of user */
    displayName?: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash?: string;
}

export interface ShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    content?: DataDictionary;
    metadata?: DataDictionary;
    id?: string;
    outputs?: ShareOutputBase[];
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary;
}

export interface ShareOutputBase {
    contentId?: string;
    outputFormatId?: string;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    url?: string;
    detail?: OutputDataBase;
}

export interface ShareOutputBasic extends ShareOutputBase {
}

export interface ShareOutputEmbed extends ShareOutputBase {
    token?: string;
}

export interface ShareDataBase {
    url?: string;
}

export interface ShareDataEmbed extends ShareDataBase {
    token?: string;
}

export interface ShareDataBasic extends ShareDataBase {
    mailRecipients?: MailRecipient[];
    internalRecipients?: InternalRecipient[];
    languageCode?: string;
}

export interface MailRecipient {
    userEmail?: UserEmail;
    token?: string;
    url?: string;
}

export interface UserEmail {
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
}

export interface InternalRecipient {
    recipient?: User;
    token?: string;
    url?: string;
}

export interface User {
    id?: string;
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
}

export interface TemplateBase {
    width?: number;
    height?: number;
}

export interface CardTemplate extends TemplateBase {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;
}

export interface ListTemplate extends TemplateBase {
}

export interface BasicTemplate extends TemplateBase {
}

export enum OutputAccess {
    Full = <any>"Full", 
    Preview = <any>"Preview", 
    None = <any>"None", 
}

export interface SchemaDetail {
    /** The schema id. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[];
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[];
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[];
    audit?: UserAudit;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: SearchFieldCount;
}

export interface DisplayPattern {
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary;
}

export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid", 
}

/** The field base class. */
export interface FieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string;
    /** The index id is auto generated by the system. */
    indexId?: string;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string;
    /** Language specific field names. */
    names?: TranslatedStringDictionary;
    /** Language specific field descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic filter index. */
    index: boolean;
    /** Includes fields in the simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
}

export interface FieldBoolean extends FieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export interface FieldDate extends FieldBase {
    /** Defines the date format structure. */
    format?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export interface FieldDateTime extends FieldBase {
    /** Defines the date time format structure. */
    format?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export interface FieldDateTimeArray extends FieldDateTime {
    maximumItems?: number;
    minimumItems?: number;
}

export interface FieldDecimal extends FieldBase {
    pattern?: string;
    /** Defines the lowest possible value. */
    minimum?: number;
    /** Defines the highest possible value. */
    maximum?: number;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export interface FieldDictionary extends FieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export interface FieldDictionaryArray extends FieldDictionary {
    maximumItems?: number;
    minimumItems?: number;
}

export interface FieldGeoPoint extends FieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export interface FieldLong extends FieldBase {
    pattern?: string;
    /** Defines the lowest possible value. */
    minimum?: number;
    /** Defines the highest possible value. */
    maximum?: number;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export interface FieldLongArray extends FieldLong {
    maximumItems?: number;
    minimumItems?: number;
}

export interface FieldSingleFieldset extends FieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
}

export interface SchemaIndexingInfo {
    /** A collecction of indexing information for the fields of a schema */
    fields?: FieldIndexingInfo[];
}

export interface FieldIndexingInfo {
    /** The field Id */
    id?: string;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Include the field for the sort index. */
    sortable: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
    /** Indexing information of fields of the schema related to this field (if existing) */
    relatedSchemaIndexing?: SchemaIndexingInfo;
}

export interface FieldMultiFieldset extends FieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number;
}

export interface FieldSingleTagbox extends FieldBase {
    /** The id of the schema with type list. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
}

export interface FieldMultiTagbox extends FieldBase {
    /** The id of the schema with type list. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Defines the lowest possible item count. */
    minimumItems?: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
}

export interface FieldString extends FieldBase {
    /** It is a DotLiquid template. */
    template?: string;
    /** Contains a regex validation pattern. */
    pattern?: string;
    /** Defines the minimal string length. */
    minimumLength?: number;
    /** Defines the maximal string length. */
    maximumLength?: number;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    indexAnalyzers?: AnalyzerBase[];
    /** Analyzers used for the simple search. Only one analyzer per type is allowed. Only considered if SimpleSearch is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[];
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[];
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** The analyzer base class. */
export interface AnalyzerBase {
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export interface EdgeNGramAnalyzer extends AnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

export enum Analyzer {
    None = <any>"None", 
    Simple = <any>"Simple", 
    Language = <any>"Language", 
    PathHierarchy = <any>"PathHierarchy", 
    EdgeNGram = <any>"EdgeNGram", 
    NGram = <any>"NGram", 
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export interface LanguageAnalyzer extends AnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export interface NGramAnalyzer extends AnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export interface PathHierarchyAnalyzer extends AnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export interface SimpleAnalyzer extends AnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** For internal use only (system schemas) */
export interface FieldStringArray extends FieldString {
    maximumItems?: number;
    minimumItems?: number;
}

export interface FieldTranslatedString extends FieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string;
    /** Defines the minimal string length. */
    minimumLength?: number;
    /** Defines the maximal string length. */
    maximumLength?: number;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    indexAnalyzers?: AnalyzerBase[];
    /** Analyzers used for the simple search. Only one analyzer per type is allowed. Only considered if SimpleSearch is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[];
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[];
    /** It is a DotLiquid template. */
    template?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export interface FieldSingleRelation extends FieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[];
}

export interface RelationType {
    /** The id property. */
    id?: string;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary;
    /** Defines the valid target context. */
    targetDocType?: string;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase;
}

export interface FieldMultiRelation extends FieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[];
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Dfines the lowest possible item count. */
    minimumItems?: number;
}

/** Base class for overwritten information on a field. */
export interface FieldOverwriteBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the required property of the field is overwritten */
    overwriteRequired: boolean;
}

/** Overwritten information for Single Tagbox field. */
export interface FieldOverwriteSingleTagbox extends FieldOverwriteBase {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Defines if the Filter property of the field is overwritten */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
    /** Defines if the ListItemCreateTemplate property of the field is overwritten */
    overwriteListItemCreateTemplate: boolean;
}

/** Overwritten information for Multi Tagbox field. */
export interface FieldOverwriteMultiTagbox extends FieldOverwriteBase {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Defines if the Filter property of the field is overwritten */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
    /** Defines if the ListItemCreateTemplate property of the field is overwritten */
    overwriteListItemCreateTemplate: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Defines if the MaximumItems property of the field is overwritten */
    overwriteMaximumItems: boolean;
    /** Defines the lowest possible item count. */
    minimumItems?: number;
    /** Defines if the MinimumItems property of the field is overwritten */
    overwriteMinimumItems: boolean;
}

/** Count info of fields for search operations */
export interface SearchFieldCount {
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;
    /** The number of fields that have sorting information stored in the search index. */
    sortableField: number;
}

export interface SchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];
}

export interface BaseResultOfSchema {
    totalResults: number;
    results: Schema[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfSchema extends BaseResultOfSchema {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface SchemaSearchResult extends SearchBehaviourBaseResultOfSchema {
}

export interface Schema {
    /** The schema id. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;
}

export interface IndexFieldsSearchBySchemaIdsRequest {
    schemaIds?: string[];
}

/** Contains compiled field information. */
export interface IndexField {
    id?: string;
    /** The field id. */
    fieldId?: string;
    /** The field's type name. */
    type?: string;
    /** Contains all index field name variants of the field. */
    indexFields?: { [key: string] : string; };
    /** Contains all simple search field name variants of the field.
The amount of simple search fields can be equal or less to the amount of IndexFields, but never more. */
    simpleSearchFields?: { [key: string] : string; };
    /** Contains the fields boost value. */
    boost: number;
    /** Not to be returned for search query, but only used for mapping purposes */
    ignoreForSearch: boolean;
    /** The path of the Nested document this property belongs to. If set to null, it means that there is no Nested document */
    nestedPath?: string;
    /** Path to the sorting information in the DataSortValuesField sort index. */
    sortField?: string;
}

/** Response that tells if exists */
export interface ExistsResponse {
    /** Gets or sets a value indicating whether it exists */
    exists: boolean;
}

export interface SchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[];
    /** The schema fields. Can be empty. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[];
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[];
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
}

export interface SchemaCreateResult {
    schema?: SchemaDetail;
}

export interface SchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[];
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[];
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[];
}

export interface SchemaUpdateResult {
    schema?: SchemaDetail;
}

export interface SchemaDeleteResult {
}

export interface PermissionSetDetailOfMetadataRight {
    id?: string;
    names?: TranslatedStringDictionary;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[];
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[];
    exclusive: boolean;
    ownerTokenId?: string;
}

export interface SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight {
}

export interface PermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string;
    names?: TranslatedStringDictionary;
    rights?: MetadataRight[];
}

export enum MetadataRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Manage = <any>"Manage", 
}

/** Schema import request */
export interface SchemaImportRequest {
    /** Id of the previously uploaded file transfer */
    fileTransferId?: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Import the list items for the schema. */
    importListItems: boolean;
}

/** Represents a transfer. */
export interface Transfer {
    /** ID of transfer. */
    id: string;
    /** Name of transfer. */
    name: string;
    /** State of transfer. */
    state: TransferState;
    /** Type of transfer. */
    transferType: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string;
    /** Number of files in transfer. */
    fileTransferCount: number;
    /** ID of collection created from transfer. */
    collectionId?: string;
}

export enum TransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    ImportFailed = <any>"ImportFailed", 
    Created = <any>"Created", 
    Deleted = <any>"Deleted", 
    TransferReady = <any>"TransferReady", 
    FileDeleteInProgress = <any>"FileDeleteInProgress", 
    TransferCleanup = <any>"TransferCleanup", 
    ImportCompletedWithErrors = <any>"ImportCompletedWithErrors", 
}

export interface CustomerServiceProviderConfiguration {
    serviceProviderId?: string;
    customerId?: string;
    userRoleIds?: string[];
    settings?: string;
}

export interface ServiceProviderConfigurationUpdateRequest {
    customerId?: string;
    settings?: string;
    userRoleIds?: string[];
}

export interface ShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the share document result set. */
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export interface BaseResultOfShare {
    totalResults: number;
    results: Share[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfShare extends BaseResultOfShare {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface ShareSearchResult extends SearchBehaviourBaseResultOfShare {
    elapsedMilliseconds: number;
}

export interface Share {
    name?: string;
    contentIds?: string[];
    id?: string;
    audit?: UserAudit;
    expirationDate?: Date;
    shareType: ShareType;
}

export interface ShareAggregationRequest {
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    aggregationFilters?: AggregationFilter[];
    aggregators?: AggregatorBase[];
}

export interface ShareBaseCreateRequest {
    name?: string;
    description?: string;
    expirationDate?: Date;
    contents?: ShareContent[];
    layerSchemaIds?: string[];
    template?: TemplateBase;
    outputAccess: OutputAccess;
}

export interface ShareContent {
    contentId?: string;
    outputFormatIds?: string[];
}

export interface ShareBasicCreateRequest extends ShareBaseCreateRequest {
    recipientsEmail?: UserEmail[];
    recipientsUser?: User[];
    recipientsGroup?: UserRole[];
    languageCode?: string;
    mailTemplateId?: string;
}

export interface UserRole {
    /** The user role id. */
    id?: string;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights?: UserRight[];
}

export interface ShareEmbedCreateRequest extends ShareBaseCreateRequest {
}

export interface CreateShareResult {
    shareId?: string;
}

export interface ShareBaseUpdateRequest {
    name?: string;
    expirationDate?: Date;
    description?: string;
    shareContentItems?: ShareContent[];
    layerSchemaIds?: string[];
    template?: TemplateBase;
    outputAccess: OutputAccess;
}

export interface ShareBasicUpdateRequest extends ShareBaseUpdateRequest {
}

export interface ShareEmbedUpdateRequest extends ShareBaseUpdateRequest {
}

export interface ShareDeleteManyRequest {
    ids?: string[];
}

/** Represents a transfer and includes detailed information. */
export interface TransferDetail extends Transfer {
    /** Audit information. */
    audit: UserAudit;
    /** Number of items processed. */
    itemProgress: number;
    /** Total number of items. */
    itemCount: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount: number;
    /** Number of items failed. */
    itemsFailed: number;
    /** Number of items cancelled. */
    itemsCancelled: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressStamp: number;
    /** LastTime stamp of last progress update from upload. */
    lastFileUploadProgressStamp: number;
}

/** Request to search for transfers. */
export interface TransferSearchRequest {
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
    start: number;
    limit: number;
    filter?: FilterBase;
}

export interface BaseResultOfTransfer {
    totalResults: number;
    results: Transfer[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfTransfer extends BaseResultOfTransfer {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

/** Result from a search for transfers. */
export interface TransferSearchResult extends SearchBehaviourBaseResultOfTransfer {
    /** Time in milliseconds query took to execute. */
    elapsedMilliseconds: number;
}

/** Creates a transfer. */
export interface CreateTransferRequest {
    /** Name of transfer. */
    name: string;
    /** Type of transfer. */
    transferType: TransferType;
    /** Files uploaded in transfer. */
    files?: TransferUploadFile[];
    /** Weblinks downloaded in transfer. */
    webLinks?: TransferWebLink[];
    /** Name of collection created after transfer. */
    collectionName?: string;
    /** A value indicating whether to create a Collection after importing the transfer. */
    createCollection: boolean;
}

/** Represents the base class for transfer items. */
export interface TransferFile {
    /** Client generated identifier of the item. */
    identifier: string;
}

/** Represents a file being uploaded in a transfer. */
export interface TransferUploadFile extends TransferFile {
    /** Target filename of file. */
    fileName: string;
}

/** Represents an item being downloaded by URL in a transfer. */
export interface TransferWebLink extends TransferFile {
    /** URL of the item. */
    url: string;
}

/** Representation of a file transfer. */
export interface FileTransfer {
    /** ID of file transfer. */
    id: string;
    /** Name of file transfer. */
    name: string;
    /** Client provided identifier. */
    identifier: string;
    /** ID of transfer. */
    transferId: string;
    /** State of file transfer. */
    state: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string;
}

/** Detailed representation of file transfer. */
export interface FileTransferDetail extends FileTransfer {
    /** Audit information. */
    audit: UserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata;
    /** Outputs being rendered for file. */
    outputItems?: FileTransferOutput[];
}

export interface FileMetadata {
    names?: TranslatedStringDictionary;
    descriptions?: TranslatedStringDictionary;
    fileExtension?: string;
    fileName?: string;
    filePath?: string;
    fileSizeInBytes?: number;
    sha1Hash?: string;
    xmpMetadata?: any;
    exifMetadata?: any;
    language?: string;
}

export interface AudioMetadata extends FileMetadata {
    audioStreams?: AudioStream[];
}

export interface AudioStream {
    bitRate?: string;
    bitRateMode?: string;
    channels?: string;
    channelPositions?: string;
    codec?: string;
    durationInSeconds?: number;
    format?: string;
    language?: string;
    resolution?: number;
    samplingRate?: number;
    streamSize?: number;
}

export interface DocumentMetadata extends FileMetadata {
    applicationName?: string;
    applicationVersion?: string;
    author?: string;
    creator?: string;
    publisher?: string;
    company?: string;
    documentTitle?: string;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[];
    imageTitles?: string[];
    epsInfo?: EpsMetadata;
}

export interface EpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export interface ImageMetadata extends FileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string;
    colorProfile?: string;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string;
    pixelFormat?: string;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export interface VideoMetadata extends FileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string;
    codec?: string;
    overallBitrate?: number;
    videoStreams?: VideoStream[];
    audioStreams?: AudioStream[];
}

export interface VideoStream {
    bitRate?: string;
    codec?: string;
    displayAspectRatio?: string;
    durationInSeconds: number;
    format?: string;
    frameCount?: number;
    frameRate?: number;
    height?: number;
    language?: string;
    pixelAspectRatio?: number;
    resolution?: number;
    streamSize?: number;
    width?: number;
    rotation?: number;
}

export interface FileTransferOutput {
    id?: string;
    filePath?: string;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered", 
    Embedded = <any>"Embedded", 
}

export enum FileTransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    DataExtractionInProgress = <any>"DataExtractionInProgress", 
    DataExtractionDone = <any>"DataExtractionDone", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    UploadFailed = <any>"UploadFailed", 
    ImportFailed = <any>"ImportFailed", 
    DeleteInProgress = <any>"DeleteInProgress", 
    Deleted = <any>"Deleted", 
    CleanupInProgress = <any>"CleanupInProgress", 
    CleanupCompleted = <any>"CleanupCompleted", 
}

/** Request to search for file transfers. */
export interface FileTransferSearchRequest {
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
    start: number;
    limit: number;
    filter?: FilterBase;
}

export interface BaseResultOfFileTransfer {
    totalResults: number;
    results: FileTransfer[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfFileTransfer extends BaseResultOfFileTransfer {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

/** Result from a search for file transfers. */
export interface FileTransferSearchResult extends SearchBehaviourBaseResultOfFileTransfer {
    /** Time in milliseconds query took to execute. */
    elapsedMilliseconds: number;
}

/** Blacklist containing file name patterns skipped when uploading. */
export interface Blacklist {
    /** Blacklist entries. */
    items: BlacklistItem[];
}

/** Entry in the Blacklist. */
export interface BlacklistItem {
    /** Friendly name of item. */
    name: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match: string;
}

/** Deletes files from transfer. */
export interface FileTransferDeleteRequest {
    /** ID of transfer. */
    transferId: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds: string[];
}

export interface ImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    metadata?: DataDictionary;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
}

export interface ImportTransferPartialRequest {
    items?: FileTransferCreateItem[];
}

export interface FileTransferCreateItem {
    fileId?: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    metadata?: DataDictionary;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
}

export interface UserCreateRequest {
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
    languageCode?: string;
    userRoleIds?: string[];
    address?: UserAddress;
}

export interface UserUpdateRequest extends User {
    userRoles?: UserRole[];
    comment?: string;
    languageCode?: string;
    address?: UserAddress;
}

export interface UserDetail extends UserUpdateRequest {
    ownerTokens?: OwnerToken[];
    authorizationState: AuthorizationState;
    lifeCycle: LifeCycle;
    isSupportUser: boolean;
    isReadOnly: boolean;
}

export interface OwnerToken {
    /** The ownertoken id. */
    id?: string;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string;
}

export enum LifeCycle {
    Draft = <any>"Draft", 
    Active = <any>"Active", 
    Inactive = <any>"Inactive", 
    Deleted = <any>"Deleted", 
}

export interface UserSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    lifeCycleFilter: LifeCycleFilter;
    userRightsFilter?: UserRight[];
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export interface BaseResultOfUserWithRoles {
    totalResults: number;
    results: UserWithRoles[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfUserWithRoles extends BaseResultOfUserWithRoles {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface UserSearchResult extends SearchBehaviourBaseResultOfUserWithRoles {
    elapsedMilliseconds: number;
}

export interface UserWithRoles {
    userRoleIds?: string[];
    id?: string;
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
    authorizationState: AuthorizationState;
    lifeCycle: LifeCycle;
    isSupportUser: boolean;
    isReadOnly: boolean;
}

export interface UserAggregationRequest {
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    aggregationFilters?: AggregationFilter[];
    aggregators?: AggregatorBase[];
}

export interface UserLockRequest {
    lock: boolean;
}

export interface UserReviewRequest {
    reviewed: boolean;
}

export interface UserDeleteRequest {
    ownerTokenTransferUserId?: string;
}

export interface UserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];
}

export interface BaseResultOfUserRole {
    totalResults: number;
    results: UserRole[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;
}

export interface SearchBehaviourBaseResultOfUserRole extends BaseResultOfUserRole {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export interface UserRoleSearchResult extends SearchBehaviourBaseResultOfUserRole {
    elapsedMilliseconds: number;
}

export interface UserRoleCreateRequest {
    names?: TranslatedStringDictionary;
    userRights?: UserRight[];
}

export interface UserRoleCreateManyRequest {
    items?: UserRoleCreateRequest[];
}

export interface UserRoleUpdateManyRequest {
    items?: UserRoleDetail[];
}

export interface UserRoleDetail {
    /** The user role id. */
    id?: string;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights?: UserRight[];
}

export interface UserRoleDeleteManyRequest {
    ids?: string[];
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

export class OidcClientSettings {
  static create(settings: { serverUrl: string, stsServerUrl: string, clientId: string, customerAlias: string, 
    customerId: string, scope: string, redirectServerUrl?: string, logoutServerUrl?: string }) {
    
    return {
      client_id: settings.clientId,
      scope: settings.scope,
      authority: settings.stsServerUrl,
      response_type: "id_token token",
      filterProtocolClaims: true,
      loadUserInfo: true,
      redirect_uri: settings.redirectServerUrl ? settings.redirectServerUrl : settings.serverUrl + '/auth-callback',
      post_logout_redirect_uri: settings.logoutServerUrl ? settings.logoutServerUrl : settings.serverUrl,
      acr_values: 'tenant:{"id":"' +
        settings.customerId + '","alias":"' +
        settings.customerAlias + '"}'
    }
  }
}

export class AccessTokenAuthClient extends AuthClient {
  constructor(pictureparkApiUrl: string, customerAlias: string, private accessToken: string) {
    super(pictureparkApiUrl, customerAlias);
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.accessToken) {
      (<Headers>options.headers).set('Authorization', 'Bearer ' + this.accessToken);
    }

    return super.transformHttpRequestOptions(options);
  }
}
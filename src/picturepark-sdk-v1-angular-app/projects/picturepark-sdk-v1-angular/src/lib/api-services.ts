/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { PictureparkServiceBase } from './base.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const PICTUREPARK_API_URL = new InjectionToken<string>('PICTUREPARK_API_URL');

export abstract class AuthService {
    private _pictureparkApiUrl: string;

    constructor(pictureparkApiUrl: string) {
        this._pictureparkApiUrl = pictureparkApiUrl;
    }

    get apiServer() {
        return this._pictureparkApiUrl;
    }

    abstract get isAuthenticated(): boolean;
    abstract transformHttpRequestOptions(options: any): Promise<any>;
}

@Injectable({
    providedIn: 'root'
})
export class BusinessProcessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param businessProcessSearchRequest The business process request
     * @return BusinessProcessSearchResult
     */
    search(businessProcessSearchRequest: BusinessProcessSearchRequest): Observable<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<BusinessProcessSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessSearchResult.fromJS(resultData200) : new BusinessProcessSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessSearchResult>(<any>null);
    }

    /**
     * Wait for lifeCycles
     * @param processId The process id
     * @param lifeCycleIds (optional) Business process lifeCycle to wait for
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitForLifeCycleResult
     */
    waitForLifeCycles(processId: string, lifeCycleIds: BusinessProcessLifeCycle[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitLifeCycles?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (lifeCycleIds !== undefined)
            lifeCycleIds && lifeCycleIds.forEach(item => { url_ += "lifeCycleIds=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForLifeCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForLifeCycles(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForLifeCycles(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitForLifeCycleResult.fromJS(resultData200) : new BusinessProcessWaitForLifeCycleResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Wait for states
     * @param processId The process id
     * @param states (optional) Business process states to wait for
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForStateResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitStates?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForStates(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForStateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForStateResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForStates(response: HttpResponseBase): Observable<BusinessProcessWaitForStateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitForStateResult.fromJS(resultData200) : new BusinessProcessWaitForStateResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForStateResult>(<any>null);
    }

    /**
     * Wait for completion
     * @param processId The process id
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(processId: string, timeout: string | null | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitCompletion?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForCompletion(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForCompletion(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitForLifeCycleResult.fromJS(resultData200) : new BusinessProcessWaitForLifeCycleResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Get details
     * @param processId The process id
     * @return BusinessProcessDetails
     */
    getDetails(processId: string): Observable<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/details";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessDetails>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<BusinessProcessDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessDetails.fromJS(resultData200) : new BusinessProcessDetails();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessDetails>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChannelService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get list of channels
     */
    getChannels(): Observable<Channel[]> {
        let url_ = this.baseUrl + "/v1/channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChannels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChannels(<any>response_);
                } catch (e) {
                    return <Observable<Channel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChannels(response: HttpResponseBase): Observable<Channel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Channel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    
    private thumbnailCache: { [key: string]: FileResponse | null; } = {};

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, cache?: boolean): Observable<FileResponse | null> {
        const key = contentId + ':' + size;
        if (cache !== false && this.thumbnailCache[key] !== undefined) {
            return _observableOf(this.thumbnailCache[key]);
        }

        const response = this.downloadThumbnailCore(contentId, size, null, null);
        response.subscribe(blob => {
            this.thumbnailCache[key] = blob;
        });
        return response;
    }

    /**
     * Get detail - single
     * @param contentId The content id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @return ContentDetail
     */
    get(contentId: string, resolveBehaviours: ContentResolveBehaviour[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Delete - single
     * @param contentId the id of the content to delete
     * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     */
    delete(contentId: string, forceReferenceRemoval: boolean | null | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get detail - many
     * @param ids List of contentIds
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @return List of ContentDetail
     */
    getMany(ids: string[] | null, resolveBehaviours: ContentResolveBehaviour[] | null | undefined): Observable<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContentDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @param allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @param contentCreateRequest The content create request.
     */
    create(resolveBehaviours: ContentResolveBehaviour[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, contentCreateRequest: ContentCreateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Search
     * @param contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    search(contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ContentSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : new ContentSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param contentAggregationRequest The aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Aggregate on channel
     * @param contentAggregationOnChannelRequest The content aggregation on channel request.
     * @return ObjectAggregationResult
     */
    aggregateOnChannel(contentAggregationOnChannelRequest: ContentAggregationOnChannelRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregateonchannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationOnChannelRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregateOnChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregateOnChannel(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregateOnChannel(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Get references
     * @return ContentReferencesResult
     */
    getReferences(contentId: string, contentReferencesRequest: ContentReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/references";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferences(<any>response_);
                } catch (e) {
                    return <Observable<ContentReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferences(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentReferencesResult.fromJS(resultData200) : new ContentReferencesResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentReferencesResult>(<any>null);
    }

    /**
     * Get references - many
     * @return ContentReferencesResult
     */
    getReferencesMany(contentManyReferencesRequest: ContentManyReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/many/references";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentManyReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesMany(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentReferencesResult.fromJS(resultData200) : new ContentReferencesResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentReferencesResult>(<any>null);
    }

    /**
     * Create download link
     * @param request The content download link request
     * @return ContentBatchDonloadItem
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDownloadLink(<any>response_);
                } catch (e) {
                    return <Observable<DownloadLink>><any>_observableThrow(e);
                }
            } else
                return <Observable<DownloadLink>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DownloadLink.fromJS(resultData200) : new DownloadLink();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DownloadLink>(<any>null);
    }

    /**
     * Download output
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download thumbnail
     * @param contentId The Content id
     * @param size Thumbnail size. Either small, medium or large
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @return HttpResponseMessage
     */
    protected downloadThumbnailCore(contentId: string, size: ThumbnailSize, width: number | null | undefined, height: number | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/thumbnails/{contentId}/{size}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadThumbnail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadThumbnail(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadThumbnail(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Create - many
     * @param contentCreateManyRequest The content create many request.
     */
    createMany(contentCreateManyRequest: ContentCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete - many
     * @param deleteManyRequest The delete many request
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ContentDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Restore - single
     * @param contentId The content id.
     * @param allowMissingDependencies (optional) Allow restoring contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return Void
     */
    restore(contentId: string, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/restore?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore - many
     * @param restoreManyRequest The content restore many request.
     * @return BusinessProcess
     */
    restoreMany(restoreManyRequest: ContentRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update file - single
     * @param contentId The id of the content to replace
     * @param updateRequest Update request
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/file";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFile(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFile(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update metadata - single
     * @param contentId The content id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @param allowMissingDependencies (optional) Allow storing references to missing list items
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @param updateRequest The metadata update request.
     * @return ContentDetail
     */
    updateMetadata(contentId: string, resolveBehaviours: ContentResolveBehaviour[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, updateRequest: ContentMetadataUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/metadata?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadata(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMetadata(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Update permissions - single
     * @param contentId The content id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the content are resolved and returned
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @param updateRequest The content permission update request.
     * @return ContentDetail
     */
    updatePermissions(contentId: string, resolveBehaviours: ContentResolveBehaviour[] | null | undefined, timeout: string | null | undefined, updateRequest: ContentPermissionsUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Update metadata - many
     * @param updateRequest The metadata update requests.
     * @return BusinessProcess
     */
    updateMetadataMany(updateRequest: ContentMetadataUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadataMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadataMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMetadataMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update permissions - many
     * @param updateManyRequest The permissions update many request.
     * @return BusinessProcess
     */
    updatePermissionsMany(updateManyRequest: ContentPermissionsUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissionsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Transfer ownership - single
     * @param contentId The content id.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @param updateRequest The content ownership transfer request update request.
     * @return ContentDetail
     */
    transferOwnership(contentId: string, timeout: string | null | undefined, updateRequest: ContentOwnershipTransferRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/ownership?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Transfer ownership - many
     * @param contentOwnershipTransferManyRequest The content ownership transfer many request.
     * @return BusinessProcess
     */
    transferOwnershipMany(contentOwnershipTransferManyRequest: ContentOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentOwnershipTransferManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by ids
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByIds(updateRequest: ContentFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByFilter(updateRequest: ContentFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param request The permission search request.
     * @return PermissionSetSearchResult
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : new PermissionSetSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetSearchResult>(<any>null);
    }

    /**
     * Get detail - single
     * @param permissionSetId The content permission set id.
     * @return ContentPermissionSetDetail
     */
    get(permissionSetId: string): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentPermissionSetDetail.fromJS(resultData200) : new ContentPermissionSetDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param documentHistorySearchRequest The document history search request
     * @return DocumentHistorySearchResult
     */
    search(documentHistorySearchRequest: DocumentHistorySearchRequest): Observable<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistorySearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistorySearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<DocumentHistorySearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistorySearchResult.fromJS(resultData200) : new DocumentHistorySearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistorySearchResult>(<any>null);
    }

    /**
     * Get latest
     * @param id The id of the document (e.g. ContentId)
     * @return DocumentHistory
     */
    get(id: string): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistory.fromJS(resultData200) : new DocumentHistory();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistory>(<any>null);
    }

    /**
     * Get latest by version
     * @param id The id of the document (e.g. ContentId)
     * @param version The version
     * @return DocumentHistory
     */
    getVersion(id: string, version: string): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{id}/{version}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistory.fromJS(resultData200) : new DocumentHistory();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistory>(<any>null);
    }

    /**
     * Get latest difference
     * @param id The id of the document (e.g. ContentId)
     * @param oldVersion The old version
     * @return DocumentHistoryDifference
     */
    getDifferenceLatest(id: string, oldVersion: number): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{id}/difference/{oldVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{oldVersion}", encodeURIComponent("" + oldVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDifferenceLatest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDifferenceLatest(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>_observableThrow(response_);
        }));
    }

    protected processGetDifferenceLatest(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifference.fromJS(resultData200) : new DocumentHistoryDifference();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Get difference
     * @param id The id of the document (e.g. ContentId)
     * @param oldVersion The old version
     * @param newVersion The new version
     * @return DocumentHistoryDifference
     */
    getDifference(id: string, oldVersion: number, newVersion: number): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{id}/difference/{oldVersion}/{newVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{oldVersion}", encodeURIComponent("" + oldVersion)); 
        if (newVersion === undefined || newVersion === null)
            throw new Error("The parameter 'newVersion' must be defined.");
        url_ = url_.replace("{newVersion}", encodeURIComponent("" + newVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDifference(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDifference(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>_observableThrow(response_);
        }));
    }

    protected processGetDifference(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifference.fromJS(resultData200) : new DocumentHistoryDifference();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistoryDifference>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class InfoService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get info
     * @return CustomerInfo
     */
    get(): Observable<CustomerInfo> {
        let url_ = this.baseUrl + "/v1/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CustomerInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerInfo.fromJS(resultData200) : new CustomerInfo();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerInfo>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class JsonSchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Json Schema
     * @param schemaId Schema Id
     * @return JsonSchemaViewItem
     */
    get(schemaId: string): Observable<any> {
        let url_ = this.baseUrl + "/v1/jsonSchemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ListItemService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get detail - single
     * @param listItemId The list item id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the list item are resolved and returned
     * @return List item detail
     */
    get(listItemId: string, resolveBehaviours: ListItemResolveBehaviour[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Update - single
     * @param listItemId The list item id.
     * @param resolveBehaviours (optional) List of enum that control which parts of the list item are resolved and returned
     * @param allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @param updateRequest The list item update request.
     * @return ListItemDetail
     */
    update(listItemId: string, resolveBehaviours: ListItemResolveBehaviour[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, updateRequest: ListItemUpdateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Delete - single
     * @param listItemId The id of the list item to delete
     * @param forceReferenceRemoval (optional) A value indicating whether references to the listitem should be removed.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return Void
     */
    delete(listItemId: string, forceReferenceRemoval: boolean | null | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get detail - many
     * @param ids List of list item ids
     * @param resolveBehaviours (optional) List of enum that control which parts of the list items are resolved and returned
     * @return List of list item details
     */
    getMany(ids: string[] | null, resolveBehaviours: ListItemResolveBehaviour[] | null | undefined): Observable<ListItemDetail[]> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ListItemDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ListItemDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @param resolveBehaviours (optional) List of enum that control which parts of the list item are resolved and returned
     * @param allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @param listItemCreateRequest List item create request.
     * @return ListItemDetail
     */
    create(resolveBehaviours: ListItemResolveBehaviour[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, listItemCreateRequest: ListItemCreateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (resolveBehaviours !== undefined)
            resolveBehaviours && resolveBehaviours.forEach(item => { url_ += "resolveBehaviours=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Search
     * @param listItemSearchRequest The list item search request.
     * @return List item result set.
     */
    search(listItemSearchRequest: ListItemSearchRequest): Observable<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/listItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListItemSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListItemSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemSearchResult.fromJS(resultData200) : new ListItemSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param listItemAggregationRequest The list item aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/listItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create - many
     * @param listItemCreateManyRequest List item create many request.
     * @return BusinessProcess
     */
    createMany(listItemCreateManyRequest: ListItemCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update - many
     * @param listItemUpdateManyRequest List item update many request.
     * @return BusinessProcess
     */
    updateMany(listItemUpdateManyRequest: ListItemUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemUpdateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete - many
     * @param deleteManyRequest The list items delete many request
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ListItemDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Restore - single
     * @param listItemId The list item id.
     * @param allowMissingDependencies (optional) Allow restoring list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the business process completed state.
     * @return Void
     */
    restore(listItemId: string, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/restore?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore - many
     * @param restoreManyRequest The list items restore many request.
     * @return BusinessProcess
     */
    restoreMany(restoreManyRequest: ListItemRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by ids
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByIds(updateRequest: ListItemFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByFilter(updateRequest: ListItemFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Gets the references to a list item.
     * @param listItemId The ID of the list item.
     * @return MetadataReferences
     */
    getReferencesToListItem(listItemId: string): Observable<ListItemReferences> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/references";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesToListItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesToListItem(<any>response_);
                } catch (e) {
                    return <Observable<ListItemReferences>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemReferences>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesToListItem(response: HttpResponseBase): Observable<ListItemReferences> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemReferences.fromJS(resultData200) : new ListItemReferences();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemReferences>(<any>null);
    }

    /**
     * Gets the references to the specified list items.
     * @param ids The IDs of the list items.
     * @return A MetadataReferences per list item id.
     */
    getReferencesToListItems(ids: string[] | null): Observable<ListItemReferences[]> {
        let url_ = this.baseUrl + "/v1/listItems/many/references?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesToListItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesToListItems(<any>response_);
                } catch (e) {
                    return <Observable<ListItemReferences[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemReferences[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesToListItems(response: HttpResponseBase): Observable<ListItemReferences[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ListItemReferences.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemReferences[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LiveStreamService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search LiveStream
     * @param liveStreamSearchRequest The livestream search request
     * @return ObjectSearchResult
     */
    search(liveStreamSearchRequest: LiveStreamSearchRequest): Observable<ObjectSearchResult> {
        let url_ = this.baseUrl + "/v1/liveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(liveStreamSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ObjectSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ObjectSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectSearchResult.fromJS(resultData200) : new ObjectSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search output documents
     * @param outputSearchRequest The output search request.
     * @return Output result set.
     */
    search(outputSearchRequest: OutputSearchRequest): Observable<OutputSearchResult> {
        let url_ = this.baseUrl + "/v1/outputs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(outputSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<OutputSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<OutputSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutputSearchResult.fromJS(resultData200) : new OutputSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputSearchResult>(<any>null);
    }

    /**
     * Get - single
     * @param outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Observable<OutputDetail> {
        let url_ = this.baseUrl + "/v1/outputs/{outputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{outputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OutputDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkBusinessException.fromJS(resultData404) : new PictureparkBusinessException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutputDetail.fromJS(resultData200) : new OutputDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputDetail>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProfileService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return UserProfile
     */
    get(): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfile>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfile.fromJS(resultData200) : new UserProfile();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfile>(<any>null);
    }

    /**
     * Update
     * @return UserProfile
     */
    update(updateRequest: UserProfileUpdateRequest): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfile>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfile.fromJS(resultData200) : new UserProfile();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfile>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PublicAccessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Version
     * @return VersionInfo
     */
    getVersion(): Observable<VersionInfo> {
        let url_ = this.baseUrl + "/v1/publicAccess/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<VersionInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<VersionInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<VersionInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VersionInfo.fromJS(resultData200) : new VersionInfo();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VersionInfo>(<any>null);
    }

    /**
     * Get Share
     * @param token The token
     * @return ShareBaseDetail
     */
    getShare(token: string): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/publicAccess/shares/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShare(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetShare(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareDetail.fromJS(resultData200) : new ShareDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @param schemaId The schema id.
     * @return SchemaDetail
     */
    get(schemaId: string): Observable<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaDetail.fromJS(resultData200) : new SchemaDetail();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail>(<any>null);
    }

    /**
     * Update - single
     * @param schemaId The schema id.
     * @param timeout (optional) Maximum time to wait for the operation to complete.
     * @param schema The schema update request.
     * @return SchemaUpdateResult containing the updated schema
     */
    update(schemaId: string, timeout: string | null | undefined, schema: SchemaUpdateRequest): Observable<SchemaUpdateResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaUpdateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaUpdateResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaUpdateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaUpdateResult.fromJS(resultData200) : new SchemaUpdateResult();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaUpdateResult>(<any>null);
    }

    /**
     * Delete - single
     * @param schemaId The schema id.
     * @param timeout (optional) Maximum time to wait for the operation to complete.
     * @return SchemaDeleteResult
     */
    delete(schemaId: string, timeout: string | null | undefined): Observable<SchemaDeleteResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDeleteResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDeleteResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SchemaDeleteResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaDeleteResult.fromJS(resultData200) : new SchemaDeleteResult();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDeleteResult>(<any>null);
    }

    /**
     * Get - many
     * @param ids (optional) Comma separated list of schema ids
     * @return SchemaDetail
     */
    getMany(ids: string[] | null | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @param timeout (optional) Maximum time to wait for the operation to complete.
     * @param schema The schema create request.
     * @return SchemaCreateResult containing the created schema.
     */
    create(timeout: string | null | undefined, schema: SchemaCreateRequest): Observable<SchemaCreateResult> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaCreateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaCreateResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaCreateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaCreateResult.fromJS(resultData200) : new SchemaCreateResult();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaCreateResult>(<any>null);
    }

    /**
     * Search
     * @param schemaSearchRequest The schema search request.
     * @return Schema result set.
     */
    search(schemaSearchRequest: SchemaSearchRequest): Observable<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SchemaSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SchemaSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaSearchResult.fromJS(resultData200) : new SchemaSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaSearchResult>(<any>null);
    }

    /**
     * Get index fields
     * @param request The get request.
     * @return Indexed fields
     */
    getIndexFields(request: IndexFieldsSearchBySchemaIdsRequest): Observable<IndexField[]> {
        let url_ = this.baseUrl + "/v1/schemas/indexFields/searchBySchemaIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetIndexFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndexFields(<any>response_);
                } catch (e) {
                    return <Observable<IndexField[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndexField[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndexFields(response: HttpResponseBase): Observable<IndexField[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(IndexField.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndexField[]>(<any>null);
    }

    /**
     * Exists
     * @param schemaId The schema id.
     * @param fieldId (optional) The optional field id.
     * @return ExistsResponse
     */
    exists(schemaId: string, fieldId: string | null | undefined): Observable<ExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/exists?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(<any>response_);
                } catch (e) {
                    return <Observable<ExistsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExistsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<ExistsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExistsResponse.fromJS(resultData200) : new ExistsResponse();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExistsResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param request The permission search request.
     * @return PermissionSetSearchResult
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : new PermissionSetSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetSearchResult>(<any>null);
    }

    /**
     * Get detail - single
     * @param permissionSetId The schema permission set id.
     * @return SchemaPermissionSetDetail
     */
    get(permissionSetId: string): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaPermissionSetDetail.fromJS(resultData200) : new SchemaPermissionSetDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaTransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Import schemas
     * @param schemaImportRequest The schema import request.
     * @return Transfer
     */
    import(schemaImportRequest: SchemaImportRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/schematransfers/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaImportRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkBusinessException.fromJS(resultData400) : new PictureparkBusinessException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ServiceProviderService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get configuration
     */
    getConfiguration(serviceProviderId: string): Observable<CustomerServiceProviderConfiguration> {
        let url_ = this.baseUrl + "/v1/serviceProviders/{serviceProviderId}/configuration";
        if (serviceProviderId === undefined || serviceProviderId === null)
            throw new Error("The parameter 'serviceProviderId' must be defined.");
        url_ = url_.replace("{serviceProviderId}", encodeURIComponent("" + serviceProviderId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<CustomerServiceProviderConfiguration>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerServiceProviderConfiguration>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<CustomerServiceProviderConfiguration> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerServiceProviderConfiguration.fromJS(resultData200) : new CustomerServiceProviderConfiguration();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerServiceProviderConfiguration>(<any>null);
    }

    /**
     * Update configuration
     */
    updateConfiguration(serviceProviderId: string, configuration: ServiceProviderConfigurationUpdateRequest): Observable<CustomerServiceProviderConfiguration> {
        let url_ = this.baseUrl + "/v1/serviceProviders/{serviceProviderId}/configuration";
        if (serviceProviderId === undefined || serviceProviderId === null)
            throw new Error("The parameter 'serviceProviderId' must be defined.");
        url_ = url_.replace("{serviceProviderId}", encodeURIComponent("" + serviceProviderId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configuration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<CustomerServiceProviderConfiguration>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerServiceProviderConfiguration>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfiguration(response: HttpResponseBase): Observable<CustomerServiceProviderConfiguration> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerServiceProviderConfiguration.fromJS(resultData200) : new CustomerServiceProviderConfiguration();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerServiceProviderConfiguration>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ShareAccessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Share json
     * @param token The token
     * @return ShareDetail
     */
    getShareJson(token: string): Observable<any> {
        let url_ = this.baseUrl + "/v1/shareAccess/json/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShareJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShareJson(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetShareJson(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Download Shared outputs
     * @param token The token
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(token: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shareAccess/d/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download Shared outputs
     * @param token The token
     * @param contentId The content id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithContentId(token: string, contentId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shareAccess/d/{token}/{contentId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithContentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithContentId(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWithContentId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download Shared outputs
     * @param token The token
     * @param contentId The content id
     * @param outputFormatId The output format id+
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithOutputFormatId(token: string, contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shareAccess/d/{token}/{contentId}/{outputFormatId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithOutputFormatId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithOutputFormatId(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWithOutputFormatId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ShareService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @param id Share Id (not token, use PublicAccess to get share by token)
     * @return Polymorph share
     */
    get(id: string): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareDetail.fromJS(resultData200) : new ShareDetail();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }

    /**
     * Update - single
     * @param id The share id.
     * @param updateRequest The share update request.
     * @return Share
     */
    update(id: string, updateRequest: ShareBaseUpdateRequest): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareDetail.fromJS(resultData200) : new ShareDetail();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }

    /**
     * Search
     * @param request Search request
     * @return Share search result
     */
    search(request: ShareSearchRequest): Observable<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ShareSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ShareSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareSearchResult.fromJS(resultData200) : new ShareSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param request Aggregation request
     * @return AggregationResult
     */
    aggregate(request: ShareAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create - single
     * @param request Polymorph create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest): Observable<CreateShareResult> {
        let url_ = this.baseUrl + "/v1/shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateShareResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateShareResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateShareResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? PermissionValidationException.fromJS(resultData403) : new PermissionValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateShareResult.fromJS(resultData200) : new CreateShareResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateShareResult>(<any>null);
    }

    /**
     * Delete - many
     * @param deleteManyRequest A delete many request containing the ids of the shares to delete.
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ShareDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/shares/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BulkResponse.fromJS(resultData200) : new BulkResponse();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get transfer details
     * @param transferId ID of transfer.
     * @return TransferDetail
     */
    get(transferId: string): Observable<TransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TransferDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferDetail.fromJS(resultData200) : new TransferDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferDetail>(<any>null);
    }

    /**
     * Delete transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    delete(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Search
     * @param request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest): Observable<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<TransferSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<TransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferSearchResult.fromJS(resultData200) : new TransferSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferSearchResult>(<any>null);
    }

    /**
     * Cancel transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    cancelTransfer(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelTransfer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelTransfer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create transfer
     * @param request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Get file
     * @param fileTransferId ID of filetransfer.
     * @return FileTransferDetail
     */
    getFile(fileTransferId: string): Observable<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/files/{fileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{fileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileTransferDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileTransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferDetail.fromJS(resultData200) : new FileTransferDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileTransferDetail>(<any>null);
    }

    /**
     * Search for files
     * @param request The filetransfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest): Observable<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFiles(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileTransferSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchFiles(response: HttpResponseBase): Observable<FileTransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferSearchResult.fromJS(resultData200) : new FileTransferSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileTransferSearchResult>(<any>null);
    }

    /**
     * Get blacklist
     * @return Blacklist
     */
    getBlacklist(): Observable<Blacklist> {
        let url_ = this.baseUrl + "/v1/transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBlacklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlacklist(<any>response_);
                } catch (e) {
                    return <Observable<Blacklist>><any>_observableThrow(e);
                }
            } else
                return <Observable<Blacklist>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlacklist(response: HttpResponseBase): Observable<Blacklist> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Blacklist.fromJS(resultData200) : new Blacklist();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Blacklist>(<any>null);
    }

    /**
     * Delete files
     * @param request The filetransfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFiles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Import transfer
     * @param transferId ID of transfer.
     * @param request The ImportTransfer request.
     * @return Transfer
     */
    importTransfer(transferId: string, request: ImportTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImportTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTransfer(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processImportTransfer(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Import transfer partially
     * @param transferId ID of transfer.
     * @param request The ImportTransferPartial request.
     * @return Transfer
     */
    partialImport(transferId: string, request: ImportTransferPartialRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/partialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPartialImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartialImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processPartialImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Upload file
     * @param formFile (optional) Gets or sets the form file.
     * @param relativePath Relative path of the uploading file.
     * @param chunkNumber Current chunk number. Starts at 1.
     * @param currentChunkSize Size in bytes of the current chunk.
     * @param totalSize Total size in bytes of the uploading file.
     * @param totalChunks Total chunks of the uploading file.
     * @param transferId ID of transfer.
     * @param identifier Identifier of file.
     * @return OK
     */
    uploadFile(formFile: FileParameter | null | undefined, relativePath: string | null, chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string, identifier: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/files/{identifier}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier)); 
        if (relativePath === undefined)
            throw new Error("The parameter 'relativePath' must be defined.");
        else
            url_ += "relativePath=" + encodeURIComponent("" + relativePath) + "&"; 
        if (chunkNumber === undefined || chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
        else
            url_ += "chunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === undefined || currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
        else
            url_ += "currentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === undefined || totalSize === null)
            throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
        else
            url_ += "totalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === undefined || totalChunks === null)
            throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
        else
            url_ += "totalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create a new user (without inviting him)
     */
    create(request: UserCreateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : new UserDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Get by id
     * @param userId The user id
     * @return UserDetail
     */
    get(userId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : new UserDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Updates one or more users
     */
    update(userId: string, userUpdatableDetail: UserUpdateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userUpdatableDetail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : new UserDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Search for users
     * @param searchRequest The user search request
     * @return UserSearchResult
     */
    search(searchRequest: UserSearchRequest): Observable<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserSearchResult.fromJS(resultData200) : new UserSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSearchResult>(<any>null);
    }

    /**
     * Get by owner token
     * @param tokenId The token id
     * @return UserDetail
     */
    getByOwnerToken(tokenId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByOwnerToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOwnerToken(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetByOwnerToken(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : new UserDetail();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Get multiple user details by supplying their ID's
     * @param ids The user ID's
     * @return IEnumerable&lt;UserDetail&gt;
     */
    getMany(ids: string[] | null): Observable<UserDetail[]> {
        let url_ = this.baseUrl + "/v1/users/many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail[]>(<any>null);
    }

    /**
     * Searches and aggregates users by different attributes
     */
    aggregate(userAggregationRequest: UserAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/users/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Locks or unlocks one or more users
     */
    lock(userId: string, userLockRequest: UserLockRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/lock";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userLockRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Sets one or more users as reviewed or under review
     */
    review(userId: string, userReviewRequest: UserReviewRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/review";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userReviewRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReview(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Invites (or creates) new users
     */
    invite(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/invite";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvite(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Deletes a user
     */
    delete(userId: string, userDeactivateRequest: UserDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/delete";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDeactivateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restores a previously deleted user
     */
    restore(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/restore";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get all roles
     * @return UserDetail
     */
    getAll(): Observable<UserRole[]> {
        let url_ = this.baseUrl + "/v1/userRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserRole[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserRole.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole[]>(<any>null);
    }

    /**
     * Create a new user role
     * @param request Create request
     */
    create(request: UserRoleCreateRequest): Observable<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserRole.fromJS(resultData200) : new UserRole();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole>(<any>null);
    }

    /**
     * Get by id
     * @param userRoleId The user role id
     * @return UserDetail
     */
    get(userRoleId: string): Observable<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles/{userRoleId}";
        if (userRoleId === undefined || userRoleId === null)
            throw new Error("The parameter 'userRoleId' must be defined.");
        url_ = url_.replace("{userRoleId}", encodeURIComponent("" + userRoleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserRole.fromJS(resultData200) : new UserRole();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole>(<any>null);
    }

    /**
     * Search for user roles
     * @param searchRequest The user role search request
     * @return UserRoleSearchResult
     */
    search(searchRequest: UserRoleSearchRequest): Observable<UserRoleSearchResult> {
        let url_ = this.baseUrl + "/v1/userRoles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserRoleSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserRoleSearchResult.fromJS(resultData200) : new UserRoleSearchResult();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleSearchResult>(<any>null);
    }

    /**
     * Create multiple new user roles
     * @param request Create request
     */
    createMany(request: UserRoleCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BulkResponse.fromJS(resultData200) : new BulkResponse();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple user roles
     * @param request Update request
     */
    updateMany(request: UserRoleUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BulkResponse.fromJS(resultData200) : new BulkResponse();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Deletes multiple user roles
     * @param request Delete request
     */
    deleteMany(request: UserRoleDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BulkResponse.fromJS(resultData200) : new BulkResponse();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : new PictureparkException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? PictureparkNotFoundException.fromJS(resultData404) : new PictureparkNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? PictureparkConflictException.fromJS(resultData409) : new PictureparkConflictException();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkValidationException.fromJS(resultData400) : new PictureparkValidationException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }
}

export class BusinessProcessSearchRequest implements IBusinessProcessSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];

    constructor(data?: IBusinessProcessSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.filter = new FilterBase();
            this.searchBehaviours = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
        }
    }

    static fromJS(data: any): BusinessProcessSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        return data; 
    }
}

export interface IBusinessProcessSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
}

/** The FilterBase is the base class for all filters. */
export class FilterBase implements IFilterBase {

    protected _discriminator: string;

    getDisplayName(locale: string): string | null {
        return null;
    }

    constructor(data?: IFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FilterBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): FilterBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AndFilter") {
            let result = new AndFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrFilter") {
            let result = new OrFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFilter") {
            let result = new NotFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DateRangeFilter") {
            let result = new DateRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ExistsFilter") {
            let result = new ExistsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoBoundingBoxFilter") {
            let result = new GeoBoundingBoxFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceFilter") {
            let result = new GeoDistanceFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedFilter") {
            let result = new NestedFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeFilter") {
            let result = new NumericRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PrefixFilter") {
            let result = new PrefixFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermFilter") {
            let result = new TermFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsFilter") {
            let result = new TermsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilter") {
            let result = new AggregationFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChildFilter") {
            let result = new ChildFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ParentFilter") {
            let result = new ParentFilter();
            result.init(data);
            return result;
        }
        let result = new FilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

/** The FilterBase is the base class for all filters. */
export interface IFilterBase {
}

/** The AndFilter&gt; is a compound filter and returns documents that match all of the specified filters. */
export class AndFilter extends FilterBase implements IAndFilter {
    /** Accepts all filters. */
    filters?: FilterBase[];

    constructor(data?: IAndFilter) {
        super(data);
        if (!data) {
            this.filters = [];
        }
        this._discriminator = "AndFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AndFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AndFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The AndFilter&gt; is a compound filter and returns documents that match all of the specified filters. */
export interface IAndFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[];
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export class OrFilter extends FilterBase implements IOrFilter {
    /** Accepts all filters. */
    filters?: FilterBase[];

    constructor(data?: IOrFilter) {
        super(data);
        if (!data) {
            this.filters = [];
        }
        this._discriminator = "OrFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OrFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export interface IOrFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[];
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export class NotFilter extends FilterBase implements INotFilter {
    /** Limits the result set. */
    filter?: FilterBase;

    constructor(data?: INotFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "NotFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): NotFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NotFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export interface INotFilter extends IFilterBase {
    /** Limits the result set. */
    filter?: FilterBase;
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export class DateRangeFilter extends FilterBase implements IDateRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange;

    getDisplayName(locale: string) {
        return this.range && this.range.names ? this.range.names.translate(locale) : 'n/a';
    }

    constructor(data?: IDateRangeFilter) {
        super(data);
        if (!data) {
            this.range = new DateRange();
        }
        this._discriminator = "DateRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.range = data["range"] ? DateRange.fromJS(data["range"]) : new DateRange();
        }
    }

    static fromJS(data: any): DateRangeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export interface IDateRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: IDateRange;
}

/** The date range class used in aggregators and filters. */
export class DateRange implements IDateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string;

    constructor(data?: IDateRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): DateRange {
        data = typeof data === 'object' ? data : {};
        let result = new DateRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

/** The date range class used in aggregators and filters. */
export interface IDateRange {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string;
}

/** A custom dictionary type to distinguish language specific class properties. */
export class TranslatedStringDictionary implements ITranslatedStringDictionary {

    [key: string]: string | any; 

    translate(locale: string) {
        const language = locale.split('-')[0];
        return this[language] ? this[language] : this[Object.keys(this)[0]];
    }

    constructor(data?: ITranslatedStringDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): TranslatedStringDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new TranslatedStringDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

/** A custom dictionary type to distinguish language specific class properties. */
export interface ITranslatedStringDictionary {

    [key: string]: string | any; 
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export class ExistsFilter extends FilterBase implements IExistsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;

    constructor(data?: IExistsFilter) {
        super(data);
        this._discriminator = "ExistsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
        }
    }

    static fromJS(data: any): ExistsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ExistsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        super.toJSON(data);
        return data; 
    }
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export interface IExistsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export class GeoBoundingBoxFilter extends FilterBase implements IGeoBoundingBoxFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation;

    constructor(data?: IGeoBoundingBoxFilter) {
        super(data);
        if (!data) {
            this.topLeft = new GeoLocation();
            this.bottomRight = new GeoLocation();
        }
        this._discriminator = "GeoBoundingBoxFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.topLeft = data["topLeft"] ? GeoLocation.fromJS(data["topLeft"]) : new GeoLocation();
            this.bottomRight = data["bottomRight"] ? GeoLocation.fromJS(data["bottomRight"]) : new GeoLocation();
        }
    }

    static fromJS(data: any): GeoBoundingBoxFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoBoundingBoxFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["topLeft"] = this.topLeft ? this.topLeft.toJSON() : <any>undefined;
        data["bottomRight"] = this.bottomRight ? this.bottomRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export interface IGeoBoundingBoxFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The top left longitude/latitude configuration. */
    topLeft?: IGeoLocation;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: IGeoLocation;
}

export class GeoLocation implements IGeoLocation {
    lat: number;
    lon: number;

    constructor(data?: IGeoLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["lat"];
            this.lon = data["lon"];
        }
    }

    static fromJS(data: any): GeoLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeoLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data; 
    }
}

export interface IGeoLocation {
    lat: number;
    lon: number;
}

/** The GeoDistanceFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export class GeoDistanceFilter extends FilterBase implements IGeoDistanceFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation;
    /** The range distance in meters. */
    distance: number;

    constructor(data?: IGeoDistanceFilter) {
        super(data);
        if (!data) {
            this.location = new GeoLocation();
        }
        this._discriminator = "GeoDistanceFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : new GeoLocation();
            this.distance = data["distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export interface IGeoDistanceFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The longitude/latitude configuration for the point of origin. */
    location?: IGeoLocation;
    /** The range distance in meters. */
    distance: number;
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export class NestedFilter extends FilterBase implements INestedFilter {
    /** The path pointing to the nested object. */
    path?: string;
    /** Limits the result set. */
    filter?: FilterBase;

    constructor(data?: INestedFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "NestedFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["path"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): NestedFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NestedFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export interface INestedFilter extends IFilterBase {
    /** The path pointing to the nested object. */
    path?: string;
    /** Limits the result set. */
    filter?: FilterBase;
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export class NumericRangeFilter extends FilterBase implements INumericRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The numeric range with from and to properties. */
    range?: NumericRange;

    constructor(data?: INumericRangeFilter) {
        super(data);
        if (!data) {
            this.range = new NumericRange();
        }
        this._discriminator = "NumericRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.range = data["range"] ? NumericRange.fromJS(data["range"]) : new NumericRange();
        }
    }

    static fromJS(data: any): NumericRangeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export interface INumericRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The numeric range with from and to properties. */
    range?: INumericRange;
}

export class NumericRange implements INumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value. */
    from?: number;
    /** The to value. */
    to?: number;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): NumericRange {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

export interface INumericRange {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary;
    /** The from value. */
    from?: number;
    /** The to value. */
    to?: number;
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export class PrefixFilter extends FilterBase implements IPrefixFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The prefix term to filter on. */
    prefix?: string;

    constructor(data?: IPrefixFilter) {
        super(data);
        this._discriminator = "PrefixFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.prefix = data["prefix"];
        }
    }

    static fromJS(data: any): PrefixFilter {
        data = typeof data === 'object' ? data : {};
        let result = new PrefixFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["prefix"] = this.prefix;
        super.toJSON(data);
        return data; 
    }
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export interface IPrefixFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The prefix term to filter on. */
    prefix?: string;
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export class TermFilter extends FilterBase implements ITermFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The term to filter on. */
    term?: string;

    constructor(data?: ITermFilter) {
        super(data);
        this._discriminator = "TermFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.term = data["term"];
        }
    }

    static fromJS(data: any): TermFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TermFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["term"] = this.term;
        super.toJSON(data);
        return data; 
    }
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export interface ITermFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** The term to filter on. */
    term?: string;
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export class TermsFilter extends FilterBase implements ITermsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** A list of OR combined terms. */
    terms?: string[];

    constructor(data?: ITermsFilter) {
        super(data);
        if (!data) {
            this.terms = [];
        }
        this._discriminator = "TermsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["terms"] && data["terms"].constructor === Array) {
                this.terms = [];
                for (let item of data["terms"])
                    this.terms.push(item);
            }
        }
    }

    static fromJS(data: any): TermsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TermsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.terms && this.terms.constructor === Array) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export interface ITermsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string;
    /** A list of OR combined terms. */
    terms?: string[];
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export class AggregationFilter extends FilterBase implements IAggregationFilter {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter, GeoDistanceFilter and NestedFilter. */
    filter?: FilterBase;
    temporaryAggregatorRequestId?: string;

    constructor(data?: IAggregationFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "AggregationFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregationName = data["aggregationName"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.temporaryAggregatorRequestId = data["temporaryAggregatorRequestId"];
        }
    }

    static fromJS(data: any): AggregationFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["temporaryAggregatorRequestId"] = this.temporaryAggregatorRequestId;
        super.toJSON(data);
        return data; 
    }
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export interface IAggregationFilter extends IFilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter, GeoDistanceFilter and NestedFilter. */
    filter?: FilterBase;
    temporaryAggregatorRequestId?: string;
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export class ChildFilter extends FilterBase implements IChildFilter {
    /** The elastic search index type to filter as a child. */
    childType?: string;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase;

    constructor(data?: IChildFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "ChildFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.childType = data["childType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): ChildFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ChildFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childType"] = this.childType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export interface IChildFilter extends IFilterBase {
    /** The elastic search index type to filter as a child. */
    childType?: string;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase;
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export class ParentFilter extends FilterBase implements IParentFilter {
    /** The elastic search index type to filter as a parent. */
    parentType?: string;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase;

    constructor(data?: IParentFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "ParentFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentType = data["parentType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): ParentFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ParentFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentType"] = this.parentType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export interface IParentFilter extends IFilterBase {
    /** The elastic search index type to filter as a parent. */
    parentType?: string;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase;
}

export enum SearchBehaviour {
    DropInvalidCharactersOnFailure = <any>"DropInvalidCharactersOnFailure", 
    WildcardOnSingleTerm = <any>"WildcardOnSingleTerm", 
}

export class BaseResultOfBusinessProcess implements IBaseResultOfBusinessProcess {
    totalResults: number;
    results: BusinessProcess[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(BusinessProcess.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfBusinessProcess {
    totalResults: number;
    results: BusinessProcess[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess implements ISearchBehaviourBaseResultOfBusinessProcess {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfBusinessProcess) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfBusinessProcess extends IBaseResultOfBusinessProcess {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class BusinessProcessSearchResult extends SearchBehaviourBaseResultOfBusinessProcess implements IBusinessProcessSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IBusinessProcessSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): BusinessProcessSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessSearchResult extends ISearchBehaviourBaseResultOfBusinessProcess {
    elapsedMilliseconds: number;
}

export class BusinessProcess implements IBusinessProcess {
    id?: string;
    processDefinitionId?: string;
    referenceId?: string;
    referenceDocType?: string;
    supportsCancellation: boolean;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCycle;
    startDate: Date;
    endDate: Date;
    finished: boolean;
    stateHistory?: BusinessProcessState[];
    currentState?: string;
    processDefinitionName?: string;

    protected _discriminator: string;

    constructor(data?: IBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.stateHistory) {
                this.stateHistory = [];
                for (let i = 0; i < data.stateHistory.length; i++) {
                    let item = data.stateHistory[i];
                    this.stateHistory[i] = item && !(<any>item).toJSON ? new BusinessProcessState(item) : <BusinessProcessState>item;
                }
            }
        }
        if (!data) {
            this.stateHistory = [];
        }
        this._discriminator = "BusinessProcess";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.processDefinitionId = data["processDefinitionId"];
            this.referenceId = data["referenceId"];
            this.referenceDocType = data["referenceDocType"];
            this.supportsCancellation = data["supportsCancellation"];
            this.businessProcessScope = data["businessProcessScope"];
            this.lifeCycle = data["lifeCycle"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.finished = data["finished"];
            if (data["stateHistory"] && data["stateHistory"].constructor === Array) {
                this.stateHistory = [];
                for (let item of data["stateHistory"])
                    this.stateHistory.push(BusinessProcessState.fromJS(item));
            }
            this.currentState = data["currentState"];
            this.processDefinitionName = data["processDefinitionName"];
        }
    }

    static fromJS(data: any): BusinessProcess {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessBulkResponse") {
            let result = new BusinessProcessBulkResponse();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetails") {
            let result = new BusinessProcessDetails();
            result.init(data);
            return result;
        }
        let result = new BusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["processDefinitionId"] = this.processDefinitionId;
        data["referenceId"] = this.referenceId;
        data["referenceDocType"] = this.referenceDocType;
        data["supportsCancellation"] = this.supportsCancellation;
        data["businessProcessScope"] = this.businessProcessScope;
        data["lifeCycle"] = this.lifeCycle;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["finished"] = this.finished;
        if (this.stateHistory && this.stateHistory.constructor === Array) {
            data["stateHistory"] = [];
            for (let item of this.stateHistory)
                data["stateHistory"].push(item.toJSON());
        }
        data["currentState"] = this.currentState;
        data["processDefinitionName"] = this.processDefinitionName;
        return data; 
    }
}

export interface IBusinessProcess {
    id?: string;
    processDefinitionId?: string;
    referenceId?: string;
    referenceDocType?: string;
    supportsCancellation: boolean;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCycle;
    startDate: Date;
    endDate: Date;
    finished: boolean;
    stateHistory?: IBusinessProcessState[];
    currentState?: string;
    processDefinitionName?: string;
}

export enum BusinessProcessScope {
    System = <any>"System", 
    User = <any>"User", 
}

export enum BusinessProcessLifeCycle {
    Draft = <any>"Draft", 
    InProgress = <any>"InProgress", 
    Succeeded = <any>"Succeeded", 
    Cancelled = <any>"Cancelled", 
    CancellationInProgress = <any>"CancellationInProgress", 
    Failed = <any>"Failed", 
    SucceededWithErrors = <any>"SucceededWithErrors", 
}

export class BusinessProcessState implements IBusinessProcessState {
    state?: string;
    timestamp: Date;
    error?: ErrorResponse;

    constructor(data?: IBusinessProcessState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error; 
        }
        if (!data) {
            this.error = new ErrorResponse();
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.error = data["error"] ? ErrorResponse.fromJS(data["error"]) : new ErrorResponse();
        }
    }

    static fromJS(data: any): BusinessProcessState {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessState {
    state?: string;
    timestamp: Date;
    error?: IErrorResponse;
}

export class ErrorResponse implements IErrorResponse {
    exception?: string;
    traceId?: string;
    traceJobId?: string;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exception = data["exception"];
            this.traceId = data["traceId"];
            this.traceJobId = data["traceJobId"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exception"] = this.exception;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        return data; 
    }
}

export interface IErrorResponse {
    exception?: string;
    traceId?: string;
    traceJobId?: string;
}

export class BusinessProcessBulkResponse extends BusinessProcess implements IBusinessProcessBulkResponse {
    response?: BulkResponse;

    constructor(data?: IBusinessProcessBulkResponse) {
        super(data);
        if (!data) {
            this.response = new BulkResponse();
        }
        this._discriminator = "BusinessProcessBulkResponse";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.response = data["response"] ? BulkResponse.fromJS(data["response"]) : new BulkResponse();
        }
    }

    static fromJS(data: any): BusinessProcessBulkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessBulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessBulkResponse extends IBusinessProcess {
    response?: IBulkResponse;
}

export class BulkResponse implements IBulkResponse {
    rows?: BulkResponseRow[];

    constructor(data?: IBulkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rows) {
                this.rows = [];
                for (let i = 0; i < data.rows.length; i++) {
                    let item = data.rows[i];
                    this.rows[i] = item && !(<any>item).toJSON ? new BulkResponseRow(item) : <BulkResponseRow>item;
                }
            }
        }
        if (!data) {
            this.rows = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["rows"] && data["rows"].constructor === Array) {
                this.rows = [];
                for (let item of data["rows"])
                    this.rows.push(BulkResponseRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rows && this.rows.constructor === Array) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBulkResponse {
    rows?: IBulkResponseRow[];
}

export class BulkResponseRow implements IBulkResponseRow {
    id?: string;
    version: number;
    error?: string;
    succeeded: boolean;
    status: number;

    constructor(data?: IBulkResponseRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.version = data["version"];
            this.error = data["error"];
            this.succeeded = data["succeeded"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BulkResponseRow {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResponseRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["error"] = this.error;
        data["succeeded"] = this.succeeded;
        data["status"] = this.status;
        return data; 
    }
}

export interface IBulkResponseRow {
    id?: string;
    version: number;
    error?: string;
    succeeded: boolean;
    status: number;
}

export class QueryDebugInformation implements IQueryDebugInformation {
    general?: string;
    auditTrail?: string;
    request?: any;
    response?: any;

    constructor(data?: IQueryDebugInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"];
            this.auditTrail = data["auditTrail"];
            this.request = data["request"];
            this.response = data["response"];
        }
    }

    static fromJS(data: any): QueryDebugInformation {
        data = typeof data === 'object' ? data : {};
        let result = new QueryDebugInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general;
        data["auditTrail"] = this.auditTrail;
        data["request"] = this.request;
        data["response"] = this.response;
        return data; 
    }
}

export interface IQueryDebugInformation {
    general?: string;
    auditTrail?: string;
    request?: any;
    response?: any;
}

export class Exception implements IException {
    message?: string;
    innerException?: Exception;
    stackTrace?: string;
    source?: string;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.innerException = data.innerException && !(<any>data.innerException).toJSON ? new Exception(data.innerException) : <Exception>this.innerException; 
        }
        if (!data) {
            this.innerException = new Exception();
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.innerException = data["innerException"] ? Exception.fromJS(data["innerException"]) : new Exception();
            this.stackTrace = data["stackTrace"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["innerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["stackTrace"] = this.stackTrace;
        data["source"] = this.source;
        return data; 
    }
}

export interface IException {
    message?: string;
    innerException?: IException;
    stackTrace?: string;
    source?: string;
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel: TraceLevel;
    traceId?: string;
    traceJobId?: string;
    httpStatusCode: number;

    protected _discriminator: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this._discriminator = "PictureparkException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.traceLevel = data["traceLevel"];
            this.traceId = data["traceId"];
            this.traceJobId = data["traceJobId"];
            this.httpStatusCode = data["httpStatusCode"];
        }
    }

    static fromJS(data: any): PictureparkException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ElasticVersionUpdateException") {
            let result = new ElasticVersionUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidVersionException") {
            let result = new InvalidVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotDeactivatedException") {
            let result = new EnvironmentNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotFoundException") {
            let result = new EnvironmentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentDeactivationException") {
            let result = new EnvironmentDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RetryException") {
            let result = new RetryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerViolationException") {
            let result = new CustomerViolationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasNotFoundException") {
            let result = new CustomerAliasNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotDeactivatedException") {
            let result = new CustomerNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerDeactivationException") {
            let result = new CustomerDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotActiveException") {
            let result = new CustomerNotActiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConfigurationIndexNotFoundException") {
            let result = new ConfigurationIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAliasException") {
            let result = new DuplicateAliasException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviourException") {
            let result = new DuplicatedSearchBehaviourException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RedisDatabaseExceededException") {
            let result = new RedisDatabaseExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundInSearchIndexException") {
            let result = new SchemaNotFoundInSearchIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCyclicDependencyException") {
            let result = new SchemaCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithRelationsException") {
            let result = new DeleteContentsWithRelationsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessWaitTimeoutException") {
            let result = new BusinessProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["traceLevel"] = this.traceLevel;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        data["httpStatusCode"] = this.httpStatusCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkException extends IException {
    traceLevel: TraceLevel;
    traceId?: string;
    traceJobId?: string;
    httpStatusCode: number;
}

export enum TraceLevel {
    Critical = <any>"Critical", 
    Error = <any>"Error", 
    Warning = <any>"Warning", 
    Information = <any>"Information", 
    Verbose = <any>"Verbose", 
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string;
    customerAlias?: string;
    userId?: string;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this._discriminator = "PictureparkBusinessException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
            this.customerAlias = data["customerAlias"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): PictureparkBusinessException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RetryException") {
            let result = new RetryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviourException") {
            let result = new DuplicatedSearchBehaviourException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundInSearchIndexException") {
            let result = new SchemaNotFoundInSearchIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCyclicDependencyException") {
            let result = new SchemaCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithRelationsException") {
            let result = new DeleteContentsWithRelationsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessWaitTimeoutException") {
            let result = new BusinessProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerAlias"] = this.customerAlias;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string;
    customerAlias?: string;
    userId?: string;
}

export class PictureparkValidationException extends PictureparkBusinessException implements IPictureparkValidationException {

    constructor(data?: IPictureparkValidationException) {
        super(data);
        this._discriminator = "PictureparkValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkValidationException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviourException") {
            let result = new DuplicatedSearchBehaviourException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundInSearchIndexException") {
            let result = new SchemaNotFoundInSearchIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCyclicDependencyException") {
            let result = new SchemaCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithRelationsException") {
            let result = new DeleteContentsWithRelationsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessWaitTimeoutException") {
            let result = new BusinessProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkValidationException extends IPictureparkBusinessException {
}

export class PictureparkConflictException extends PictureparkBusinessException implements IPictureparkConflictException {
    reference?: string;

    constructor(data?: IPictureparkConflictException) {
        super(data);
        this._discriminator = "PictureparkConflictException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.reference = data["reference"];
        }
    }

    static fromJS(data: any): PictureparkConflictException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        let result = new PictureparkConflictException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkConflictException extends IPictureparkBusinessException {
    reference?: string;
}

export class PictureparkTimeoutException extends PictureparkValidationException implements IPictureparkTimeoutException {

    constructor(data?: IPictureparkTimeoutException) {
        super(data);
        this._discriminator = "PictureparkTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkTimeoutException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessWaitTimeoutException") {
            let result = new BusinessProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkTimeoutException extends IPictureparkValidationException {
}

export class PictureparkForbiddenException extends PictureparkBusinessException implements IPictureparkForbiddenException {

    constructor(data?: IPictureparkForbiddenException) {
        super(data);
        this._discriminator = "PictureparkForbiddenException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkForbiddenException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkForbiddenException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkForbiddenException extends IPictureparkBusinessException {
}

export class UserEmailAlreadyExistsException extends PictureparkValidationException implements IUserEmailAlreadyExistsException {
    email?: string;

    constructor(data?: IUserEmailAlreadyExistsException) {
        super(data);
        this._discriminator = "UserEmailAlreadyExistsException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): UserEmailAlreadyExistsException {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailAlreadyExistsException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserEmailAlreadyExistsException extends IPictureparkValidationException {
    email?: string;
}

export class UserRoleAssignedException extends PictureparkValidationException implements IUserRoleAssignedException {
    userRoleId?: string;

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this._discriminator = "UserRoleAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userRoleId = data["userRoleId"];
        }
    }

    static fromJS(data: any): UserRoleAssignedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRoleAssignedException extends IPictureparkValidationException {
    userRoleId?: string;
}

export class UserNotFoundException extends PictureparkBusinessException implements IUserNotFoundException {
    missingUserId?: string;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this._discriminator = "UserNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingUserId = data["missingUserId"];
        }
    }

    static fromJS(data: any): UserNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingUserId"] = this.missingUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserNotFoundException extends IPictureparkBusinessException {
    missingUserId?: string;
}

export class UserInactiveOrDeletedException extends PictureparkForbiddenException implements IUserInactiveOrDeletedException {

    constructor(data?: IUserInactiveOrDeletedException) {
        super(data);
        this._discriminator = "UserInactiveOrDeletedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): UserInactiveOrDeletedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserInactiveOrDeletedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUserInactiveOrDeletedException extends IPictureparkForbiddenException {
}

export class TermsOfServiceNotNewestException extends PictureparkBusinessException implements ITermsOfServiceNotNewestException {

    constructor(data?: ITermsOfServiceNotNewestException) {
        super(data);
        this._discriminator = "TermsOfServiceNotNewestException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TermsOfServiceNotNewestException {
        data = typeof data === 'object' ? data : {};
        let result = new TermsOfServiceNotNewestException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITermsOfServiceNotNewestException extends IPictureparkBusinessException {
}

export class RenderingException extends PictureparkBusinessException implements IRenderingException {

    constructor(data?: IRenderingException) {
        super(data);
        this._discriminator = "RenderingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingException {
        data = typeof data === 'object' ? data : {};
        let result = new RenderingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingException extends IPictureparkBusinessException {
}

export class ServiceProviderDeleteException extends PictureparkException implements IServiceProviderDeleteException {
    serviceProviderId?: string;
    detailedErrorMessage?: string;

    constructor(data?: IServiceProviderDeleteException) {
        super(data);
        this._discriminator = "ServiceProviderDeleteException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serviceProviderId = data["serviceProviderId"];
            this.detailedErrorMessage = data["detailedErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderDeleteException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["detailedErrorMessage"] = this.detailedErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderDeleteException extends IPictureparkException {
    serviceProviderId?: string;
    detailedErrorMessage?: string;
}

export class ServiceProviderCreateException extends PictureparkException implements IServiceProviderCreateException {
    userId?: string;
    externalId?: string;
    virtualHost?: string;
    detailErrorMessage?: string;

    constructor(data?: IServiceProviderCreateException) {
        super(data);
        this._discriminator = "ServiceProviderCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userId = data["userId"];
            this.externalId = data["externalId"];
            this.virtualHost = data["virtualHost"];
            this.detailErrorMessage = data["detailErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderCreateException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["externalId"] = this.externalId;
        data["virtualHost"] = this.virtualHost;
        data["detailErrorMessage"] = this.detailErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderCreateException extends IPictureparkException {
    userId?: string;
    externalId?: string;
    virtualHost?: string;
    detailErrorMessage?: string;
}

export class ServiceProviderNotFoundException extends PictureparkException implements IServiceProviderNotFoundException {
    missingServiceProviderId?: string;

    constructor(data?: IServiceProviderNotFoundException) {
        super(data);
        this._discriminator = "ServiceProviderNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingServiceProviderId = data["missingServiceProviderId"];
        }
    }

    static fromJS(data: any): ServiceProviderNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingServiceProviderId"] = this.missingServiceProviderId;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderNotFoundException extends IPictureparkException {
    missingServiceProviderId?: string;
}

export class PictureparkNotFoundException extends PictureparkBusinessException implements IPictureparkNotFoundException {
    reference?: string;

    constructor(data?: IPictureparkNotFoundException) {
        super(data);
        this._discriminator = "PictureparkNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.reference = data["reference"];
        }
    }

    static fromJS(data: any): PictureparkNotFoundException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        let result = new PictureparkNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkNotFoundException extends IPictureparkBusinessException {
    reference?: string;
}

export class DocumentVersionNotFoundException extends PictureparkNotFoundException implements IDocumentVersionNotFoundException {
    documentId?: string;
    documentVersion?: string;

    constructor(data?: IDocumentVersionNotFoundException) {
        super(data);
        this._discriminator = "DocumentVersionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
        }
    }

    static fromJS(data: any): DocumentVersionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentVersionNotFoundException extends IPictureparkNotFoundException {
    documentId?: string;
    documentVersion?: string;
}

export class DefaultChannelDeleteException extends PictureparkValidationException implements IDefaultChannelDeleteException {

    constructor(data?: IDefaultChannelDeleteException) {
        super(data);
        this._discriminator = "DefaultChannelDeleteException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DefaultChannelDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultChannelDeleteException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDefaultChannelDeleteException extends IPictureparkValidationException {
}

export class ElasticVersionUpdateException extends PictureparkException implements IElasticVersionUpdateException {
    expectedVersion?: string;
    actualVersion?: string;

    constructor(data?: IElasticVersionUpdateException) {
        super(data);
        this._discriminator = "ElasticVersionUpdateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.expectedVersion = data["expectedVersion"];
            this.actualVersion = data["actualVersion"];
        }
    }

    static fromJS(data: any): ElasticVersionUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ElasticVersionUpdateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedVersion"] = this.expectedVersion;
        data["actualVersion"] = this.actualVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface IElasticVersionUpdateException extends IPictureparkException {
    expectedVersion?: string;
    actualVersion?: string;
}

export class InvalidVersionException extends PictureparkException implements IInvalidVersionException {
    component?: string;
    version?: string;

    constructor(data?: IInvalidVersionException) {
        super(data);
        this._discriminator = "InvalidVersionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.component = data["component"];
            this.version = data["version"];
        }
    }

    static fromJS(data: any): InvalidVersionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidVersionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["component"] = this.component;
        data["version"] = this.version;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidVersionException extends IPictureparkException {
    component?: string;
    version?: string;
}

export class EnvironmentNotDeactivatedException extends PictureparkException implements IEnvironmentNotDeactivatedException {

    constructor(data?: IEnvironmentNotDeactivatedException) {
        super(data);
        this._discriminator = "EnvironmentNotDeactivatedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): EnvironmentNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotDeactivatedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IEnvironmentNotDeactivatedException extends IPictureparkException {
}

export class EnvironmentNotFoundException extends PictureparkException implements IEnvironmentNotFoundException {

    constructor(data?: IEnvironmentNotFoundException) {
        super(data);
        this._discriminator = "EnvironmentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): EnvironmentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IEnvironmentNotFoundException extends IPictureparkException {
}

export class EnvironmentDeactivationException extends PictureparkException implements IEnvironmentDeactivationException {
    deactivationMessage?: string;

    constructor(data?: IEnvironmentDeactivationException) {
        super(data);
        this._discriminator = "EnvironmentDeactivationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.deactivationMessage = data["deactivationMessage"];
        }
    }

    static fromJS(data: any): EnvironmentDeactivationException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentDeactivationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deactivationMessage"] = this.deactivationMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IEnvironmentDeactivationException extends IPictureparkException {
    deactivationMessage?: string;
}

export class ShareNotFoundException extends PictureparkNotFoundException implements IShareNotFoundException {
    shareId?: string;

    constructor(data?: IShareNotFoundException) {
        super(data);
        this._discriminator = "ShareNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.shareId = data["shareId"];
        }
    }

    static fromJS(data: any): ShareNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareNotFoundException extends IPictureparkNotFoundException {
    shareId?: string;
}

export class ShareByTokenNotFoundException extends PictureparkNotFoundException implements IShareByTokenNotFoundException {
    token?: string;

    constructor(data?: IShareByTokenNotFoundException) {
        super(data);
        this._discriminator = "ShareByTokenNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ShareByTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareByTokenNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareByTokenNotFoundException extends IPictureparkNotFoundException {
    token?: string;
}

export class TokenGenerationException extends PictureparkBusinessException implements ITokenGenerationException {
    retries: number;

    constructor(data?: ITokenGenerationException) {
        super(data);
        this._discriminator = "TokenGenerationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.retries = data["retries"];
        }
    }

    static fromJS(data: any): TokenGenerationException {
        data = typeof data === 'object' ? data : {};
        let result = new TokenGenerationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retries"] = this.retries;
        super.toJSON(data);
        return data; 
    }
}

export interface ITokenGenerationException extends IPictureparkBusinessException {
    retries: number;
}

export class ShareExpiredException extends PictureparkBusinessException implements IShareExpiredException {
    token?: string;

    constructor(data?: IShareExpiredException) {
        super(data);
        this._discriminator = "ShareExpiredException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ShareExpiredException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareExpiredException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareExpiredException extends IPictureparkBusinessException {
    token?: string;
}

export class OutputIdNotFoundException extends PictureparkNotFoundException implements IOutputIdNotFoundException {
    outputId?: string;

    constructor(data?: IOutputIdNotFoundException) {
        super(data);
        this._discriminator = "OutputIdNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.outputId = data["outputId"];
        }
    }

    static fromJS(data: any): OutputIdNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputIdNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputId"] = this.outputId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputIdNotFoundException extends IPictureparkNotFoundException {
    outputId?: string;
}

export class OutputNotFoundException extends PictureparkBusinessException implements IOutputNotFoundException {
    contentId?: string;
    outputFormatId?: string;

    constructor(data?: IOutputNotFoundException) {
        super(data);
        this._discriminator = "OutputNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
        }
    }

    static fromJS(data: any): OutputNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputNotFoundException extends IPictureparkBusinessException {
    contentId?: string;
    outputFormatId?: string;
}

export class LeaseNotAcquiredException extends PictureparkBusinessException implements ILeaseNotAcquiredException {
    resourceId?: string;

    constructor(data?: ILeaseNotAcquiredException) {
        super(data);
        this._discriminator = "LeaseNotAcquiredException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
        }
    }

    static fromJS(data: any): LeaseNotAcquiredException {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseNotAcquiredException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        super.toJSON(data);
        return data; 
    }
}

export interface ILeaseNotAcquiredException extends IPictureparkBusinessException {
    resourceId?: string;
}

export class OperationInProgressException extends PictureparkBusinessException implements IOperationInProgressException {
    leaseResourceType: LeaseResourceType;

    constructor(data?: IOperationInProgressException) {
        super(data);
        this._discriminator = "OperationInProgressException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.leaseResourceType = data["leaseResourceType"];
        }
    }

    static fromJS(data: any): OperationInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new OperationInProgressException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaseResourceType"] = this.leaseResourceType;
        super.toJSON(data);
        return data; 
    }
}

export interface IOperationInProgressException extends IPictureparkBusinessException {
    leaseResourceType: LeaseResourceType;
}

export enum LeaseResourceType {
    SchemaEditing = <any>"SchemaEditing", 
}

export class RetryException extends PictureparkBusinessException implements IRetryException {
    retries: number;
    innerExceptionDetail?: string;

    constructor(data?: IRetryException) {
        super(data);
        this._discriminator = "RetryException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.retries = data["retries"];
            this.innerExceptionDetail = data["innerExceptionDetail"];
        }
    }

    static fromJS(data: any): RetryException {
        data = typeof data === 'object' ? data : {};
        let result = new RetryException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retries"] = this.retries;
        data["innerExceptionDetail"] = this.innerExceptionDetail;
        super.toJSON(data);
        return data; 
    }
}

export interface IRetryException extends IPictureparkBusinessException {
    retries: number;
    innerExceptionDetail?: string;
}

export class OwnerTokenNotFoundException extends PictureparkNotFoundException implements IOwnerTokenNotFoundException {
    ownerTokenUserIds?: string[];

    constructor(data?: IOwnerTokenNotFoundException) {
        super(data);
        if (!data) {
            this.ownerTokenUserIds = [];
        }
        this._discriminator = "OwnerTokenNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ownerTokenUserIds"] && data["ownerTokenUserIds"].constructor === Array) {
                this.ownerTokenUserIds = [];
                for (let item of data["ownerTokenUserIds"])
                    this.ownerTokenUserIds.push(item);
            }
        }
    }

    static fromJS(data: any): OwnerTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTokenNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ownerTokenUserIds && this.ownerTokenUserIds.constructor === Array) {
            data["ownerTokenUserIds"] = [];
            for (let item of this.ownerTokenUserIds)
                data["ownerTokenUserIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOwnerTokenNotFoundException extends IPictureparkNotFoundException {
    ownerTokenUserIds?: string[];
}

export class InvalidStateException extends PictureparkValidationException implements IInvalidStateException {
    resourceId?: string;
    state?: string;

    constructor(data?: IInvalidStateException) {
        super(data);
        this._discriminator = "InvalidStateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): InvalidStateException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        let result = new InvalidStateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["state"] = this.state;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateException extends IPictureparkValidationException {
    resourceId?: string;
    state?: string;
}

export class PictureparkArgumentNullException extends PictureparkValidationException implements IPictureparkArgumentNullException {
    argumentName?: string;

    constructor(data?: IPictureparkArgumentNullException) {
        super(data);
        this._discriminator = "PictureparkArgumentNullException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["argumentName"];
        }
    }

    static fromJS(data: any): PictureparkArgumentNullException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkArgumentNullException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkArgumentNullException extends IPictureparkValidationException {
    argumentName?: string;
}

export class ObjectTypeMismatchException extends PictureparkBusinessException implements IObjectTypeMismatchException {
    type?: string;

    constructor(data?: IObjectTypeMismatchException) {
        super(data);
        this._discriminator = "ObjectTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ObjectTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectTypeMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectTypeMismatchException extends IPictureparkBusinessException {
    type?: string;
}

export class InvalidStateTransitionException extends InvalidStateException implements IInvalidStateTransitionException {
    transition?: string;

    constructor(data?: IInvalidStateTransitionException) {
        super(data);
        this._discriminator = "InvalidStateTransitionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transition = data["transition"];
        }
    }

    static fromJS(data: any): InvalidStateTransitionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidStateTransitionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transition"] = this.transition;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateTransitionException extends IInvalidStateException {
    transition?: string;
}

export class FailedToLockException extends PictureparkBusinessException implements IFailedToLockException {
    resourceId?: string;

    constructor(data?: IFailedToLockException) {
        super(data);
        this._discriminator = "FailedToLockException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
        }
    }

    static fromJS(data: any): FailedToLockException {
        data = typeof data === 'object' ? data : {};
        let result = new FailedToLockException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFailedToLockException extends IPictureparkBusinessException {
    resourceId?: string;
}

export class PictureparkOperationCanceledException extends PictureparkBusinessException implements IPictureparkOperationCanceledException {

    constructor(data?: IPictureparkOperationCanceledException) {
        super(data);
        this._discriminator = "PictureparkOperationCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkOperationCanceledException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkOperationCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkOperationCanceledException extends IPictureparkBusinessException {
}

export class PictureparkApplicationException extends PictureparkBusinessException implements IPictureparkApplicationException {

    constructor(data?: IPictureparkApplicationException) {
        super(data);
        this._discriminator = "PictureparkApplicationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkApplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkApplicationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkApplicationException extends IPictureparkBusinessException {
}

export class MissingCustomerDefaultLanguageException extends PictureparkValidationException implements IMissingCustomerDefaultLanguageException {
    customerDefaultLanguage?: string;

    constructor(data?: IMissingCustomerDefaultLanguageException) {
        super(data);
        this._discriminator = "MissingCustomerDefaultLanguageException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerDefaultLanguage = data["customerDefaultLanguage"];
        }
    }

    static fromJS(data: any): MissingCustomerDefaultLanguageException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingCustomerDefaultLanguageException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerDefaultLanguage"] = this.customerDefaultLanguage;
        super.toJSON(data);
        return data; 
    }
}

export interface IMissingCustomerDefaultLanguageException extends IPictureparkValidationException {
    customerDefaultLanguage?: string;
}

export class InvalidArgumentException extends PictureparkValidationException implements IInvalidArgumentException {
    argumentName?: string;
    argumentValue?: string;

    constructor(data?: IInvalidArgumentException) {
        super(data);
        this._discriminator = "InvalidArgumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["argumentName"];
            this.argumentValue = data["argumentValue"];
        }
    }

    static fromJS(data: any): InvalidArgumentException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidArgumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        data["argumentValue"] = this.argumentValue;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidArgumentException extends IPictureparkValidationException {
    argumentName?: string;
    argumentValue?: string;
}

export class UnknownException extends PictureparkBusinessException implements IUnknownException {
    exceptionDetail?: string;

    constructor(data?: IUnknownException) {
        super(data);
        this._discriminator = "UnknownException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.exceptionDetail = data["exceptionDetail"];
        }
    }

    static fromJS(data: any): UnknownException {
        data = typeof data === 'object' ? data : {};
        let result = new UnknownException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionDetail"] = this.exceptionDetail;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnknownException extends IPictureparkBusinessException {
    exceptionDetail?: string;
}

export class OwnerTokenInUseException extends PictureparkValidationException implements IOwnerTokenInUseException {
    ownerTokenUserId?: string;

    constructor(data?: IOwnerTokenInUseException) {
        super(data);
        this._discriminator = "OwnerTokenInUseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.ownerTokenUserId = data["ownerTokenUserId"];
        }
    }

    static fromJS(data: any): OwnerTokenInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTokenInUseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerTokenUserId"] = this.ownerTokenUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOwnerTokenInUseException extends IPictureparkValidationException {
    ownerTokenUserId?: string;
}

export class CustomerViolationException extends PictureparkException implements ICustomerViolationException {
    expectedCustomerId?: string;
    currentCustomerId?: string;

    constructor(data?: ICustomerViolationException) {
        super(data);
        this._discriminator = "CustomerViolationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.expectedCustomerId = data["expectedCustomerId"];
            this.currentCustomerId = data["currentCustomerId"];
        }
    }

    static fromJS(data: any): CustomerViolationException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerViolationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedCustomerId"] = this.expectedCustomerId;
        data["currentCustomerId"] = this.currentCustomerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerViolationException extends IPictureparkException {
    expectedCustomerId?: string;
    currentCustomerId?: string;
}

export class CustomerAliasNotFoundException extends PictureparkException implements ICustomerAliasNotFoundException {
    customerAlias?: string;

    constructor(data?: ICustomerAliasNotFoundException) {
        super(data);
        this._discriminator = "CustomerAliasNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerAlias = data["customerAlias"];
        }
    }

    static fromJS(data: any): CustomerAliasNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerAlias"] = this.customerAlias;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerAliasNotFoundException extends IPictureparkException {
    customerAlias?: string;
}

export class CustomerAliasInUseException extends PictureparkBusinessException implements ICustomerAliasInUseException {
    existingCustomerId?: string;
    alias?: string;

    constructor(data?: ICustomerAliasInUseException) {
        super(data);
        this._discriminator = "CustomerAliasInUseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.existingCustomerId = data["existingCustomerId"];
            this.alias = data["alias"];
        }
    }

    static fromJS(data: any): CustomerAliasInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasInUseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingCustomerId"] = this.existingCustomerId;
        data["alias"] = this.alias;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerAliasInUseException extends IPictureparkBusinessException {
    existingCustomerId?: string;
    alias?: string;
}

export class CustomerNotDeactivatedException extends PictureparkException implements ICustomerNotDeactivatedException {
    customerId?: string;

    constructor(data?: ICustomerNotDeactivatedException) {
        super(data);
        this._discriminator = "CustomerNotDeactivatedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CustomerNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotDeactivatedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerNotDeactivatedException extends IPictureparkException {
    customerId?: string;
}

export class CustomerDeactivationException extends PictureparkException implements ICustomerDeactivationException {
    customerId?: string;
    deactivationMessage?: string;

    constructor(data?: ICustomerDeactivationException) {
        super(data);
        this._discriminator = "CustomerDeactivationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
            this.deactivationMessage = data["deactivationMessage"];
        }
    }

    static fromJS(data: any): CustomerDeactivationException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDeactivationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["deactivationMessage"] = this.deactivationMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerDeactivationException extends IPictureparkException {
    customerId?: string;
    deactivationMessage?: string;
}

export class CustomerHostNotFoundException extends PictureparkException implements ICustomerHostNotFoundException {
    hostName?: string;

    constructor(data?: ICustomerHostNotFoundException) {
        super(data);
        this._discriminator = "CustomerHostNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.hostName = data["hostName"];
        }
    }

    static fromJS(data: any): CustomerHostNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerHostNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerHostNotFoundException extends IPictureparkException {
    hostName?: string;
}

export class CustomerNotFoundException extends PictureparkException implements ICustomerNotFoundException {
    customerId?: string;

    constructor(data?: ICustomerNotFoundException) {
        super(data);
        this._discriminator = "CustomerNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CustomerNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerNotFoundException extends IPictureparkException {
    customerId?: string;
}

export class CustomerNotActiveException extends PictureparkException implements ICustomerNotActiveException {
    customerId?: string;

    constructor(data?: ICustomerNotActiveException) {
        super(data);
        this._discriminator = "CustomerNotActiveException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CustomerNotActiveException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotActiveException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerNotActiveException extends IPictureparkException {
    customerId?: string;
}

export class ConfigurationIndexNotFoundException extends PictureparkException implements IConfigurationIndexNotFoundException {
    configurationIndex?: string;

    constructor(data?: IConfigurationIndexNotFoundException) {
        super(data);
        this._discriminator = "ConfigurationIndexNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.configurationIndex = data["configurationIndex"];
        }
    }

    static fromJS(data: any): ConfigurationIndexNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIndexNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configurationIndex"] = this.configurationIndex;
        super.toJSON(data);
        return data; 
    }
}

export interface IConfigurationIndexNotFoundException extends IPictureparkException {
    configurationIndex?: string;
}

export class DuplicateSearchIndexDocException extends PictureparkBusinessException implements IDuplicateSearchIndexDocException {
    searchIndexDocId?: string;

    constructor(data?: IDuplicateSearchIndexDocException) {
        super(data);
        this._discriminator = "DuplicateSearchIndexDocException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchIndexDocId = data["searchIndexDocId"];
        }
    }

    static fromJS(data: any): DuplicateSearchIndexDocException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSearchIndexDocException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexDocId"] = this.searchIndexDocId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateSearchIndexDocException extends IPictureparkBusinessException {
    searchIndexDocId?: string;
}

export class SearchIndexDocNotFoundException extends PictureparkBusinessException implements ISearchIndexDocNotFoundException {
    searchIndexDocId?: string;

    constructor(data?: ISearchIndexDocNotFoundException) {
        super(data);
        this._discriminator = "SearchIndexDocNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchIndexDocId = data["searchIndexDocId"];
        }
    }

    static fromJS(data: any): SearchIndexDocNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexDocNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexDocId"] = this.searchIndexDocId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchIndexDocNotFoundException extends IPictureparkBusinessException {
    searchIndexDocId?: string;
}

export class IndexDocumentNotFoundException extends PictureparkBusinessException implements IIndexDocumentNotFoundException {
    indexId?: string;

    constructor(data?: IIndexDocumentNotFoundException) {
        super(data);
        this._discriminator = "IndexDocumentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexId = data["indexId"];
        }
    }

    static fromJS(data: any): IndexDocumentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocumentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexId"] = this.indexId;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexDocumentNotFoundException extends IPictureparkBusinessException {
    indexId?: string;
}

export class DuplicateAliasException extends PictureparkException implements IDuplicateAliasException {
    indexAlias?: string;

    constructor(data?: IDuplicateAliasException) {
        super(data);
        this._discriminator = "DuplicateAliasException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexAlias = data["indexAlias"];
        }
    }

    static fromJS(data: any): DuplicateAliasException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateAliasException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexAlias"] = this.indexAlias;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateAliasException extends IPictureparkException {
    indexAlias?: string;
}

export class SearchIndexNotFoundException extends PictureparkBusinessException implements ISearchIndexNotFoundException {
    searchIndexId?: string;

    constructor(data?: ISearchIndexNotFoundException) {
        super(data);
        this._discriminator = "SearchIndexNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchIndexId = data["searchIndexId"];
        }
    }

    static fromJS(data: any): SearchIndexNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexId"] = this.searchIndexId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchIndexNotFoundException extends IPictureparkBusinessException {
    searchIndexId?: string;
}

export class DefaultSearchIndexDeleteException extends PictureparkBusinessException implements IDefaultSearchIndexDeleteException {

    constructor(data?: IDefaultSearchIndexDeleteException) {
        super(data);
        this._discriminator = "DefaultSearchIndexDeleteException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DefaultSearchIndexDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultSearchIndexDeleteException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDefaultSearchIndexDeleteException extends IPictureparkBusinessException {
}

export class SearchIndexInUseException extends PictureparkBusinessException implements ISearchIndexInUseException {
    searchIndex?: string;

    constructor(data?: ISearchIndexInUseException) {
        super(data);
        this._discriminator = "SearchIndexInUseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchIndex = data["searchIndex"];
        }
    }

    static fromJS(data: any): SearchIndexInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexInUseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndex"] = this.searchIndex;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchIndexInUseException extends IPictureparkBusinessException {
    searchIndex?: string;
}

export class IndexException extends PictureparkBusinessException implements IIndexException {
    indexName?: string;
    debugInformation?: string;

    constructor(data?: IIndexException) {
        super(data);
        this._discriminator = "IndexException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["indexName"];
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): IndexException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexException extends IPictureparkBusinessException {
    indexName?: string;
    debugInformation?: string;
}

export class IndexMappingException extends PictureparkBusinessException implements IIndexMappingException {
    indexName?: string;
    debugInformation?: string;

    constructor(data?: IIndexMappingException) {
        super(data);
        this._discriminator = "IndexMappingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["indexName"];
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): IndexMappingException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexMappingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexMappingException extends IPictureparkBusinessException {
    indexName?: string;
    debugInformation?: string;
}

export class DuplicatedSearchBehaviourException extends PictureparkValidationException implements IDuplicatedSearchBehaviourException {
    duplicatedSearchBehaviours?: string;

    constructor(data?: IDuplicatedSearchBehaviourException) {
        super(data);
        this._discriminator = "DuplicatedSearchBehaviourException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.duplicatedSearchBehaviours = data["duplicatedSearchBehaviours"];
        }
    }

    static fromJS(data: any): DuplicatedSearchBehaviourException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicatedSearchBehaviourException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duplicatedSearchBehaviours"] = this.duplicatedSearchBehaviours;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicatedSearchBehaviourException extends IPictureparkValidationException {
    duplicatedSearchBehaviours?: string;
}

export class SearchStringLeadingWildcardException extends PictureparkValidationException implements ISearchStringLeadingWildcardException {

    constructor(data?: ISearchStringLeadingWildcardException) {
        super(data);
        this._discriminator = "SearchStringLeadingWildcardException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SearchStringLeadingWildcardException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStringLeadingWildcardException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchStringLeadingWildcardException extends IPictureparkValidationException {
}

export class DuplicateAggregatorException extends PictureparkValidationException implements IDuplicateAggregatorException {
    aggregatorName?: string;

    constructor(data?: IDuplicateAggregatorException) {
        super(data);
        this._discriminator = "DuplicateAggregatorException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregatorName = data["aggregatorName"];
        }
    }

    static fromJS(data: any): DuplicateAggregatorException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateAggregatorException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateAggregatorException extends IPictureparkValidationException {
    aggregatorName?: string;
}

export class InvalidDateTimeFormatException extends PictureparkValidationException implements IInvalidDateTimeFormatException {
    value?: string;
    expectedFormat?: string;

    constructor(data?: IInvalidDateTimeFormatException) {
        super(data);
        this._discriminator = "InvalidDateTimeFormatException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"];
            this.expectedFormat = data["expectedFormat"];
        }
    }

    static fromJS(data: any): InvalidDateTimeFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidDateTimeFormatException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["expectedFormat"] = this.expectedFormat;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidDateTimeFormatException extends IPictureparkValidationException {
    value?: string;
    expectedFormat?: string;
}

export class InvalidSortFieldException extends PictureparkValidationException implements IInvalidSortFieldException {
    fieldName?: string;

    constructor(data?: IInvalidSortFieldException) {
        super(data);
        this._discriminator = "InvalidSortFieldException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldName = data["fieldName"];
        }
    }

    static fromJS(data: any): InvalidSortFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidSortFieldException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidSortFieldException extends IPictureparkValidationException {
    fieldName?: string;
}

export class DocumentVersionConflictException extends PictureparkConflictException implements IDocumentVersionConflictException {
    documentId?: string;
    documentType?: string;
    documentVersion: number;

    constructor(data?: IDocumentVersionConflictException) {
        super(data);
        this._discriminator = "DocumentVersionConflictException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentType = data["documentType"];
            this.documentVersion = data["documentVersion"];
        }
    }

    static fromJS(data: any): DocumentVersionConflictException {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersionConflictException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        data["documentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentVersionConflictException extends IPictureparkConflictException {
    documentId?: string;
    documentType?: string;
    documentVersion: number;
}

export class RedisDatabaseExceededException extends PictureparkException implements IRedisDatabaseExceededException {
    customerId?: string;
    customerCount: number;
    maxCount: number;
    startIndex: number;
    redisDatabaseCount: number;

    constructor(data?: IRedisDatabaseExceededException) {
        super(data);
        this._discriminator = "RedisDatabaseExceededException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
            this.customerCount = data["customerCount"];
            this.maxCount = data["maxCount"];
            this.startIndex = data["startIndex"];
            this.redisDatabaseCount = data["redisDatabaseCount"];
        }
    }

    static fromJS(data: any): RedisDatabaseExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new RedisDatabaseExceededException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerCount"] = this.customerCount;
        data["maxCount"] = this.maxCount;
        data["startIndex"] = this.startIndex;
        data["redisDatabaseCount"] = this.redisDatabaseCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IRedisDatabaseExceededException extends IPictureparkException {
    customerId?: string;
    customerCount: number;
    maxCount: number;
    startIndex: number;
    redisDatabaseCount: number;
}

export class DuplicateDocumentException extends PictureparkValidationException implements IDuplicateDocumentException {
    documentId?: string;
    documentType?: string;

    constructor(data?: IDuplicateDocumentException) {
        super(data);
        this._discriminator = "DuplicateDocumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): DuplicateDocumentException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateDocumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateDocumentException extends IPictureparkValidationException {
    documentId?: string;
    documentType?: string;
}

export class ObjectStoreResponseException extends PictureparkBusinessException implements IObjectStoreResponseException {
    rowErrorMessages?: string;
    message?: string;

    constructor(data?: IObjectStoreResponseException) {
        super(data);
        this._discriminator = "ObjectStoreResponseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["rowErrorMessages"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ObjectStoreResponseException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStoreResponseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreResponseException extends IPictureparkBusinessException {
    rowErrorMessages?: string;
    message?: string;
}

export class ObjectStoreException extends PictureparkBusinessException implements IObjectStoreException {
    rowErrorMessages?: string;
    errorMessage?: string;

    constructor(data?: IObjectStoreException) {
        super(data);
        this._discriminator = "ObjectStoreException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["rowErrorMessages"];
            this.errorMessage = data["errorMessage"];
        }
    }

    static fromJS(data: any): ObjectStoreException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStoreException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["errorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreException extends IPictureparkBusinessException {
    rowErrorMessages?: string;
    errorMessage?: string;
}

export class QueryException extends PictureparkBusinessException implements IQueryException {
    debugInformation?: string;
    serverError?: StorageServerError;

    constructor(data?: IQueryException) {
        super(data);
        if (!data) {
            this.serverError = new StorageServerError();
        }
        this._discriminator = "QueryException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.debugInformation = data["debugInformation"];
            this.serverError = data["serverError"] ? StorageServerError.fromJS(data["serverError"]) : new StorageServerError();
        }
    }

    static fromJS(data: any): QueryException {
        data = typeof data === 'object' ? data : {};
        let result = new QueryException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debugInformation"] = this.debugInformation;
        data["serverError"] = this.serverError ? this.serverError.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IQueryException extends IPictureparkBusinessException {
    debugInformation?: string;
    serverError?: IStorageServerError;
}

export class StorageServerError implements IStorageServerError {
    error?: StorageError;
    status: number;

    constructor(data?: IStorageServerError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new StorageError(data.error) : <StorageError>this.error; 
        }
        if (!data) {
            this.error = new StorageError();
        }
    }

    init(data?: any) {
        if (data) {
            this.error = data["error"] ? StorageError.fromJS(data["error"]) : new StorageError();
            this.status = data["status"];
        }
    }

    static fromJS(data: any): StorageServerError {
        data = typeof data === 'object' ? data : {};
        let result = new StorageServerError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }
}

export interface IStorageServerError {
    error?: IStorageError;
    status: number;
}

export class StorageError implements IStorageError {
    index?: string;
    reason?: string;
    resourceId?: string;
    resourceType?: string;
    type?: string;
    rootCause?: StorageRootCause[];
    causedBy?: StorageCausedBy;

    constructor(data?: IStorageError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rootCause) {
                this.rootCause = [];
                for (let i = 0; i < data.rootCause.length; i++) {
                    let item = data.rootCause[i];
                    this.rootCause[i] = item && !(<any>item).toJSON ? new StorageRootCause(item) : <StorageRootCause>item;
                }
            }
            this.causedBy = data.causedBy && !(<any>data.causedBy).toJSON ? new StorageCausedBy(data.causedBy) : <StorageCausedBy>this.causedBy; 
        }
        if (!data) {
            this.rootCause = [];
            this.causedBy = new StorageCausedBy();
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.reason = data["reason"];
            this.resourceId = data["resourceId"];
            this.resourceType = data["resourceType"];
            this.type = data["type"];
            if (data["rootCause"] && data["rootCause"].constructor === Array) {
                this.rootCause = [];
                for (let item of data["rootCause"])
                    this.rootCause.push(StorageRootCause.fromJS(item));
            }
            this.causedBy = data["causedBy"] ? StorageCausedBy.fromJS(data["causedBy"]) : new StorageCausedBy();
        }
    }

    static fromJS(data: any): StorageError {
        data = typeof data === 'object' ? data : {};
        let result = new StorageError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["reason"] = this.reason;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["type"] = this.type;
        if (this.rootCause && this.rootCause.constructor === Array) {
            data["rootCause"] = [];
            for (let item of this.rootCause)
                data["rootCause"].push(item.toJSON());
        }
        data["causedBy"] = this.causedBy ? this.causedBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStorageError {
    index?: string;
    reason?: string;
    resourceId?: string;
    resourceType?: string;
    type?: string;
    rootCause?: IStorageRootCause[];
    causedBy?: IStorageCausedBy;
}

export class StorageRootCause implements IStorageRootCause {
    index?: string;
    reason?: string;
    resourceId?: string;
    resourceType?: string;
    type?: string;

    constructor(data?: IStorageRootCause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.reason = data["reason"];
            this.resourceId = data["resourceId"];
            this.resourceType = data["resourceType"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): StorageRootCause {
        data = typeof data === 'object' ? data : {};
        let result = new StorageRootCause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["reason"] = this.reason;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["type"] = this.type;
        return data; 
    }
}

export interface IStorageRootCause {
    index?: string;
    reason?: string;
    resourceId?: string;
    resourceType?: string;
    type?: string;
}

export class StorageCausedBy implements IStorageCausedBy {
    reason?: string;
    type?: string;
    innerCausedBy?: StorageCausedBy;

    constructor(data?: IStorageCausedBy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.innerCausedBy = data.innerCausedBy && !(<any>data.innerCausedBy).toJSON ? new StorageCausedBy(data.innerCausedBy) : <StorageCausedBy>this.innerCausedBy; 
        }
        if (!data) {
            this.innerCausedBy = new StorageCausedBy();
        }
    }

    init(data?: any) {
        if (data) {
            this.reason = data["reason"];
            this.type = data["type"];
            this.innerCausedBy = data["innerCausedBy"] ? StorageCausedBy.fromJS(data["innerCausedBy"]) : new StorageCausedBy();
        }
    }

    static fromJS(data: any): StorageCausedBy {
        data = typeof data === 'object' ? data : {};
        let result = new StorageCausedBy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["type"] = this.type;
        data["innerCausedBy"] = this.innerCausedBy ? this.innerCausedBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStorageCausedBy {
    reason?: string;
    type?: string;
    innerCausedBy?: IStorageCausedBy;
}

export class PermissionOwnershipTransferException extends PictureparkValidationException implements IPermissionOwnershipTransferException {
    transferUserId?: string;
    missingUserRight: UserRight;

    constructor(data?: IPermissionOwnershipTransferException) {
        super(data);
        this._discriminator = "PermissionOwnershipTransferException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transferUserId = data["transferUserId"];
            this.missingUserRight = data["missingUserRight"];
        }
    }

    static fromJS(data: any): PermissionOwnershipTransferException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOwnershipTransferException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        data["missingUserRight"] = this.missingUserRight;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionOwnershipTransferException extends IPictureparkValidationException {
    transferUserId?: string;
    missingUserRight: UserRight;
}

export enum UserRight {
    ManageContent = <any>"ManageContent", 
    ManageSharings = <any>"ManageSharings", 
    ManageTransfer = <any>"ManageTransfer", 
    ManageChannels = <any>"ManageChannels", 
    ManageSchemas = <any>"ManageSchemas", 
    ManageUsers = <any>"ManageUsers", 
    ManageUserRoles = <any>"ManageUserRoles", 
    ManagePermissions = <any>"ManagePermissions", 
    ManageSearchIndexes = <any>"ManageSearchIndexes", 
    ManageCollections = <any>"ManageCollections", 
    ManageListItems = <any>"ManageListItems", 
    ManageServiceProviders = <any>"ManageServiceProviders", 
    ManageEmbeds = <any>"ManageEmbeds", 
    ManageTemplates = <any>"ManageTemplates", 
    ManageTermsOfService = <any>"ManageTermsOfService", 
}

export class PermissionSetNotFoundException extends PictureparkNotFoundException implements IPermissionSetNotFoundException {
    permissionSetIds?: string[];

    constructor(data?: IPermissionSetNotFoundException) {
        super(data);
        if (!data) {
            this.permissionSetIds = [];
        }
        this._discriminator = "PermissionSetNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["permissionSetIds"] && data["permissionSetIds"].constructor === Array) {
                this.permissionSetIds = [];
                for (let item of data["permissionSetIds"])
                    this.permissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionSetNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissionSetIds && this.permissionSetIds.constructor === Array) {
            data["permissionSetIds"] = [];
            for (let item of this.permissionSetIds)
                data["permissionSetIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionSetNotFoundException extends IPictureparkNotFoundException {
    permissionSetIds?: string[];
}

export class DuplicateRightException extends PictureparkValidationException implements IDuplicateRightException {
    permissionSetId?: string;

    constructor(data?: IDuplicateRightException) {
        super(data);
        this._discriminator = "DuplicateRightException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permissionSetId = data["permissionSetId"];
        }
    }

    static fromJS(data: any): DuplicateRightException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateRightException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateRightException extends IPictureparkValidationException {
    permissionSetId?: string;
}

export class PermissionValidationException extends PictureparkValidationException implements IPermissionValidationException {
    permission?: string;
    operation?: string;

    constructor(data?: IPermissionValidationException) {
        super(data);
        this._discriminator = "PermissionValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permission = data["permission"];
            this.operation = data["operation"];
        }
    }

    static fromJS(data: any): PermissionValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["operation"] = this.operation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionValidationException extends IPictureparkValidationException {
    permission?: string;
    operation?: string;
}

export class UnsupportedListItemChangeCommandException extends PictureparkValidationException implements IUnsupportedListItemChangeCommandException {
    commandType?: string;

    constructor(data?: IUnsupportedListItemChangeCommandException) {
        super(data);
        this._discriminator = "UnsupportedListItemChangeCommandException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.commandType = data["commandType"];
        }
    }

    static fromJS(data: any): UnsupportedListItemChangeCommandException {
        data = typeof data === 'object' ? data : {};
        let result = new UnsupportedListItemChangeCommandException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandType"] = this.commandType;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnsupportedListItemChangeCommandException extends IPictureparkValidationException {
    commandType?: string;
}

export class ListItemLayerException extends PictureparkValidationException implements IListItemLayerException {
    listItemId?: string;

    constructor(data?: IListItemLayerException) {
        super(data);
        this._discriminator = "ListItemLayerException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.listItemId = data["listItemId"];
        }
    }

    static fromJS(data: any): ListItemLayerException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemLayerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listItemId"] = this.listItemId;
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemLayerException extends IPictureparkValidationException {
    listItemId?: string;
}

export class ListItemNotFoundException extends PictureparkNotFoundException implements IListItemNotFoundException {
    listItemIds?: string[];

    constructor(data?: IListItemNotFoundException) {
        super(data);
        if (!data) {
            this.listItemIds = [];
        }
        this._discriminator = "ListItemNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemNotFoundException extends IPictureparkNotFoundException {
    listItemIds?: string[];
}

export class ListItemCyclicDependencyException extends PictureparkBusinessException implements IListItemCyclicDependencyException {
    listItemIds?: string[];

    constructor(data?: IListItemCyclicDependencyException) {
        super(data);
        if (!data) {
            this.listItemIds = [];
        }
        this._discriminator = "ListItemCyclicDependencyException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemCyclicDependencyException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCyclicDependencyException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemCyclicDependencyException extends IPictureparkBusinessException {
    listItemIds?: string[];
}

export class DeleteListItemsWithReferencesException extends PictureparkValidationException implements IDeleteListItemsWithReferencesException {
    referencesList?: string[];
    references?: string;

    constructor(data?: IDeleteListItemsWithReferencesException) {
        super(data);
        if (!data) {
            this.referencesList = [];
        }
        this._discriminator = "DeleteListItemsWithReferencesException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["referencesList"] && data["referencesList"].constructor === Array) {
                this.referencesList = [];
                for (let item of data["referencesList"])
                    this.referencesList.push(item);
            }
            this.references = data["references"];
        }
    }

    static fromJS(data: any): DeleteListItemsWithReferencesException {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteListItemsWithReferencesException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.referencesList && this.referencesList.constructor === Array) {
            data["referencesList"] = [];
            for (let item of this.referencesList)
                data["referencesList"].push(item);
        }
        data["references"] = this.references;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteListItemsWithReferencesException extends IPictureparkValidationException {
    referencesList?: string[];
    references?: string;
}

export class ListItemUpdateManyException extends PictureparkBusinessException implements IListItemUpdateManyException {
    failedItemsCount: number;
    totalItemsCount: number;

    constructor(data?: IListItemUpdateManyException) {
        super(data);
        this._discriminator = "ListItemUpdateManyException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.failedItemsCount = data["failedItemsCount"];
            this.totalItemsCount = data["totalItemsCount"];
        }
    }

    static fromJS(data: any): ListItemUpdateManyException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateManyException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["failedItemsCount"] = this.failedItemsCount;
        data["totalItemsCount"] = this.totalItemsCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemUpdateManyException extends IPictureparkBusinessException {
    failedItemsCount: number;
    totalItemsCount: number;
}

export class TransferInfoNotFoundException extends PictureparkNotFoundException implements ITransferInfoNotFoundException {
    transferInfoId?: string;

    constructor(data?: ITransferInfoNotFoundException) {
        super(data);
        this._discriminator = "TransferInfoNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transferInfoId = data["transferInfoId"];
        }
    }

    static fromJS(data: any): TransferInfoNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TransferInfoNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferInfoId"] = this.transferInfoId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferInfoNotFoundException extends IPictureparkNotFoundException {
    transferInfoId?: string;
}

export class FileTransferNotFoundException extends PictureparkNotFoundException implements IFileTransferNotFoundException {
    fileTransferId?: string;

    constructor(data?: IFileTransferNotFoundException) {
        super(data);
        this._discriminator = "FileTransferNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fileTransferId = data["fileTransferId"];
        }
    }

    static fromJS(data: any): FileTransferNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFileTransferNotFoundException extends IPictureparkNotFoundException {
    fileTransferId?: string;
}

export class InvalidTransferTypeException extends PictureparkBusinessException implements IInvalidTransferTypeException {
    transferType: TransferType;

    constructor(data?: IInvalidTransferTypeException) {
        super(data);
        this._discriminator = "InvalidTransferTypeException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transferType = data["transferType"];
        }
    }

    static fromJS(data: any): InvalidTransferTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidTransferTypeException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferType"] = this.transferType;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidTransferTypeException extends IPictureparkBusinessException {
    transferType: TransferType;
}

export enum TransferType {
    FileUpload = <any>"FileUpload", 
    FileUploadAutoImport = <any>"FileUploadAutoImport", 
    WebDownload = <any>"WebDownload", 
    SchemaImport = <any>"SchemaImport", 
}

export class TransferNotFoundException extends PictureparkNotFoundException implements ITransferNotFoundException {
    transferId?: string;

    constructor(data?: ITransferNotFoundException) {
        super(data);
        this._discriminator = "TransferNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transferId = data["transferId"];
        }
    }

    static fromJS(data: any): TransferNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TransferNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferNotFoundException extends IPictureparkNotFoundException {
    transferId?: string;
}

export class WrongChunkSizeException extends PictureparkValidationException implements IWrongChunkSizeException {
    actual: number;
    expected: number;

    constructor(data?: IWrongChunkSizeException) {
        super(data);
        this._discriminator = "WrongChunkSizeException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.actual = data["actual"];
            this.expected = data["expected"];
        }
    }

    static fromJS(data: any): WrongChunkSizeException {
        data = typeof data === 'object' ? data : {};
        let result = new WrongChunkSizeException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actual"] = this.actual;
        data["expected"] = this.expected;
        super.toJSON(data);
        return data; 
    }
}

export interface IWrongChunkSizeException extends IPictureparkValidationException {
    actual: number;
    expected: number;
}

export class MissingDependenciesException extends PictureparkValidationException implements IMissingDependenciesException {
    itemIds?: string;

    constructor(data?: IMissingDependenciesException) {
        super(data);
        this._discriminator = "MissingDependenciesException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.itemIds = data["itemIds"];
        }
    }

    static fromJS(data: any): MissingDependenciesException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingDependenciesException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemIds"] = this.itemIds;
        super.toJSON(data);
        return data; 
    }
}

export interface IMissingDependenciesException extends IPictureparkValidationException {
    itemIds?: string;
}

export class RelationSelfReferencingException extends PictureparkValidationException implements IRelationSelfReferencingException {
    itemId?: string;
    itemType?: string;

    constructor(data?: IRelationSelfReferencingException) {
        super(data);
        this._discriminator = "RelationSelfReferencingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.itemId = data["itemId"];
            this.itemType = data["itemType"];
        }
    }

    static fromJS(data: any): RelationSelfReferencingException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationSelfReferencingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["itemType"] = this.itemType;
        super.toJSON(data);
        return data; 
    }
}

export interface IRelationSelfReferencingException extends IPictureparkValidationException {
    itemId?: string;
    itemType?: string;
}

export class InvalidChangeCommandFieldTypeInvalidException extends PictureparkValidationException implements IInvalidChangeCommandFieldTypeInvalidException {
    commandType?: string;
    fieldId?: string;
    schemaId?: string;
    fieldActualType?: string;
    fieldExpectedType?: string;

    constructor(data?: IInvalidChangeCommandFieldTypeInvalidException) {
        super(data);
        this._discriminator = "InvalidChangeCommandFieldTypeInvalidException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.commandType = data["commandType"];
            this.fieldId = data["fieldId"];
            this.schemaId = data["schemaId"];
            this.fieldActualType = data["fieldActualType"];
            this.fieldExpectedType = data["fieldExpectedType"];
        }
    }

    static fromJS(data: any): InvalidChangeCommandFieldTypeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandFieldTypeInvalidException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandType"] = this.commandType;
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        data["fieldActualType"] = this.fieldActualType;
        data["fieldExpectedType"] = this.fieldExpectedType;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidChangeCommandFieldTypeInvalidException extends IPictureparkValidationException {
    commandType?: string;
    fieldId?: string;
    schemaId?: string;
    fieldActualType?: string;
    fieldExpectedType?: string;
}

export class InvalidChangeCommandFieldNotFoundException extends PictureparkValidationException implements IInvalidChangeCommandFieldNotFoundException {
    commandTypeName?: string;
    fieldId?: string;
    schemaId?: string;

    constructor(data?: IInvalidChangeCommandFieldNotFoundException) {
        super(data);
        this._discriminator = "InvalidChangeCommandFieldNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.commandTypeName = data["commandTypeName"];
            this.fieldId = data["fieldId"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): InvalidChangeCommandFieldNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandFieldNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandTypeName"] = this.commandTypeName;
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidChangeCommandFieldNotFoundException extends IPictureparkValidationException {
    commandTypeName?: string;
    fieldId?: string;
    schemaId?: string;
}

export class InvalidChangeCommandSchemaChangeInvalidException extends PictureparkValidationException implements IInvalidChangeCommandSchemaChangeInvalidException {
    commandTypeName?: string;
    schemaId?: string;

    constructor(data?: IInvalidChangeCommandSchemaChangeInvalidException) {
        super(data);
        this._discriminator = "InvalidChangeCommandSchemaChangeInvalidException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.commandTypeName = data["commandTypeName"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): InvalidChangeCommandSchemaChangeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandSchemaChangeInvalidException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandTypeName"] = this.commandTypeName;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidChangeCommandSchemaChangeInvalidException extends IPictureparkValidationException {
    commandTypeName?: string;
    schemaId?: string;
}

export class InvalidMetadataException extends PictureparkValidationException implements IInvalidMetadataException {
    metadataErrors?: MetadataError[];

    constructor(data?: IInvalidMetadataException) {
        super(data);
        if (!data) {
            this.metadataErrors = [];
        }
        this._discriminator = "InvalidMetadataException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["metadataErrors"] && data["metadataErrors"].constructor === Array) {
                this.metadataErrors = [];
                for (let item of data["metadataErrors"])
                    this.metadataErrors.push(MetadataError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvalidMetadataException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidMetadataException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.metadataErrors && this.metadataErrors.constructor === Array) {
            data["metadataErrors"] = [];
            for (let item of this.metadataErrors)
                data["metadataErrors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidMetadataException extends IPictureparkValidationException {
    metadataErrors?: IMetadataError[];
}

export class MetadataError implements IMetadataError {
    errorType?: string;
    lineNumber: number;
    linePosition: number;
    path?: string;
    message?: string;
    schemaId?: string;

    constructor(data?: IMetadataError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorType = data["errorType"];
            this.lineNumber = data["lineNumber"];
            this.linePosition = data["linePosition"];
            this.path = data["path"];
            this.message = data["message"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataError {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorType"] = this.errorType;
        data["lineNumber"] = this.lineNumber;
        data["linePosition"] = this.linePosition;
        data["path"] = this.path;
        data["message"] = this.message;
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

export interface IMetadataError {
    errorType?: string;
    lineNumber: number;
    linePosition: number;
    path?: string;
    message?: string;
    schemaId?: string;
}

export class RelationNotFoundException extends PictureparkBusinessException implements IRelationNotFoundException {
    relationId?: string;

    constructor(data?: IRelationNotFoundException) {
        super(data);
        this._discriminator = "RelationNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.relationId = data["relationId"];
        }
    }

    static fromJS(data: any): RelationNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationId"] = this.relationId;
        super.toJSON(data);
        return data; 
    }
}

export interface IRelationNotFoundException extends IPictureparkBusinessException {
    relationId?: string;
}

export class RelationTypeNotFoundException extends PictureparkBusinessException implements IRelationTypeNotFoundException {
    relationType?: string;

    constructor(data?: IRelationTypeNotFoundException) {
        super(data);
        this._discriminator = "RelationTypeNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.relationType = data["relationType"];
        }
    }

    static fromJS(data: any): RelationTypeNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationType"] = this.relationType;
        super.toJSON(data);
        return data; 
    }
}

export interface IRelationTypeNotFoundException extends IPictureparkBusinessException {
    relationType?: string;
}

export class RelationTypeTargetDocTypeMismatchException extends PictureparkBusinessException implements IRelationTypeTargetDocTypeMismatchException {
    relationType?: string;
    targetDocType?: string;
    expectedTargetDocType?: string;

    constructor(data?: IRelationTypeTargetDocTypeMismatchException) {
        super(data);
        this._discriminator = "RelationTypeTargetDocTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.relationType = data["relationType"];
            this.targetDocType = data["targetDocType"];
            this.expectedTargetDocType = data["expectedTargetDocType"];
        }
    }

    static fromJS(data: any): RelationTypeTargetDocTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeTargetDocTypeMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationType"] = this.relationType;
        data["targetDocType"] = this.targetDocType;
        data["expectedTargetDocType"] = this.expectedTargetDocType;
        super.toJSON(data);
        return data; 
    }
}

export interface IRelationTypeTargetDocTypeMismatchException extends IPictureparkBusinessException {
    relationType?: string;
    targetDocType?: string;
    expectedTargetDocType?: string;
}

export class AggregationNameInvalidException extends PictureparkValidationException implements IAggregationNameInvalidException {
    aggregationName?: string;
    aggregationPrefix?: string;

    constructor(data?: IAggregationNameInvalidException) {
        super(data);
        this._discriminator = "AggregationNameInvalidException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregationName = data["aggregationName"];
            this.aggregationPrefix = data["aggregationPrefix"];
        }
    }

    static fromJS(data: any): AggregationNameInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationNameInvalidException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["aggregationPrefix"] = this.aggregationPrefix;
        super.toJSON(data);
        return data; 
    }
}

export interface IAggregationNameInvalidException extends IPictureparkValidationException {
    aggregationName?: string;
    aggregationPrefix?: string;
}

export class SchemaFieldOverwriteTypeMismatchException extends PictureparkValidationException implements ISchemaFieldOverwriteTypeMismatchException {
    schemaId?: string;
    fieldId?: string;
    fieldOverwriteType?: string;
    fieldType?: string;

    constructor(data?: ISchemaFieldOverwriteTypeMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldOverwriteTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.fieldOverwriteType = data["fieldOverwriteType"];
            this.fieldType = data["fieldType"];
        }
    }

    static fromJS(data: any): SchemaFieldOverwriteTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldOverwriteTypeMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["fieldOverwriteType"] = this.fieldOverwriteType;
        data["fieldType"] = this.fieldType;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldOverwriteTypeMismatchException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    fieldOverwriteType?: string;
    fieldType?: string;
}

export class SchemaFieldOverwriteIdException extends PictureparkValidationException implements ISchemaFieldOverwriteIdException {
    schemaId?: string;
    fieldId?: string;

    constructor(data?: ISchemaFieldOverwriteIdException) {
        super(data);
        this._discriminator = "SchemaFieldOverwriteIdException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldOverwriteIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldOverwriteIdException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldOverwriteIdException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export class SchemaFieldIdDuplicatedException extends PictureparkValidationException implements ISchemaFieldIdDuplicatedException {
    schemaId?: string;
    fieldId?: string;

    constructor(data?: ISchemaFieldIdDuplicatedException) {
        super(data);
        this._discriminator = "SchemaFieldIdDuplicatedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldIdDuplicatedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdDuplicatedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldIdDuplicatedException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export class SchemaFieldSchemaIndexInfoSimpleSearchNestingException extends PictureparkValidationException implements ISchemaFieldSchemaIndexInfoSimpleSearchNestingException {
    schemaId?: string;
    fieldId?: string;
    relatedFieldId?: string;
    relatedOuterFieldId?: string;

    constructor(data?: ISchemaFieldSchemaIndexInfoSimpleSearchNestingException) {
        super(data);
        this._discriminator = "SchemaFieldSchemaIndexInfoSimpleSearchNestingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.relatedFieldId = data["relatedFieldId"];
            this.relatedOuterFieldId = data["relatedOuterFieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldSchemaIndexInfoSimpleSearchNestingException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relatedFieldId"] = this.relatedFieldId;
        data["relatedOuterFieldId"] = this.relatedOuterFieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldSchemaIndexInfoSimpleSearchNestingException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relatedFieldId?: string;
    relatedOuterFieldId?: string;
}

export class SchemaFieldSchemaIndexInfoNestingException extends PictureparkValidationException implements ISchemaFieldSchemaIndexInfoNestingException {
    schemaId?: string;
    fieldId?: string;
    relatedFieldId?: string;
    relatedOuterFieldId?: string;

    constructor(data?: ISchemaFieldSchemaIndexInfoNestingException) {
        super(data);
        this._discriminator = "SchemaFieldSchemaIndexInfoNestingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.relatedFieldId = data["relatedFieldId"];
            this.relatedOuterFieldId = data["relatedOuterFieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldSchemaIndexInfoNestingException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSchemaIndexInfoNestingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relatedFieldId"] = this.relatedFieldId;
        data["relatedOuterFieldId"] = this.relatedOuterFieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldSchemaIndexInfoNestingException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relatedFieldId?: string;
    relatedOuterFieldId?: string;
}

export class SchemaFieldIdUppercaseException extends PictureparkValidationException implements ISchemaFieldIdUppercaseException {
    schemaId?: string;
    fieldId?: string;

    constructor(data?: ISchemaFieldIdUppercaseException) {
        super(data);
        this._discriminator = "SchemaFieldIdUppercaseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldIdUppercaseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdUppercaseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldIdUppercaseException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export class SchemaIdLowercaseException extends PictureparkValidationException implements ISchemaIdLowercaseException {
    schemaId?: string;

    constructor(data?: ISchemaIdLowercaseException) {
        super(data);
        this._discriminator = "SchemaIdLowercaseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaIdLowercaseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIdLowercaseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaIdLowercaseException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaInfoNotFoundException extends PictureparkNotFoundException implements ISchemaInfoNotFoundException {
    schemaId?: string;

    constructor(data?: ISchemaInfoNotFoundException) {
        super(data);
        this._discriminator = "SchemaInfoNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaInfoNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInfoNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInfoNotFoundException extends IPictureparkNotFoundException {
    schemaId?: string;
}

export class IndexedFieldThresholdExceededException extends PictureparkValidationException implements IIndexedFieldThresholdExceededException {
    schemaId?: string;
    indexedFieldCount: number;
    indexedFieldThreshold: number;

    constructor(data?: IIndexedFieldThresholdExceededException) {
        super(data);
        this._discriminator = "IndexedFieldThresholdExceededException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.indexedFieldCount = data["indexedFieldCount"];
            this.indexedFieldThreshold = data["indexedFieldThreshold"];
        }
    }

    static fromJS(data: any): IndexedFieldThresholdExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexedFieldThresholdExceededException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["indexedFieldCount"] = this.indexedFieldCount;
        data["indexedFieldThreshold"] = this.indexedFieldThreshold;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexedFieldThresholdExceededException extends IPictureparkValidationException {
    schemaId?: string;
    indexedFieldCount: number;
    indexedFieldThreshold: number;
}

export class SortableFieldThresholdExceededException extends PictureparkValidationException implements ISortableFieldThresholdExceededException {
    schemaId?: string;
    sortableFieldCount: number;
    sortableFieldThreshold: number;

    constructor(data?: ISortableFieldThresholdExceededException) {
        super(data);
        this._discriminator = "SortableFieldThresholdExceededException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.sortableFieldCount = data["sortableFieldCount"];
            this.sortableFieldThreshold = data["sortableFieldThreshold"];
        }
    }

    static fromJS(data: any): SortableFieldThresholdExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new SortableFieldThresholdExceededException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["sortableFieldCount"] = this.sortableFieldCount;
        data["sortableFieldThreshold"] = this.sortableFieldThreshold;
        super.toJSON(data);
        return data; 
    }
}

export interface ISortableFieldThresholdExceededException extends IPictureparkValidationException {
    schemaId?: string;
    sortableFieldCount: number;
    sortableFieldThreshold: number;
}

export class DuplicateSchemaInfoException extends PictureparkBusinessException implements IDuplicateSchemaInfoException {
    schemaId?: string;

    constructor(data?: IDuplicateSchemaInfoException) {
        super(data);
        this._discriminator = "DuplicateSchemaInfoException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): DuplicateSchemaInfoException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSchemaInfoException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateSchemaInfoException extends IPictureparkBusinessException {
    schemaId?: string;
}

export class SchemaFieldNumberRangeException extends PictureparkValidationException implements ISchemaFieldNumberRangeException {
    fieldId?: string;
    propertyName?: string;
    minValue: number;
    maxValue: number;

    constructor(data?: ISchemaFieldNumberRangeException) {
        super(data);
        this._discriminator = "SchemaFieldNumberRangeException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldId = data["fieldId"];
            this.propertyName = data["propertyName"];
            this.minValue = data["minValue"];
            this.maxValue = data["maxValue"];
        }
    }

    static fromJS(data: any): SchemaFieldNumberRangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNumberRangeException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["propertyName"] = this.propertyName;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldNumberRangeException extends IPictureparkValidationException {
    fieldId?: string;
    propertyName?: string;
    minValue: number;
    maxValue: number;
}

export class SchemaInUseContentSchemaException extends PictureparkValidationException implements ISchemaInUseContentSchemaException {
    schemaId?: string;
    contentSchemaIds?: string[];

    constructor(data?: ISchemaInUseContentSchemaException) {
        super(data);
        if (!data) {
            this.contentSchemaIds = [];
        }
        this._discriminator = "SchemaInUseContentSchemaException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["contentSchemaIds"] && data["contentSchemaIds"].constructor === Array) {
                this.contentSchemaIds = [];
                for (let item of data["contentSchemaIds"])
                    this.contentSchemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaInUseContentSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseContentSchemaException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.contentSchemaIds && this.contentSchemaIds.constructor === Array) {
            data["contentSchemaIds"] = [];
            for (let item of this.contentSchemaIds)
                data["contentSchemaIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInUseContentSchemaException extends IPictureparkValidationException {
    schemaId?: string;
    contentSchemaIds?: string[];
}

export class SchemaInUseListItemException extends PictureparkValidationException implements ISchemaInUseListItemException {
    schemaId?: string;
    listItemCount: number;

    constructor(data?: ISchemaInUseListItemException) {
        super(data);
        this._discriminator = "SchemaInUseListItemException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.listItemCount = data["listItemCount"];
        }
    }

    static fromJS(data: any): SchemaInUseListItemException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseListItemException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["listItemCount"] = this.listItemCount;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInUseListItemException extends IPictureparkValidationException {
    schemaId?: string;
    listItemCount: number;
}

export class SchemaInUseContentException extends PictureparkValidationException implements ISchemaInUseContentException {
    schemaId?: string;
    contentCount: number;

    constructor(data?: ISchemaInUseContentException) {
        super(data);
        this._discriminator = "SchemaInUseContentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.contentCount = data["contentCount"];
        }
    }

    static fromJS(data: any): SchemaInUseContentException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseContentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["contentCount"] = this.contentCount;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInUseContentException extends IPictureparkValidationException {
    schemaId?: string;
    contentCount: number;
}

export class SchemaInUseFieldException extends PictureparkValidationException implements ISchemaInUseFieldException {
    schemaId?: string;
    fieldNamespaces?: string[];

    constructor(data?: ISchemaInUseFieldException) {
        super(data);
        if (!data) {
            this.fieldNamespaces = [];
        }
        this._discriminator = "SchemaInUseFieldException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["fieldNamespaces"] && data["fieldNamespaces"].constructor === Array) {
                this.fieldNamespaces = [];
                for (let item of data["fieldNamespaces"])
                    this.fieldNamespaces.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaInUseFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseFieldException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.fieldNamespaces && this.fieldNamespaces.constructor === Array) {
            data["fieldNamespaces"] = [];
            for (let item of this.fieldNamespaces)
                data["fieldNamespaces"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInUseFieldException extends IPictureparkValidationException {
    schemaId?: string;
    fieldNamespaces?: string[];
}

export class SchemaNotFoundInSearchIndexException extends PictureparkValidationException implements ISchemaNotFoundInSearchIndexException {
    searchIndexId?: string;
    schemaId?: string;

    constructor(data?: ISchemaNotFoundInSearchIndexException) {
        super(data);
        this._discriminator = "SchemaNotFoundInSearchIndexException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchIndexId = data["searchIndexId"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaNotFoundInSearchIndexException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNotFoundInSearchIndexException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexId"] = this.searchIndexId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaNotFoundInSearchIndexException extends IPictureparkValidationException {
    searchIndexId?: string;
    schemaId?: string;
}

export class DuplicateMetadataDisplayPatternException extends PictureparkValidationException implements IDuplicateMetadataDisplayPatternException {
    schemaId?: string;
    displayPatternId?: string;

    constructor(data?: IDuplicateMetadataDisplayPatternException) {
        super(data);
        this._discriminator = "DuplicateMetadataDisplayPatternException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.displayPatternId = data["displayPatternId"];
        }
    }

    static fromJS(data: any): DuplicateMetadataDisplayPatternException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateMetadataDisplayPatternException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["displayPatternId"] = this.displayPatternId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateMetadataDisplayPatternException extends IPictureparkValidationException {
    schemaId?: string;
    displayPatternId?: string;
}

export class DuplicateSchemaException extends PictureparkValidationException implements IDuplicateSchemaException {
    schemaId?: string;

    constructor(data?: IDuplicateSchemaException) {
        super(data);
        this._discriminator = "DuplicateSchemaException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): DuplicateSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSchemaException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateSchemaException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaImportEmptyException extends PictureparkValidationException implements ISchemaImportEmptyException {

    constructor(data?: ISchemaImportEmptyException) {
        super(data);
        this._discriminator = "SchemaImportEmptyException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaImportEmptyException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportEmptyException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaImportEmptyException extends IPictureparkValidationException {
}

export class SchemaImportVersionMismatchException extends PictureparkValidationException implements ISchemaImportVersionMismatchException {
    providedVersion?: string;
    expectedVersion?: string;

    constructor(data?: ISchemaImportVersionMismatchException) {
        super(data);
        this._discriminator = "SchemaImportVersionMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.providedVersion = data["providedVersion"];
            this.expectedVersion = data["expectedVersion"];
        }
    }

    static fromJS(data: any): SchemaImportVersionMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportVersionMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providedVersion"] = this.providedVersion;
        data["expectedVersion"] = this.expectedVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaImportVersionMismatchException extends IPictureparkValidationException {
    providedVersion?: string;
    expectedVersion?: string;
}

export class SchemaCyclicDependencyException extends PictureparkValidationException implements ISchemaCyclicDependencyException {
    schemaIds?: string[];

    constructor(data?: ISchemaCyclicDependencyException) {
        super(data);
        if (!data) {
            this.schemaIds = [];
        }
        this._discriminator = "SchemaCyclicDependencyException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaCyclicDependencyException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCyclicDependencyException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaCyclicDependencyException extends IPictureparkValidationException {
    schemaIds?: string[];
}

export class SchemaInheritanceFieldIndexDeviationException extends PictureparkValidationException implements ISchemaInheritanceFieldIndexDeviationException {
    schemaId?: string;

    constructor(data?: ISchemaInheritanceFieldIndexDeviationException) {
        super(data);
        this._discriminator = "SchemaInheritanceFieldIndexDeviationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaInheritanceFieldIndexDeviationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInheritanceFieldIndexDeviationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInheritanceFieldIndexDeviationException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaInheritanceTypeDeviationException extends PictureparkValidationException implements ISchemaInheritanceTypeDeviationException {
    schemaId?: string;

    constructor(data?: ISchemaInheritanceTypeDeviationException) {
        super(data);
        this._discriminator = "SchemaInheritanceTypeDeviationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaInheritanceTypeDeviationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInheritanceTypeDeviationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInheritanceTypeDeviationException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaValidationException extends PictureparkValidationException implements ISchemaValidationException {
    schemaId?: string;
    exceptions?: PictureparkBusinessException[];

    constructor(data?: ISchemaValidationException) {
        super(data);
        if (!data) {
            this.exceptions = [];
        }
        this._discriminator = "SchemaValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["exceptions"] && data["exceptions"].constructor === Array) {
                this.exceptions = [];
                for (let item of data["exceptions"])
                    this.exceptions.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.exceptions && this.exceptions.constructor === Array) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaValidationException extends IPictureparkValidationException {
    schemaId?: string;
    exceptions?: PictureparkBusinessException[];
}

export class SchemaSortFieldException extends PictureparkValidationException implements ISchemaSortFieldException {
    schemaId?: string;
    fieldId?: string;

    constructor(data?: ISchemaSortFieldException) {
        super(data);
        this._discriminator = "SchemaSortFieldException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
        }
    }

    static fromJS(data: any): SchemaSortFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSortFieldException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaSortFieldException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export class SchemaFieldIdException extends PictureparkValidationException implements ISchemaFieldIdException {
    schemaId?: string;
    fieldId?: string;

    constructor(data?: ISchemaFieldIdException) {
        super(data);
        this._discriminator = "SchemaFieldIdException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldIdException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export class SchemaFieldTypeChangeException extends PictureparkValidationException implements ISchemaFieldTypeChangeException {
    schemaId?: string;
    fieldId?: string;
    oldTypeName?: string;
    newTypeName?: string;

    constructor(data?: ISchemaFieldTypeChangeException) {
        super(data);
        this._discriminator = "SchemaFieldTypeChangeException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.oldTypeName = data["oldTypeName"];
            this.newTypeName = data["newTypeName"];
        }
    }

    static fromJS(data: any): SchemaFieldTypeChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldTypeChangeException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["oldTypeName"] = this.oldTypeName;
        data["newTypeName"] = this.newTypeName;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldTypeChangeException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    oldTypeName?: string;
    newTypeName?: string;
}

export class SchemaFieldIndexException extends PictureparkValidationException implements ISchemaFieldIndexException {
    schemaId?: string;
    fieldId?: string;

    constructor(data?: ISchemaFieldIndexException) {
        super(data);
        this._discriminator = "SchemaFieldIndexException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
        }
    }

    static fromJS(data: any): SchemaFieldIndexException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIndexException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldIndexException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
}

export class SchemaFieldNotSortableException extends PictureparkValidationException implements ISchemaFieldNotSortableException {
    fieldId?: string;
    schemaId?: string;

    constructor(data?: ISchemaFieldNotSortableException) {
        super(data);
        this._discriminator = "SchemaFieldNotSortableException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldId = data["fieldId"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaFieldNotSortableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSortableException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldNotSortableException extends IPictureparkValidationException {
    fieldId?: string;
    schemaId?: string;
}

export class SchemaFieldNotSearchableException extends PictureparkValidationException implements ISchemaFieldNotSearchableException {
    fieldId?: string;
    schemaId?: string;

    constructor(data?: ISchemaFieldNotSearchableException) {
        super(data);
        this._discriminator = "SchemaFieldNotSearchableException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldId = data["fieldId"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaFieldNotSearchableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSearchableException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldNotSearchableException extends IPictureparkValidationException {
    fieldId?: string;
    schemaId?: string;
}

export class SchemaNoContentException extends PictureparkValidationException implements ISchemaNoContentException {
    schemaId?: string;

    constructor(data?: ISchemaNoContentException) {
        super(data);
        this._discriminator = "SchemaNoContentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaNoContentException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNoContentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaNoContentException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaParentChangeException extends PictureparkValidationException implements ISchemaParentChangeException {
    schemaId?: string;
    oldSchemaParentId?: string;
    newSchemaParentId?: string;

    constructor(data?: ISchemaParentChangeException) {
        super(data);
        this._discriminator = "SchemaParentChangeException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.oldSchemaParentId = data["oldSchemaParentId"];
            this.newSchemaParentId = data["newSchemaParentId"];
        }
    }

    static fromJS(data: any): SchemaParentChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaParentChangeException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["oldSchemaParentId"] = this.oldSchemaParentId;
        data["newSchemaParentId"] = this.newSchemaParentId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaParentChangeException extends IPictureparkValidationException {
    schemaId?: string;
    oldSchemaParentId?: string;
    newSchemaParentId?: string;
}

export class SchemaMissingTypeException extends PictureparkValidationException implements ISchemaMissingTypeException {
    schemaId?: string;
    expectedSchemaTypes?: SchemaType[];

    constructor(data?: ISchemaMissingTypeException) {
        super(data);
        if (!data) {
            this.expectedSchemaTypes = [];
        }
        this._discriminator = "SchemaMissingTypeException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["expectedSchemaTypes"] && data["expectedSchemaTypes"].constructor === Array) {
                this.expectedSchemaTypes = [];
                for (let item of data["expectedSchemaTypes"])
                    this.expectedSchemaTypes.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaMissingTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMissingTypeException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.expectedSchemaTypes && this.expectedSchemaTypes.constructor === Array) {
            data["expectedSchemaTypes"] = [];
            for (let item of this.expectedSchemaTypes)
                data["expectedSchemaTypes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaMissingTypeException extends IPictureparkValidationException {
    schemaId?: string;
    expectedSchemaTypes?: SchemaType[];
}

export enum SchemaType {
    Content = <any>"Content", 
    Layer = <any>"Layer", 
    List = <any>"List", 
    Struct = <any>"Struct", 
}

export class SchemaPermissionException extends PictureparkValidationException implements ISchemaPermissionException {
    schemaId?: string;

    constructor(data?: ISchemaPermissionException) {
        super(data);
        this._discriminator = "SchemaPermissionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaPermissionException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaNoLayerException extends PictureparkValidationException implements ISchemaNoLayerException {
    schemaId?: string;

    constructor(data?: ISchemaNoLayerException) {
        super(data);
        this._discriminator = "SchemaNoLayerException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaNoLayerException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNoLayerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaNoLayerException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaIdException extends PictureparkValidationException implements ISchemaIdException {
    schemaId?: string;

    constructor(data?: ISchemaIdException) {
        super(data);
        this._discriminator = "SchemaIdException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIdException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaIdException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaInUseException extends PictureparkValidationException implements ISchemaInUseException {
    schemaId?: string;
    exceptions?: PictureparkBusinessException[];

    constructor(data?: ISchemaInUseException) {
        super(data);
        if (!data) {
            this.exceptions = [];
        }
        this._discriminator = "SchemaInUseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["exceptions"] && data["exceptions"].constructor === Array) {
                this.exceptions = [];
                for (let item of data["exceptions"])
                    this.exceptions.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.exceptions && this.exceptions.constructor === Array) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInUseException extends IPictureparkValidationException {
    schemaId?: string;
    exceptions?: PictureparkBusinessException[];
}

export class SchemaNotFoundException extends PictureparkNotFoundException implements ISchemaNotFoundException {
    schemaId?: string;

    constructor(data?: ISchemaNotFoundException) {
        super(data);
        this._discriminator = "SchemaNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaNotFoundException extends IPictureparkNotFoundException {
    schemaId?: string;
}

export class SystemSchemaInvalidModificationException extends PictureparkValidationException implements ISystemSchemaInvalidModificationException {
    schemaId?: string;

    constructor(data?: ISystemSchemaInvalidModificationException) {
        super(data);
        this._discriminator = "SystemSchemaInvalidModificationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SystemSchemaInvalidModificationException {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSchemaInvalidModificationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISystemSchemaInvalidModificationException extends IPictureparkValidationException {
    schemaId?: string;
}

export class SchemaFieldRelationSchemaSystemSchemaException extends PictureparkValidationException implements ISchemaFieldRelationSchemaSystemSchemaException {
    schemaId?: string;
    fieldId?: string;
    relationSchemaId?: string;

    constructor(data?: ISchemaFieldRelationSchemaSystemSchemaException) {
        super(data);
        this._discriminator = "SchemaFieldRelationSchemaSystemSchemaException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.relationSchemaId = data["relationSchemaId"];
        }
    }

    static fromJS(data: any): SchemaFieldRelationSchemaSystemSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationSchemaSystemSchemaException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relationSchemaId"] = this.relationSchemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldRelationSchemaSystemSchemaException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relationSchemaId?: string;
}

export class SchemaFieldRelationSchemaTypeUnsupportedException extends PictureparkValidationException implements ISchemaFieldRelationSchemaTypeUnsupportedException {
    schemaId?: string;
    fieldId?: string;
    relationSchemaId?: string;

    constructor(data?: ISchemaFieldRelationSchemaTypeUnsupportedException) {
        super(data);
        this._discriminator = "SchemaFieldRelationSchemaTypeUnsupportedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.relationSchemaId = data["relationSchemaId"];
        }
    }

    static fromJS(data: any): SchemaFieldRelationSchemaTypeUnsupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relationSchemaId"] = this.relationSchemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldRelationSchemaTypeUnsupportedException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    relationSchemaId?: string;
}

export class SchemaMultipleTypesException extends PictureparkValidationException implements ISchemaMultipleTypesException {
    schemaId?: string;
    schemaTypes?: string[];

    constructor(data?: ISchemaMultipleTypesException) {
        super(data);
        if (!data) {
            this.schemaTypes = [];
        }
        this._discriminator = "SchemaMultipleTypesException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["schemaTypes"] && data["schemaTypes"].constructor === Array) {
                this.schemaTypes = [];
                for (let item of data["schemaTypes"])
                    this.schemaTypes.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaMultipleTypesException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMultipleTypesException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.schemaTypes && this.schemaTypes.constructor === Array) {
            data["schemaTypes"] = [];
            for (let item of this.schemaTypes)
                data["schemaTypes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaMultipleTypesException extends IPictureparkValidationException {
    schemaId?: string;
    schemaTypes?: string[];
}

export class MissingDisplayPatternForCustomerDefaultLanguageException extends PictureparkValidationException implements IMissingDisplayPatternForCustomerDefaultLanguageException {
    schemaId?: string;
    missingTypes?: DisplayPatternType[];

    constructor(data?: IMissingDisplayPatternForCustomerDefaultLanguageException) {
        super(data);
        if (!data) {
            this.missingTypes = [];
        }
        this._discriminator = "MissingDisplayPatternForCustomerDefaultLanguageException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["missingTypes"] && data["missingTypes"].constructor === Array) {
                this.missingTypes = [];
                for (let item of data["missingTypes"])
                    this.missingTypes.push(item);
            }
        }
    }

    static fromJS(data: any): MissingDisplayPatternForCustomerDefaultLanguageException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.missingTypes && this.missingTypes.constructor === Array) {
            data["missingTypes"] = [];
            for (let item of this.missingTypes)
                data["missingTypes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IMissingDisplayPatternForCustomerDefaultLanguageException extends IPictureparkValidationException {
    schemaId?: string;
    missingTypes?: DisplayPatternType[];
}

export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail", 
    List = <any>"List", 
    Detail = <any>"Detail", 
    Name = <any>"Name", 
}

export class DeleteContentsWithRelationsException extends PictureparkValidationException implements IDeleteContentsWithRelationsException {
    relationList?: string[];
    relations?: string;

    constructor(data?: IDeleteContentsWithRelationsException) {
        super(data);
        if (!data) {
            this.relationList = [];
        }
        this._discriminator = "DeleteContentsWithRelationsException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["relationList"] && data["relationList"].constructor === Array) {
                this.relationList = [];
                for (let item of data["relationList"])
                    this.relationList.push(item);
            }
            this.relations = data["relations"];
        }
    }

    static fromJS(data: any): DeleteContentsWithRelationsException {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContentsWithRelationsException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.relationList && this.relationList.constructor === Array) {
            data["relationList"] = [];
            for (let item of this.relationList)
                data["relationList"].push(item);
        }
        data["relations"] = this.relations;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteContentsWithRelationsException extends IPictureparkValidationException {
    relationList?: string[];
    relations?: string;
}

export class ContentMetadataUpdateManyException extends PictureparkBusinessException implements IContentMetadataUpdateManyException {
    failedItemsCount: number;
    totalItemsCount: number;

    constructor(data?: IContentMetadataUpdateManyException) {
        super(data);
        this._discriminator = "ContentMetadataUpdateManyException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.failedItemsCount = data["failedItemsCount"];
            this.totalItemsCount = data["totalItemsCount"];
        }
    }

    static fromJS(data: any): ContentMetadataUpdateManyException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateManyException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["failedItemsCount"] = this.failedItemsCount;
        data["totalItemsCount"] = this.totalItemsCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentMetadataUpdateManyException extends IPictureparkBusinessException {
    failedItemsCount: number;
    totalItemsCount: number;
}

export class ContentNotFoundException extends PictureparkNotFoundException implements IContentNotFoundException {
    contentIds?: string[];

    constructor(data?: IContentNotFoundException) {
        super(data);
        if (!data) {
            this.contentIds = [];
        }
        this._discriminator = "ContentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentNotFoundException extends IPictureparkNotFoundException {
    contentIds?: string[];
}

export class ContentLayerInvalidException extends PictureparkValidationException implements IContentLayerInvalidException {
    contentId?: string;
    layerIds?: string;

    constructor(data?: IContentLayerInvalidException) {
        super(data);
        this._discriminator = "ContentLayerInvalidException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
            this.layerIds = data["layerIds"];
        }
    }

    static fromJS(data: any): ContentLayerInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentLayerInvalidException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["layerIds"] = this.layerIds;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentLayerInvalidException extends IPictureparkValidationException {
    contentId?: string;
    layerIds?: string;
}

export class ContentFileReplaceTypeMismatchException extends PictureparkValidationException implements IContentFileReplaceTypeMismatchException {
    contentId?: string;
    originalContentType: ContentType;
    newContentType: ContentType;

    constructor(data?: IContentFileReplaceTypeMismatchException) {
        super(data);
        this._discriminator = "ContentFileReplaceTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
            this.originalContentType = data["originalContentType"];
            this.newContentType = data["newContentType"];
        }
    }

    static fromJS(data: any): ContentFileReplaceTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileReplaceTypeMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["originalContentType"] = this.originalContentType;
        data["newContentType"] = this.newContentType;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentFileReplaceTypeMismatchException extends IPictureparkValidationException {
    contentId?: string;
    originalContentType: ContentType;
    newContentType: ContentType;
}

export enum ContentType {
    Unknown = <any>"Unknown", 
    Bitmap = <any>"Bitmap", 
    VectorGraphic = <any>"VectorGraphic", 
    RawImage = <any>"RawImage", 
    InterchangeDocument = <any>"InterchangeDocument", 
    WordProcessingDocument = <any>"WordProcessingDocument", 
    TextDocument = <any>"TextDocument", 
    DesktopPublishingDocument = <any>"DesktopPublishingDocument", 
    Presentation = <any>"Presentation", 
    Spreadsheet = <any>"Spreadsheet", 
    Archive = <any>"Archive", 
    Audio = <any>"Audio", 
    Video = <any>"Video", 
    Font = <any>"Font", 
    Multimedia = <any>"Multimedia", 
    Application = <any>"Application", 
    SourceCode = <any>"SourceCode", 
    Database = <any>"Database", 
    Cad = <any>"Cad", 
    Model3d = <any>"Model3d", 
    ContentItem = <any>"ContentItem", 
}

export class BusinessProcessWaitTimeoutException extends PictureparkTimeoutException implements IBusinessProcessWaitTimeoutException {
    businessProcessId?: string;

    constructor(data?: IBusinessProcessWaitTimeoutException) {
        super(data);
        this._discriminator = "BusinessProcessWaitTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcessWaitTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessWaitTimeoutException extends IPictureparkTimeoutException {
    businessProcessId?: string;
}

export class BusinessProcessEngineRequestException extends PictureparkBusinessException implements IBusinessProcessEngineRequestException {
    businessProcessId?: string;
    engineError?: string;

    constructor(data?: IBusinessProcessEngineRequestException) {
        super(data);
        this._discriminator = "BusinessProcessEngineRequestException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
            this.engineError = data["engineError"];
        }
    }

    static fromJS(data: any): BusinessProcessEngineRequestException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessEngineRequestException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["engineError"] = this.engineError;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessEngineRequestException extends IPictureparkBusinessException {
    businessProcessId?: string;
    engineError?: string;
}

export class BusinessProcessNotFoundException extends PictureparkNotFoundException implements IBusinessProcessNotFoundException {
    businessProcessId?: string;

    constructor(data?: IBusinessProcessNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcessNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessNotFoundException extends IPictureparkNotFoundException {
    businessProcessId?: string;
}

export class BusinessProcessDefinitionNotFoundException extends PictureparkNotFoundException implements IBusinessProcessDefinitionNotFoundException {
    processDefinitionId?: string;

    constructor(data?: IBusinessProcessDefinitionNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.processDefinitionId = data["processDefinitionId"];
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDefinitionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefinitionId"] = this.processDefinitionId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionNotFoundException extends IPictureparkNotFoundException {
    processDefinitionId?: string;
}

export class BusinessProcessDefinitionCreateException extends PictureparkBusinessException implements IBusinessProcessDefinitionCreateException {
    processDefinitionIds?: string[];

    constructor(data?: IBusinessProcessDefinitionCreateException) {
        super(data);
        if (!data) {
            this.processDefinitionIds = [];
        }
        this._discriminator = "BusinessProcessDefinitionCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["processDefinitionIds"] && data["processDefinitionIds"].constructor === Array) {
                this.processDefinitionIds = [];
                for (let item of data["processDefinitionIds"])
                    this.processDefinitionIds.push(item);
            }
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionCreateException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDefinitionCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.processDefinitionIds && this.processDefinitionIds.constructor === Array) {
            data["processDefinitionIds"] = [];
            for (let item of this.processDefinitionIds)
                data["processDefinitionIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionCreateException extends IPictureparkBusinessException {
    processDefinitionIds?: string[];
}

export class SchemaFieldImportMismatchException extends PictureparkValidationException implements ISchemaFieldImportMismatchException {
    schemaId?: string;
    importingFieldIds?: string;
    existingFieldIds?: string;

    constructor(data?: ISchemaFieldImportMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldImportMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.importingFieldIds = data["importingFieldIds"];
            this.existingFieldIds = data["existingFieldIds"];
        }
    }

    static fromJS(data: any): SchemaFieldImportMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["importingFieldIds"] = this.importingFieldIds;
        data["existingFieldIds"] = this.existingFieldIds;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldImportMismatchException extends IPictureparkValidationException {
    schemaId?: string;
    importingFieldIds?: string;
    existingFieldIds?: string;
}

export class SchemaFieldImportRelatedSchemaMismatchException extends PictureparkValidationException implements ISchemaFieldImportRelatedSchemaMismatchException {
    schemaId?: string;
    fieldId?: string;
    importingRelatedSchemaId?: string;
    existingRelatedSchemaId?: string;

    constructor(data?: ISchemaFieldImportRelatedSchemaMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldImportRelatedSchemaMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.importingRelatedSchemaId = data["importingRelatedSchemaId"];
            this.existingRelatedSchemaId = data["existingRelatedSchemaId"];
        }
    }

    static fromJS(data: any): SchemaFieldImportRelatedSchemaMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportRelatedSchemaMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["importingRelatedSchemaId"] = this.importingRelatedSchemaId;
        data["existingRelatedSchemaId"] = this.existingRelatedSchemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldImportRelatedSchemaMismatchException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    importingRelatedSchemaId?: string;
    existingRelatedSchemaId?: string;
}

export class SchemaFieldImportTypeMismatchException extends PictureparkValidationException implements ISchemaFieldImportTypeMismatchException {
    schemaId?: string;
    fieldId?: string;
    importingFieldType?: string;
    existingFieldType?: string;

    constructor(data?: ISchemaFieldImportTypeMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldImportTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.fieldId = data["fieldId"];
            this.importingFieldType = data["importingFieldType"];
            this.existingFieldType = data["existingFieldType"];
        }
    }

    static fromJS(data: any): SchemaFieldImportTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportTypeMismatchException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["importingFieldType"] = this.importingFieldType;
        data["existingFieldType"] = this.existingFieldType;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaFieldImportTypeMismatchException extends IPictureparkValidationException {
    schemaId?: string;
    fieldId?: string;
    importingFieldType?: string;
    existingFieldType?: string;
}

export class SnapshotTimeoutException extends PictureparkTimeoutException implements ISnapshotTimeoutException {

    constructor(data?: ISnapshotTimeoutException) {
        super(data);
        this._discriminator = "SnapshotTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SnapshotTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISnapshotTimeoutException extends IPictureparkTimeoutException {
}

export class SnapshotFailedException extends PictureparkBusinessException implements ISnapshotFailedException {

    constructor(data?: ISnapshotFailedException) {
        super(data);
        this._discriminator = "SnapshotFailedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SnapshotFailedException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotFailedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISnapshotFailedException extends IPictureparkBusinessException {
}

export class AddMetadataLanguageTimeoutException extends PictureparkTimeoutException implements IAddMetadataLanguageTimeoutException {
    environmentProcessId?: string;

    constructor(data?: IAddMetadataLanguageTimeoutException) {
        super(data);
        this._discriminator = "AddMetadataLanguageTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.environmentProcessId = data["environmentProcessId"];
        }
    }

    static fromJS(data: any): AddMetadataLanguageTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new AddMetadataLanguageTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IAddMetadataLanguageTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string;
}

export class EnvironmentProcessAlreadyRunningException extends PictureparkValidationException implements IEnvironmentProcessAlreadyRunningException {
    environmentProcessType: EnvironmentProcessType;

    constructor(data?: IEnvironmentProcessAlreadyRunningException) {
        super(data);
        this._discriminator = "EnvironmentProcessAlreadyRunningException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.environmentProcessType = data["environmentProcessType"];
        }
    }

    static fromJS(data: any): EnvironmentProcessAlreadyRunningException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessAlreadyRunningException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessType"] = this.environmentProcessType;
        super.toJSON(data);
        return data; 
    }
}

export interface IEnvironmentProcessAlreadyRunningException extends IPictureparkValidationException {
    environmentProcessType: EnvironmentProcessType;
}

export enum EnvironmentProcessType {
    AddMetadataLanguage = <any>"AddMetadataLanguage", 
    CustomerUpdate = <any>"CustomerUpdate", 
    EnvironmentUpdate = <any>"EnvironmentUpdate", 
}

export class EnvironmentProcessNotFoundException extends PictureparkNotFoundException implements IEnvironmentProcessNotFoundException {
    environmentProcessId?: string;

    constructor(data?: IEnvironmentProcessNotFoundException) {
        super(data);
        this._discriminator = "EnvironmentProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.environmentProcessId = data["environmentProcessId"];
        }
    }

    static fromJS(data: any): EnvironmentProcessNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IEnvironmentProcessNotFoundException extends IPictureparkNotFoundException {
    environmentProcessId?: string;
}

export class EnvironmentProcessWaitTimeoutException extends PictureparkTimeoutException implements IEnvironmentProcessWaitTimeoutException {
    environmentProcessId?: string;
    waitedLifecycles?: string;

    constructor(data?: IEnvironmentProcessWaitTimeoutException) {
        super(data);
        this._discriminator = "EnvironmentProcessWaitTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.environmentProcessId = data["environmentProcessId"];
            this.waitedLifecycles = data["waitedLifecycles"];
        }
    }

    static fromJS(data: any): EnvironmentProcessWaitTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessWaitTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        data["waitedLifecycles"] = this.waitedLifecycles;
        super.toJSON(data);
        return data; 
    }
}

export interface IEnvironmentProcessWaitTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string;
    waitedLifecycles?: string;
}

export class NoTermsOfServiceDefinedException extends PictureparkBusinessException implements INoTermsOfServiceDefinedException {

    constructor(data?: INoTermsOfServiceDefinedException) {
        super(data);
        this._discriminator = "NoTermsOfServiceDefinedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): NoTermsOfServiceDefinedException {
        data = typeof data === 'object' ? data : {};
        let result = new NoTermsOfServiceDefinedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface INoTermsOfServiceDefinedException extends IPictureparkBusinessException {
}

export class AtLeastOneActiveTermsOfServiceMustExistException extends PictureparkValidationException implements IAtLeastOneActiveTermsOfServiceMustExistException {

    constructor(data?: IAtLeastOneActiveTermsOfServiceMustExistException) {
        super(data);
        this._discriminator = "AtLeastOneActiveTermsOfServiceMustExistException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): AtLeastOneActiveTermsOfServiceMustExistException {
        data = typeof data === 'object' ? data : {};
        let result = new AtLeastOneActiveTermsOfServiceMustExistException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IAtLeastOneActiveTermsOfServiceMustExistException extends IPictureparkValidationException {
}

export class ForbiddenHtmlElementsUsedException extends PictureparkValidationException implements IForbiddenHtmlElementsUsedException {

    constructor(data?: IForbiddenHtmlElementsUsedException) {
        super(data);
        this._discriminator = "ForbiddenHtmlElementsUsedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ForbiddenHtmlElementsUsedException {
        data = typeof data === 'object' ? data : {};
        let result = new ForbiddenHtmlElementsUsedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IForbiddenHtmlElementsUsedException extends IPictureparkValidationException {
}

export class BusinessProcessStateNotHitException extends PictureparkTimeoutException implements IBusinessProcessStateNotHitException {
    businessProcessId?: string;
    expected?: string[];
    actual?: string;

    constructor(data?: IBusinessProcessStateNotHitException) {
        super(data);
        if (!data) {
            this.expected = [];
        }
        this._discriminator = "BusinessProcessStateNotHitException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
            if (data["expected"] && data["expected"].constructor === Array) {
                this.expected = [];
                for (let item of data["expected"])
                    this.expected.push(item);
            }
            this.actual = data["actual"];
        }
    }

    static fromJS(data: any): BusinessProcessStateNotHitException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessStateNotHitException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        if (this.expected && this.expected.constructor === Array) {
            data["expected"] = [];
            for (let item of this.expected)
                data["expected"].push(item);
        }
        data["actual"] = this.actual;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessStateNotHitException extends IPictureparkTimeoutException {
    businessProcessId?: string;
    expected?: string[];
    actual?: string;
}

export class BusinessProcessLifeCycleNotHitException extends PictureparkTimeoutException implements IBusinessProcessLifeCycleNotHitException {
    businessProcessId?: string;
    expected?: BusinessProcessLifeCycle[];
    actual: BusinessProcessLifeCycle;

    constructor(data?: IBusinessProcessLifeCycleNotHitException) {
        super(data);
        if (!data) {
            this.expected = [];
        }
        this._discriminator = "BusinessProcessLifeCycleNotHitException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
            if (data["expected"] && data["expected"].constructor === Array) {
                this.expected = [];
                for (let item of data["expected"])
                    this.expected.push(item);
            }
            this.actual = data["actual"];
        }
    }

    static fromJS(data: any): BusinessProcessLifeCycleNotHitException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessLifeCycleNotHitException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        if (this.expected && this.expected.constructor === Array) {
            data["expected"] = [];
            for (let item of this.expected)
                data["expected"].push(item);
        }
        data["actual"] = this.actual;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessLifeCycleNotHitException extends IPictureparkTimeoutException {
    businessProcessId?: string;
    expected?: BusinessProcessLifeCycle[];
    actual: BusinessProcessLifeCycle;
}

export class BusinessProcessWaitForLifeCycleResult implements IBusinessProcessWaitForLifeCycleResult {
    lifeCycleHit?: BusinessProcessLifeCycle;
    businessProcess?: BusinessProcess;

    constructor(data?: IBusinessProcessWaitForLifeCycleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.businessProcess = new BusinessProcess();
        }
    }

    init(data?: any) {
        if (data) {
            this.lifeCycleHit = data["lifeCycleHit"];
            this.businessProcess = data["businessProcess"] ? BusinessProcess.fromJS(data["businessProcess"]) : new BusinessProcess();
        }
    }

    static fromJS(data: any): BusinessProcessWaitForLifeCycleResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitForLifeCycleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lifeCycleHit"] = this.lifeCycleHit;
        data["businessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessWaitForLifeCycleResult {
    lifeCycleHit?: BusinessProcessLifeCycle;
    businessProcess?: BusinessProcess;
}

export class BusinessProcessWaitForStateResult implements IBusinessProcessWaitForStateResult {
    stateHit?: string;
    businessProcess?: BusinessProcess;

    constructor(data?: IBusinessProcessWaitForStateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.businessProcess = new BusinessProcess();
        }
    }

    init(data?: any) {
        if (data) {
            this.stateHit = data["stateHit"];
            this.businessProcess = data["businessProcess"] ? BusinessProcess.fromJS(data["businessProcess"]) : new BusinessProcess();
        }
    }

    static fromJS(data: any): BusinessProcessWaitForStateResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitForStateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateHit"] = this.stateHit;
        data["businessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessWaitForStateResult {
    stateHit?: string;
    businessProcess?: BusinessProcess;
}

export class BusinessProcessDetails extends BusinessProcess implements IBusinessProcessDetails {
    details?: BusinessProcessDetailsDataBase;

    constructor(data?: IBusinessProcessDetails) {
        super(data);
        this._discriminator = "BusinessProcessDetails";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.details = data["details"] ? BusinessProcessDetailsDataBase.fromJS(data["details"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDetails extends IBusinessProcess {
    details?: BusinessProcessDetailsDataBase;
}

export abstract class BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBase {

    protected _discriminator: string;

    constructor(data?: IBusinessProcessDetailsDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcessDetailsDataBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessDetailsDataBatchResponse") {
            let result = new BusinessProcessDetailsDataBatchResponse();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataSchemaImport") {
            let result = new BusinessProcessDetailsDataSchemaImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataCdnPurge") {
            let result = new BusinessProcessDetailsDataCdnPurge();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataContentImport") {
            let result = new BusinessProcessDetailsDataContentImport();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessProcessDetailsDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

export interface IBusinessProcessDetailsDataBase {
}

export class BusinessProcessDetailsDataBatchResponse extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBatchResponse {
    docType?: string;
    response?: BatchResponse;

    constructor(data?: IBusinessProcessDetailsDataBatchResponse) {
        super(data);
        if (!data) {
            this.response = new BatchResponse();
        }
        this._discriminator = "BusinessProcessDetailsDataBatchResponse";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.docType = data["docType"];
            this.response = data["response"] ? BatchResponse.fromJS(data["response"]) : new BatchResponse();
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataBatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataBatchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDetailsDataBatchResponse extends IBusinessProcessDetailsDataBase {
    docType?: string;
    response?: IBatchResponse;
}

export class BatchResponse implements IBatchResponse {
    rows?: BatchResponseRow[];

    constructor(data?: IBatchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rows) {
                this.rows = [];
                for (let i = 0; i < data.rows.length; i++) {
                    let item = data.rows[i];
                    this.rows[i] = item && !(<any>item).toJSON ? new BatchResponseRow(item) : <BatchResponseRow>item;
                }
            }
        }
        if (!data) {
            this.rows = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["rows"] && data["rows"].constructor === Array) {
                this.rows = [];
                for (let item of data["rows"])
                    this.rows.push(BatchResponseRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BatchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rows && this.rows.constructor === Array) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBatchResponse {
    rows?: IBatchResponseRow[];
}

export class BatchResponseRow implements IBatchResponseRow {
    id?: string;
    succeeded: boolean;
    status: number;
    version: number;
    error?: ErrorResponse;

    constructor(data?: IBatchResponseRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error; 
        }
        if (!data) {
            this.error = new ErrorResponse();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.succeeded = data["succeeded"];
            this.status = data["status"];
            this.version = data["version"];
            this.error = data["error"] ? ErrorResponse.fromJS(data["error"]) : new ErrorResponse();
        }
    }

    static fromJS(data: any): BatchResponseRow {
        data = typeof data === 'object' ? data : {};
        let result = new BatchResponseRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["succeeded"] = this.succeeded;
        data["status"] = this.status;
        data["version"] = this.version;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBatchResponseRow {
    id?: string;
    succeeded: boolean;
    status: number;
    version: number;
    error?: IErrorResponse;
}

/** Business process detailed information regarding Schema / ListItems import operation */
export class BusinessProcessDetailsDataSchemaImport extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataSchemaImport {
    /** Result information of a schema import operation */
    schemaImportResult?: SchemaImportResult;
    /** Result information of a list item import operation */
    listItemImportResult?: ListItemImportResult;

    constructor(data?: IBusinessProcessDetailsDataSchemaImport) {
        super(data);
        if (!data) {
            this.schemaImportResult = new SchemaImportResult();
            this.listItemImportResult = new ListItemImportResult();
        }
        this._discriminator = "BusinessProcessDetailsDataSchemaImport";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaImportResult = data["schemaImportResult"] ? SchemaImportResult.fromJS(data["schemaImportResult"]) : new SchemaImportResult();
            this.listItemImportResult = data["listItemImportResult"] ? ListItemImportResult.fromJS(data["listItemImportResult"]) : new ListItemImportResult();
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataSchemaImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataSchemaImport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaImportResult"] = this.schemaImportResult ? this.schemaImportResult.toJSON() : <any>undefined;
        data["listItemImportResult"] = this.listItemImportResult ? this.listItemImportResult.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Business process detailed information regarding Schema / ListItems import operation */
export interface IBusinessProcessDetailsDataSchemaImport extends IBusinessProcessDetailsDataBase {
    /** Result information of a schema import operation */
    schemaImportResult?: ISchemaImportResult;
    /** Result information of a list item import operation */
    listItemImportResult?: IListItemImportResult;
}

/** Result information of a schema import operation */
export class SchemaImportResult implements ISchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[];
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[];

    constructor(data?: ISchemaImportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.skippedSchemaIds = [];
            this.importedSchemaIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.importedSchemaCount = data["importedSchemaCount"];
            this.skippedSchemaCount = data["skippedSchemaCount"];
            this.totalSchemaCount = data["totalSchemaCount"];
            if (data["skippedSchemaIds"] && data["skippedSchemaIds"].constructor === Array) {
                this.skippedSchemaIds = [];
                for (let item of data["skippedSchemaIds"])
                    this.skippedSchemaIds.push(item);
            }
            if (data["importedSchemaIds"] && data["importedSchemaIds"].constructor === Array) {
                this.importedSchemaIds = [];
                for (let item of data["importedSchemaIds"])
                    this.importedSchemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importedSchemaCount"] = this.importedSchemaCount;
        data["skippedSchemaCount"] = this.skippedSchemaCount;
        data["totalSchemaCount"] = this.totalSchemaCount;
        if (this.skippedSchemaIds && this.skippedSchemaIds.constructor === Array) {
            data["skippedSchemaIds"] = [];
            for (let item of this.skippedSchemaIds)
                data["skippedSchemaIds"].push(item);
        }
        if (this.importedSchemaIds && this.importedSchemaIds.constructor === Array) {
            data["importedSchemaIds"] = [];
            for (let item of this.importedSchemaIds)
                data["importedSchemaIds"].push(item);
        }
        return data; 
    }
}

/** Result information of a schema import operation */
export interface ISchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[];
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[];
}

/** Result information of a list item import operation */
export class ListItemImportResult implements IListItemImportResult {
    /** Number of list items imported */
    importedListItemCount: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount: number;
    /** Total number of list items requested to be imported */
    totalListItemCount: number;
    /** Ids of the list items that were not imported because already found in the system */
    skippedListItemIds?: string[];
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[];

    constructor(data?: IListItemImportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.skippedListItemIds = [];
            this.importedListItemIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.importedListItemCount = data["importedListItemCount"];
            this.skippedListItemCount = data["skippedListItemCount"];
            this.totalListItemCount = data["totalListItemCount"];
            if (data["skippedListItemIds"] && data["skippedListItemIds"].constructor === Array) {
                this.skippedListItemIds = [];
                for (let item of data["skippedListItemIds"])
                    this.skippedListItemIds.push(item);
            }
            if (data["importedListItemIds"] && data["importedListItemIds"].constructor === Array) {
                this.importedListItemIds = [];
                for (let item of data["importedListItemIds"])
                    this.importedListItemIds.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemImportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importedListItemCount"] = this.importedListItemCount;
        data["skippedListItemCount"] = this.skippedListItemCount;
        data["totalListItemCount"] = this.totalListItemCount;
        if (this.skippedListItemIds && this.skippedListItemIds.constructor === Array) {
            data["skippedListItemIds"] = [];
            for (let item of this.skippedListItemIds)
                data["skippedListItemIds"].push(item);
        }
        if (this.importedListItemIds && this.importedListItemIds.constructor === Array) {
            data["importedListItemIds"] = [];
            for (let item of this.importedListItemIds)
                data["importedListItemIds"].push(item);
        }
        return data; 
    }
}

/** Result information of a list item import operation */
export interface IListItemImportResult {
    /** Number of list items imported */
    importedListItemCount: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount: number;
    /** Total number of list items requested to be imported */
    totalListItemCount: number;
    /** Ids of the list items that were not imported because already found in the system */
    skippedListItemIds?: string[];
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[];
}

export class BusinessProcessDetailsDataCdnPurge extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataCdnPurge {
    serializedCdnConfiguration?: string;
    jobs?: CdnPurgeJobBase[];

    constructor(data?: IBusinessProcessDetailsDataCdnPurge) {
        super(data);
        if (!data) {
            this.jobs = [];
        }
        this._discriminator = "BusinessProcessDetailsDataCdnPurge";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serializedCdnConfiguration = data["serializedCdnConfiguration"];
            if (data["jobs"] && data["jobs"].constructor === Array) {
                this.jobs = [];
                for (let item of data["jobs"])
                    this.jobs.push(CdnPurgeJobBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataCdnPurge {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataCdnPurge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serializedCdnConfiguration"] = this.serializedCdnConfiguration;
        if (this.jobs && this.jobs.constructor === Array) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDetailsDataCdnPurge extends IBusinessProcessDetailsDataBase {
    serializedCdnConfiguration?: string;
    jobs?: CdnPurgeJobBase[];
}

export class CdnPurgeJobBase implements ICdnPurgeJobBase {
    success: boolean;
    retriesLeft: number;

    protected _discriminator: string;

    constructor(data?: ICdnPurgeJobBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CdnPurgeJobBase";
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.retriesLeft = data["retriesLeft"];
        }
    }

    static fromJS(data: any): CdnPurgeJobBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CdnPurgeJobByTag") {
            let result = new CdnPurgeJobByTag();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CdnPurgeJobByUri") {
            let result = new CdnPurgeJobByUri();
            result.init(data);
            return result;
        }
        let result = new CdnPurgeJobBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["success"] = this.success;
        data["retriesLeft"] = this.retriesLeft;
        return data; 
    }
}

export interface ICdnPurgeJobBase {
    success: boolean;
    retriesLeft: number;
}

export class CdnPurgeJobByTag extends CdnPurgeJobBase implements ICdnPurgeJobByTag {
    tag?: string;

    constructor(data?: ICdnPurgeJobByTag) {
        super(data);
        this._discriminator = "CdnPurgeJobByTag";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.tag = data["tag"];
        }
    }

    static fromJS(data: any): CdnPurgeJobByTag {
        data = typeof data === 'object' ? data : {};
        let result = new CdnPurgeJobByTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag"] = this.tag;
        super.toJSON(data);
        return data; 
    }
}

export interface ICdnPurgeJobByTag extends ICdnPurgeJobBase {
    tag?: string;
}

export class CdnPurgeJobByUri extends CdnPurgeJobBase implements ICdnPurgeJobByUri {
    uri?: string;

    constructor(data?: ICdnPurgeJobByUri) {
        super(data);
        this._discriminator = "CdnPurgeJobByUri";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): CdnPurgeJobByUri {
        data = typeof data === 'object' ? data : {};
        let result = new CdnPurgeJobByUri();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        super.toJSON(data);
        return data; 
    }
}

export interface ICdnPurgeJobByUri extends ICdnPurgeJobBase {
    uri?: string;
}

export class BusinessProcessDetailsDataContentImport extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataContentImport {
    items?: ContentImportResult[];

    constructor(data?: IBusinessProcessDetailsDataContentImport) {
        super(data);
        if (!data) {
            this.items = [];
        }
        this._discriminator = "BusinessProcessDetailsDataContentImport";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContentImportResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataContentImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataContentImport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDetailsDataContentImport extends IBusinessProcessDetailsDataBase {
    items?: IContentImportResult[];
}

export class ContentImportResult implements IContentImportResult {
    fileTransferId?: string;
    contentId?: string;
    state?: string;
    succeeded: boolean;
    error?: ErrorResponse;

    constructor(data?: IContentImportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error; 
        }
        if (!data) {
            this.error = new ErrorResponse();
        }
    }

    init(data?: any) {
        if (data) {
            this.fileTransferId = data["fileTransferId"];
            this.contentId = data["contentId"];
            this.state = data["state"];
            this.succeeded = data["succeeded"];
            this.error = data["error"] ? ErrorResponse.fromJS(data["error"]) : new ErrorResponse();
        }
    }

    static fromJS(data: any): ContentImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentImportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        data["contentId"] = this.contentId;
        data["state"] = this.state;
        data["succeeded"] = this.succeeded;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentImportResult {
    fileTransferId?: string;
    contentId?: string;
    state?: string;
    succeeded: boolean;
    error?: IErrorResponse;
}

export class Channel implements IChannel {
    id?: string;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[];
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase;
    /** Language specific names. */
    names?: TranslatedStringDictionary;
    sort?: SortInfo[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary;
    audit?: UserAudit;

    constructor(data?: IChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.missingResultsDisplayPatterns = data.missingResultsDisplayPatterns && !(<any>data.missingResultsDisplayPatterns).toJSON ? new TranslatedStringDictionary(data.missingResultsDisplayPatterns) : <TranslatedStringDictionary>this.missingResultsDisplayPatterns; 
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
        if (!data) {
            this.schemaIds = [];
            this.filter = new FilterBase();
            this.names = new TranslatedStringDictionary();
            this.sort = [];
            this.aggregations = [];
            this.extendedSimpleSearchFields = [];
            this.grantedUserRoleIds = [];
            this.missingResultsDisplayPatterns = new TranslatedStringDictionary();
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
            this.searchIndexId = data["searchIndexId"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            if (data["extendedSimpleSearchFields"] && data["extendedSimpleSearchFields"].constructor === Array) {
                this.extendedSimpleSearchFields = [];
                for (let item of data["extendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields.push(item);
            }
            if (data["grantedUserRoleIds"] && data["grantedUserRoleIds"].constructor === Array) {
                this.grantedUserRoleIds = [];
                for (let item of data["grantedUserRoleIds"])
                    this.grantedUserRoleIds.push(item);
            }
            this.missingResultsDisplayPatterns = data["missingResultsDisplayPatterns"] ? TranslatedStringDictionary.fromJS(data["missingResultsDisplayPatterns"]) : new TranslatedStringDictionary();
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
        }
    }

    static fromJS(data: any): Channel {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["searchIndexId"] = this.searchIndexId;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (this.extendedSimpleSearchFields && this.extendedSimpleSearchFields.constructor === Array) {
            data["extendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["extendedSimpleSearchFields"].push(item);
        }
        if (this.grantedUserRoleIds && this.grantedUserRoleIds.constructor === Array) {
            data["grantedUserRoleIds"] = [];
            for (let item of this.grantedUserRoleIds)
                data["grantedUserRoleIds"].push(item);
        }
        data["missingResultsDisplayPatterns"] = this.missingResultsDisplayPatterns ? this.missingResultsDisplayPatterns.toJSON() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChannel {
    id?: string;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[];
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase;
    /** Language specific names. */
    names?: ITranslatedStringDictionary;
    sort?: ISortInfo[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: ITranslatedStringDictionary;
    audit?: IUserAudit;
}

export class SortInfo implements ISortInfo {
    /** The elastic search index field to sort on. */
    field?: string;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface ISortInfo {
    /** The elastic search index field to sort on. */
    field?: string;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;
}

export enum SortDirection {
    Asc = <any>"Asc", 
    Desc = <any>"Desc", 
}

/** The AggregatorBase is the base class for all aggregators. */
export abstract class AggregatorBase implements IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[];

    protected _discriminator: string;

    constructor(data?: IAggregatorBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.aggregators = [];
        }
        this._discriminator = "AggregatorBase";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregatorBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DateRangeAggregator") {
            let result = new DateRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceAggregator") {
            let result = new GeoDistanceAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedAggregator") {
            let result = new NestedAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeAggregator") {
            let result = new NumericRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsAggregator") {
            let result = new TermsAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AggregatorBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        return data; 
    }
}

/** The AggregatorBase is the base class for all aggregators. */
export interface IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string;
    /** The translated names of the aggregation. */
    names?: ITranslatedStringDictionary;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[];
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export class DateRangeAggregator extends AggregatorBase implements IDateRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRangeForAggregator[];

    constructor(data?: IDateRangeAggregator) {
        super(data);
        if (!data) {
            this.ranges = [];
        }
        this._discriminator = "DateRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(DateRangeForAggregator.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateRangeAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export interface IDateRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: IDateRangeForAggregator[];
}

/** The date range class used in aggregators. */
export class DateRangeForAggregator implements IDateRangeForAggregator {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string;

    constructor(data?: IDateRangeForAggregator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): DateRangeForAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeForAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

/** The date range class used in aggregators. */
export interface IDateRangeForAggregator {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string;
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export class GeoDistanceAggregator extends AggregatorBase implements IGeoDistanceAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation;
    /** A list of numeric ranges in meter. */
    ranges?: GeoDistance[];

    constructor(data?: IGeoDistanceAggregator) {
        super(data);
        if (!data) {
            this.location = new GeoLocation();
            this.ranges = [];
        }
        this._discriminator = "GeoDistanceAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : new GeoLocation();
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(GeoDistance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeoDistanceAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export interface IGeoDistanceAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** The latitude/logitude configuration for the point of origin. */
    location?: IGeoLocation;
    /** A list of numeric ranges in meter. */
    ranges?: IGeoDistance[];
}

export class GeoDistance implements IGeoDistance {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The to value. */
    distance: number;

    constructor(data?: IGeoDistance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.distance = data["distance"];
        }
    }

    static fromJS(data: any): GeoDistance {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        return data; 
    }
}

export interface IGeoDistance {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary;
    /** The to value. */
    distance: number;
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export class NestedAggregator extends AggregatorBase implements INestedAggregator {
    /** The path pointing to the nested object. */
    path?: string;

    constructor(data?: INestedAggregator) {
        super(data);
        this._discriminator = "NestedAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["path"];
        }
    }

    static fromJS(data: any): NestedAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NestedAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        super.toJSON(data);
        return data; 
    }
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export interface INestedAggregator extends IAggregatorBase {
    /** The path pointing to the nested object. */
    path?: string;
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export class NumericRangeAggregator extends AggregatorBase implements INumericRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** A list of numeric ranges. */
    ranges?: NumericRangeForAggregator[];

    constructor(data?: INumericRangeAggregator) {
        super(data);
        if (!data) {
            this.ranges = [];
        }
        this._discriminator = "NumericRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(NumericRangeForAggregator.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NumericRangeAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export interface INumericRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string;
    /** A list of numeric ranges. */
    ranges?: INumericRangeForAggregator[];
}

export class NumericRangeForAggregator implements INumericRangeForAggregator {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary;
    /** The from value. */
    from?: number;
    /** The to value. */
    to?: number;

    constructor(data?: INumericRangeForAggregator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): NumericRangeForAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeForAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

export interface INumericRangeForAggregator {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary;
    /** The from value. */
    from?: number;
    /** The to value. */
    to?: number;
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export class TermsAggregator extends AggregatorBase implements ITermsAggregator {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[];
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[];
    /** Search string to be used to search within possible aggregation values */
    searchString?: string;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used */
    searchFields?: string[];

    constructor(data?: ITermsAggregator) {
        super(data);
        if (!data) {
            this.includes = [];
            this.excludes = [];
            this.searchFields = [];
        }
        this._discriminator = "TermsAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.size = data["size"];
            if (data["includes"] && data["includes"].constructor === Array) {
                this.includes = [];
                for (let item of data["includes"])
                    this.includes.push(item);
            }
            if (data["excludes"] && data["excludes"].constructor === Array) {
                this.excludes = [];
                for (let item of data["excludes"])
                    this.excludes.push(item);
            }
            this.searchString = data["searchString"];
            if (data["searchFields"] && data["searchFields"].constructor === Array) {
                this.searchFields = [];
                for (let item of data["searchFields"])
                    this.searchFields.push(item);
            }
        }
    }

    static fromJS(data: any): TermsAggregator {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new TermsAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["size"] = this.size;
        if (this.includes && this.includes.constructor === Array) {
            data["includes"] = [];
            for (let item of this.includes)
                data["includes"].push(item);
        }
        if (this.excludes && this.excludes.constructor === Array) {
            data["excludes"] = [];
            for (let item of this.excludes)
                data["excludes"].push(item);
        }
        data["searchString"] = this.searchString;
        if (this.searchFields && this.searchFields.constructor === Array) {
            data["searchFields"] = [];
            for (let item of this.searchFields)
                data["searchFields"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export interface ITermsAggregator extends IAggregatorBase {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[];
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[];
    /** Search string to be used to search within possible aggregation values */
    searchString?: string;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used */
    searchFields?: string[];
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export class TermsRelationAggregator extends TermsAggregator implements ITermsRelationAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;

    constructor(data?: ITermsRelationAggregator) {
        super(data);
        this._discriminator = "TermsRelationAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): TermsRelationAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new TermsRelationAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export interface ITermsRelationAggregator extends ITermsAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    Schema = <any>"Schema", 
    User = <any>"User", 
    ContentPermissionSet = <any>"ContentPermissionSet", 
    Owner = <any>"Owner", 
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export class TermsEnumAggregator extends TermsAggregator implements ITermsEnumAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string;

    constructor(data?: ITermsEnumAggregator) {
        super(data);
        this._discriminator = "TermsEnumAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.enumType = data["enumType"];
        }
    }

    static fromJS(data: any): TermsEnumAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new TermsEnumAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumType"] = this.enumType;
        super.toJSON(data);
        return data; 
    }
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export interface ITermsEnumAggregator extends ITermsAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string;
}

export class UserAudit implements IUserAudit {
    creationDate: Date;
    modificationDate: Date;
    createdByUser?: string;
    modifiedByUser?: string;

    constructor(data?: IUserAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creationDate = data["creationDate"] ? new Date(data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            this.createdByUser = data["createdByUser"];
            this.modifiedByUser = data["modifiedByUser"];
        }
    }

    static fromJS(data: any): UserAudit {
        data = typeof data === 'object' ? data : {};
        let result = new UserAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser;
        data["modifiedByUser"] = this.modifiedByUser;
        return data; 
    }
}

export interface IUserAudit {
    creationDate: Date;
    modificationDate: Date;
    createdByUser?: string;
    modifiedByUser?: string;
}

export enum ContentResolveBehaviour {
    Content = <any>"Content", 
    LinkedListItems = <any>"LinkedListItems", 
    Metadata = <any>"Metadata", 
    Outputs = <any>"Outputs", 
    InnerDisplayValueThumbnail = <any>"InnerDisplayValueThumbnail", 
    InnerDisplayValueList = <any>"InnerDisplayValueList", 
    InnerDisplayValueDetail = <any>"InnerDisplayValueDetail", 
    InnerDisplayValueName = <any>"InnerDisplayValueName", 
}

/** A content detail. */
export class ContentDetail implements IContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit;
    /** The content data */
    content?: any;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
    /** The id of the content schema */
    contentSchemaId?: string;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: DisplayValueDictionary;
    /** The content id. */
    id?: string;
    /** An optional list of layer schemas ids */
    layerSchemaIds?: string[];
    /** The metadata dictionary */
    metadata?: DataDictionary;
    /** A list of rendering ouputs for underlying digital file. */
    outputs?: Output[];
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string;
    /** The trashed flag. */
    trashed: boolean;

    constructor(data?: IContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
        if (!data) {
            this.audit = new UserAudit();
            this.contentPermissionSetIds = [];
            this.displayValues = new DisplayValueDictionary();
            this.layerSchemaIds = [];
            this.metadata = new DataDictionary();
            this.outputs = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.content = data["content"];
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
            this.contentSchemaId = data["contentSchemaId"];
            this.contentType = data["contentType"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : new DisplayValueDictionary();
            this.id = data["id"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : new DataDictionary();
            if (data["outputs"] && data["outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["outputs"])
                    this.outputs.push(Output.fromJS(item));
            }
            this.ownerTokenId = data["ownerTokenId"];
            this.trashed = data["trashed"];
        }
    }

    static fromJS(data: any): ContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["content"] = this.content;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        data["contentSchemaId"] = this.contentSchemaId;
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.outputs && this.outputs.constructor === Array) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["ownerTokenId"] = this.ownerTokenId;
        data["trashed"] = this.trashed;
        return data; 
    }
}

/** A content detail. */
export interface IContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: IUserAudit;
    /** The content data */
    content?: any;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
    /** The id of the content schema */
    contentSchemaId?: string;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: IDisplayValueDictionary;
    /** The content id. */
    id?: string;
    /** An optional list of layer schemas ids */
    layerSchemaIds?: string[];
    /** The metadata dictionary */
    metadata?: IDataDictionary;
    /** A list of rendering ouputs for underlying digital file. */
    outputs?: Output[];
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string;
    /** The trashed flag. */
    trashed: boolean;
}

export class DisplayValueDictionary implements IDisplayValueDictionary {

    [key: string]: string | any; 

    constructor(data?: IDisplayValueDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DisplayValueDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayValueDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface IDisplayValueDictionary {

    [key: string]: string | any; 
}

export class DataDictionary implements IDataDictionary {

    [key: string]: any; 

    constructor(data?: IDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DataDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DataDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface IDataDictionary {

    [key: string]: any; 
}

export class Output implements IOutput {
    id?: string;
    outputFormatId?: string;
    contentId?: string;
    renderingState: OutputRenderingState;
    detail?: OutputDataBase;
    backupTimestamp?: Date;

    protected _discriminator: string;

    constructor(data?: IOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Output";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.outputFormatId = data["outputFormatId"];
            this.contentId = data["contentId"];
            this.renderingState = data["renderingState"];
            this.detail = data["detail"] ? OutputDataBase.fromJS(data["detail"]) : <any>undefined;
            this.backupTimestamp = data["backupTimestamp"] ? new Date(data["backupTimestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Output {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputDetail") {
            let result = new OutputDetail();
            result.init(data);
            return result;
        }
        let result = new Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["outputFormatId"] = this.outputFormatId;
        data["contentId"] = this.contentId;
        data["renderingState"] = this.renderingState;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        data["backupTimestamp"] = this.backupTimestamp ? this.backupTimestamp.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOutput {
    id?: string;
    outputFormatId?: string;
    contentId?: string;
    renderingState: OutputRenderingState;
    detail?: OutputDataBase;
    backupTimestamp?: Date;
}

export enum OutputRenderingState {
    InProgress = <any>"InProgress", 
    Completed = <any>"Completed", 
    Failed = <any>"Failed", 
    Skipped = <any>"Skipped", 
}

export abstract class OutputDataBase implements IOutputDataBase {
    fileExtension?: string;
    fileName?: string;
    filePath?: string;
    fileSizeInBytes?: number;
    sha1Hash?: string;

    protected _discriminator: string;

    constructor(data?: IOutputDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputDataBase";
    }

    init(data?: any) {
        if (data) {
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
        }
    }

    static fromJS(data: any): OutputDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputDataImage") {
            let result = new OutputDataImage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataAudio") {
            let result = new OutputDataAudio();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataVideo") {
            let result = new OutputDataVideo();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDocument") {
            let result = new OutputDataDocument();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDefault") {
            let result = new OutputDataDefault();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'OutputDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        return data; 
    }
}

export interface IOutputDataBase {
    fileExtension?: string;
    fileName?: string;
    filePath?: string;
    fileSizeInBytes?: number;
    sha1Hash?: string;
}

export class OutputDataImage extends OutputDataBase implements IOutputDataImage {
    width: number;
    height: number;

    constructor(data?: IOutputDataImage) {
        super(data);
        this._discriminator = "OutputDataImage";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): OutputDataImage {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataImage extends IOutputDataBase {
    width: number;
    height: number;
}

export class OutputDataAudio extends OutputDataBase implements IOutputDataAudio {
    durationInSeconds?: number;

    constructor(data?: IOutputDataAudio) {
        super(data);
        this._discriminator = "OutputDataAudio";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
        }
    }

    static fromJS(data: any): OutputDataAudio {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataAudio extends IOutputDataBase {
    durationInSeconds?: number;
}

export class OutputDataVideo extends OutputDataBase implements IOutputDataVideo {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[];

    constructor(data?: IOutputDataVideo) {
        super(data);
        if (!data) {
            this.sprites = [];
        }
        this._discriminator = "OutputDataVideo";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
            this.width = data["width"];
            this.height = data["height"];
            if (data["sprites"] && data["sprites"].constructor === Array) {
                this.sprites = [];
                for (let item of data["sprites"])
                    this.sprites.push(Sprite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputDataVideo {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataVideo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        data["width"] = this.width;
        data["height"] = this.height;
        if (this.sprites && this.sprites.constructor === Array) {
            data["sprites"] = [];
            for (let item of this.sprites)
                data["sprites"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataVideo extends IOutputDataBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: ISprite[];
}

export class Sprite implements ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;

    constructor(data?: ISprite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.y = data["y"];
            this.x = data["x"];
            this.start = data["start"];
            this.end = data["end"];
        }
    }

    static fromJS(data: any): Sprite {
        data = typeof data === 'object' ? data : {};
        let result = new Sprite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["y"] = this.y;
        data["x"] = this.x;
        data["start"] = this.start;
        data["end"] = this.end;
        return data; 
    }
}

export interface ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;
}

export class OutputDataDocument extends OutputDataBase implements IOutputDataDocument {
    pageCount: number;

    constructor(data?: IOutputDataDocument) {
        super(data);
        this._discriminator = "OutputDataDocument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pageCount = data["pageCount"];
        }
    }

    static fromJS(data: any): OutputDataDocument {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataDocument extends IOutputDataBase {
    pageCount: number;
}

export class OutputDataDefault extends OutputDataBase implements IOutputDataDefault {

    constructor(data?: IOutputDataDefault) {
        super(data);
        this._discriminator = "OutputDataDefault";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDataDefault {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataDefault();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataDefault extends IOutputDataBase {
}

export class OutputDetail extends Output implements IOutputDetail {

    constructor(data?: IOutputDetail) {
        super(data);
        this._discriminator = "OutputDetail";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetail extends IOutput {
}

export class ContentSearchRequest implements IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** The collection id. */
    collectionId?: string;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied in the specified order. */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the returned contents that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[];
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IContentSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.displayPatternIds = [];
            this.searchLanguages = [];
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.rightsFilter = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.channelId = data["channelId"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["collectionId"];
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.lifeCycleFilter = data["lifeCycleFilter"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["rightsFilter"] && data["rightsFilter"].constructor === Array) {
                this.rightsFilter = [];
                for (let item of data["rightsFilter"])
                    this.rightsFilter.push(item);
            }
            this.searchType = data["searchType"];
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): ContentSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channelId"] = this.channelId;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.rightsFilter && this.rightsFilter.constructor === Array) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        data["searchType"] = this.searchType;
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** The collection id. */
    collectionId?: string;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied in the specified order. */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the returned contents that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[];
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly", 
    All = <any>"All", 
    InactiveOnly = <any>"InactiveOnly", 
    ActiveInactiveOnly = <any>"ActiveInactiveOnly", 
}

export enum BrokenDependenciesFilter {
    All = <any>"All", 
    NotBrokenOnly = <any>"NotBrokenOnly", 
    BrokenOnly = <any>"BrokenOnly", 
}

export enum ContentRight {
    View = <any>"View", 
    AccessOriginal = <any>"AccessOriginal", 
    Edit = <any>"Edit", 
    Update = <any>"Update", 
    Manage = <any>"Manage", 
    Trash = <any>"Trash", 
}

export enum ContentSearchType {
    Metadata = <any>"Metadata", 
    FullText = <any>"FullText", 
    MetadataAndFullText = <any>"MetadataAndFullText", 
}

export class BaseResultOfContent implements IBaseResultOfContent {
    totalResults: number;
    results: Content[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Content(item) : <Content>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Content.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfContent {
    totalResults: number;
    results: IContent[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfContent extends BaseResultOfContent implements ISearchBehaviourBaseResultOfContent {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfContent) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfContent extends IBaseResultOfContent {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class ContentSearchResult extends SearchBehaviourBaseResultOfContent implements IContentSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IContentSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ContentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentSearchResult extends ISearchBehaviourBaseResultOfContent {
    elapsedMilliseconds: number;
}

export class Content implements IContent {
    audit?: UserAudit;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; };
    id?: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[];
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[];
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[];

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
        if (!data) {
            this.audit = new UserAudit();
            this.layerSchemaIds = [];
            this.displayValues = {};
            this.brokenReferenceIds = [];
            this.brokenIndirectReferenceIds = [];
            this.brokenRelationTargetIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["displayValues"]) {
                this.displayValues = {};
                for (let key in data["displayValues"]) {
                    if (data["displayValues"].hasOwnProperty(key))
                        this.displayValues[key] = data["displayValues"][key];
                }
            }
            this.id = data["id"];
            if (data["brokenReferenceIds"] && data["brokenReferenceIds"].constructor === Array) {
                this.brokenReferenceIds = [];
                for (let item of data["brokenReferenceIds"])
                    this.brokenReferenceIds.push(item);
            }
            if (data["brokenIndirectReferenceIds"] && data["brokenIndirectReferenceIds"].constructor === Array) {
                this.brokenIndirectReferenceIds = [];
                for (let item of data["brokenIndirectReferenceIds"])
                    this.brokenIndirectReferenceIds.push(item);
            }
            if (data["brokenRelationTargetIds"] && data["brokenRelationTargetIds"].constructor === Array) {
                this.brokenRelationTargetIds = [];
                for (let item of data["brokenRelationTargetIds"])
                    this.brokenRelationTargetIds.push(item);
            }
        }
    }

    static fromJS(data: any): Content {
        data = typeof data === 'object' ? data : {};
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayValues) {
            data["displayValues"] = {};
            for (let key in this.displayValues) {
                if (this.displayValues.hasOwnProperty(key))
                    data["displayValues"][key] = this.displayValues[key];
            }
        }
        data["id"] = this.id;
        if (this.brokenReferenceIds && this.brokenReferenceIds.constructor === Array) {
            data["brokenReferenceIds"] = [];
            for (let item of this.brokenReferenceIds)
                data["brokenReferenceIds"].push(item);
        }
        if (this.brokenIndirectReferenceIds && this.brokenIndirectReferenceIds.constructor === Array) {
            data["brokenIndirectReferenceIds"] = [];
            for (let item of this.brokenIndirectReferenceIds)
                data["brokenIndirectReferenceIds"].push(item);
        }
        if (this.brokenRelationTargetIds && this.brokenRelationTargetIds.constructor === Array) {
            data["brokenRelationTargetIds"] = [];
            for (let item of this.brokenRelationTargetIds)
                data["brokenRelationTargetIds"].push(item);
        }
        return data; 
    }
}

export interface IContent {
    audit?: IUserAudit;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; };
    id?: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[];
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[];
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[];
}

export class ContentAggregationOnChannelRequest implements IContentAggregationOnChannelRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[];
    /** Limits the simple search fields to the fields available in the specified channel and retrieve the existing aggregation for it. */
    channelId?: string;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[];
    /** The collection id. */
    collectionId?: string;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;

    constructor(data?: IContentAggregationOnChannelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.filter = new FilterBase();
            this.aggregationFilters = [];
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            this.channelId = data["channelId"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["collectionId"];
            this.lifeCycleFilter = data["lifeCycleFilter"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            this.searchType = data["searchType"];
        }
    }

    static fromJS(data: any): ContentAggregationOnChannelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAggregationOnChannelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        data["channelId"] = this.channelId;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        data["searchType"] = this.searchType;
        return data; 
    }
}

export interface IContentAggregationOnChannelRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[];
    /** Limits the simple search fields to the fields available in the specified channel and retrieve the existing aggregation for it. */
    channelId?: string;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[];
    /** The collection id. */
    collectionId?: string;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
}

export class ContentAggregationRequest extends ContentAggregationOnChannelRequest implements IContentAggregationRequest {
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[];

    constructor(data?: IContentAggregationRequest) {
        super(data);
        if (!data) {
            this.aggregators = [];
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentAggregationRequest extends IContentAggregationOnChannelRequest {
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[];
}

export class ObjectAggregationResult implements IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[];
    /** The search string used to query the data */
    searchString?: string;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten: boolean;

    constructor(data?: IObjectAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
        if (!data) {
            this.aggregationResults = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): ObjectAggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectAggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        return data; 
    }
}

export interface IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: IAggregationResult[];
    /** The search string used to query the data */
    searchString?: string;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten: boolean;
}

export class AggregationResult implements IAggregationResult {
    name?: string;
    sumOtherDocCount?: number;
    aggregationResultItems?: AggregationResultItem[];

    constructor(data?: IAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResultItems) {
                this.aggregationResultItems = [];
                for (let i = 0; i < data.aggregationResultItems.length; i++) {
                    let item = data.aggregationResultItems[i];
                    this.aggregationResultItems[i] = item && !(<any>item).toJSON ? new AggregationResultItem(item) : <AggregationResultItem>item;
                }
            }
        }
        if (!data) {
            this.aggregationResultItems = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.sumOtherDocCount = data["sumOtherDocCount"];
            if (data["aggregationResultItems"] && data["aggregationResultItems"].constructor === Array) {
                this.aggregationResultItems = [];
                for (let item of data["aggregationResultItems"])
                    this.aggregationResultItems.push(AggregationResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sumOtherDocCount"] = this.sumOtherDocCount;
        if (this.aggregationResultItems && this.aggregationResultItems.constructor === Array) {
            data["aggregationResultItems"] = [];
            for (let item of this.aggregationResultItems)
                data["aggregationResultItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResult {
    name?: string;
    sumOtherDocCount?: number;
    aggregationResultItems?: IAggregationResultItem[];
}

export class AggregationResultItem implements IAggregationResultItem {
    name?: string;
    count: number;
    filter?: AggregationFilter;
    active: boolean;
    aggregationResults?: AggregationResult[];

    getDisplayName(locale: string) {
      const displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null;
      return displayName ? displayName : this.name;
    }

    constructor(data?: IAggregationResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
        if (!data) {
            this.filter = new AggregationFilter();
            this.aggregationResults = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.count = data["count"];
            this.filter = data["filter"] ? AggregationFilter.fromJS(data["filter"]) : new AggregationFilter();
            this.active = data["active"];
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResultItem {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["count"] = this.count;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["active"] = this.active;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResultItem {
    name?: string;
    count: number;
    filter?: AggregationFilter;
    active: boolean;
    aggregationResults?: IAggregationResult[];
}

export class ContentReferencesRequest implements IContentReferencesRequest {
    shares?: PagingRequest;

    constructor(data?: IContentReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.shares = data.shares && !(<any>data.shares).toJSON ? new PagingRequest(data.shares) : <PagingRequest>this.shares; 
        }
        if (!data) {
            this.shares = new PagingRequest();
        }
    }

    init(data?: any) {
        if (data) {
            this.shares = data["shares"] ? PagingRequest.fromJS(data["shares"]) : new PagingRequest();
        }
    }

    static fromJS(data: any): ContentReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shares"] = this.shares ? this.shares.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentReferencesRequest {
    shares?: IPagingRequest;
}

export class PagingRequest implements IPagingRequest {
    start: number;
    limit: number;

    constructor(data?: IPagingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.start = data["start"];
            this.limit = data["limit"];
        }
    }

    static fromJS(data: any): PagingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["limit"] = this.limit;
        return data; 
    }
}

export interface IPagingRequest {
    start: number;
    limit: number;
}

export class ContentReferencesResult implements IContentReferencesResult {
    metadataReferences?: ContentReferences[];
    shareReferences?: ContentShareReferenceResult;

    constructor(data?: IContentReferencesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.metadataReferences) {
                this.metadataReferences = [];
                for (let i = 0; i < data.metadataReferences.length; i++) {
                    let item = data.metadataReferences[i];
                    this.metadataReferences[i] = item && !(<any>item).toJSON ? new ContentReferences(item) : <ContentReferences>item;
                }
            }
            this.shareReferences = data.shareReferences && !(<any>data.shareReferences).toJSON ? new ContentShareReferenceResult(data.shareReferences) : <ContentShareReferenceResult>this.shareReferences; 
        }
        if (!data) {
            this.metadataReferences = [];
            this.shareReferences = new ContentShareReferenceResult();
        }
    }

    init(data?: any) {
        if (data) {
            if (data["metadataReferences"] && data["metadataReferences"].constructor === Array) {
                this.metadataReferences = [];
                for (let item of data["metadataReferences"])
                    this.metadataReferences.push(ContentReferences.fromJS(item));
            }
            this.shareReferences = data["shareReferences"] ? ContentShareReferenceResult.fromJS(data["shareReferences"]) : new ContentShareReferenceResult();
        }
    }

    static fromJS(data: any): ContentReferencesResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferencesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.metadataReferences && this.metadataReferences.constructor === Array) {
            data["metadataReferences"] = [];
            for (let item of this.metadataReferences)
                data["metadataReferences"].push(item.toJSON());
        }
        data["shareReferences"] = this.shareReferences ? this.shareReferences.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentReferencesResult {
    metadataReferences?: IContentReferences[];
    shareReferences?: IContentShareReferenceResult;
}

export abstract class ReferencesBase implements IReferencesBase {
    targetMetadataItemId?: string;
    references?: MetadataReference[];
    isReferencedByRestrictedItem: boolean;

    constructor(data?: IReferencesBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.references) {
                this.references = [];
                for (let i = 0; i < data.references.length; i++) {
                    let item = data.references[i];
                    this.references[i] = item && !(<any>item).toJSON ? new MetadataReference(item) : <MetadataReference>item;
                }
            }
        }
        if (!data) {
            this.references = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.targetMetadataItemId = data["targetMetadataItemId"];
            if (data["references"] && data["references"].constructor === Array) {
                this.references = [];
                for (let item of data["references"])
                    this.references.push(MetadataReference.fromJS(item));
            }
            this.isReferencedByRestrictedItem = data["isReferencedByRestrictedItem"];
        }
    }

    static fromJS(data: any): ReferencesBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ReferencesBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetMetadataItemId"] = this.targetMetadataItemId;
        if (this.references && this.references.constructor === Array) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item.toJSON());
        }
        data["isReferencedByRestrictedItem"] = this.isReferencedByRestrictedItem;
        return data; 
    }
}

export interface IReferencesBase {
    targetMetadataItemId?: string;
    references?: IMetadataReference[];
    isReferencedByRestrictedItem: boolean;
}

export class ContentReferences extends ReferencesBase implements IContentReferences {
    relations?: MetadataReference[];

    constructor(data?: IContentReferences) {
        super(data);
        if (!data) {
            this.relations = [];
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["relations"] && data["relations"].constructor === Array) {
                this.relations = [];
                for (let item of data["relations"])
                    this.relations.push(MetadataReference.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentReferences {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.relations && this.relations.constructor === Array) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentReferences extends IReferencesBase {
    relations?: IMetadataReference[];
}

export class MetadataReference implements IMetadataReference {
    targetDocType?: string;
    sourceId?: string;
    sourceDocType?: string;

    constructor(data?: IMetadataReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetDocType = data["targetDocType"];
            this.sourceId = data["sourceId"];
            this.sourceDocType = data["sourceDocType"];
        }
    }

    static fromJS(data: any): MetadataReference {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetDocType"] = this.targetDocType;
        data["sourceId"] = this.sourceId;
        data["sourceDocType"] = this.sourceDocType;
        return data; 
    }
}

export interface IMetadataReference {
    targetDocType?: string;
    sourceId?: string;
    sourceDocType?: string;
}

export class BaseResultOfContentShareReference implements IBaseResultOfContentShareReference {
    totalResults: number;
    results: ContentShareReference[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfContentShareReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ContentShareReference(item) : <ContentShareReference>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(ContentShareReference.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfContentShareReference {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfContentShareReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfContentShareReference {
    totalResults: number;
    results: IContentShareReference[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class ContentShareReferenceResult extends BaseResultOfContentShareReference implements IContentShareReferenceResult {

    constructor(data?: IContentShareReferenceResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ContentShareReferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareReferenceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IContentShareReferenceResult extends IBaseResultOfContentShareReference {
}

export class ContentShareReference implements IContentShareReference {
    id?: string;
    name?: string;
    audit?: UserAudit;
    shareType: ShareType;
    emailAddress?: string;

    constructor(data?: IContentShareReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
        if (!data) {
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.shareType = data["shareType"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): ContentShareReference {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["shareType"] = this.shareType;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IContentShareReference {
    id?: string;
    name?: string;
    audit?: IUserAudit;
    shareType: ShareType;
    emailAddress?: string;
}

export enum ShareType {
    Basic = <any>"Basic", 
    Embed = <any>"Embed", 
}

export class ContentManyReferencesRequest implements IContentManyReferencesRequest {
    contentIds?: string[];
    shares?: PagingRequest;

    constructor(data?: IContentManyReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.shares = data.shares && !(<any>data.shares).toJSON ? new PagingRequest(data.shares) : <PagingRequest>this.shares; 
        }
        if (!data) {
            this.contentIds = [];
            this.shares = new PagingRequest();
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.shares = data["shares"] ? PagingRequest.fromJS(data["shares"]) : new PagingRequest();
        }
    }

    static fromJS(data: any): ContentManyReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentManyReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["shares"] = this.shares ? this.shares.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentManyReferencesRequest {
    contentIds?: string[];
    shares?: IPagingRequest;
}

export class ContentDownloadLinkCreateRequest implements IContentDownloadLinkCreateRequest {
    contents?: ContentDownloadRequestItem[];

    constructor(data?: IContentDownloadLinkCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contents) {
                this.contents = [];
                for (let i = 0; i < data.contents.length; i++) {
                    let item = data.contents[i];
                    this.contents[i] = item && !(<any>item).toJSON ? new ContentDownloadRequestItem(item) : <ContentDownloadRequestItem>item;
                }
            }
        }
        if (!data) {
            this.contents = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contents"] && data["contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["contents"])
                    this.contents.push(ContentDownloadRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentDownloadLinkCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadLinkCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contents && this.contents.constructor === Array) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContentDownloadLinkCreateRequest {
    contents?: IContentDownloadRequestItem[];
}

export class ContentDownloadRequestItem implements IContentDownloadRequestItem {
    contentId?: string;
    outputFormatId?: string;

    constructor(data?: IContentDownloadRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
        }
    }

    static fromJS(data: any): ContentDownloadRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        return data; 
    }
}

export interface IContentDownloadRequestItem {
    contentId?: string;
    outputFormatId?: string;
}

export class DownloadLink implements IDownloadLink {
    downloadToken?: string;
    downloadUrl?: string;

    constructor(data?: IDownloadLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.downloadToken = data["downloadToken"];
            this.downloadUrl = data["downloadUrl"];
        }
    }

    static fromJS(data: any): DownloadLink {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadToken"] = this.downloadToken;
        data["downloadUrl"] = this.downloadUrl;
        return data; 
    }
}

export interface IDownloadLink {
    downloadToken?: string;
    downloadUrl?: string;
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = <any>"Small", 
    Medium = <any>"Medium", 
    Large = <any>"Large", 
}

/** A request structure for creating a content document. */
export class ContentCreateRequest implements IContentCreateRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** The content data of the content document. */
    content?: any;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[];

    constructor(data?: IContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
        if (!data) {
            this.layerSchemaIds = [];
            this.metadata = new DataDictionary();
            this.contentPermissionSetIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"];
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : new DataDictionary();
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

/** A request structure for creating a content document. */
export interface IContentCreateRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** The content data of the content document. */
    content?: any;
    /** The layer metadata of the content document. */
    metadata?: IDataDictionary;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[];
}

/** A request structure for creating multiple content documents. */
export class ContentCreateManyRequest implements IContentCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: ContentCreateRequest[];

    constructor(data?: IContentCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentCreateRequest(item) : <ContentCreateRequest>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContentCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

/** A request structure for creating multiple content documents. */
export interface IContentCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: IContentCreateRequest[];
}

export class ContentDeleteManyRequest implements IContentDeleteManyRequest {
    contentIds?: string[];
    forceReferenceRemoval: boolean;

    constructor(data?: IContentDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.forceReferenceRemoval = data["forceReferenceRemoval"];
        }
    }

    static fromJS(data: any): ContentDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        return data; 
    }
}

export interface IContentDeleteManyRequest {
    contentIds?: string[];
    forceReferenceRemoval: boolean;
}

export class ContentRestoreManyRequest implements IContentRestoreManyRequest {
    contentIds?: string[];
    allowMissingDependencies: boolean;

    constructor(data?: IContentRestoreManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ContentRestoreManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRestoreManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

export interface IContentRestoreManyRequest {
    contentIds?: string[];
    allowMissingDependencies: boolean;
}

export class ContentFileUpdateRequest implements IContentFileUpdateRequest {
    fileTransferId?: string;

    constructor(data?: IContentFileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileTransferId = data["fileTransferId"];
        }
    }

    static fromJS(data: any): ContentFileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        return data; 
    }
}

export interface IContentFileUpdateRequest {
    fileTransferId?: string;
}

export class ContentMetadataUpdateRequest implements IContentMetadataUpdateRequest {
    /** An id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** The dynamic data structure matching the field schematics of the content schema (ContentSchemaId). */
    content?: DataDictionary;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds). */
    metadata?: DataDictionary;
    /** Options to modify the behavior for updating schemas. */
    layerSchemasUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas. */
    schemaFieldsUpdateOptions: UpdateOption;

    constructor(data?: IContentMetadataUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.content = data.content && !(<any>data.content).toJSON ? new DataDictionary(data.content) : <DataDictionary>this.content; 
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
        if (!data) {
            this.layerSchemaIds = [];
            this.content = new DataDictionary();
            this.metadata = new DataDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"] ? DataDictionary.fromJS(data["content"]) : new DataDictionary();
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : new DataDictionary();
            this.layerSchemasUpdateOptions = data["layerSchemasUpdateOptions"];
            this.schemaFieldsUpdateOptions = data["schemaFieldsUpdateOptions"];
        }
    }

    static fromJS(data: any): ContentMetadataUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["layerSchemasUpdateOptions"] = this.layerSchemasUpdateOptions;
        data["schemaFieldsUpdateOptions"] = this.schemaFieldsUpdateOptions;
        return data; 
    }
}

export interface IContentMetadataUpdateRequest {
    /** An id list of schemas with schema type layer. */
    layerSchemaIds?: string[];
    /** The dynamic data structure matching the field schematics of the content schema (ContentSchemaId). */
    content?: IDataDictionary;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds). */
    metadata?: IDataDictionary;
    /** Options to modify the behavior for updating schemas. */
    layerSchemasUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas. */
    schemaFieldsUpdateOptions: UpdateOption;
}

export enum UpdateOption {
    Merge = <any>"Merge", 
    Replace = <any>"Replace", 
}

export class ContentPermissionsUpdateRequest implements IContentPermissionsUpdateRequest {
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];

    constructor(data?: IContentPermissionsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentPermissionSetIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentPermissionsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IContentPermissionsUpdateRequest {
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
}

/** Update many contents metadata */
export class ContentMetadataUpdateManyRequest implements IContentMetadataUpdateManyRequest {
    /** Allow storing references to missing list items */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: ContentMetadataUpdateItem[];

    constructor(data?: IContentMetadataUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentMetadataUpdateItem(item) : <ContentMetadataUpdateItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContentMetadataUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentMetadataUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

/** Update many contents metadata */
export interface IContentMetadataUpdateManyRequest {
    /** Allow storing references to missing list items */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: IContentMetadataUpdateItem[];
}

export class ContentMetadataUpdateItem extends ContentMetadataUpdateRequest implements IContentMetadataUpdateItem {
    /** The content id. */
    id?: string;

    constructor(data?: IContentMetadataUpdateItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContentMetadataUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentMetadataUpdateItem extends IContentMetadataUpdateRequest {
    /** The content id. */
    id?: string;
}

export class ContentPermissionsUpdateManyRequest implements IContentPermissionsUpdateManyRequest {
    /** List of Content Permissions update items */
    items?: ContentPermissionsUpdateItem[];

    constructor(data?: IContentPermissionsUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentPermissionsUpdateItem(item) : <ContentPermissionsUpdateItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContentPermissionsUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentPermissionsUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContentPermissionsUpdateManyRequest {
    /** List of Content Permissions update items */
    items?: IContentPermissionsUpdateItem[];
}

export class ContentPermissionsUpdateItem extends ContentPermissionsUpdateRequest implements IContentPermissionsUpdateItem {
    /** The content id. */
    contentId?: string;

    constructor(data?: IContentPermissionsUpdateItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): ContentPermissionsUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentPermissionsUpdateItem extends IContentPermissionsUpdateRequest {
    /** The content id. */
    contentId?: string;
}

export class ContentOwnershipTransferRequest implements IContentOwnershipTransferRequest {
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string;

    constructor(data?: IContentOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferUserId = data["transferUserId"];
        }
    }

    static fromJS(data: any): ContentOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        return data; 
    }
}

export interface IContentOwnershipTransferRequest {
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string;
}

export class ContentOwnershipTransferManyRequest implements IContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer requests */
    items?: ContentOwnershipTransferItem[];

    constructor(data?: IContentOwnershipTransferManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentOwnershipTransferItem(item) : <ContentOwnershipTransferItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContentOwnershipTransferItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer requests */
    items?: IContentOwnershipTransferItem[];
}

export class ContentOwnershipTransferItem extends ContentOwnershipTransferRequest implements IContentOwnershipTransferItem {
    /** The content id. */
    contentId?: string;

    constructor(data?: IContentOwnershipTransferItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): ContentOwnershipTransferItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentOwnershipTransferItem extends IContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string;
}

export abstract class MetadataValuesChangeRequestBase implements IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.changeCommands = [];
        }
        this._discriminator = "MetadataValuesChangeRequestBase";
    }

    init(data?: any) {
        if (data) {
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
            this.notifyProgress = data["notifyProgress"];
        }
    }

    static fromJS(data: any): MetadataValuesChangeRequestBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ContentFieldsBatchUpdateRequest") {
            let result = new ContentFieldsBatchUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFieldsBatchUpdateFilterRequest") {
            let result = new ContentFieldsBatchUpdateFilterRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeRequestBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["notifyProgress"] = this.notifyProgress;
        return data; 
    }
}

export interface IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;
}

export class ContentFieldsBatchUpdateRequest extends MetadataValuesChangeRequestBase implements IContentFieldsBatchUpdateRequest {
    /** The ids of the content documents. */
    contentIds?: string[];

    constructor(data?: IContentFieldsBatchUpdateRequest) {
        super(data);
        if (!data) {
            this.contentIds = [];
        }
        this._discriminator = "ContentFieldsBatchUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentFieldsBatchUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFieldsBatchUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentFieldsBatchUpdateRequest extends IMetadataValuesChangeRequestBase {
    /** The ids of the content documents. */
    contentIds?: string[];
}

/** The base class for metadata value change commands. */
export abstract class MetadataValuesChangeCommandBase implements IMetadataValuesChangeCommandBase {
    /** The id of the schema to which the operation scope is addressed. */
    schemaId?: string;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeCommandBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeCommandBase";
    }

    init(data?: any) {
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataValuesChangeCommandBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "MetadataValuesSchemaUpdateCommand") {
            let result = new MetadataValuesSchemaUpdateCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaUpsertCommand") {
            let result = new MetadataValuesSchemaUpsertCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaRemoveCommand") {
            let result = new MetadataValuesSchemaRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaReplaceCommand") {
            let result = new MetadataValuesSchemaReplaceCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesFieldRemoveCommand") {
            let result = new MetadataValuesFieldRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemAddCommand") {
            let result = new MetadataValuesSchemaItemAddCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemRemoveCommand") {
            let result = new MetadataValuesSchemaItemRemoveCommand();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeCommandBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

/** The base class for metadata value change commands. */
export interface IMetadataValuesChangeCommandBase {
    /** The id of the schema to which the operation scope is addressed. */
    schemaId?: string;
}

/** Updates schema values. */
export class MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpdateCommand {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary;

    constructor(data?: IMetadataValuesSchemaUpdateCommand) {
        super(data);
        if (!data) {
            this.value = new DataDictionary();
        }
        this._discriminator = "MetadataValuesSchemaUpdateCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : new DataDictionary();
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Updates schema values. */
export interface IMetadataValuesSchemaUpdateCommand extends IMetadataValuesChangeCommandBase {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: IDataDictionary;
}

/** Adds or updates schema values. */
export class MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpsertCommand {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary;

    constructor(data?: IMetadataValuesSchemaUpsertCommand) {
        super(data);
        if (!data) {
            this.value = new DataDictionary();
        }
        this._discriminator = "MetadataValuesSchemaUpsertCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : new DataDictionary();
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Adds or updates schema values. */
export interface IMetadataValuesSchemaUpsertCommand extends IMetadataValuesChangeCommandBase {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: IDataDictionary;
}

/** Removes schema values. */
export class MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaRemoveCommand {

    constructor(data?: IMetadataValuesSchemaRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** Removes schema values. */
export interface IMetadataValuesSchemaRemoveCommand extends IMetadataValuesChangeCommandBase {
}

/** Replaces schema values. */
export class MetadataValuesSchemaReplaceCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaReplaceCommand {
    /** The metadata values containing the new values for the schema. All old values will be overwritten. */
    value?: DataDictionary;

    constructor(data?: IMetadataValuesSchemaReplaceCommand) {
        super(data);
        if (!data) {
            this.value = new DataDictionary();
        }
        this._discriminator = "MetadataValuesSchemaReplaceCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : new DataDictionary();
        }
    }

    static fromJS(data: any): MetadataValuesSchemaReplaceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaReplaceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Replaces schema values. */
export interface IMetadataValuesSchemaReplaceCommand extends IMetadataValuesChangeCommandBase {
    /** The metadata values containing the new values for the schema. All old values will be overwritten. */
    value?: IDataDictionary;
}

/** Removes a field and its value from the schema values. */
export class MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesFieldRemoveCommand {
    /** The path of the field to be removed (within tha data structure), e.g. "data.schemaId.fieldId" */
    fieldPath?: string;

    constructor(data?: IMetadataValuesFieldRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesFieldRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldPath = data["fieldPath"];
        }
    }

    static fromJS(data: any): MetadataValuesFieldRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesFieldRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a field and its value from the schema values. */
export interface IMetadataValuesFieldRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field to be removed (within tha data structure), e.g. "data.schemaId.fieldId" */
    fieldPath?: string;
}

/** Adds a list item id reference to a multi tagbox. */
export class MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemAddCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string;
    /** The field namespace */
    fieldNamespace?: string;
    /** The id of the list item to be added. */
    referenceId?: string;

    constructor(data?: IMetadataValuesSchemaItemAddCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemAddCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldPath = data["fieldPath"];
            this.fieldNamespace = data["fieldNamespace"];
            this.referenceId = data["referenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaItemAddCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Adds a list item id reference to a multi tagbox. */
export interface IMetadataValuesSchemaItemAddCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string;
    /** The field namespace */
    fieldNamespace?: string;
    /** The id of the list item to be added. */
    referenceId?: string;
}

/** Removes a list item id reference from a multi tagbox. */
export class MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemRemoveCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string;
    /** The field namespace */
    fieldNamespace?: string;
    /** The id of the list item to be removed. */
    referenceId?: string;

    constructor(data?: IMetadataValuesSchemaItemRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldPath = data["fieldPath"];
            this.fieldNamespace = data["fieldNamespace"];
            this.referenceId = data["referenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaItemRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a list item id reference from a multi tagbox. */
export interface IMetadataValuesSchemaItemRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string;
    /** The field namespace */
    fieldNamespace?: string;
    /** The id of the list item to be removed. */
    referenceId?: string;
}

export class ContentFieldsBatchUpdateFilterRequest extends MetadataValuesChangeRequestBase implements IContentFieldsBatchUpdateFilterRequest {
    filterRequest?: ContentFilterRequest;

    constructor(data?: IContentFieldsBatchUpdateFilterRequest) {
        super(data);
        if (!data) {
            this.filterRequest = new ContentFilterRequest();
        }
        this._discriminator = "ContentFieldsBatchUpdateFilterRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filterRequest = data["filterRequest"] ? ContentFilterRequest.fromJS(data["filterRequest"]) : new ContentFilterRequest();
        }
    }

    static fromJS(data: any): ContentFieldsBatchUpdateFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFieldsBatchUpdateFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterRequest"] = this.filterRequest ? this.filterRequest.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentFieldsBatchUpdateFilterRequest extends IMetadataValuesChangeRequestBase {
    filterRequest?: IContentFilterRequest;
}

export class ContentFilterRequest implements IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[];

    constructor(data?: IContentFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.searchLanguages = [];
            this.filter = new FilterBase();
            this.rightsFilter = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.channelId = data["channelId"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.searchString = data["searchString"];
            this.searchType = data["searchType"];
            this.collectionId = data["collectionId"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.lifeCycleFilter = data["lifeCycleFilter"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["rightsFilter"] && data["rightsFilter"].constructor === Array) {
                this.rightsFilter = [];
                for (let item of data["rightsFilter"])
                    this.rightsFilter.push(item);
            }
        }
    }

    static fromJS(data: any): ContentFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channelId"] = this.channelId;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["searchString"] = this.searchString;
        data["searchType"] = this.searchType;
        data["collectionId"] = this.collectionId;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.rightsFilter && this.rightsFilter.constructor === Array) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        return data; 
    }
}

export interface IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[];
}

export class PermissionSetSearchRequest implements IPermissionSetSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    rightFilter?: PermissionSetRight;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];

    constructor(data?: IPermissionSetSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.rightFilter = data["rightFilter"];
            this.debugMode = data["debugMode"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionSetSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["rightFilter"] = this.rightFilter;
        data["debugMode"] = this.debugMode;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data; 
    }
}

export interface IPermissionSetSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    rightFilter?: PermissionSetRight;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];
}

export enum PermissionSetRight {
    Apply = <any>"Apply", 
    Manage = <any>"Manage", 
}

export class BaseResultOfPermissionSet implements IBaseResultOfPermissionSet {
    totalResults: number;
    results: PermissionSet[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new PermissionSet(item) : <PermissionSet>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(PermissionSet.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfPermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfPermissionSet {
    totalResults: number;
    results: IPermissionSet[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfPermissionSet extends BaseResultOfPermissionSet implements ISearchBehaviourBaseResultOfPermissionSet {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfPermissionSet) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfPermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfPermissionSet extends IBaseResultOfPermissionSet {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class PermissionSetSearchResult extends SearchBehaviourBaseResultOfPermissionSet implements IPermissionSetSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IPermissionSetSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): PermissionSetSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionSetSearchResult extends ISearchBehaviourBaseResultOfPermissionSet {
    elapsedMilliseconds: number;
}

export class PermissionSet implements IPermissionSet {
    /** The permission set id. */
    id?: string;
    /** When true this permission set will derogate all other configured permission sets. */
    exclusive: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary;

    constructor(data?: IPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.exclusive = data["exclusive"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
        }
    }

    static fromJS(data: any): PermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exclusive"] = this.exclusive;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPermissionSet {
    /** The permission set id. */
    id?: string;
    /** When true this permission set will derogate all other configured permission sets. */
    exclusive: boolean;
    /** Language specific permission set names. */
    names?: ITranslatedStringDictionary;
}

export abstract class PermissionSetDetailOfContentRight implements IPermissionSetDetailOfContentRight {
    id?: string;
    names?: TranslatedStringDictionary;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[];
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[];
    exclusive: boolean;
    ownerTokenId?: string;

    constructor(data?: IPermissionSetDetailOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfContentRight(item) : <PermissionUserRoleRightsOfContentRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfPermissionSetRight(item) : <PermissionUserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRolesRights = [];
            this.userRolesPermissionSetRights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.trashed = data["trashed"];
            if (data["userRolesRights"] && data["userRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["userRolesRights"])
                    this.userRolesRights.push(PermissionUserRoleRightsOfContentRight.fromJS(item));
            }
            if (data["userRolesPermissionSetRights"] && data["userRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["exclusive"];
            this.ownerTokenId = data["ownerTokenId"];
        }
    }

    static fromJS(data: any): PermissionSetDetailOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetDetailOfContentRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        data["ownerTokenId"] = this.ownerTokenId;
        return data; 
    }
}

export interface IPermissionSetDetailOfContentRight {
    id?: string;
    names?: ITranslatedStringDictionary;
    trashed: boolean;
    userRolesRights?: IPermissionUserRoleRightsOfContentRight[];
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[];
    exclusive: boolean;
    ownerTokenId?: string;
}

export class ContentPermissionSetDetail extends PermissionSetDetailOfContentRight implements IContentPermissionSetDetail {

    constructor(data?: IContentPermissionSetDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ContentPermissionSetDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IContentPermissionSetDetail extends IPermissionSetDetailOfContentRight {
}

export class PermissionUserRoleRightsOfContentRight implements IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string;
    names?: TranslatedStringDictionary;
    rights?: ContentRight[];

    constructor(data?: IPermissionUserRoleRightsOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.rights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfContentRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string;
    names?: ITranslatedStringDictionary;
    rights?: ContentRight[];
}

export class PermissionUserRoleRightsOfPermissionSetRight implements IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string;
    names?: TranslatedStringDictionary;
    rights?: PermissionSetRight[];

    constructor(data?: IPermissionUserRoleRightsOfPermissionSetRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.rights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfPermissionSetRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string;
    names?: ITranslatedStringDictionary;
    rights?: PermissionSetRight[];
}

export class DocumentHistorySearchRequest implements IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. Default to last 1 year. */
    from: Date;
    /** Limits the end date of the search request. Default to now. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string;
    /** Limits the search to a specific document id. E.g. ContentId */
    documentId?: string;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specifc document type. */
    documentType?: string;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo;

    constructor(data?: IDocumentHistorySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.sort = data.sort && !(<any>data.sort).toJSON ? new SortInfo(data.sort) : <SortInfo>this.sort; 
        }
        if (!data) {
            this.sort = new SortInfo();
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.limit = data["limit"];
            this.pageToken = data["pageToken"];
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
            this.documentType = data["documentType"];
            this.sort = data["sort"] ? SortInfo.fromJS(data["sort"]) : new SortInfo();
        }
    }

    static fromJS(data: any): DocumentHistorySearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistorySearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. Default to last 1 year. */
    from: Date;
    /** Limits the end date of the search request. Default to now. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string;
    /** Limits the search to a specific document id. E.g. ContentId */
    documentId?: string;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specifc document type. */
    documentType?: string;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo;
}

export class DocumentHistorySearchResult implements IDocumentHistorySearchResult {
    totalResults: number;
    results?: DocumentHistory[];
    pageToken?: string;
    elapsedMilliseconds: number;

    constructor(data?: IDocumentHistorySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new DocumentHistory(item) : <DocumentHistory>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(DocumentHistory.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): DocumentHistorySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistorySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        return data; 
    }
}

export interface IDocumentHistorySearchResult {
    totalResults: number;
    results?: IDocumentHistory[];
    pageToken?: string;
    elapsedMilliseconds: number;
}

export class DocumentHistory implements IDocumentHistory {
    id?: string;
    documentId?: string;
    documentVersion: number;
    documentType?: string;
    documentTypeContract?: string;
    documentDate: Date;
    document?: string;
    timestamp: Date;
    audit?: UserAuditHistory;
    deleted: boolean;
    action: DocumentChangeAction;

    constructor(data?: IDocumentHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditHistory(data.audit) : <UserAuditHistory>this.audit; 
        }
        if (!data) {
            this.audit = new UserAuditHistory();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
            this.documentType = data["documentType"];
            this.documentTypeContract = data["documentTypeContract"];
            this.documentDate = data["documentDate"] ? new Date(data["documentDate"].toString()) : <any>undefined;
            this.document = data["document"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.audit = data["audit"] ? UserAuditHistory.fromJS(data["audit"]) : new UserAuditHistory();
            this.deleted = data["deleted"];
            this.action = data["action"];
        }
    }

    static fromJS(data: any): DocumentHistory {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        data["documentTypeContract"] = this.documentTypeContract;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["document"] = this.document;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["action"] = this.action;
        return data; 
    }
}

export interface IDocumentHistory {
    id?: string;
    documentId?: string;
    documentVersion: number;
    documentType?: string;
    documentTypeContract?: string;
    documentDate: Date;
    document?: string;
    timestamp: Date;
    audit?: IUserAuditHistory;
    deleted: boolean;
    action: DocumentChangeAction;
}

export class UserAuditHistory implements IUserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string;

    constructor(data?: IUserAuditHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = data["modifiedByUser"];
        }
    }

    static fromJS(data: any): UserAuditHistory {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuditHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["modifiedByUser"] = this.modifiedByUser;
        return data; 
    }
}

export interface IUserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string;
}

export enum DocumentChangeAction {
    Create = <any>"Create", 
    Update = <any>"Update", 
    Delete = <any>"Delete", 
    Activate = <any>"Activate", 
    Deactivate = <any>"Deactivate", 
}

export class DocumentHistoryDifference implements IDocumentHistoryDifference {
    documentId?: string;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any;
    newValues?: any;

    constructor(data?: IDocumentHistoryDifference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.oldDocumentVersion = data["oldDocumentVersion"];
            this.newDocumentVersion = data["newDocumentVersion"];
            this.oldValues = data["oldValues"];
            this.newValues = data["newValues"];
        }
    }

    static fromJS(data: any): DocumentHistoryDifference {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistoryDifference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["oldDocumentVersion"] = this.oldDocumentVersion;
        data["newDocumentVersion"] = this.newDocumentVersion;
        data["oldValues"] = this.oldValues;
        data["newValues"] = this.newValues;
        return data; 
    }
}

export interface IDocumentHistoryDifference {
    documentId?: string;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any;
    newValues?: any;
}

export class CustomerInfo implements ICustomerInfo {
    customerId?: string;
    name?: string;
    customerAlias?: string;
    identityServerUrl?: string;
    enableQueryDetails: boolean;
    languageConfiguration?: LanguageConfiguration;
    languages?: Language[];
    outputFormats?: OutputFormatInfo[];

    constructor(data?: ICustomerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.languageConfiguration = data.languageConfiguration && !(<any>data.languageConfiguration).toJSON ? new LanguageConfiguration(data.languageConfiguration) : <LanguageConfiguration>this.languageConfiguration; 
            if (data.languages) {
                this.languages = [];
                for (let i = 0; i < data.languages.length; i++) {
                    let item = data.languages[i];
                    this.languages[i] = item && !(<any>item).toJSON ? new Language(item) : <Language>item;
                }
            }
            if (data.outputFormats) {
                this.outputFormats = [];
                for (let i = 0; i < data.outputFormats.length; i++) {
                    let item = data.outputFormats[i];
                    this.outputFormats[i] = item && !(<any>item).toJSON ? new OutputFormatInfo(item) : <OutputFormatInfo>item;
                }
            }
        }
        if (!data) {
            this.languageConfiguration = new LanguageConfiguration();
            this.languages = [];
            this.outputFormats = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.name = data["name"];
            this.customerAlias = data["customerAlias"];
            this.identityServerUrl = data["identityServerUrl"];
            this.enableQueryDetails = data["enableQueryDetails"];
            this.languageConfiguration = data["languageConfiguration"] ? LanguageConfiguration.fromJS(data["languageConfiguration"]) : new LanguageConfiguration();
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(Language.fromJS(item));
            }
            if (data["outputFormats"] && data["outputFormats"].constructor === Array) {
                this.outputFormats = [];
                for (let item of data["outputFormats"])
                    this.outputFormats.push(OutputFormatInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["name"] = this.name;
        data["customerAlias"] = this.customerAlias;
        data["identityServerUrl"] = this.identityServerUrl;
        data["enableQueryDetails"] = this.enableQueryDetails;
        data["languageConfiguration"] = this.languageConfiguration ? this.languageConfiguration.toJSON() : <any>undefined;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (this.outputFormats && this.outputFormats.constructor === Array) {
            data["outputFormats"] = [];
            for (let item of this.outputFormats)
                data["outputFormats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerInfo {
    customerId?: string;
    name?: string;
    customerAlias?: string;
    identityServerUrl?: string;
    enableQueryDetails: boolean;
    languageConfiguration?: ILanguageConfiguration;
    languages?: ILanguage[];
    outputFormats?: IOutputFormatInfo[];
}

export class LanguageConfiguration implements ILanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages?: string[];
    /** A list of languages serving as metadata languages. */
    metadataLanguages?: string[];
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage?: string;

    constructor(data?: ILanguageConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.systemLanguages = [];
            this.metadataLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["systemLanguages"] && data["systemLanguages"].constructor === Array) {
                this.systemLanguages = [];
                for (let item of data["systemLanguages"])
                    this.systemLanguages.push(item);
            }
            if (data["metadataLanguages"] && data["metadataLanguages"].constructor === Array) {
                this.metadataLanguages = [];
                for (let item of data["metadataLanguages"])
                    this.metadataLanguages.push(item);
            }
            this.defaultLanguage = data["defaultLanguage"];
        }
    }

    static fromJS(data: any): LanguageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.systemLanguages && this.systemLanguages.constructor === Array) {
            data["systemLanguages"] = [];
            for (let item of this.systemLanguages)
                data["systemLanguages"].push(item);
        }
        if (this.metadataLanguages && this.metadataLanguages.constructor === Array) {
            data["metadataLanguages"] = [];
            for (let item of this.metadataLanguages)
                data["metadataLanguages"].push(item);
        }
        data["defaultLanguage"] = this.defaultLanguage;
        return data; 
    }
}

export interface ILanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages?: string[];
    /** A list of languages serving as metadata languages. */
    metadataLanguages?: string[];
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage?: string;
}

export class Language implements ILanguage {
    name?: TranslatedStringDictionary;
    ietf?: string;
    twoLetterISOLanguageName?: string;
    threeLetterISOLanguageName?: string;
    regionCode?: string;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.name = data.name && !(<any>data.name).toJSON ? new TranslatedStringDictionary(data.name) : <TranslatedStringDictionary>this.name; 
        }
        if (!data) {
            this.name = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] ? TranslatedStringDictionary.fromJS(data["name"]) : new TranslatedStringDictionary();
            this.ietf = data["ietf"];
            this.twoLetterISOLanguageName = data["twoLetterISOLanguageName"];
            this.threeLetterISOLanguageName = data["threeLetterISOLanguageName"];
            this.regionCode = data["regionCode"];
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["ietf"] = this.ietf;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["threeLetterISOLanguageName"] = this.threeLetterISOLanguageName;
        data["regionCode"] = this.regionCode;
        return data; 
    }
}

export interface ILanguage {
    name?: ITranslatedStringDictionary;
    ietf?: string;
    twoLetterISOLanguageName?: string;
    threeLetterISOLanguageName?: string;
    regionCode?: string;
}

export class OutputFormatInfo implements IOutputFormatInfo {
    id?: string;
    names?: TranslatedStringDictionary;

    constructor(data?: IOutputFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
        }
    }

    static fromJS(data: any): OutputFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOutputFormatInfo {
    id?: string;
    names?: ITranslatedStringDictionary;
}

export enum ListItemResolveBehaviour {
    Content = <any>"Content", 
    LinkedListItems = <any>"LinkedListItems", 
    InnerDisplayValueThumbnail = <any>"InnerDisplayValueThumbnail", 
    InnerDisplayValueList = <any>"InnerDisplayValueList", 
    InnerDisplayValueDetail = <any>"InnerDisplayValueDetail", 
    InnerDisplayValueName = <any>"InnerDisplayValueName", 
}

/** The detail view item for the list item. */
export class ListItemDetail implements IListItemDetail {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary;
    /** The list item id. */
    id?: string;

    constructor(data?: IListItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
        }
        if (!data) {
            this.displayValues = new DisplayValueDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : new DisplayValueDictionary();
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

/** The detail view item for the list item. */
export interface IListItemDetail {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary;
    /** The list item id. */
    id?: string;
}

export class ListItemSearchRequest implements IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[];
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[];
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Define the display values included in the search response for the referenced fields. Defaults to no display value. */
    referencedFieldsDisplayPatternIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** When set to true the content data is included in the result items. */
    includeContentData: boolean;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IListItemSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.schemaIds = [];
            this.displayPatternIds = [];
            this.referencedFieldsDisplayPatternIds = [];
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["referencedFieldsDisplayPatternIds"] && data["referencedFieldsDisplayPatternIds"].constructor === Array) {
                this.referencedFieldsDisplayPatternIds = [];
                for (let item of data["referencedFieldsDisplayPatternIds"])
                    this.referencedFieldsDisplayPatternIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.includeContentData = data["includeContentData"];
            this.debugMode = data["debugMode"];
            this.lifeCycleFilter = data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): ListItemSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.referencedFieldsDisplayPatternIds && this.referencedFieldsDisplayPatternIds.constructor === Array) {
            data["referencedFieldsDisplayPatternIds"] = [];
            for (let item of this.referencedFieldsDisplayPatternIds)
                data["referencedFieldsDisplayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["includeContentData"] = this.includeContentData;
        data["debugMode"] = this.debugMode;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[];
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[];
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Define the display values included in the search response for the referenced fields. Defaults to no display value. */
    referencedFieldsDisplayPatternIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** When set to true the content data is included in the result items. */
    includeContentData: boolean;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

export class BaseResultOfListItem implements IBaseResultOfListItem {
    totalResults: number;
    results: ListItem[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ListItem(item) : <ListItem>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(ListItem.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfListItem {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfListItem {
    totalResults: number;
    results: IListItem[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

/** Encapsulates the result of a list item search. */
export class ListItemSearchResult extends BaseResultOfListItem implements IListItemSearchResult {

    constructor(data?: IListItemSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** Encapsulates the result of a list item search. */
export interface IListItemSearchResult extends IBaseResultOfListItem {
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export class ListItem implements IListItem {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary;
    /** The list item id. */
    id?: string;

    constructor(data?: IListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
        }
        if (!data) {
            this.displayValues = new DisplayValueDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : new DisplayValueDictionary();
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export interface IListItem {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary;
    /** The list item id. */
    id?: string;
}

export class ListItemAggregationRequest implements IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[];
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[];
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Filter the list items document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IListItemAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.filter = new FilterBase();
            this.aggregationFilters = [];
            this.aggregators = [];
            this.schemaIds = [];
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.lifeCycleFilter = data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): ListItemAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[];
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[];
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Filter the list items document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** A request structure for creating a list item document. */
export class ListItemCreateRequest implements IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string;

    constructor(data?: IListItemCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.listItemId = data["listItemId"];
        }
    }

    static fromJS(data: any): ListItemCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["listItemId"] = this.listItemId;
        return data; 
    }
}

/** A request structure for creating a list item document. */
export interface IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string;
}

/** A request structure for creating multiple list items. */
export class ListItemCreateManyRequest implements IListItemCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: ListItemCreateRequest[];

    constructor(data?: IListItemCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ListItemCreateRequest(item) : <ListItemCreateRequest>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ListItemCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

/** A request structure for creating multiple list items. */
export interface IListItemCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: IListItemCreateRequest[];
}

/** A request structure for updating a list item. */
export class ListItemUpdateRequest implements IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any;

    constructor(data?: IListItemUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): ListItemUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

/** A request structure for updating a list item. */
export interface IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any;
}

/** A request structure for updating multiple list items. */
export class ListItemUpdateManyRequest implements IListItemUpdateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: ListItemUpdateItem[];

    constructor(data?: IListItemUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ListItemUpdateItem(item) : <ListItemUpdateItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ListItemUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

/** A request structure for updating multiple list items. */
export interface IListItemUpdateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: IListItemUpdateItem[];
}

export class ListItemUpdateItem extends ListItemUpdateRequest implements IListItemUpdateItem {
    /** The list item id. */
    id?: string;

    constructor(data?: IListItemUpdateItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItemUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemUpdateItem extends IListItemUpdateRequest {
    /** The list item id. */
    id?: string;
}

export class ListItemDeleteManyRequest implements IListItemDeleteManyRequest {
    listItemIds?: string[];
    forceReferenceRemoval: boolean;

    constructor(data?: IListItemDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.listItemIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
            this.forceReferenceRemoval = data["forceReferenceRemoval"];
        }
    }

    static fromJS(data: any): ListItemDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        return data; 
    }
}

export interface IListItemDeleteManyRequest {
    listItemIds?: string[];
    forceReferenceRemoval: boolean;
}

export class ListItemRestoreManyRequest implements IListItemRestoreManyRequest {
    listItemIds?: string[];
    allowMissingDependencies: boolean;

    constructor(data?: IListItemRestoreManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.listItemIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ListItemRestoreManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemRestoreManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

export interface IListItemRestoreManyRequest {
    listItemIds?: string[];
    allowMissingDependencies: boolean;
}

export class ListItemFieldsBatchUpdateRequest implements IListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated */
    listItemIds?: string[];
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;

    constructor(data?: IListItemFieldsBatchUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.listItemIds = [];
            this.changeCommands = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
            this.notifyProgress = data["notifyProgress"];
        }
    }

    static fromJS(data: any): ListItemFieldsBatchUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFieldsBatchUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["notifyProgress"] = this.notifyProgress;
        return data; 
    }
}

export interface IListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated */
    listItemIds?: string[];
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;
}

/** ListItemFieldsFilterUpdateRequest class */
export class ListItemFieldsBatchUpdateFilterRequest implements IListItemFieldsBatchUpdateFilterRequest {
    /** The search request used to filter the list items on which the change commands must be applied */
    filterRequest?: ListItemFilterRequest;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;

    constructor(data?: IListItemFieldsBatchUpdateFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.filterRequest = data.filterRequest && !(<any>data.filterRequest).toJSON ? new ListItemFilterRequest(data.filterRequest) : <ListItemFilterRequest>this.filterRequest; 
        }
        if (!data) {
            this.filterRequest = new ListItemFilterRequest();
            this.changeCommands = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.filterRequest = data["filterRequest"] ? ListItemFilterRequest.fromJS(data["filterRequest"]) : new ListItemFilterRequest();
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
            this.notifyProgress = data["notifyProgress"];
        }
    }

    static fromJS(data: any): ListItemFieldsBatchUpdateFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFieldsBatchUpdateFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterRequest"] = this.filterRequest ? this.filterRequest.toJSON() : <any>undefined;
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["notifyProgress"] = this.notifyProgress;
        return data; 
    }
}

/** ListItemFieldsFilterUpdateRequest class */
export interface IListItemFieldsBatchUpdateFilterRequest {
    /** The search request used to filter the list items on which the change commands must be applied */
    filterRequest?: IListItemFilterRequest;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[];
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create notification and notify on progress */
    notifyProgress: boolean;
}

export class ListItemFilterRequest implements IListItemFilterRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;

    constructor(data?: IListItemFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.filter = new FilterBase();
            this.schemaIds = [];
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
        }
    }

    static fromJS(data: any): ListItemFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        return data; 
    }
}

export interface IListItemFilterRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[];
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[];
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
}

export class ListItemReferences extends ReferencesBase implements IListItemReferences {

    constructor(data?: IListItemReferences) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListItemReferences {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemReferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemReferences extends IReferencesBase {
}

export class LiveStreamSearchRequest implements ILiveStreamSearchRequest {
    /** Limits the start date of the search request. */
    from: Date;
    /** Limits the end date of the search request. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string;

    constructor(data?: ILiveStreamSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.limit = data["limit"];
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): LiveStreamSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface ILiveStreamSearchRequest {
    /** Limits the start date of the search request. */
    from: Date;
    /** Limits the end date of the search request. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string;
}

export class BaseResultOfObject implements IBaseResultOfObject {
    totalResults: number;
    results: any[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(item);
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfObject {
    totalResults: number;
    results: any[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfObject extends BaseResultOfObject implements ISearchBehaviourBaseResultOfObject {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfObject) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfObject extends IBaseResultOfObject {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class ObjectSearchResult extends SearchBehaviourBaseResultOfObject implements IObjectSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IObjectSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ObjectSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectSearchResult extends ISearchBehaviourBaseResultOfObject {
    elapsedMilliseconds: number;
}

export class OutputSearchRequest implements IOutputSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[];
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[];
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[];
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[];

    constructor(data?: IOutputSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentIds = [];
            this.renderingStates = [];
            this.fileExtensions = [];
            this.outputFormatIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.start = data["start"];
            this.limit = data["limit"];
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            if (data["renderingStates"] && data["renderingStates"].constructor === Array) {
                this.renderingStates = [];
                for (let item of data["renderingStates"])
                    this.renderingStates.push(item);
            }
            if (data["fileExtensions"] && data["fileExtensions"].constructor === Array) {
                this.fileExtensions = [];
                for (let item of data["fileExtensions"])
                    this.fileExtensions.push(item);
            }
            if (data["outputFormatIds"] && data["outputFormatIds"].constructor === Array) {
                this.outputFormatIds = [];
                for (let item of data["outputFormatIds"])
                    this.outputFormatIds.push(item);
            }
        }
    }

    static fromJS(data: any): OutputSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["limit"] = this.limit;
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        if (this.renderingStates && this.renderingStates.constructor === Array) {
            data["renderingStates"] = [];
            for (let item of this.renderingStates)
                data["renderingStates"].push(item);
        }
        if (this.fileExtensions && this.fileExtensions.constructor === Array) {
            data["fileExtensions"] = [];
            for (let item of this.fileExtensions)
                data["fileExtensions"].push(item);
        }
        if (this.outputFormatIds && this.outputFormatIds.constructor === Array) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        return data; 
    }
}

export interface IOutputSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[];
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[];
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[];
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[];
}

export class BaseResultOfOutput implements IBaseResultOfOutput {
    totalResults: number;
    results: Output[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Output.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfOutput {
    totalResults: number;
    results: Output[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class OutputSearchResult extends BaseResultOfOutput implements IOutputSearchResult {

    constructor(data?: IOutputSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OutputSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputSearchResult extends IBaseResultOfOutput {
}

export class UserProfile implements IUserProfile {
    id?: string;
    emailAddress?: string;
    firstName?: string;
    lastName?: string;
    languageCode?: string;
    address?: UserAddress;
    authorizationState: AuthorizationState;
    userRights?: UserRight[];
    userRoleIds?: string[];
    termsConsentExpired: boolean;
    systemUserRoles?: SystemUserRole[];
    isDeveloper: boolean;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address; 
        }
        if (!data) {
            this.address = new UserAddress();
            this.userRights = [];
            this.userRoleIds = [];
            this.systemUserRoles = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.languageCode = data["languageCode"];
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : new UserAddress();
            this.authorizationState = data["authorizationState"];
            if (data["userRights"] && data["userRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["userRights"])
                    this.userRights.push(item);
            }
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
            this.termsConsentExpired = data["termsConsentExpired"];
            if (data["systemUserRoles"] && data["systemUserRoles"].constructor === Array) {
                this.systemUserRoles = [];
                for (let item of data["systemUserRoles"])
                    this.systemUserRoles.push(item);
            }
            this.isDeveloper = data["isDeveloper"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["authorizationState"] = this.authorizationState;
        if (this.userRights && this.userRights.constructor === Array) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["termsConsentExpired"] = this.termsConsentExpired;
        if (this.systemUserRoles && this.systemUserRoles.constructor === Array) {
            data["systemUserRoles"] = [];
            for (let item of this.systemUserRoles)
                data["systemUserRoles"].push(item);
        }
        data["isDeveloper"] = this.isDeveloper;
        return data; 
    }
}

export interface IUserProfile {
    id?: string;
    emailAddress?: string;
    firstName?: string;
    lastName?: string;
    languageCode?: string;
    address?: IUserAddress;
    authorizationState: AuthorizationState;
    userRights?: UserRight[];
    userRoleIds?: string[];
    termsConsentExpired: boolean;
    systemUserRoles?: SystemUserRole[];
    isDeveloper: boolean;
}

export class UserAddress implements IUserAddress {
    company?: string;
    address?: string;
    alternativeAddress?: string;
    department?: string;
    zip?: string;
    city?: string;
    phone?: string;
    countryCode?: string;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.address = data["address"];
            this.alternativeAddress = data["alternativeAddress"];
            this.department = data["department"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.phone = data["phone"];
            this.countryCode = data["countryCode"];
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["address"] = this.address;
        data["alternativeAddress"] = this.alternativeAddress;
        data["department"] = this.department;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["phone"] = this.phone;
        data["countryCode"] = this.countryCode;
        return data; 
    }
}

export interface IUserAddress {
    company?: string;
    address?: string;
    alternativeAddress?: string;
    department?: string;
    zip?: string;
    city?: string;
    phone?: string;
    countryCode?: string;
}

export enum AuthorizationState {
    Reviewed = <any>"Reviewed", 
    ToBeReviewed = <any>"ToBeReviewed", 
    Locked = <any>"Locked", 
    Invited = <any>"Invited", 
}

export enum SystemUserRole {
    Administrator = <any>"Administrator", 
}

export class UserProfileUpdateRequest implements IUserProfileUpdateRequest {
    id?: string;
    emailAddress?: string;
    firstName?: string;
    lastName?: string;
    languageCode?: string;
    address?: UserAddress;

    constructor(data?: IUserProfileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address; 
        }
        if (!data) {
            this.address = new UserAddress();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.languageCode = data["languageCode"];
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : new UserAddress();
        }
    }

    static fromJS(data: any): UserProfileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserProfileUpdateRequest {
    id?: string;
    emailAddress?: string;
    firstName?: string;
    lastName?: string;
    languageCode?: string;
    address?: IUserAddress;
}

/** The version view item for the environment. */
export class VersionInfo implements IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string;

    constructor(data?: IVersionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileVersion = data["fileVersion"];
            this.fileProductVersion = data["fileProductVersion"];
            this.contractVersion = data["contractVersion"];
            this.release = data["release"];
        }
    }

    static fromJS(data: any): VersionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VersionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileVersion"] = this.fileVersion;
        data["fileProductVersion"] = this.fileProductVersion;
        data["contractVersion"] = this.contractVersion;
        data["release"] = this.release;
        return data; 
    }
}

/** The version view item for the environment. */
export interface IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string;
}

export class ShareDetail implements IShareDetail {
    id?: string;
    name?: string;
    description?: string;
    creator?: ShareUser;
    audit?: UserAudit;
    contentSelections?: ShareContentDetail[];
    layerSchemaIds?: string[];
    data?: ShareDataBase;
    mailTemplateId?: string;
    expirationDate?: Date;
    expired: boolean;
    template?: TemplateBase;
    outputAccess: OutputAccess;
    shareType: ShareType;

    constructor(data?: IShareDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.creator = data.creator && !(<any>data.creator).toJSON ? new ShareUser(data.creator) : <ShareUser>this.creator; 
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            if (data.contentSelections) {
                this.contentSelections = [];
                for (let i = 0; i < data.contentSelections.length; i++) {
                    let item = data.contentSelections[i];
                    this.contentSelections[i] = item && !(<any>item).toJSON ? new ShareContentDetail(item) : <ShareContentDetail>item;
                }
            }
        }
        if (!data) {
            this.creator = new ShareUser();
            this.audit = new UserAudit();
            this.contentSelections = [];
            this.layerSchemaIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.creator = data["creator"] ? ShareUser.fromJS(data["creator"]) : new ShareUser();
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            if (data["contentSelections"] && data["contentSelections"].constructor === Array) {
                this.contentSelections = [];
                for (let item of data["contentSelections"])
                    this.contentSelections.push(ShareContentDetail.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.data = data["data"] ? ShareDataBase.fromJS(data["data"]) : <any>undefined;
            this.mailTemplateId = data["mailTemplateId"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.expired = data["expired"];
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
            this.shareType = data["shareType"];
        }
    }

    static fromJS(data: any): ShareDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        if (this.contentSelections && this.contentSelections.constructor === Array) {
            data["contentSelections"] = [];
            for (let item of this.contentSelections)
                data["contentSelections"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["mailTemplateId"] = this.mailTemplateId;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["expired"] = this.expired;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        data["shareType"] = this.shareType;
        return data; 
    }
}

export interface IShareDetail {
    id?: string;
    name?: string;
    description?: string;
    creator?: IShareUser;
    audit?: IUserAudit;
    contentSelections?: IShareContentDetail[];
    layerSchemaIds?: string[];
    data?: ShareDataBase;
    mailTemplateId?: string;
    expirationDate?: Date;
    expired: boolean;
    template?: TemplateBase;
    outputAccess: OutputAccess;
    shareType: ShareType;
}

/** Reduced set of user information used for shares */
export class ShareUser implements IShareUser {
    /** Name of user */
    displayName?: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash?: string;

    constructor(data?: IShareUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.emailHash = data["emailHash"];
        }
    }

    static fromJS(data: any): ShareUser {
        data = typeof data === 'object' ? data : {};
        let result = new ShareUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["emailHash"] = this.emailHash;
        return data; 
    }
}

/** Reduced set of user information used for shares */
export interface IShareUser {
    /** Name of user */
    displayName?: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash?: string;
}

export class ShareContentDetail implements IShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    content?: DataDictionary;
    metadata?: DataDictionary;
    id?: string;
    outputs?: ShareOutputBase[];
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary;

    constructor(data?: IShareContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.content = data.content && !(<any>data.content).toJSON ? new DataDictionary(data.content) : <DataDictionary>this.content; 
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
        }
        if (!data) {
            this.layerSchemaIds = [];
            this.content = new DataDictionary();
            this.metadata = new DataDictionary();
            this.outputs = [];
            this.displayValues = new DisplayValueDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"] ? DataDictionary.fromJS(data["content"]) : new DataDictionary();
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : new DataDictionary();
            this.id = data["id"];
            if (data["outputs"] && data["outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["outputs"])
                    this.outputs.push(ShareOutputBase.fromJS(item));
            }
            this.contentType = data["contentType"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : new DisplayValueDictionary();
        }
    }

    static fromJS(data: any): ShareContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.outputs && this.outputs.constructor === Array) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId?: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    content?: IDataDictionary;
    metadata?: IDataDictionary;
    id?: string;
    outputs?: ShareOutputBase[];
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary;
}

export abstract class ShareOutputBase implements IShareOutputBase {
    contentId?: string;
    outputFormatId?: string;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    url?: string;
    detail?: OutputDataBase;

    protected _discriminator: string;

    constructor(data?: IShareOutputBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareOutputBase";
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
            this.url = data["url"];
            this.detail = data["detail"] ? OutputDataBase.fromJS(data["detail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShareOutputBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareOutputBasic") {
            let result = new ShareOutputBasic();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputEmbed") {
            let result = new ShareOutputEmbed();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareOutputBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["url"] = this.url;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShareOutputBase {
    contentId?: string;
    outputFormatId?: string;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    url?: string;
    detail?: OutputDataBase;
}

export class ShareOutputBasic extends ShareOutputBase implements IShareOutputBasic {

    constructor(data?: IShareOutputBasic) {
        super(data);
        this._discriminator = "ShareOutputBasic";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareOutputBasic {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputBasic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareOutputBasic extends IShareOutputBase {
}

export class ShareOutputEmbed extends ShareOutputBase implements IShareOutputEmbed {
    token?: string;

    constructor(data?: IShareOutputEmbed) {
        super(data);
        this._discriminator = "ShareOutputEmbed";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ShareOutputEmbed {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputEmbed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareOutputEmbed extends IShareOutputBase {
    token?: string;
}

export abstract class ShareDataBase implements IShareDataBase {
    url?: string;

    protected _discriminator: string;

    constructor(data?: IShareDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareDataBase";
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ShareDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareDataEmbed") {
            let result = new ShareDataEmbed();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareDataBasic") {
            let result = new ShareDataBasic();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["url"] = this.url;
        return data; 
    }
}

export interface IShareDataBase {
    url?: string;
}

export class ShareDataEmbed extends ShareDataBase implements IShareDataEmbed {
    token?: string;

    constructor(data?: IShareDataEmbed) {
        super(data);
        this._discriminator = "ShareDataEmbed";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ShareDataEmbed {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDataEmbed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareDataEmbed extends IShareDataBase {
    token?: string;
}

export class ShareDataBasic extends ShareDataBase implements IShareDataBasic {
    mailRecipients?: MailRecipient[];
    internalRecipients?: InternalRecipient[];
    languageCode?: string;

    constructor(data?: IShareDataBasic) {
        super(data);
        if (!data) {
            this.mailRecipients = [];
            this.internalRecipients = [];
        }
        this._discriminator = "ShareDataBasic";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["mailRecipients"] && data["mailRecipients"].constructor === Array) {
                this.mailRecipients = [];
                for (let item of data["mailRecipients"])
                    this.mailRecipients.push(MailRecipient.fromJS(item));
            }
            if (data["internalRecipients"] && data["internalRecipients"].constructor === Array) {
                this.internalRecipients = [];
                for (let item of data["internalRecipients"])
                    this.internalRecipients.push(InternalRecipient.fromJS(item));
            }
            this.languageCode = data["languageCode"];
        }
    }

    static fromJS(data: any): ShareDataBasic {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDataBasic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.mailRecipients && this.mailRecipients.constructor === Array) {
            data["mailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["mailRecipients"].push(item.toJSON());
        }
        if (this.internalRecipients && this.internalRecipients.constructor === Array) {
            data["internalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["internalRecipients"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareDataBasic extends IShareDataBase {
    mailRecipients?: IMailRecipient[];
    internalRecipients?: IInternalRecipient[];
    languageCode?: string;
}

export class MailRecipient implements IMailRecipient {
    userEmail?: UserEmail;
    token?: string;
    url?: string;

    constructor(data?: IMailRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.userEmail = data.userEmail && !(<any>data.userEmail).toJSON ? new UserEmail(data.userEmail) : <UserEmail>this.userEmail; 
        }
        if (!data) {
            this.userEmail = new UserEmail();
        }
    }

    init(data?: any) {
        if (data) {
            this.userEmail = data["userEmail"] ? UserEmail.fromJS(data["userEmail"]) : new UserEmail();
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MailRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new MailRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail ? this.userEmail.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMailRecipient {
    userEmail?: IUserEmail;
    token?: string;
    url?: string;
}

export class UserEmail implements IUserEmail {
    firstName?: string;
    lastName?: string;
    emailAddress?: string;

    constructor(data?: IUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UserEmail {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserEmail {
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
}

export class InternalRecipient implements IInternalRecipient {
    recipient?: User;
    token?: string;
    url?: string;

    constructor(data?: IInternalRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.recipient = data.recipient && !(<any>data.recipient).toJSON ? new User(data.recipient) : <User>this.recipient; 
        }
        if (!data) {
            this.recipient = new User();
        }
    }

    init(data?: any) {
        if (data) {
            this.recipient = data["recipient"] ? User.fromJS(data["recipient"]) : new User();
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): InternalRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new InternalRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IInternalRecipient {
    recipient?: IUser;
    token?: string;
    url?: string;
}

export class User implements IUser {
    id?: string;
    firstName?: string;
    lastName?: string;
    emailAddress?: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUser {
    id?: string;
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
}

export abstract class TemplateBase implements ITemplateBase {
    width?: number;
    height?: number;

    protected _discriminator: string;

    constructor(data?: ITemplateBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "TemplateBase";
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): TemplateBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CardTemplate") {
            let result = new CardTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListTemplate") {
            let result = new ListTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BasicTemplate") {
            let result = new BasicTemplate();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TemplateBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ITemplateBase {
    width?: number;
    height?: number;
}

export class CardTemplate extends TemplateBase implements ICardTemplate {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;

    constructor(data?: ICardTemplate) {
        super(data);
        this._discriminator = "CardTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.showNavigation = data["showNavigation"];
            this.showOverlay = data["showOverlay"];
            this.showLogo = data["showLogo"];
            this.showFooter = data["showFooter"];
        }
    }

    static fromJS(data: any): CardTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new CardTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showNavigation"] = this.showNavigation;
        data["showOverlay"] = this.showOverlay;
        data["showLogo"] = this.showLogo;
        data["showFooter"] = this.showFooter;
        super.toJSON(data);
        return data; 
    }
}

export interface ICardTemplate extends ITemplateBase {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;
}

export class ListTemplate extends TemplateBase implements IListTemplate {

    constructor(data?: IListTemplate) {
        super(data);
        this._discriminator = "ListTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new ListTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IListTemplate extends ITemplateBase {
}

export class BasicTemplate extends TemplateBase implements IBasicTemplate {

    constructor(data?: IBasicTemplate) {
        super(data);
        this._discriminator = "BasicTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): BasicTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new BasicTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IBasicTemplate extends ITemplateBase {
}

export enum OutputAccess {
    Full = <any>"Full", 
    Preview = <any>"Preview", 
    None = <any>"None", 
}

export class SchemaDetail implements ISchemaDetail {
    /** The schema id. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[];
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[];
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[];
    audit?: UserAudit;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: SearchFieldCount;

    constructor(data?: ISchemaDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            this.searchFieldCount = data.searchFieldCount && !(<any>data.searchFieldCount).toJSON ? new SearchFieldCount(data.searchFieldCount) : <SearchFieldCount>this.searchFieldCount; 
        }
        if (!data) {
            this.types = [];
            this.names = new TranslatedStringDictionary();
            this.descriptions = new TranslatedStringDictionary();
            this.layerSchemaIds = [];
            this.displayPatterns = [];
            this.fields = [];
            this.fieldsOverwrite = [];
            this.sort = [];
            this.aggregations = [];
            this.schemaPermissionSetIds = [];
            this.referencedInContentSchemaIds = [];
            this.descendantSchemaIds = [];
            this.audit = new UserAudit();
            this.searchFieldCount = new SearchFieldCount();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : new TranslatedStringDictionary();
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["fieldsOverwrite"] && data["fieldsOverwrite"].constructor === Array) {
                this.fieldsOverwrite = [];
                for (let item of data["fieldsOverwrite"])
                    this.fieldsOverwrite.push(FieldOverwriteBase.fromJS(item));
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.system = data["system"];
            this.ownerTokenId = data["ownerTokenId"];
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["descendantSchemaIds"] && data["descendantSchemaIds"].constructor === Array) {
                this.descendantSchemaIds = [];
                for (let item of data["descendantSchemaIds"])
                    this.descendantSchemaIds.push(item);
            }
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.searchFieldCount = data["searchFieldCount"] ? SearchFieldCount.fromJS(data["searchFieldCount"]) : new SearchFieldCount();
        }
    }

    static fromJS(data: any): SchemaDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.fieldsOverwrite && this.fieldsOverwrite.constructor === Array) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["system"] = this.system;
        data["ownerTokenId"] = this.ownerTokenId;
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (this.descendantSchemaIds && this.descendantSchemaIds.constructor === Array) {
            data["descendantSchemaIds"] = [];
            for (let item of this.descendantSchemaIds)
                data["descendantSchemaIds"].push(item);
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["searchFieldCount"] = this.searchFieldCount ? this.searchFieldCount.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaDetail {
    /** The schema id. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** Sorts content documents and/or list items. */
    sort?: ISortInfo[];
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[];
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[];
    audit?: IUserAudit;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: ISearchFieldCount;
}

export class DisplayPattern implements IDisplayPattern {
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary;

    constructor(data?: IDisplayPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.templates = data.templates && !(<any>data.templates).toJSON ? new TranslatedStringDictionary(data.templates) : <TranslatedStringDictionary>this.templates; 
        }
        if (!data) {
            this.templates = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        if (data) {
            this.templateEngine = data["templateEngine"];
            this.displayPatternType = data["displayPatternType"];
            this.templates = data["templates"] ? TranslatedStringDictionary.fromJS(data["templates"]) : new TranslatedStringDictionary();
        }
    }

    static fromJS(data: any): DisplayPattern {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateEngine"] = this.templateEngine;
        data["displayPatternType"] = this.displayPatternType;
        data["templates"] = this.templates ? this.templates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDisplayPattern {
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: ITranslatedStringDictionary;
}

export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid", 
}

/** The field base class. */
export abstract class FieldBase implements IFieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string;
    /** The index id is auto generated by the system. */
    indexId?: string;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string;
    /** Language specific field names. */
    names?: TranslatedStringDictionary;
    /** Language specific field descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic filter index. */
    index: boolean;
    /** Includes fields in the simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;

    protected _discriminator: string;

    constructor(data?: IFieldBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.descriptions = new TranslatedStringDictionary();
        }
        this._discriminator = "FieldBase";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.indexId = data["indexId"];
            this.fieldNamespace = data["fieldNamespace"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : new TranslatedStringDictionary();
            this.required = data["required"];
            this.fixed = data["fixed"];
            this.index = data["index"];
            this.simpleSearch = data["simpleSearch"];
            this.sortable = data["sortable"];
        }
    }

    static fromJS(data: any): FieldBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldBoolean") {
            let result = new FieldBoolean();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDate") {
            let result = new FieldDate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTime") {
            let result = new FieldDateTime();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDecimal") {
            let result = new FieldDecimal();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionary") {
            let result = new FieldDictionary();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldGeoPoint") {
            let result = new FieldGeoPoint();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLong") {
            let result = new FieldLong();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleFieldset") {
            let result = new FieldSingleFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiFieldset") {
            let result = new FieldMultiFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleTagbox") {
            let result = new FieldSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiTagbox") {
            let result = new FieldMultiTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldString") {
            let result = new FieldString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldTranslatedString") {
            let result = new FieldTranslatedString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleRelation") {
            let result = new FieldSingleRelation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiRelation") {
            let result = new FieldMultiRelation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["indexId"] = this.indexId;
        data["fieldNamespace"] = this.fieldNamespace;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["required"] = this.required;
        data["fixed"] = this.fixed;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["sortable"] = this.sortable;
        return data; 
    }
}

/** The field base class. */
export interface IFieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string;
    /** The index id is auto generated by the system. */
    indexId?: string;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string;
    /** Language specific field names. */
    names?: ITranslatedStringDictionary;
    /** Language specific field descriptions. */
    descriptions?: ITranslatedStringDictionary;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic filter index. */
    index: boolean;
    /** Includes fields in the simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
}

export class FieldBoolean extends FieldBase implements IFieldBoolean {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldBoolean) {
        super(data);
        this._discriminator = "FieldBoolean";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldBoolean extends IFieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldDate extends FieldBase implements IFieldDate {
    /** Defines the date format structure. */
    format?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDate) {
        super(data);
        this._discriminator = "FieldDate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["format"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDate {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDate extends IFieldBase {
    /** Defines the date format structure. */
    format?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldDateTime extends FieldBase implements IFieldDateTime {
    /** Defines the date time format structure. */
    format?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDateTime) {
        super(data);
        this._discriminator = "FieldDateTime";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["format"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDateTime {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        let result = new FieldDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDateTime extends IFieldBase {
    /** Defines the date time format structure. */
    format?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldDateTimeArray extends FieldDateTime implements IFieldDateTimeArray {
    maximumItems?: number;
    minimumItems?: number;

    constructor(data?: IFieldDateTimeArray) {
        super(data);
        this._discriminator = "FieldDateTimeArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldDateTimeArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDateTimeArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDateTimeArray extends IFieldDateTime {
    maximumItems?: number;
    minimumItems?: number;
}

export class FieldDecimal extends FieldBase implements IFieldDecimal {
    pattern?: string;
    /** Defines the lowest possible value. */
    minimum?: number;
    /** Defines the highest possible value. */
    maximum?: number;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDecimal) {
        super(data);
        this._discriminator = "FieldDecimal";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimum = data["minimum"];
            this.maximum = data["maximum"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDecimal extends IFieldBase {
    pattern?: string;
    /** Defines the lowest possible value. */
    minimum?: number;
    /** Defines the highest possible value. */
    maximum?: number;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldDictionary extends FieldBase implements IFieldDictionary {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDictionary) {
        super(data);
        this._discriminator = "FieldDictionary";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDictionary {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        let result = new FieldDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDictionary extends IFieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldDictionaryArray extends FieldDictionary implements IFieldDictionaryArray {
    maximumItems?: number;
    minimumItems?: number;

    constructor(data?: IFieldDictionaryArray) {
        super(data);
        this._discriminator = "FieldDictionaryArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldDictionaryArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDictionaryArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDictionaryArray extends IFieldDictionary {
    maximumItems?: number;
    minimumItems?: number;
}

export class FieldGeoPoint extends FieldBase implements IFieldGeoPoint {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldGeoPoint) {
        super(data);
        this._discriminator = "FieldGeoPoint";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldGeoPoint {
        data = typeof data === 'object' ? data : {};
        let result = new FieldGeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldGeoPoint extends IFieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldLong extends FieldBase implements IFieldLong {
    pattern?: string;
    /** Defines the lowest possible value. */
    minimum?: number;
    /** Defines the highest possible value. */
    maximum?: number;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldLong) {
        super(data);
        this._discriminator = "FieldLong";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimum = data["minimum"];
            this.maximum = data["maximum"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldLong {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        let result = new FieldLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldLong extends IFieldBase {
    pattern?: string;
    /** Defines the lowest possible value. */
    minimum?: number;
    /** Defines the highest possible value. */
    maximum?: number;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldLongArray extends FieldLong implements IFieldLongArray {
    maximumItems?: number;
    minimumItems?: number;

    constructor(data?: IFieldLongArray) {
        super(data);
        this._discriminator = "FieldLongArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldLongArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLongArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldLongArray extends IFieldLong {
    maximumItems?: number;
    minimumItems?: number;
}

export class FieldSingleFieldset extends FieldBase implements IFieldSingleFieldset {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;

    constructor(data?: IFieldSingleFieldset) {
        super(data);
        if (!data) {
            this.schemaIndexingInfo = new SchemaIndexingInfo();
        }
        this._discriminator = "FieldSingleFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : new SchemaIndexingInfo();
        }
    }

    static fromJS(data: any): FieldSingleFieldset {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleFieldset extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo;
}

export class SchemaIndexingInfo implements ISchemaIndexingInfo {
    /** A collecction of indexing information for the fields of a schema */
    fields?: FieldIndexingInfo[];

    constructor(data?: ISchemaIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.fields) {
                this.fields = [];
                for (let i = 0; i < data.fields.length; i++) {
                    let item = data.fields[i];
                    this.fields[i] = item && !(<any>item).toJSON ? new FieldIndexingInfo(item) : <FieldIndexingInfo>item;
                }
            }
        }
        if (!data) {
            this.fields = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldIndexingInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaIndexingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISchemaIndexingInfo {
    /** A collecction of indexing information for the fields of a schema */
    fields?: IFieldIndexingInfo[];
}

export class FieldIndexingInfo implements IFieldIndexingInfo {
    /** The field Id */
    id?: string;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Include the field for the sort index. */
    sortable: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
    /** Indexing information of fields of the schema related to this field (if existing) */
    relatedSchemaIndexing?: SchemaIndexingInfo;

    constructor(data?: IFieldIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.relatedSchemaIndexing = data.relatedSchemaIndexing && !(<any>data.relatedSchemaIndexing).toJSON ? new SchemaIndexingInfo(data.relatedSchemaIndexing) : <SchemaIndexingInfo>this.relatedSchemaIndexing; 
        }
        if (!data) {
            this.relatedSchemaIndexing = new SchemaIndexingInfo();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.index = data["index"];
            this.simpleSearch = data["simpleSearch"];
            this.sortable = data["sortable"];
            this.boost = data["boost"];
            this.relatedSchemaIndexing = data["relatedSchemaIndexing"] ? SchemaIndexingInfo.fromJS(data["relatedSchemaIndexing"]) : new SchemaIndexingInfo();
        }
    }

    static fromJS(data: any): FieldIndexingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["sortable"] = this.sortable;
        data["boost"] = this.boost;
        data["relatedSchemaIndexing"] = this.relatedSchemaIndexing ? this.relatedSchemaIndexing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFieldIndexingInfo {
    /** The field Id */
    id?: string;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Include the field for the sort index. */
    sortable: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
    /** Indexing information of fields of the schema related to this field (if existing) */
    relatedSchemaIndexing?: ISchemaIndexingInfo;
}

export class FieldMultiFieldset extends FieldBase implements IFieldMultiFieldset {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number;

    constructor(data?: IFieldMultiFieldset) {
        super(data);
        if (!data) {
            this.schemaIndexingInfo = new SchemaIndexingInfo();
        }
        this._discriminator = "FieldMultiFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : new SchemaIndexingInfo();
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiFieldset {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiFieldset extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number;
}

export class FieldSingleTagbox extends FieldBase implements IFieldSingleTagbox {
    /** The id of the schema with type list. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;

    constructor(data?: IFieldSingleTagbox) {
        super(data);
        if (!data) {
            this.schemaIndexingInfo = new SchemaIndexingInfo();
            this.filter = new FilterBase();
        }
        this._discriminator = "FieldSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : new SchemaIndexingInfo();
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldSingleTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleTagbox extends IFieldBase {
    /** The id of the schema with type list. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
}

export class FieldMultiTagbox extends FieldBase implements IFieldMultiTagbox {
    /** The id of the schema with type list. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Defines the lowest possible item count. */
    minimumItems?: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;

    constructor(data?: IFieldMultiTagbox) {
        super(data);
        if (!data) {
            this.schemaIndexingInfo = new SchemaIndexingInfo();
            this.filter = new FilterBase();
        }
        this._discriminator = "FieldMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : new SchemaIndexingInfo();
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldMultiTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiTagbox extends IFieldBase {
    /** The id of the schema with type list. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo;
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Defines the lowest possible item count. */
    minimumItems?: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
}

export class FieldString extends FieldBase implements IFieldString {
    /** It is a DotLiquid template. */
    template?: string;
    /** Contains a regex validation pattern. */
    pattern?: string;
    /** Defines the minimal string length. */
    minimumLength?: number;
    /** Defines the maximal string length. */
    maximumLength?: number;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    indexAnalyzers?: AnalyzerBase[];
    /** Analyzers used for the simple search. Only one analyzer per type is allowed. Only considered if SimpleSearch is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[];
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[];
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldString) {
        super(data);
        if (!data) {
            this.indexAnalyzers = [];
            this.simpleSearchAnalyzers = [];
            this.grantedValues = [];
        }
        this._discriminator = "FieldString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.template = data["template"];
            this.pattern = data["pattern"];
            this.minimumLength = data["minimumLength"];
            this.maximumLength = data["maximumLength"];
            if (data["indexAnalyzers"] && data["indexAnalyzers"].constructor === Array) {
                this.indexAnalyzers = [];
                for (let item of data["indexAnalyzers"])
                    this.indexAnalyzers.push(AnalyzerBase.fromJS(item));
            }
            if (data["simpleSearchAnalyzers"] && data["simpleSearchAnalyzers"].constructor === Array) {
                this.simpleSearchAnalyzers = [];
                for (let item of data["simpleSearchAnalyzers"])
                    this.simpleSearchAnalyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["multiLine"];
            if (data["grantedValues"] && data["grantedValues"].constructor === Array) {
                this.grantedValues = [];
                for (let item of data["grantedValues"])
                    this.grantedValues.push(item);
            }
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldString {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        let result = new FieldString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (this.indexAnalyzers && this.indexAnalyzers.constructor === Array) {
            data["indexAnalyzers"] = [];
            for (let item of this.indexAnalyzers)
                data["indexAnalyzers"].push(item.toJSON());
        }
        if (this.simpleSearchAnalyzers && this.simpleSearchAnalyzers.constructor === Array) {
            data["simpleSearchAnalyzers"] = [];
            for (let item of this.simpleSearchAnalyzers)
                data["simpleSearchAnalyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (this.grantedValues && this.grantedValues.constructor === Array) {
            data["grantedValues"] = [];
            for (let item of this.grantedValues)
                data["grantedValues"].push(item);
        }
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldString extends IFieldBase {
    /** It is a DotLiquid template. */
    template?: string;
    /** Contains a regex validation pattern. */
    pattern?: string;
    /** Defines the minimal string length. */
    minimumLength?: number;
    /** Defines the maximal string length. */
    maximumLength?: number;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    indexAnalyzers?: AnalyzerBase[];
    /** Analyzers used for the simple search. Only one analyzer per type is allowed. Only considered if SimpleSearch is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[];
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[];
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** The analyzer base class. */
export abstract class AnalyzerBase implements IAnalyzerBase {

    protected _discriminator: string;

    constructor(data?: IAnalyzerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AnalyzerBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): AnalyzerBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "EdgeNGramAnalyzer") {
            let result = new EdgeNGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageAnalyzer") {
            let result = new LanguageAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NGramAnalyzer") {
            let result = new NGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PathHierarchyAnalyzer") {
            let result = new PathHierarchyAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SimpleAnalyzer") {
            let result = new SimpleAnalyzer();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AnalyzerBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

/** The analyzer base class. */
export interface IAnalyzerBase {
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export class EdgeNGramAnalyzer extends AnalyzerBase implements IEdgeNGramAnalyzer {
    type: Analyzer;
    fieldSuffix?: string;

    constructor(data?: IEdgeNGramAnalyzer) {
        super(data);
        this._discriminator = "EdgeNGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.type = data["type"];
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): EdgeNGramAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new EdgeNGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export interface IEdgeNGramAnalyzer extends IAnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

export enum Analyzer {
    None = <any>"None", 
    Simple = <any>"Simple", 
    Language = <any>"Language", 
    PathHierarchy = <any>"PathHierarchy", 
    EdgeNGram = <any>"EdgeNGram", 
    NGram = <any>"NGram", 
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export class LanguageAnalyzer extends AnalyzerBase implements ILanguageAnalyzer {
    type: Analyzer;
    fieldSuffix?: string;

    constructor(data?: ILanguageAnalyzer) {
        super(data);
        this._discriminator = "LanguageAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.type = data["type"];
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): LanguageAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export interface ILanguageAnalyzer extends IAnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export class NGramAnalyzer extends AnalyzerBase implements INGramAnalyzer {
    type: Analyzer;
    fieldSuffix?: string;

    constructor(data?: INGramAnalyzer) {
        super(data);
        this._discriminator = "NGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.type = data["type"];
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): NGramAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new NGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export interface INGramAnalyzer extends IAnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export class PathHierarchyAnalyzer extends AnalyzerBase implements IPathHierarchyAnalyzer {
    type: Analyzer;
    fieldSuffix?: string;

    constructor(data?: IPathHierarchyAnalyzer) {
        super(data);
        this._discriminator = "PathHierarchyAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.type = data["type"];
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): PathHierarchyAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new PathHierarchyAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export interface IPathHierarchyAnalyzer extends IAnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export class SimpleAnalyzer extends AnalyzerBase implements ISimpleAnalyzer {
    type: Analyzer;
    fieldSuffix?: string;

    constructor(data?: ISimpleAnalyzer) {
        super(data);
        this._discriminator = "SimpleAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.type = data["type"];
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): SimpleAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export interface ISimpleAnalyzer extends IAnalyzerBase {
    type: Analyzer;
    fieldSuffix?: string;
}

/** For internal use only (system schemas) */
export class FieldStringArray extends FieldString implements IFieldStringArray {
    maximumItems?: number;
    minimumItems?: number;

    constructor(data?: IFieldStringArray) {
        super(data);
        this._discriminator = "FieldStringArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldStringArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldStringArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldStringArray extends IFieldString {
    maximumItems?: number;
    minimumItems?: number;
}

export class FieldTranslatedString extends FieldBase implements IFieldTranslatedString {
    /** Contains a regex validation pattern. */
    pattern?: string;
    /** Defines the minimal string length. */
    minimumLength?: number;
    /** Defines the maximal string length. */
    maximumLength?: number;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    indexAnalyzers?: AnalyzerBase[];
    /** Analyzers used for the simple search. Only one analyzer per type is allowed. Only considered if SimpleSearch is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[];
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[];
    /** It is a DotLiquid template. */
    template?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldTranslatedString) {
        super(data);
        if (!data) {
            this.indexAnalyzers = [];
            this.simpleSearchAnalyzers = [];
            this.requiredMetadataLanguages = [];
        }
        this._discriminator = "FieldTranslatedString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimumLength = data["minimumLength"];
            this.maximumLength = data["maximumLength"];
            if (data["indexAnalyzers"] && data["indexAnalyzers"].constructor === Array) {
                this.indexAnalyzers = [];
                for (let item of data["indexAnalyzers"])
                    this.indexAnalyzers.push(AnalyzerBase.fromJS(item));
            }
            if (data["simpleSearchAnalyzers"] && data["simpleSearchAnalyzers"].constructor === Array) {
                this.simpleSearchAnalyzers = [];
                for (let item of data["simpleSearchAnalyzers"])
                    this.simpleSearchAnalyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["multiLine"];
            if (data["requiredMetadataLanguages"] && data["requiredMetadataLanguages"].constructor === Array) {
                this.requiredMetadataLanguages = [];
                for (let item of data["requiredMetadataLanguages"])
                    this.requiredMetadataLanguages.push(item);
            }
            this.template = data["template"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldTranslatedString {
        data = typeof data === 'object' ? data : {};
        let result = new FieldTranslatedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (this.indexAnalyzers && this.indexAnalyzers.constructor === Array) {
            data["indexAnalyzers"] = [];
            for (let item of this.indexAnalyzers)
                data["indexAnalyzers"].push(item.toJSON());
        }
        if (this.simpleSearchAnalyzers && this.simpleSearchAnalyzers.constructor === Array) {
            data["simpleSearchAnalyzers"] = [];
            for (let item of this.simpleSearchAnalyzers)
                data["simpleSearchAnalyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (this.requiredMetadataLanguages && this.requiredMetadataLanguages.constructor === Array) {
            data["requiredMetadataLanguages"] = [];
            for (let item of this.requiredMetadataLanguages)
                data["requiredMetadataLanguages"].push(item);
        }
        data["template"] = this.template;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldTranslatedString extends IFieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string;
    /** Defines the minimal string length. */
    minimumLength?: number;
    /** Defines the maximal string length. */
    maximumLength?: number;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    indexAnalyzers?: AnalyzerBase[];
    /** Analyzers used for the simple search. Only one analyzer per type is allowed. Only considered if SimpleSearch is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[];
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[];
    /** It is a DotLiquid template. */
    template?: string;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldSingleRelation extends FieldBase implements IFieldSingleRelation {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[];

    constructor(data?: IFieldSingleRelation) {
        super(data);
        if (!data) {
            this.schemaIndexingInfo = new SchemaIndexingInfo();
            this.relationTypes = [];
        }
        this._discriminator = "FieldSingleRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : new SchemaIndexingInfo();
            if (data["relationTypes"] && data["relationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["relationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldSingleRelation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleRelation extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo;
    /** Defines the relation types supported by the field. */
    relationTypes?: IRelationType[];
}

export class RelationType implements IRelationType {
    /** The id property. */
    id?: string;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary;
    /** Defines the valid target context. */
    targetDocType?: string;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase;

    constructor(data?: IRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.filter = new FilterBase();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.targetDocType = data["targetDocType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): RelationType {
        data = typeof data === 'object' ? data : {};
        let result = new RelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["targetDocType"] = this.targetDocType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRelationType {
    /** The id property. */
    id?: string;
    /** Language specific relation names. */
    names?: ITranslatedStringDictionary;
    /** Defines the valid target context. */
    targetDocType?: string;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase;
}

export class FieldMultiRelation extends FieldBase implements IFieldMultiRelation {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[];
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Dfines the lowest possible item count. */
    minimumItems?: number;

    constructor(data?: IFieldMultiRelation) {
        super(data);
        if (!data) {
            this.schemaIndexingInfo = new SchemaIndexingInfo();
            this.relationTypes = [];
        }
        this._discriminator = "FieldMultiRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : new SchemaIndexingInfo();
            if (data["relationTypes"] && data["relationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["relationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiRelation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiRelation extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo;
    /** Defines the relation types supported by the field. */
    relationTypes?: IRelationType[];
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Dfines the lowest possible item count. */
    minimumItems?: number;
}

/** Base class for overwritten information on a field. */
export abstract class FieldOverwriteBase implements IFieldOverwriteBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the required property of the field is overwritten */
    overwriteRequired: boolean;

    protected _discriminator: string;

    constructor(data?: IFieldOverwriteBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FieldOverwriteBase";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.required = data["required"];
            this.overwriteRequired = data["overwriteRequired"];
        }
    }

    static fromJS(data: any): FieldOverwriteBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldOverwriteSingleTagbox") {
            let result = new FieldOverwriteSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldOverwriteMultiTagbox") {
            let result = new FieldOverwriteMultiTagbox();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldOverwriteBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["required"] = this.required;
        data["overwriteRequired"] = this.overwriteRequired;
        return data; 
    }
}

/** Base class for overwritten information on a field. */
export interface IFieldOverwriteBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the required property of the field is overwritten */
    overwriteRequired: boolean;
}

/** Overwritten information for Single Tagbox field. */
export class FieldOverwriteSingleTagbox extends FieldOverwriteBase implements IFieldOverwriteSingleTagbox {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Defines if the Filter property of the field is overwritten */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
    /** Defines if the ListItemCreateTemplate property of the field is overwritten */
    overwriteListItemCreateTemplate: boolean;

    constructor(data?: IFieldOverwriteSingleTagbox) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "FieldOverwriteSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.overwriteFilter = data["overwriteFilter"];
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
            this.overwriteListItemCreateTemplate = data["overwriteListItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldOverwriteSingleTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOverwriteSingleTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["overwriteFilter"] = this.overwriteFilter;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        data["overwriteListItemCreateTemplate"] = this.overwriteListItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

/** Overwritten information for Single Tagbox field. */
export interface IFieldOverwriteSingleTagbox extends IFieldOverwriteBase {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Defines if the Filter property of the field is overwritten */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
    /** Defines if the ListItemCreateTemplate property of the field is overwritten */
    overwriteListItemCreateTemplate: boolean;
}

/** Overwritten information for Multi Tagbox field. */
export class FieldOverwriteMultiTagbox extends FieldOverwriteBase implements IFieldOverwriteMultiTagbox {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Defines if the Filter property of the field is overwritten */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
    /** Defines if the ListItemCreateTemplate property of the field is overwritten */
    overwriteListItemCreateTemplate: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Defines if the MaximumItems property of the field is overwritten */
    overwriteMaximumItems: boolean;
    /** Defines the lowest possible item count. */
    minimumItems?: number;
    /** Defines if the MinimumItems property of the field is overwritten */
    overwriteMinimumItems: boolean;

    constructor(data?: IFieldOverwriteMultiTagbox) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "FieldOverwriteMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.overwriteFilter = data["overwriteFilter"];
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
            this.overwriteListItemCreateTemplate = data["overwriteListItemCreateTemplate"];
            this.maximumItems = data["maximumItems"];
            this.overwriteMaximumItems = data["overwriteMaximumItems"];
            this.minimumItems = data["minimumItems"];
            this.overwriteMinimumItems = data["overwriteMinimumItems"];
        }
    }

    static fromJS(data: any): FieldOverwriteMultiTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOverwriteMultiTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["overwriteFilter"] = this.overwriteFilter;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        data["overwriteListItemCreateTemplate"] = this.overwriteListItemCreateTemplate;
        data["maximumItems"] = this.maximumItems;
        data["overwriteMaximumItems"] = this.overwriteMaximumItems;
        data["minimumItems"] = this.minimumItems;
        data["overwriteMinimumItems"] = this.overwriteMinimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** Overwritten information for Multi Tagbox field. */
export interface IFieldOverwriteMultiTagbox extends IFieldOverwriteBase {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase;
    /** Defines if the Filter property of the field is overwritten */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string;
    /** Defines if the ListItemCreateTemplate property of the field is overwritten */
    overwriteListItemCreateTemplate: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number;
    /** Defines if the MaximumItems property of the field is overwritten */
    overwriteMaximumItems: boolean;
    /** Defines the lowest possible item count. */
    minimumItems?: number;
    /** Defines if the MinimumItems property of the field is overwritten */
    overwriteMinimumItems: boolean;
}

/** Count info of fields for search operations */
export class SearchFieldCount implements ISearchFieldCount {
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;
    /** The number of fields that have sorting information stored in the search index. */
    sortableField: number;

    constructor(data?: ISearchFieldCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.indexedField = data["indexedField"];
            this.simpleSearchField = data["simpleSearchField"];
            this.sortableField = data["sortableField"];
        }
    }

    static fromJS(data: any): SearchFieldCount {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFieldCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexedField"] = this.indexedField;
        data["simpleSearchField"] = this.simpleSearchField;
        data["sortableField"] = this.sortableField;
        return data; 
    }
}

/** Count info of fields for search operations */
export interface ISearchFieldCount {
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;
    /** The number of fields that have sorting information stored in the search index. */
    sortableField: number;
}

export class SchemaSearchRequest implements ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];

    constructor(data?: ISchemaSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.debugMode = data["debugMode"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data; 
    }
}

export interface ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];
}

export class BaseResultOfSchema implements IBaseResultOfSchema {
    totalResults: number;
    results: Schema[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Schema(item) : <Schema>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Schema.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfSchema {
    totalResults: number;
    results: ISchema[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfSchema extends BaseResultOfSchema implements ISearchBehaviourBaseResultOfSchema {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfSchema) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfSchema extends IBaseResultOfSchema {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class SchemaSearchResult extends SearchBehaviourBaseResultOfSchema implements ISchemaSearchResult {

    constructor(data?: ISchemaSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaSearchResult extends ISearchBehaviourBaseResultOfSchema {
}

export class Schema implements ISchema {
    /** The schema id. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;

    constructor(data?: ISchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
        }
        if (!data) {
            this.types = [];
            this.names = new TranslatedStringDictionary();
            this.descriptions = new TranslatedStringDictionary();
            this.layerSchemaIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : new TranslatedStringDictionary();
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.fieldCount = data["fieldCount"];
            this.childCount = data["childCount"];
            this.level = data["level"];
            this.system = data["system"];
        }
    }

    static fromJS(data: any): Schema {
        data = typeof data === 'object' ? data : {};
        let result = new Schema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["fieldCount"] = this.fieldCount;
        data["childCount"] = this.childCount;
        data["level"] = this.level;
        data["system"] = this.system;
        return data; 
    }
}

export interface ISchema {
    /** The schema id. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;
}

export class IndexFieldsSearchBySchemaIdsRequest implements IIndexFieldsSearchBySchemaIdsRequest {
    schemaIds?: string[];

    constructor(data?: IIndexFieldsSearchBySchemaIdsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schemaIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): IndexFieldsSearchBySchemaIdsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IndexFieldsSearchBySchemaIdsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        return data; 
    }
}

export interface IIndexFieldsSearchBySchemaIdsRequest {
    schemaIds?: string[];
}

/** Contains compiled field information. */
export class IndexField implements IIndexField {
    id?: string;
    /** The field id. */
    fieldId?: string;
    /** The field's type name. */
    type?: string;
    /** Contains all index field name variants of the field. */
    indexFields?: { [key: string] : string; };
    /** Contains all simple search field name variants of the field.
The amount of simple search fields can be equal or less to the amount of IndexFields, but never more. */
    simpleSearchFields?: { [key: string] : string; };
    /** Contains the fields boost value. */
    boost: number;
    /** Not to be returned for search query, but only used for mapping purposes */
    ignoreForSearch: boolean;
    /** The path of the Nested document this property belongs to. If set to null, it means that there is no Nested document */
    nestedPath?: string;
    /** Path to the sorting information in the DataSortValuesField sort index. */
    sortField?: string;

    constructor(data?: IIndexField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.indexFields = {};
            this.simpleSearchFields = {};
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fieldId = data["fieldId"];
            this.type = data["type"];
            if (data["indexFields"]) {
                this.indexFields = {};
                for (let key in data["indexFields"]) {
                    if (data["indexFields"].hasOwnProperty(key))
                        this.indexFields[key] = data["indexFields"][key];
                }
            }
            if (data["simpleSearchFields"]) {
                this.simpleSearchFields = {};
                for (let key in data["simpleSearchFields"]) {
                    if (data["simpleSearchFields"].hasOwnProperty(key))
                        this.simpleSearchFields[key] = data["simpleSearchFields"][key];
                }
            }
            this.boost = data["boost"];
            this.ignoreForSearch = data["ignoreForSearch"];
            this.nestedPath = data["nestedPath"];
            this.sortField = data["sortField"];
        }
    }

    static fromJS(data: any): IndexField {
        data = typeof data === 'object' ? data : {};
        let result = new IndexField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldId"] = this.fieldId;
        data["type"] = this.type;
        if (this.indexFields) {
            data["indexFields"] = {};
            for (let key in this.indexFields) {
                if (this.indexFields.hasOwnProperty(key))
                    data["indexFields"][key] = this.indexFields[key];
            }
        }
        if (this.simpleSearchFields) {
            data["simpleSearchFields"] = {};
            for (let key in this.simpleSearchFields) {
                if (this.simpleSearchFields.hasOwnProperty(key))
                    data["simpleSearchFields"][key] = this.simpleSearchFields[key];
            }
        }
        data["boost"] = this.boost;
        data["ignoreForSearch"] = this.ignoreForSearch;
        data["nestedPath"] = this.nestedPath;
        data["sortField"] = this.sortField;
        return data; 
    }
}

/** Contains compiled field information. */
export interface IIndexField {
    id?: string;
    /** The field id. */
    fieldId?: string;
    /** The field's type name. */
    type?: string;
    /** Contains all index field name variants of the field. */
    indexFields?: { [key: string] : string; };
    /** Contains all simple search field name variants of the field.
The amount of simple search fields can be equal or less to the amount of IndexFields, but never more. */
    simpleSearchFields?: { [key: string] : string; };
    /** Contains the fields boost value. */
    boost: number;
    /** Not to be returned for search query, but only used for mapping purposes */
    ignoreForSearch: boolean;
    /** The path of the Nested document this property belongs to. If set to null, it means that there is no Nested document */
    nestedPath?: string;
    /** Path to the sorting information in the DataSortValuesField sort index. */
    sortField?: string;
}

/** Response that tells if exists */
export class ExistsResponse implements IExistsResponse {
    /** Gets or sets a value indicating whether it exists */
    exists: boolean;

    constructor(data?: IExistsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exists = data["exists"];
        }
    }

    static fromJS(data: any): ExistsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExistsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        return data; 
    }
}

/** Response that tells if exists */
export interface IExistsResponse {
    /** Gets or sets a value indicating whether it exists */
    exists: boolean;
}

export class SchemaCreateRequest implements ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[];
    /** The schema fields. Can be empty. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[];
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[];
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];

    constructor(data?: ISchemaCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.types = [];
            this.names = new TranslatedStringDictionary();
            this.descriptions = new TranslatedStringDictionary();
            this.displayPatterns = [];
            this.fields = [];
            this.fieldsOverwrite = [];
            this.aggregations = [];
            this.sort = [];
            this.schemaPermissionSetIds = [];
            this.layerSchemaIds = [];
            this.referencedInContentSchemaIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : new TranslatedStringDictionary();
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["fieldsOverwrite"] && data["fieldsOverwrite"].constructor === Array) {
                this.fieldsOverwrite = [];
                for (let item of data["fieldsOverwrite"])
                    this.fieldsOverwrite.push(FieldOverwriteBase.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.fieldsOverwrite && this.fieldsOverwrite.constructor === Array) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        return data; 
    }
}

export interface ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string;
    /** The parent schema id. */
    parentSchemaId?: string;
    /** Types control schema usage. */
    types?: SchemaType[];
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[];
    /** The schema fields. Can be empty. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[];
    /** Sorts content documents and/or list items. */
    sort?: ISortInfo[];
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
}

export class SchemaCreateResult implements ISchemaCreateResult {
    schema?: SchemaDetail;

    constructor(data?: ISchemaCreateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.schema = data.schema && !(<any>data.schema).toJSON ? new SchemaDetail(data.schema) : <SchemaDetail>this.schema; 
        }
        if (!data) {
            this.schema = new SchemaDetail();
        }
    }

    init(data?: any) {
        if (data) {
            this.schema = data["schema"] ? SchemaDetail.fromJS(data["schema"]) : new SchemaDetail();
        }
    }

    static fromJS(data: any): SchemaCreateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaCreateResult {
    schema?: ISchemaDetail;
}

export class SchemaUpdateRequest implements ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[];
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[];
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[];

    constructor(data?: ISchemaUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.descriptions = new TranslatedStringDictionary();
            this.displayPatterns = [];
            this.fields = [];
            this.fieldsOverwrite = [];
            this.aggregations = [];
            this.sort = [];
            this.schemaPermissionSetIds = [];
            this.layerSchemaIds = [];
            this.referencedInContentSchemaIds = [];
            this.types = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : new TranslatedStringDictionary();
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["fieldsOverwrite"] && data["fieldsOverwrite"].constructor === Array) {
                this.fieldsOverwrite = [];
                for (let item of data["fieldsOverwrite"])
                    this.fieldsOverwrite.push(FieldOverwriteBase.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.fieldsOverwrite && this.fieldsOverwrite.constructor === Array) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        return data; 
    }
}

export interface ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[];
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[];
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[];
    /** Sorts content documents and/or list items. */
    sort?: ISortInfo[];
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[];
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[];
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[];
}

export class SchemaUpdateResult implements ISchemaUpdateResult {
    schema?: SchemaDetail;

    constructor(data?: ISchemaUpdateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.schema = data.schema && !(<any>data.schema).toJSON ? new SchemaDetail(data.schema) : <SchemaDetail>this.schema; 
        }
        if (!data) {
            this.schema = new SchemaDetail();
        }
    }

    init(data?: any) {
        if (data) {
            this.schema = data["schema"] ? SchemaDetail.fromJS(data["schema"]) : new SchemaDetail();
        }
    }

    static fromJS(data: any): SchemaUpdateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaUpdateResult {
    schema?: ISchemaDetail;
}

export class SchemaDeleteResult implements ISchemaDeleteResult {

    constructor(data?: ISchemaDeleteResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): SchemaDeleteResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaDeleteResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ISchemaDeleteResult {
}

export abstract class PermissionSetDetailOfMetadataRight implements IPermissionSetDetailOfMetadataRight {
    id?: string;
    names?: TranslatedStringDictionary;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[];
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[];
    exclusive: boolean;
    ownerTokenId?: string;

    constructor(data?: IPermissionSetDetailOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfMetadataRight(item) : <PermissionUserRoleRightsOfMetadataRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfPermissionSetRight(item) : <PermissionUserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRolesRights = [];
            this.userRolesPermissionSetRights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.trashed = data["trashed"];
            if (data["userRolesRights"] && data["userRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["userRolesRights"])
                    this.userRolesRights.push(PermissionUserRoleRightsOfMetadataRight.fromJS(item));
            }
            if (data["userRolesPermissionSetRights"] && data["userRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["exclusive"];
            this.ownerTokenId = data["ownerTokenId"];
        }
    }

    static fromJS(data: any): PermissionSetDetailOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetDetailOfMetadataRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        data["ownerTokenId"] = this.ownerTokenId;
        return data; 
    }
}

export interface IPermissionSetDetailOfMetadataRight {
    id?: string;
    names?: ITranslatedStringDictionary;
    trashed: boolean;
    userRolesRights?: IPermissionUserRoleRightsOfMetadataRight[];
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[];
    exclusive: boolean;
    ownerTokenId?: string;
}

export class SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight implements ISchemaPermissionSetDetail {

    constructor(data?: ISchemaPermissionSetDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaPermissionSetDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaPermissionSetDetail extends IPermissionSetDetailOfMetadataRight {
}

export class PermissionUserRoleRightsOfMetadataRight implements IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string;
    names?: TranslatedStringDictionary;
    rights?: MetadataRight[];

    constructor(data?: IPermissionUserRoleRightsOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.rights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string;
    names?: ITranslatedStringDictionary;
    rights?: MetadataRight[];
}

export enum MetadataRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Manage = <any>"Manage", 
}

/** Schema import request */
export class SchemaImportRequest implements ISchemaImportRequest {
    /** Id of the previously uploaded file transfer */
    fileTransferId?: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Import the list items for the schema. */
    importListItems: boolean;

    constructor(data?: ISchemaImportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileTransferId = data["fileTransferId"];
            this.allowMissingDependencies = data["allowMissingDependencies"];
            this.importListItems = data["importListItems"];
        }
    }

    static fromJS(data: any): SchemaImportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["importListItems"] = this.importListItems;
        return data; 
    }
}

/** Schema import request */
export interface ISchemaImportRequest {
    /** Id of the previously uploaded file transfer */
    fileTransferId?: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Import the list items for the schema. */
    importListItems: boolean;
}

/** Represents a transfer. */
export class Transfer implements ITransfer {
    /** ID of transfer. */
    id: string;
    /** Name of transfer. */
    name: string;
    /** State of transfer. */
    state: TransferState;
    /** Type of transfer. */
    transferType: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string;
    /** Number of files in transfer. */
    fileTransferCount: number;
    /** ID of collection created from transfer. */
    collectionId?: string;

    constructor(data?: ITransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.state = data["state"];
            this.transferType = data["transferType"];
            this.businessProcessId = data["businessProcessId"];
            this.fileTransferCount = data["fileTransferCount"];
            this.collectionId = data["collectionId"];
        }
    }

    static fromJS(data: any): Transfer {
        data = typeof data === 'object' ? data : {};
        let result = new Transfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["transferType"] = this.transferType;
        data["businessProcessId"] = this.businessProcessId;
        data["fileTransferCount"] = this.fileTransferCount;
        data["collectionId"] = this.collectionId;
        return data; 
    }
}

/** Represents a transfer. */
export interface ITransfer {
    /** ID of transfer. */
    id: string;
    /** Name of transfer. */
    name: string;
    /** State of transfer. */
    state: TransferState;
    /** Type of transfer. */
    transferType: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string;
    /** Number of files in transfer. */
    fileTransferCount: number;
    /** ID of collection created from transfer. */
    collectionId?: string;
}

export enum TransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    ImportFailed = <any>"ImportFailed", 
    Created = <any>"Created", 
    Deleted = <any>"Deleted", 
    TransferReady = <any>"TransferReady", 
    FileDeleteInProgress = <any>"FileDeleteInProgress", 
    TransferCleanup = <any>"TransferCleanup", 
    ImportCompletedWithErrors = <any>"ImportCompletedWithErrors", 
}

export class CustomerServiceProviderConfiguration implements ICustomerServiceProviderConfiguration {
    serviceProviderId?: string;
    customerId?: string;
    userRoleIds?: string[];
    settings?: string;

    constructor(data?: ICustomerServiceProviderConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userRoleIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceProviderId = data["serviceProviderId"];
            this.customerId = data["customerId"];
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
            this.settings = data["settings"];
        }
    }

    static fromJS(data: any): CustomerServiceProviderConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerServiceProviderConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["customerId"] = this.customerId;
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["settings"] = this.settings;
        return data; 
    }
}

export interface ICustomerServiceProviderConfiguration {
    serviceProviderId?: string;
    customerId?: string;
    userRoleIds?: string[];
    settings?: string;
}

export class ServiceProviderConfigurationUpdateRequest implements IServiceProviderConfigurationUpdateRequest {
    customerId?: string;
    settings?: string;
    userRoleIds?: string[];

    constructor(data?: IServiceProviderConfigurationUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userRoleIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.settings = data["settings"];
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
        }
    }

    static fromJS(data: any): ServiceProviderConfigurationUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderConfigurationUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["settings"] = this.settings;
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        return data; 
    }
}

export interface IServiceProviderConfigurationUpdateRequest {
    customerId?: string;
    settings?: string;
    userRoleIds?: string[];
}

export class ShareSearchRequest implements IShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the share document result set. */
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IShareSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): ShareSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the share document result set. */
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export class BaseResultOfShare implements IBaseResultOfShare {
    totalResults: number;
    results: Share[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Share(item) : <Share>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Share.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfShare {
    totalResults: number;
    results: IShare[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfShare extends BaseResultOfShare implements ISearchBehaviourBaseResultOfShare {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfShare) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfShare extends IBaseResultOfShare {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class ShareSearchResult extends SearchBehaviourBaseResultOfShare implements IShareSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IShareSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ShareSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareSearchResult extends ISearchBehaviourBaseResultOfShare {
    elapsedMilliseconds: number;
}

export class Share implements IShare {
    name?: string;
    contentIds?: string[];
    id?: string;
    audit?: UserAudit;
    expirationDate?: Date;
    shareType: ShareType;

    constructor(data?: IShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
        if (!data) {
            this.contentIds = [];
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.id = data["id"];
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.shareType = data["shareType"];
        }
    }

    static fromJS(data: any): Share {
        data = typeof data === 'object' ? data : {};
        let result = new Share();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["id"] = this.id;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["shareType"] = this.shareType;
        return data; 
    }
}

export interface IShare {
    name?: string;
    contentIds?: string[];
    id?: string;
    audit?: IUserAudit;
    expirationDate?: Date;
    shareType: ShareType;
}

export class ShareAggregationRequest implements IShareAggregationRequest {
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    aggregationFilters?: AggregationFilter[];
    aggregators?: AggregatorBase[];

    constructor(data?: IShareAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.aggregationFilters = [];
            this.aggregators = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShareAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShareAggregationRequest {
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: ISortInfo[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    aggregationFilters?: AggregationFilter[];
    aggregators?: AggregatorBase[];
}

export abstract class ShareBaseCreateRequest implements IShareBaseCreateRequest {
    name?: string;
    description?: string;
    expirationDate?: Date;
    contents?: ShareContent[];
    layerSchemaIds?: string[];
    template?: TemplateBase;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contents) {
                this.contents = [];
                for (let i = 0; i < data.contents.length; i++) {
                    let item = data.contents[i];
                    this.contents[i] = item && !(<any>item).toJSON ? new ShareContent(item) : <ShareContent>item;
                }
            }
        }
        if (!data) {
            this.contents = [];
            this.layerSchemaIds = [];
        }
        this._discriminator = "ShareBaseCreateRequest";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            if (data["contents"] && data["contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["contents"])
                    this.contents.push(ShareContent.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseCreateRequest {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareBasicCreateRequest") {
            let result = new ShareBasicCreateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedCreateRequest") {
            let result = new ShareEmbedCreateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseCreateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["description"] = this.description;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (this.contents && this.contents.constructor === Array) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseCreateRequest {
    name?: string;
    description?: string;
    expirationDate?: Date;
    contents?: IShareContent[];
    layerSchemaIds?: string[];
    template?: TemplateBase;
    outputAccess: OutputAccess;
}

export class ShareContent implements IShareContent {
    contentId?: string;
    outputFormatIds?: string[];

    constructor(data?: IShareContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.outputFormatIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            if (data["outputFormatIds"] && data["outputFormatIds"].constructor === Array) {
                this.outputFormatIds = [];
                for (let item of data["outputFormatIds"])
                    this.outputFormatIds.push(item);
            }
        }
    }

    static fromJS(data: any): ShareContent {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (this.outputFormatIds && this.outputFormatIds.constructor === Array) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        return data; 
    }
}

export interface IShareContent {
    contentId?: string;
    outputFormatIds?: string[];
}

export class ShareBasicCreateRequest extends ShareBaseCreateRequest implements IShareBasicCreateRequest {
    recipientsEmail?: UserEmail[];
    recipientsUser?: User[];
    recipientsGroup?: UserRole[];
    languageCode?: string;
    mailTemplateId?: string;

    constructor(data?: IShareBasicCreateRequest) {
        super(data);
        if (!data) {
            this.recipientsEmail = [];
            this.recipientsUser = [];
            this.recipientsGroup = [];
        }
        this._discriminator = "ShareBasicCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["recipientsEmail"] && data["recipientsEmail"].constructor === Array) {
                this.recipientsEmail = [];
                for (let item of data["recipientsEmail"])
                    this.recipientsEmail.push(UserEmail.fromJS(item));
            }
            if (data["recipientsUser"] && data["recipientsUser"].constructor === Array) {
                this.recipientsUser = [];
                for (let item of data["recipientsUser"])
                    this.recipientsUser.push(User.fromJS(item));
            }
            if (data["recipientsGroup"] && data["recipientsGroup"].constructor === Array) {
                this.recipientsGroup = [];
                for (let item of data["recipientsGroup"])
                    this.recipientsGroup.push(UserRole.fromJS(item));
            }
            this.languageCode = data["languageCode"];
            this.mailTemplateId = data["mailTemplateId"];
        }
    }

    static fromJS(data: any): ShareBasicCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBasicCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.recipientsEmail && this.recipientsEmail.constructor === Array) {
            data["recipientsEmail"] = [];
            for (let item of this.recipientsEmail)
                data["recipientsEmail"].push(item.toJSON());
        }
        if (this.recipientsUser && this.recipientsUser.constructor === Array) {
            data["recipientsUser"] = [];
            for (let item of this.recipientsUser)
                data["recipientsUser"].push(item.toJSON());
        }
        if (this.recipientsGroup && this.recipientsGroup.constructor === Array) {
            data["recipientsGroup"] = [];
            for (let item of this.recipientsGroup)
                data["recipientsGroup"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        data["mailTemplateId"] = this.mailTemplateId;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicCreateRequest extends IShareBaseCreateRequest {
    recipientsEmail?: IUserEmail[];
    recipientsUser?: IUser[];
    recipientsGroup?: IUserRole[];
    languageCode?: string;
    mailTemplateId?: string;
}

export class UserRole implements IUserRole {
    /** The user role id. */
    id?: string;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights?: UserRight[];

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.trashed = data["trashed"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["userRights"] && data["userRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["userRights"])
                    this.userRights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trashed"] = this.trashed;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.userRights && this.userRights.constructor === Array) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        return data; 
    }
}

export interface IUserRole {
    /** The user role id. */
    id?: string;
    trashed: boolean;
    /** Language specific user role names. */
    names?: ITranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights?: UserRight[];
}

export class ShareEmbedCreateRequest extends ShareBaseCreateRequest implements IShareEmbedCreateRequest {

    constructor(data?: IShareEmbedCreateRequest) {
        super(data);
        this._discriminator = "ShareEmbedCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareEmbedCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedCreateRequest extends IShareBaseCreateRequest {
}

export class CreateShareResult implements ICreateShareResult {
    shareId?: string;

    constructor(data?: ICreateShareResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shareId = data["shareId"];
        }
    }

    static fromJS(data: any): CreateShareResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShareResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        return data; 
    }
}

export interface ICreateShareResult {
    shareId?: string;
}

export abstract class ShareBaseUpdateRequest implements IShareBaseUpdateRequest {
    name?: string;
    expirationDate?: Date;
    description?: string;
    shareContentItems?: ShareContent[];
    layerSchemaIds?: string[];
    template?: TemplateBase;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.shareContentItems) {
                this.shareContentItems = [];
                for (let i = 0; i < data.shareContentItems.length; i++) {
                    let item = data.shareContentItems[i];
                    this.shareContentItems[i] = item && !(<any>item).toJSON ? new ShareContent(item) : <ShareContent>item;
                }
            }
        }
        if (!data) {
            this.shareContentItems = [];
            this.layerSchemaIds = [];
        }
        this._discriminator = "ShareBaseUpdateRequest";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.description = data["description"];
            if (data["shareContentItems"] && data["shareContentItems"].constructor === Array) {
                this.shareContentItems = [];
                for (let item of data["shareContentItems"])
                    this.shareContentItems.push(ShareContent.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseUpdateRequest {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareBasicUpdateRequest") {
            let result = new ShareBasicUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedUpdateRequest") {
            let result = new ShareEmbedUpdateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseUpdateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (this.shareContentItems && this.shareContentItems.constructor === Array) {
            data["shareContentItems"] = [];
            for (let item of this.shareContentItems)
                data["shareContentItems"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseUpdateRequest {
    name?: string;
    expirationDate?: Date;
    description?: string;
    shareContentItems?: IShareContent[];
    layerSchemaIds?: string[];
    template?: TemplateBase;
    outputAccess: OutputAccess;
}

export class ShareBasicUpdateRequest extends ShareBaseUpdateRequest implements IShareBasicUpdateRequest {

    constructor(data?: IShareBasicUpdateRequest) {
        super(data);
        this._discriminator = "ShareBasicUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareBasicUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBasicUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicUpdateRequest extends IShareBaseUpdateRequest {
}

export class ShareEmbedUpdateRequest extends ShareBaseUpdateRequest implements IShareEmbedUpdateRequest {

    constructor(data?: IShareEmbedUpdateRequest) {
        super(data);
        this._discriminator = "ShareEmbedUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareEmbedUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedUpdateRequest extends IShareBaseUpdateRequest {
}

export class ShareDeleteManyRequest implements IShareDeleteManyRequest {
    ids?: string[];

    constructor(data?: IShareDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): ShareDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IShareDeleteManyRequest {
    ids?: string[];
}

/** Represents a transfer and includes detailed information. */
export class TransferDetail extends Transfer implements ITransferDetail {
    /** Audit information. */
    audit: UserAudit;
    /** Number of items processed. */
    itemProgress: number;
    /** Total number of items. */
    itemCount: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount: number;
    /** Number of items failed. */
    itemsFailed: number;
    /** Number of items cancelled. */
    itemsCancelled: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressStamp: number;
    /** LastTime stamp of last progress update from upload. */
    lastFileUploadProgressStamp: number;

    constructor(data?: ITransferDetail) {
        super(data);
        if (!data) {
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.itemProgress = data["itemProgress"];
            this.itemCount = data["itemCount"];
            this.fileUploadInProgressCount = data["fileUploadInProgressCount"];
            this.dataExtractionInProgressCount = data["dataExtractionInProgressCount"];
            this.itemsFailed = data["itemsFailed"];
            this.itemsCancelled = data["itemsCancelled"];
            this.lastDataExtractionProgressStamp = data["lastDataExtractionProgressStamp"];
            this.lastFileUploadProgressStamp = data["lastFileUploadProgressStamp"];
        }
    }

    static fromJS(data: any): TransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["itemProgress"] = this.itemProgress;
        data["itemCount"] = this.itemCount;
        data["fileUploadInProgressCount"] = this.fileUploadInProgressCount;
        data["dataExtractionInProgressCount"] = this.dataExtractionInProgressCount;
        data["itemsFailed"] = this.itemsFailed;
        data["itemsCancelled"] = this.itemsCancelled;
        data["lastDataExtractionProgressStamp"] = this.lastDataExtractionProgressStamp;
        data["lastFileUploadProgressStamp"] = this.lastFileUploadProgressStamp;
        super.toJSON(data);
        return data; 
    }
}

/** Represents a transfer and includes detailed information. */
export interface ITransferDetail extends ITransfer {
    /** Audit information. */
    audit: IUserAudit;
    /** Number of items processed. */
    itemProgress: number;
    /** Total number of items. */
    itemCount: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount: number;
    /** Number of items failed. */
    itemsFailed: number;
    /** Number of items cancelled. */
    itemsCancelled: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressStamp: number;
    /** LastTime stamp of last progress update from upload. */
    lastFileUploadProgressStamp: number;
}

/** Request to search for transfers. */
export class TransferSearchRequest implements ITransferSearchRequest {
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
    start: number;
    limit: number;
    filter?: FilterBase;

    constructor(data?: ITransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.filter = new FilterBase();
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): TransferSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

/** Request to search for transfers. */
export interface ITransferSearchRequest {
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
    start: number;
    limit: number;
    filter?: FilterBase;
}

export class BaseResultOfTransfer implements IBaseResultOfTransfer {
    totalResults: number;
    results: Transfer[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Transfer(item) : <Transfer>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Transfer.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfTransfer {
    totalResults: number;
    results: ITransfer[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfTransfer extends BaseResultOfTransfer implements ISearchBehaviourBaseResultOfTransfer {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfTransfer) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfTransfer extends IBaseResultOfTransfer {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

/** Result from a search for transfers. */
export class TransferSearchResult extends SearchBehaviourBaseResultOfTransfer implements ITransferSearchResult {
    /** Time in milliseconds query took to execute. */
    elapsedMilliseconds: number;

    constructor(data?: ITransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): TransferSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

/** Result from a search for transfers. */
export interface ITransferSearchResult extends ISearchBehaviourBaseResultOfTransfer {
    /** Time in milliseconds query took to execute. */
    elapsedMilliseconds: number;
}

/** Creates a transfer. */
export class CreateTransferRequest implements ICreateTransferRequest {
    /** Name of transfer. */
    name: string;
    /** Type of transfer. */
    transferType: TransferType;
    /** Files uploaded in transfer. */
    files?: TransferUploadFile[];
    /** Weblinks downloaded in transfer. */
    webLinks?: TransferWebLink[];
    /** Name of collection created after transfer. */
    collectionName?: string;
    /** A value indicating whether to create a Collection after importing the transfer. */
    createCollection: boolean;

    constructor(data?: ICreateTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.files) {
                this.files = [];
                for (let i = 0; i < data.files.length; i++) {
                    let item = data.files[i];
                    this.files[i] = item && !(<any>item).toJSON ? new TransferUploadFile(item) : <TransferUploadFile>item;
                }
            }
            if (data.webLinks) {
                this.webLinks = [];
                for (let i = 0; i < data.webLinks.length; i++) {
                    let item = data.webLinks[i];
                    this.webLinks[i] = item && !(<any>item).toJSON ? new TransferWebLink(item) : <TransferWebLink>item;
                }
            }
        }
        if (!data) {
            this.files = [];
            this.webLinks = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.transferType = data["transferType"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(TransferUploadFile.fromJS(item));
            }
            if (data["webLinks"] && data["webLinks"].constructor === Array) {
                this.webLinks = [];
                for (let item of data["webLinks"])
                    this.webLinks.push(TransferWebLink.fromJS(item));
            }
            this.collectionName = data["collectionName"];
            this.createCollection = data["createCollection"];
        }
    }

    static fromJS(data: any): CreateTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["transferType"] = this.transferType;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (this.webLinks && this.webLinks.constructor === Array) {
            data["webLinks"] = [];
            for (let item of this.webLinks)
                data["webLinks"].push(item.toJSON());
        }
        data["collectionName"] = this.collectionName;
        data["createCollection"] = this.createCollection;
        return data; 
    }
}

/** Creates a transfer. */
export interface ICreateTransferRequest {
    /** Name of transfer. */
    name: string;
    /** Type of transfer. */
    transferType: TransferType;
    /** Files uploaded in transfer. */
    files?: ITransferUploadFile[];
    /** Weblinks downloaded in transfer. */
    webLinks?: ITransferWebLink[];
    /** Name of collection created after transfer. */
    collectionName?: string;
    /** A value indicating whether to create a Collection after importing the transfer. */
    createCollection: boolean;
}

/** Represents the base class for transfer items. */
export abstract class TransferFile implements ITransferFile {
    /** Client generated identifier of the item. */
    identifier: string;

    constructor(data?: ITransferFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.identifier = data["identifier"];
        }
    }

    static fromJS(data: any): TransferFile {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'TransferFile' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        return data; 
    }
}

/** Represents the base class for transfer items. */
export interface ITransferFile {
    /** Client generated identifier of the item. */
    identifier: string;
}

/** Represents a file being uploaded in a transfer. */
export class TransferUploadFile extends TransferFile implements ITransferUploadFile {
    /** Target filename of file. */
    fileName: string;

    constructor(data?: ITransferUploadFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): TransferUploadFile {
        data = typeof data === 'object' ? data : {};
        let result = new TransferUploadFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        super.toJSON(data);
        return data; 
    }
}

/** Represents a file being uploaded in a transfer. */
export interface ITransferUploadFile extends ITransferFile {
    /** Target filename of file. */
    fileName: string;
}

/** Represents an item being downloaded by URL in a transfer. */
export class TransferWebLink extends TransferFile implements ITransferWebLink {
    /** URL of the item. */
    url: string;

    constructor(data?: ITransferWebLink) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): TransferWebLink {
        data = typeof data === 'object' ? data : {};
        let result = new TransferWebLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        super.toJSON(data);
        return data; 
    }
}

/** Represents an item being downloaded by URL in a transfer. */
export interface ITransferWebLink extends ITransferFile {
    /** URL of the item. */
    url: string;
}

/** Representation of a file transfer. */
export class FileTransfer implements IFileTransfer {
    /** ID of file transfer. */
    id: string;
    /** Name of file transfer. */
    name: string;
    /** Client provided identifier. */
    identifier: string;
    /** ID of transfer. */
    transferId: string;
    /** State of file transfer. */
    state: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string;

    constructor(data?: IFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.transferId = data["transferId"];
            this.state = data["state"];
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): FileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        data["contentId"] = this.contentId;
        return data; 
    }
}

/** Representation of a file transfer. */
export interface IFileTransfer {
    /** ID of file transfer. */
    id: string;
    /** Name of file transfer. */
    name: string;
    /** Client provided identifier. */
    identifier: string;
    /** ID of transfer. */
    transferId: string;
    /** State of file transfer. */
    state: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string;
}

/** Detailed representation of file transfer. */
export class FileTransferDetail extends FileTransfer implements IFileTransferDetail {
    /** Audit information. */
    audit: UserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata;
    /** Outputs being rendered for file. */
    outputItems?: FileTransferOutput[];

    constructor(data?: IFileTransferDetail) {
        super(data);
        if (!data) {
            this.audit = new UserAudit();
            this.fileMetadata = new FileMetadata();
            this.outputItems = [];
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : new UserAudit();
            this.fileMetadata = data["fileMetadata"] ? FileMetadata.fromJS(data["fileMetadata"]) : new FileMetadata();
            if (data["outputItems"] && data["outputItems"].constructor === Array) {
                this.outputItems = [];
                for (let item of data["outputItems"])
                    this.outputItems.push(FileTransferOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FileTransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["fileMetadata"] = this.fileMetadata ? this.fileMetadata.toJSON() : <any>undefined;
        if (this.outputItems && this.outputItems.constructor === Array) {
            data["outputItems"] = [];
            for (let item of this.outputItems)
                data["outputItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** Detailed representation of file transfer. */
export interface IFileTransferDetail extends IFileTransfer {
    /** Audit information. */
    audit: IUserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata;
    /** Outputs being rendered for file. */
    outputItems?: IFileTransferOutput[];
}

export class FileMetadata implements IFileMetadata {
    names?: TranslatedStringDictionary;
    descriptions?: TranslatedStringDictionary;
    fileExtension?: string;
    fileName?: string;
    filePath?: string;
    fileSizeInBytes?: number;
    sha1Hash?: string;
    xmpMetadata?: any;
    exifMetadata?: any;
    language?: string;

    protected _discriminator: string;

    constructor(data?: IFileMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.descriptions = new TranslatedStringDictionary();
        }
        this._discriminator = "FileMetadata";
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : new TranslatedStringDictionary();
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
            this.xmpMetadata = data["xmpMetadata"];
            this.exifMetadata = data["exifMetadata"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): FileMetadata {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AudioMetadata") {
            let result = new AudioMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentMetadata") {
            let result = new DocumentMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageMetadata") {
            let result = new ImageMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoMetadata") {
            let result = new VideoMetadata();
            result.init(data);
            return result;
        }
        let result = new FileMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        data["xmpMetadata"] = this.xmpMetadata;
        data["exifMetadata"] = this.exifMetadata;
        data["language"] = this.language;
        return data; 
    }
}

export interface IFileMetadata {
    names?: ITranslatedStringDictionary;
    descriptions?: ITranslatedStringDictionary;
    fileExtension?: string;
    fileName?: string;
    filePath?: string;
    fileSizeInBytes?: number;
    sha1Hash?: string;
    xmpMetadata?: any;
    exifMetadata?: any;
    language?: string;
}

export class AudioMetadata extends FileMetadata implements IAudioMetadata {
    audioStreams?: AudioStream[];

    constructor(data?: IAudioMetadata) {
        super(data);
        if (!data) {
            this.audioStreams = [];
        }
        this._discriminator = "AudioMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["audioStreams"] && data["audioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["audioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AudioMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new AudioMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAudioMetadata extends IFileMetadata {
    audioStreams?: IAudioStream[];
}

export class AudioStream implements IAudioStream {
    bitRate?: string;
    bitRateMode?: string;
    channels?: string;
    channelPositions?: string;
    codec?: string;
    durationInSeconds?: number;
    format?: string;
    language?: string;
    resolution?: number;
    samplingRate?: number;
    streamSize?: number;

    constructor(data?: IAudioStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["bitRate"];
            this.bitRateMode = data["bitRateMode"];
            this.channels = data["channels"];
            this.channelPositions = data["channelPositions"];
            this.codec = data["codec"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.language = data["language"];
            this.resolution = data["resolution"];
            this.samplingRate = data["samplingRate"];
            this.streamSize = data["streamSize"];
        }
    }

    static fromJS(data: any): AudioStream {
        data = typeof data === 'object' ? data : {};
        let result = new AudioStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["bitRateMode"] = this.bitRateMode;
        data["channels"] = this.channels;
        data["channelPositions"] = this.channelPositions;
        data["codec"] = this.codec;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["language"] = this.language;
        data["resolution"] = this.resolution;
        data["samplingRate"] = this.samplingRate;
        data["streamSize"] = this.streamSize;
        return data; 
    }
}

export interface IAudioStream {
    bitRate?: string;
    bitRateMode?: string;
    channels?: string;
    channelPositions?: string;
    codec?: string;
    durationInSeconds?: number;
    format?: string;
    language?: string;
    resolution?: number;
    samplingRate?: number;
    streamSize?: number;
}

export class DocumentMetadata extends FileMetadata implements IDocumentMetadata {
    applicationName?: string;
    applicationVersion?: string;
    author?: string;
    creator?: string;
    publisher?: string;
    company?: string;
    documentTitle?: string;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[];
    imageTitles?: string[];
    epsInfo?: EpsMetadata;

    constructor(data?: IDocumentMetadata) {
        super(data);
        if (!data) {
            this.titles = [];
            this.imageTitles = [];
            this.epsInfo = new EpsMetadata();
        }
        this._discriminator = "DocumentMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.applicationName = data["applicationName"];
            this.applicationVersion = data["applicationVersion"];
            this.author = data["author"];
            this.creator = data["creator"];
            this.publisher = data["publisher"];
            this.company = data["company"];
            this.documentTitle = data["documentTitle"];
            this.characterCount = data["characterCount"];
            this.characterCountWithSpaces = data["characterCountWithSpaces"];
            this.lineCount = data["lineCount"];
            this.pageCount = data["pageCount"];
            this.slideCount = data["slideCount"];
            this.paragraphCount = data["paragraphCount"];
            this.revisionNumber = data["revisionNumber"];
            if (data["titles"] && data["titles"].constructor === Array) {
                this.titles = [];
                for (let item of data["titles"])
                    this.titles.push(item);
            }
            if (data["imageTitles"] && data["imageTitles"].constructor === Array) {
                this.imageTitles = [];
                for (let item of data["imageTitles"])
                    this.imageTitles.push(item);
            }
            this.epsInfo = data["epsInfo"] ? EpsMetadata.fromJS(data["epsInfo"]) : new EpsMetadata();
        }
    }

    static fromJS(data: any): DocumentMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["applicationVersion"] = this.applicationVersion;
        data["author"] = this.author;
        data["creator"] = this.creator;
        data["publisher"] = this.publisher;
        data["company"] = this.company;
        data["documentTitle"] = this.documentTitle;
        data["characterCount"] = this.characterCount;
        data["characterCountWithSpaces"] = this.characterCountWithSpaces;
        data["lineCount"] = this.lineCount;
        data["pageCount"] = this.pageCount;
        data["slideCount"] = this.slideCount;
        data["paragraphCount"] = this.paragraphCount;
        data["revisionNumber"] = this.revisionNumber;
        if (this.titles && this.titles.constructor === Array) {
            data["titles"] = [];
            for (let item of this.titles)
                data["titles"].push(item);
        }
        if (this.imageTitles && this.imageTitles.constructor === Array) {
            data["imageTitles"] = [];
            for (let item of this.imageTitles)
                data["imageTitles"].push(item);
        }
        data["epsInfo"] = this.epsInfo ? this.epsInfo.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentMetadata extends IFileMetadata {
    applicationName?: string;
    applicationVersion?: string;
    author?: string;
    creator?: string;
    publisher?: string;
    company?: string;
    documentTitle?: string;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[];
    imageTitles?: string[];
    epsInfo?: IEpsMetadata;
}

export class EpsMetadata implements IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;

    constructor(data?: IEpsMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isRasterized = data["isRasterized"];
            this.widthInPoints = data["widthInPoints"];
            this.heightInPoints = data["heightInPoints"];
        }
    }

    static fromJS(data: any): EpsMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new EpsMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRasterized"] = this.isRasterized;
        data["widthInPoints"] = this.widthInPoints;
        data["heightInPoints"] = this.heightInPoints;
        return data; 
    }
}

export interface IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export class ImageMetadata extends FileMetadata implements IImageMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string;
    colorProfile?: string;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string;
    pixelFormat?: string;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;

    constructor(data?: IImageMetadata) {
        super(data);
        this._discriminator = "ImageMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.widthInInch = data["widthInInch"];
            this.heightInInch = data["heightInInch"];
            this.widthInCm = data["widthInCm"];
            this.heightInCm = data["heightInCm"];
            this.colorSpace = data["colorSpace"];
            this.colorProfile = data["colorProfile"];
            this.bitsPerPixel = data["bitsPerPixel"];
            this.bitsPerChannel = data["bitsPerChannel"];
            this.channels = data["channels"];
            this.pixelFormat = data["pixelFormat"];
            this.hasAlpha = data["hasAlpha"];
            this.isIndexed = data["isIndexed"];
            this.isExtended = data["isExtended"];
            this.horizontalResolution = data["horizontalResolution"];
            this.verticalResolution = data["verticalResolution"];
            this.totalFrames = data["totalFrames"];
            this.totalUnspecifiedTiffExtraChannels = data["totalUnspecifiedTiffExtraChannels"];
            this.hasExifData = data["hasExifData"];
            this.hasIptcData = data["hasIptcData"];
            this.hasAdobeResourceData = data["hasAdobeResourceData"];
            this.hasXmpData = data["hasXmpData"];
            this.uncompressedSizeInBytes = data["uncompressedSizeInBytes"];
        }
    }

    static fromJS(data: any): ImageMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ImageMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["widthInInch"] = this.widthInInch;
        data["heightInInch"] = this.heightInInch;
        data["widthInCm"] = this.widthInCm;
        data["heightInCm"] = this.heightInCm;
        data["colorSpace"] = this.colorSpace;
        data["colorProfile"] = this.colorProfile;
        data["bitsPerPixel"] = this.bitsPerPixel;
        data["bitsPerChannel"] = this.bitsPerChannel;
        data["channels"] = this.channels;
        data["pixelFormat"] = this.pixelFormat;
        data["hasAlpha"] = this.hasAlpha;
        data["isIndexed"] = this.isIndexed;
        data["isExtended"] = this.isExtended;
        data["horizontalResolution"] = this.horizontalResolution;
        data["verticalResolution"] = this.verticalResolution;
        data["totalFrames"] = this.totalFrames;
        data["totalUnspecifiedTiffExtraChannels"] = this.totalUnspecifiedTiffExtraChannels;
        data["hasExifData"] = this.hasExifData;
        data["hasIptcData"] = this.hasIptcData;
        data["hasAdobeResourceData"] = this.hasAdobeResourceData;
        data["hasXmpData"] = this.hasXmpData;
        data["uncompressedSizeInBytes"] = this.uncompressedSizeInBytes;
        super.toJSON(data);
        return data; 
    }
}

export interface IImageMetadata extends IFileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string;
    colorProfile?: string;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string;
    pixelFormat?: string;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export class VideoMetadata extends FileMetadata implements IVideoMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string;
    codec?: string;
    overallBitrate?: number;
    videoStreams?: VideoStream[];
    audioStreams?: AudioStream[];

    constructor(data?: IVideoMetadata) {
        super(data);
        if (!data) {
            this.videoStreams = [];
            this.audioStreams = [];
        }
        this._discriminator = "VideoMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.codec = data["codec"];
            this.overallBitrate = data["overallBitrate"];
            if (data["videoStreams"] && data["videoStreams"].constructor === Array) {
                this.videoStreams = [];
                for (let item of data["videoStreams"])
                    this.videoStreams.push(VideoStream.fromJS(item));
            }
            if (data["audioStreams"] && data["audioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["audioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new VideoMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["codec"] = this.codec;
        data["overallBitrate"] = this.overallBitrate;
        if (this.videoStreams && this.videoStreams.constructor === Array) {
            data["videoStreams"] = [];
            for (let item of this.videoStreams)
                data["videoStreams"].push(item.toJSON());
        }
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IVideoMetadata extends IFileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string;
    codec?: string;
    overallBitrate?: number;
    videoStreams?: IVideoStream[];
    audioStreams?: IAudioStream[];
}

export class VideoStream implements IVideoStream {
    bitRate?: string;
    codec?: string;
    displayAspectRatio?: string;
    durationInSeconds: number;
    format?: string;
    frameCount?: number;
    frameRate?: number;
    height?: number;
    language?: string;
    pixelAspectRatio?: number;
    resolution?: number;
    streamSize?: number;
    width?: number;
    rotation?: number;

    constructor(data?: IVideoStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["bitRate"];
            this.codec = data["codec"];
            this.displayAspectRatio = data["displayAspectRatio"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.frameCount = data["frameCount"];
            this.frameRate = data["frameRate"];
            this.height = data["height"];
            this.language = data["language"];
            this.pixelAspectRatio = data["pixelAspectRatio"];
            this.resolution = data["resolution"];
            this.streamSize = data["streamSize"];
            this.width = data["width"];
            this.rotation = data["rotation"];
        }
    }

    static fromJS(data: any): VideoStream {
        data = typeof data === 'object' ? data : {};
        let result = new VideoStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["codec"] = this.codec;
        data["displayAspectRatio"] = this.displayAspectRatio;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["frameCount"] = this.frameCount;
        data["frameRate"] = this.frameRate;
        data["height"] = this.height;
        data["language"] = this.language;
        data["pixelAspectRatio"] = this.pixelAspectRatio;
        data["resolution"] = this.resolution;
        data["streamSize"] = this.streamSize;
        data["width"] = this.width;
        data["rotation"] = this.rotation;
        return data; 
    }
}

export interface IVideoStream {
    bitRate?: string;
    codec?: string;
    displayAspectRatio?: string;
    durationInSeconds: number;
    format?: string;
    frameCount?: number;
    frameRate?: number;
    height?: number;
    language?: string;
    pixelAspectRatio?: number;
    resolution?: number;
    streamSize?: number;
    width?: number;
    rotation?: number;
}

export class FileTransferOutput implements IFileTransferOutput {
    id?: string;
    filePath?: string;
    outputSource: OutputSource;

    constructor(data?: IFileTransferOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.filePath = data["filePath"];
            this.outputSource = data["outputSource"];
        }
    }

    static fromJS(data: any): FileTransferOutput {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["outputSource"] = this.outputSource;
        return data; 
    }
}

export interface IFileTransferOutput {
    id?: string;
    filePath?: string;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered", 
    Embedded = <any>"Embedded", 
}

export enum FileTransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    DataExtractionInProgress = <any>"DataExtractionInProgress", 
    DataExtractionDone = <any>"DataExtractionDone", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    UploadFailed = <any>"UploadFailed", 
    ImportFailed = <any>"ImportFailed", 
    DeleteInProgress = <any>"DeleteInProgress", 
    Deleted = <any>"Deleted", 
    CleanupInProgress = <any>"CleanupInProgress", 
    CleanupCompleted = <any>"CleanupCompleted", 
}

/** Request to search for file transfers. */
export class FileTransferSearchRequest implements IFileTransferSearchRequest {
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
    start: number;
    limit: number;
    filter?: FilterBase;

    constructor(data?: IFileTransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.filter = new FilterBase();
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
        }
    }

    static fromJS(data: any): FileTransferSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

/** Request to search for file transfers. */
export interface IFileTransferSearchRequest {
    searchString?: string;
    searchBehaviours?: SearchBehaviour[];
    start: number;
    limit: number;
    filter?: FilterBase;
}

export class BaseResultOfFileTransfer implements IBaseResultOfFileTransfer {
    totalResults: number;
    results: FileTransfer[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new FileTransfer(item) : <FileTransfer>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(FileTransfer.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfFileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfFileTransfer {
    totalResults: number;
    results: IFileTransfer[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfFileTransfer extends BaseResultOfFileTransfer implements ISearchBehaviourBaseResultOfFileTransfer {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfFileTransfer) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfFileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfFileTransfer extends IBaseResultOfFileTransfer {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

/** Result from a search for file transfers. */
export class FileTransferSearchResult extends SearchBehaviourBaseResultOfFileTransfer implements IFileTransferSearchResult {
    /** Time in milliseconds query took to execute. */
    elapsedMilliseconds: number;

    constructor(data?: IFileTransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): FileTransferSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

/** Result from a search for file transfers. */
export interface IFileTransferSearchResult extends ISearchBehaviourBaseResultOfFileTransfer {
    /** Time in milliseconds query took to execute. */
    elapsedMilliseconds: number;
}

/** Blacklist containing file name patterns skipped when uploading. */
export class Blacklist implements IBlacklist {
    /** Blacklist entries. */
    items: BlacklistItem[];

    constructor(data?: IBlacklist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new BlacklistItem(item) : <BlacklistItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BlacklistItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Blacklist {
        data = typeof data === 'object' ? data : {};
        let result = new Blacklist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

/** Blacklist containing file name patterns skipped when uploading. */
export interface IBlacklist {
    /** Blacklist entries. */
    items: IBlacklistItem[];
}

/** Entry in the Blacklist. */
export class BlacklistItem implements IBlacklistItem {
    /** Friendly name of item. */
    name: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match: string;

    constructor(data?: IBlacklistItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.match = data["match"];
        }
    }

    static fromJS(data: any): BlacklistItem {
        data = typeof data === 'object' ? data : {};
        let result = new BlacklistItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["match"] = this.match;
        return data; 
    }
}

/** Entry in the Blacklist. */
export interface IBlacklistItem {
    /** Friendly name of item. */
    name: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match: string;
}

/** Deletes files from transfer. */
export class FileTransferDeleteRequest implements IFileTransferDeleteRequest {
    /** ID of transfer. */
    transferId: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds: string[];

    constructor(data?: IFileTransferDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fileTransferIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["fileTransferIds"] && data["fileTransferIds"].constructor === Array) {
                this.fileTransferIds = [];
                for (let item of data["fileTransferIds"])
                    this.fileTransferIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.fileTransferIds && this.fileTransferIds.constructor === Array) {
            data["fileTransferIds"] = [];
            for (let item of this.fileTransferIds)
                data["fileTransferIds"].push(item);
        }
        return data; 
    }
}

/** Deletes files from transfer. */
export interface IFileTransferDeleteRequest {
    /** ID of transfer. */
    transferId: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds: string[];
}

export class ImportTransferRequest implements IImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    metadata?: DataDictionary;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];

    constructor(data?: IImportTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
        if (!data) {
            this.layerSchemaIds = [];
            this.metadata = new DataDictionary();
            this.contentPermissionSetIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : new DataDictionary();
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): ImportTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    metadata?: IDataDictionary;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
}

export class ImportTransferPartialRequest implements IImportTransferPartialRequest {
    items?: FileTransferCreateItem[];

    constructor(data?: IImportTransferPartialRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new FileTransferCreateItem(item) : <FileTransferCreateItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FileTransferCreateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportTransferPartialRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTransferPartialRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IImportTransferPartialRequest {
    items?: IFileTransferCreateItem[];
}

export class FileTransferCreateItem implements IFileTransferCreateItem {
    fileId?: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    metadata?: DataDictionary;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];

    constructor(data?: IFileTransferCreateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
        if (!data) {
            this.layerSchemaIds = [];
            this.metadata = new DataDictionary();
            this.contentPermissionSetIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.fileId = data["fileId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : new DataDictionary();
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferCreateItem {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferCreateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransferCreateItem {
    fileId?: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[];
    metadata?: IDataDictionary;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[];
}

export class UserCreateRequest implements IUserCreateRequest {
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
    languageCode?: string;
    userRoleIds?: string[];
    address?: UserAddress;

    constructor(data?: IUserCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address; 
        }
        if (!data) {
            this.userRoleIds = [];
            this.address = new UserAddress();
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.languageCode = data["languageCode"];
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : new UserAddress();
        }
    }

    static fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["languageCode"] = this.languageCode;
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserCreateRequest {
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
    languageCode?: string;
    userRoleIds?: string[];
    address?: IUserAddress;
}

export class UserUpdateRequest extends User implements IUserUpdateRequest {
    userRoles?: UserRole[];
    comment?: string;
    languageCode?: string;
    address?: UserAddress;

    constructor(data?: IUserUpdateRequest) {
        super(data);
        if (!data) {
            this.userRoles = [];
            this.address = new UserAddress();
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["userRoles"] && data["userRoles"].constructor === Array) {
                this.userRoles = [];
                for (let item of data["userRoles"])
                    this.userRoles.push(UserRole.fromJS(item));
            }
            this.comment = data["comment"];
            this.languageCode = data["languageCode"];
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : new UserAddress();
        }
    }

    static fromJS(data: any): UserUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userRoles && this.userRoles.constructor === Array) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserUpdateRequest extends IUser {
    userRoles?: IUserRole[];
    comment?: string;
    languageCode?: string;
    address?: IUserAddress;
}

export class UserDetail extends UserUpdateRequest implements IUserDetail {
    ownerTokens?: OwnerToken[];
    authorizationState: AuthorizationState;
    lifeCycle: LifeCycle;
    isSupportUser: boolean;
    isReadOnly: boolean;

    constructor(data?: IUserDetail) {
        super(data);
        if (!data) {
            this.ownerTokens = [];
        }
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ownerTokens"] && data["ownerTokens"].constructor === Array) {
                this.ownerTokens = [];
                for (let item of data["ownerTokens"])
                    this.ownerTokens.push(OwnerToken.fromJS(item));
            }
            this.authorizationState = data["authorizationState"];
            this.lifeCycle = data["lifeCycle"];
            this.isSupportUser = data["isSupportUser"];
            this.isReadOnly = data["isReadOnly"];
        }
    }

    static fromJS(data: any): UserDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ownerTokens && this.ownerTokens.constructor === Array) {
            data["ownerTokens"] = [];
            for (let item of this.ownerTokens)
                data["ownerTokens"].push(item.toJSON());
        }
        data["authorizationState"] = this.authorizationState;
        data["lifeCycle"] = this.lifeCycle;
        data["isSupportUser"] = this.isSupportUser;
        data["isReadOnly"] = this.isReadOnly;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserDetail extends IUserUpdateRequest {
    ownerTokens?: IOwnerToken[];
    authorizationState: AuthorizationState;
    lifeCycle: LifeCycle;
    isSupportUser: boolean;
    isReadOnly: boolean;
}

export class OwnerToken implements IOwnerToken {
    /** The ownertoken id. */
    id?: string;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string;

    constructor(data?: IOwnerToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): OwnerToken {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IOwnerToken {
    /** The ownertoken id. */
    id?: string;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string;
}

export enum LifeCycle {
    Draft = <any>"Draft", 
    Active = <any>"Active", 
    Inactive = <any>"Inactive", 
    Deleted = <any>"Deleted", 
}

export class UserSearchRequest implements IUserSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    lifeCycleFilter: LifeCycleFilter;
    userRightsFilter?: UserRight[];
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IUserSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.userRightsFilter = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.lifeCycleFilter = data["lifeCycleFilter"];
            if (data["userRightsFilter"] && data["userRightsFilter"].constructor === Array) {
                this.userRightsFilter = [];
                for (let item of data["userRightsFilter"])
                    this.userRightsFilter.push(item);
            }
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): UserSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        if (this.userRightsFilter && this.userRightsFilter.constructor === Array) {
            data["userRightsFilter"] = [];
            for (let item of this.userRightsFilter)
                data["userRightsFilter"].push(item);
        }
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IUserSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    lifeCycleFilter: LifeCycleFilter;
    userRightsFilter?: UserRight[];
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export class BaseResultOfUserWithRoles implements IBaseResultOfUserWithRoles {
    totalResults: number;
    results: UserWithRoles[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfUserWithRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new UserWithRoles(item) : <UserWithRoles>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(UserWithRoles.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfUserWithRoles {
    totalResults: number;
    results: IUserWithRoles[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfUserWithRoles extends BaseResultOfUserWithRoles implements ISearchBehaviourBaseResultOfUserWithRoles {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfUserWithRoles) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfUserWithRoles extends IBaseResultOfUserWithRoles {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class UserSearchResult extends SearchBehaviourBaseResultOfUserWithRoles implements IUserSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IUserSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): UserSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserSearchResult extends ISearchBehaviourBaseResultOfUserWithRoles {
    elapsedMilliseconds: number;
}

export class UserWithRoles implements IUserWithRoles {
    userRoleIds?: string[];
    id?: string;
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
    authorizationState: AuthorizationState;
    lifeCycle: LifeCycle;
    isSupportUser: boolean;
    isReadOnly: boolean;

    constructor(data?: IUserWithRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userRoleIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.authorizationState = data["authorizationState"];
            this.lifeCycle = data["lifeCycle"];
            this.isSupportUser = data["isSupportUser"];
            this.isReadOnly = data["isReadOnly"];
        }
    }

    static fromJS(data: any): UserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["authorizationState"] = this.authorizationState;
        data["lifeCycle"] = this.lifeCycle;
        data["isSupportUser"] = this.isSupportUser;
        data["isReadOnly"] = this.isReadOnly;
        return data; 
    }
}

export interface IUserWithRoles {
    userRoleIds?: string[];
    id?: string;
    firstName?: string;
    lastName?: string;
    emailAddress?: string;
    authorizationState: AuthorizationState;
    lifeCycle: LifeCycle;
    isSupportUser: boolean;
    isReadOnly: boolean;
}

export class UserAggregationRequest implements IUserAggregationRequest {
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    aggregationFilters?: AggregationFilter[];
    aggregators?: AggregatorBase[];

    constructor(data?: IUserAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.aggregationFilters = [];
            this.aggregators = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserAggregationRequest {
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: ISortInfo[];
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase;
    aggregationFilters?: AggregationFilter[];
    aggregators?: AggregatorBase[];
}

export class UserLockRequest implements IUserLockRequest {
    lock: boolean;

    constructor(data?: IUserLockRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lock = data["lock"];
        }
    }

    static fromJS(data: any): UserLockRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lock"] = this.lock;
        return data; 
    }
}

export interface IUserLockRequest {
    lock: boolean;
}

export class UserReviewRequest implements IUserReviewRequest {
    reviewed: boolean;

    constructor(data?: IUserReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewed = data["reviewed"];
        }
    }

    static fromJS(data: any): UserReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewed"] = this.reviewed;
        return data; 
    }
}

export interface IUserReviewRequest {
    reviewed: boolean;
}

export class UserDeleteRequest implements IUserDeleteRequest {
    ownerTokenTransferUserId?: string;

    constructor(data?: IUserDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerTokenTransferUserId = data["ownerTokenTransferUserId"];
        }
    }

    static fromJS(data: any): UserDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerTokenTransferUserId"] = this.ownerTokenTransferUserId;
        return data; 
    }
}

export interface IUserDeleteRequest {
    ownerTokenTransferUserId?: string;
}

export class UserRoleSearchRequest implements IUserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: SortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];

    constructor(data?: IUserRoleSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.searchBehaviours = [];
            this.sort = [];
            this.filter = new FilterBase();
            this.searchLanguages = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : new FilterBase();
            this.debugMode = data["debugMode"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[];
    sort?: ISortInfo[];
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    searchLanguages?: string[];
}

export class BaseResultOfUserRole implements IBaseResultOfUserRole {
    totalResults: number;
    results: UserRole[];
    pageToken?: string;
    queryDebugInformation?: QueryDebugInformation;

    constructor(data?: IBaseResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new UserRole(item) : <UserRole>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
        if (!data) {
            this.results = [];
            this.queryDebugInformation = new QueryDebugInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(UserRole.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : new QueryDebugInformation();
        }
    }

    static fromJS(data: any): BaseResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfUserRole {
    totalResults: number;
    results: IUserRole[];
    pageToken?: string;
    queryDebugInformation?: IQueryDebugInformation;
}

export class SearchBehaviourBaseResultOfUserRole extends BaseResultOfUserRole implements ISearchBehaviourBaseResultOfUserRole {
    searchString?: string;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfUserRole) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviourBaseResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfUserRole extends IBaseResultOfUserRole {
    searchString?: string;
    isSearchStringRewritten: boolean;
}

export class UserRoleSearchResult extends SearchBehaviourBaseResultOfUserRole implements IUserRoleSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IUserRoleSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): UserRoleSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRoleSearchResult extends ISearchBehaviourBaseResultOfUserRole {
    elapsedMilliseconds: number;
}

export class UserRoleCreateRequest implements IUserRoleCreateRequest {
    names?: TranslatedStringDictionary;
    userRights?: UserRight[];

    constructor(data?: IUserRoleCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["userRights"] && data["userRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["userRights"])
                    this.userRights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.userRights && this.userRights.constructor === Array) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleCreateRequest {
    names?: ITranslatedStringDictionary;
    userRights?: UserRight[];
}

export class UserRoleCreateManyRequest implements IUserRoleCreateManyRequest {
    items?: UserRoleCreateRequest[];

    constructor(data?: IUserRoleCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new UserRoleCreateRequest(item) : <UserRoleCreateRequest>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserRoleCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserRoleCreateManyRequest {
    items?: IUserRoleCreateRequest[];
}

export class UserRoleUpdateManyRequest implements IUserRoleUpdateManyRequest {
    items?: UserRoleDetail[];

    constructor(data?: IUserRoleUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new UserRoleDetail(item) : <UserRoleDetail>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserRoleDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserRoleUpdateManyRequest {
    items?: IUserRoleDetail[];
}

export class UserRoleDetail implements IUserRoleDetail {
    /** The user role id. */
    id?: string;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights?: UserRight[];

    constructor(data?: IUserRoleDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRights = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.trashed = data["trashed"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : new TranslatedStringDictionary();
            if (data["userRights"] && data["userRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["userRights"])
                    this.userRights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trashed"] = this.trashed;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.userRights && this.userRights.constructor === Array) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleDetail {
    /** The user role id. */
    id?: string;
    trashed: boolean;
    /** Language specific user role names. */
    names?: ITranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights?: UserRight[];
}

export class UserRoleDeleteManyRequest implements IUserRoleDeleteManyRequest {
    ids?: string[];

    constructor(data?: IUserRoleDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleDeleteManyRequest {
    ids?: string[];
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}
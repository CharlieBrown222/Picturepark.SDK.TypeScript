/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.4.3.0 (NJsonSchema v9.4.8.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { Output as NgOutput, EventEmitter } from '@angular/core';
import { PictureparkServiceBase, PICTUREPARK_CONFIGURATION } from './picturepark.servicebase';
import { PictureparkConfiguration } from './picturepark.config';
import { OidcSecurityService, OpenIDImplicitFlowConfiguration } from "angular-auth-oidc-client";

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response, RequestOptionsArgs } from '@angular/http';

export const PICTUREPARK_API_URL = new OpaqueToken('PICTUREPARK_API_URL');

@Injectable()
export class AuthService {
    private _isAuthorizing = false;
    private _isAuthorized = false;
    private _token: string | undefined = undefined;
    private _username: string | undefined = undefined;

    constructor(
        @Optional() @Inject(OidcSecurityService) private oidcSecurityService: OidcSecurityService,
        @Optional() @Inject(PICTUREPARK_API_URL) private pictureparkApiUrl?: string,
        @Optional() @Inject(PICTUREPARK_CONFIGURATION) private pictureparkConfiguration?: PictureparkConfiguration) {

        if (this.oidcSecurityService) {
            this.oidcSecurityService.getUserData().subscribe((userData) => this.userDataChanged(userData));
        }
    }

    get apiServer() {
        return this.pictureparkConfiguration ? this.pictureparkConfiguration.apiServer : this.pictureparkApiUrl!;
    }

    get customerAlias() {
        return this.pictureparkConfiguration ? this.pictureparkConfiguration.customerAlias : undefined;
    }

    @NgOutput()
    isAuthorizedChanged = new EventEmitter<boolean>();

    login() {
        this.oidcSecurityService.authorize();
    }

    logout() {
        this.oidcSecurityService.logoff();
    }

    get username() {
        return this._username;
    }

    get token() {
        return this._token;
    }

    get isAuthorizing() {
        return this._isAuthorizing;
    }

    get isAuthorized() {
        return this._isAuthorized;
    }

    processAuthorizationRedirect() {
        this._isAuthorizing = true;
        this.oidcSecurityService.authorizedCallback();
    }

    private userDataChanged(userData: any) {
        console.log(userData);
        this._username = userData && userData.name ? <string>userData.name : undefined;
        this._token = this.oidcSecurityService.getToken();

        if (!this._isAuthorized && this._token) {
            this._isAuthorizing = false;
            this._isAuthorized = true;
            this.isAuthorizedChanged.emit(this._isAuthorized);
        } else if (this._isAuthorized) {
            this._isAuthorized = false;
            this.isAuthorizedChanged.emit(this._isAuthorized);
        }
    }

    updateTokenIfRequired() {
        return Promise.resolve();
    }
}

@Injectable()
export class ContentService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }
    
    private thumbnailCache: { [key: string]: FileResponse | null; } = {};

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, cache?: boolean): Observable<FileResponse | null> {
        let key = contentId + ":" + size;
        if (cache !== false && this.thumbnailCache[key] !== undefined)
            return Observable.of(this.thumbnailCache[key]);

        let response = this.downloadThumbnailCore(contentId, size);
        response.subscribe(blob => {
            this.thumbnailCache[key] = blob;
        });
        return response;
    }

    

    /**
     * Update Single - OwnershipTransfer
     * @contentId The content id.
     * @updateRequest The content ownership transfer request update request.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return ContentDoc
     */
    updateTransferOwnership(contentId: string, updateRequest: ContentOwnershipTransferRequest | null, timeout: number | null): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Ownership/Transfer?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateTransferOwnership(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateTransferOwnership(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTransferOwnership(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Get Many
     * @contentIds Comma-separated list of contentIds
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    getMany(contentIds: string[] | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ContentDetail[] | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many?";
        if (contentIds !== undefined)
            contentIds && contentIds.forEach(item => { url_ += "contentIds=" + encodeURIComponent("" + item) + "&"; });
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMany(response_);
                } catch (e) {
                    return <Observable<ContentDetail[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMany(response: Response): Observable<ContentDetail[] | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContentDetail.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail[] | null>(<any>null);
    }

    transferOwnershipMany(contentsOwnershipTransferRequest: ContentsOwnershipTransferRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Ownership/Transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentsOwnershipTransferRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processTransferOwnershipMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTransferOwnershipMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processTransferOwnershipMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Aggregate
     * @contentAggregationRequest The aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest | null): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregate(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Aggregate By Channel
     * @channelId The channel id
     * @contentAggregationRequest The content aggregation request.
     * @return ObjectAggregationResult
     */
    aggregateByChannel(channelId: string, contentAggregationRequest: ContentAggregationRequest | null): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ChannelId}/Aggregate";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{ChannelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregateByChannel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregateByChannel(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregateByChannel(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    createDownloadLink(request: ContentBatchDownloadRequest | null): Observable<ContentBatchDownloadItem | null> {
        let url_ = this.baseUrl + "/V1/Contents/CreateBatchContentDownload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreateDownloadLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateDownloadLink(response_);
                } catch (e) {
                    return <Observable<ContentBatchDownloadItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentBatchDownloadItem>><any>Observable.throw(response_);
        });
    }

    protected processCreateDownloadLink(response: Response): Observable<ContentBatchDownloadItem | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentBatchDownloadItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentBatchDownloadItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentBatchDownloadItem | null>(<any>null);
    }

    /**
     * Create Single
     * @createRequest The content create request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    createContent(createRequest: CreateContentRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreateContent(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContent(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processCreateContent(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    download(contentId: string, outputFormatId: string, range: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/V1/Contents/Downloads/{ContentId}/{OutputFormatId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{OutputFormatId}", encodeURIComponent("" + outputFormatId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Range": range, 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDownload(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownload(response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processDownload(response: Response): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: response.blob(), status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: response.blob(), status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return blobToText(response.blob()).flatMap(_responseText => {
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    protected downloadThumbnailCore(contentId: string, size: ThumbnailSize): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/V1/Contents/Thumbnails/{ContentId}/{Size}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{Size}", encodeURIComponent("" + size)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDownloadThumbnail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloadThumbnail(response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processDownloadThumbnail(response: Response): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: response.blob(), status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return blobToText(response.blob()).flatMap(_responseText => {
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    downloadResized(contentId: string, outputFormatId: string, width: number, height: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/V1/Contents/Downloads/{ContentId}/{OutputFormatId}/{Width}/{Height}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{OutputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined.");
        url_ = url_.replace("{Width}", encodeURIComponent("" + width)); 
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined.");
        url_ = url_.replace("{Height}", encodeURIComponent("" + height)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDownloadResized(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloadResized(response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processDownloadResized(response: Response): Observable<FileResponse | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: response.blob(), status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return blobToText(response.blob()).flatMap(_responseText => {
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    /**
     * Get Single
     * @contentId The content id.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    get(contentId: string, resolve: boolean, patterns: string[] | null): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 404) {
            const _responseText = response.text();
            let result404: ContentNotFoundException | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Update Single - Metadata
     * @contentId The content id.
     * @updateRequest The metadata update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    updateMetadata(contentId: string, updateRequest: UpdateContentMetadataRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateMetadata(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateMetadata(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMetadata(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Update Single - Permissions
     * @contentId The content id.
     * @updateRequest The content permission update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    updatePermissions(contentId: string, updateRequest: UpdateContentPermissionsRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdatePermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdatePermissions(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePermissions(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Search
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    search(contentSearchRequest: ContentSearchRequest | null): Observable<ContentSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<ContentSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentSearchResult | null>(<any>null);
    }

    /**
     * Search By Channel
     * @channelId The channel id.
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    searchByChannel(channelId: string, contentSearchRequest: ContentSearchRequest | null): Observable<ContentSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ChannelId}/Search";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{ChannelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchByChannel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchByChannel(response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchByChannel(response: Response): Observable<ContentSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentSearchResult | null>(<any>null);
    }

    deactivate(contentId: string, timeout: number): Observable<void> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Deactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeactivate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeactivate(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Update file
     * @contentId The id of the content to replace
     * @updateRequest Update request
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/File";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateFile(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdateFile(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    reactivate(contentId: string, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Reactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processReactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReactivate(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processReactivate(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    deactivateMany(deactivationRequest: ContentDeactivationRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeactivateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDeactivateMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    reactivateMany(reactivationRequest: ContentReactivationRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Reactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reactivationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processReactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReactivateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processReactivateMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Update Many - Metadata
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    updateMetadataMany(updateRequest: ContentsMetadataUpdateRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateMetadataMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateMetadataMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMetadataMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Update Many - Permissions
     * @updateRequest The permissions update request.
     * @return BusinessProcess
     */
    updatePermissionsMany(updateRequest: UpdateContentPermissionsRequest[] | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdatePermissionsMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdatePermissionsMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePermissionsMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }
}

@Injectable()
export class BusinessProcessService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    search(businessProcessSearchRequest: BusinessProcessSearchResult | null): Observable<BusinessProcessSearchResult | null> {
        let url_ = this.baseUrl + "/V1/BusinessProcesses/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<BusinessProcessSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<BusinessProcessSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcessSearchResult | null>(<any>null);
    }

    start(processDefinitionId: string, request: StartProcessRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/BusinessProcesses/ProcessDefinitions/{ProcessDefinitionId}/Start";
        if (processDefinitionId === undefined || processDefinitionId === null)
            throw new Error("The parameter 'processDefinitionId' must be defined.");
        url_ = url_.replace("{ProcessDefinitionId}", encodeURIComponent("" + processDefinitionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processStart(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStart(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processStart(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    markAsEnded(processId: string): Observable<void> {
        let url_ = this.baseUrl + "/V1/BusinessProcesses/Processes/{ProcessId}/MarkAsEnded";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processMarkAsEnded(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMarkAsEnded(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAsEnded(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    sendMessage(processId: string, request: SendMessageRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/V1/BusinessProcesses/Processes/{ProcessId}/Message";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSendMessage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendMessage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendMessage(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    waitForStates(processId: string, states: string | null, timeout: number): Observable<BusinessProcessWaitResult | null> {
        let url_ = this.baseUrl + "/V1/BusinessProcesses/{ProcessId}/Wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        if (states === undefined)
            throw new Error("The parameter 'states' must be defined.");
        else
            url_ += "states=" + encodeURIComponent("" + states) + "&"; 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processWaitForStates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processWaitForStates(response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessWaitResult>><any>Observable.throw(response_);
        });
    }

    protected processWaitForStates(response: Response): Observable<BusinessProcessWaitResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessWaitResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcessWaitResult | null>(<any>null);
    }
}

@Injectable()
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    search(documentHistorySearchRequest: DocumentHistorySearchRequest | null): Observable<DocumentHistorySearchResult | null> {
        let url_ = this.baseUrl + "/V1/History/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<DocumentHistorySearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistorySearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<DocumentHistorySearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistorySearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistorySearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentHistorySearchResult | null>(<any>null);
    }

    get(id: string): Observable<DocumentHistory | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistory>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DocumentHistory | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistory | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistory.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentHistory | null>(<any>null);
    }

    getVersion(id: string, version: string): Observable<DocumentHistory | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}/{Version}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{Version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetVersion(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetVersion(response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistory>><any>Observable.throw(response_);
        });
    }

    protected processGetVersion(response: Response): Observable<DocumentHistory | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistory | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistory.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentHistory | null>(<any>null);
    }

    getDifferenceLatest(id: string, oldVersion: number): Observable<DocumentHistoryDifference | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}/Difference/{OldVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{OldVersion}", encodeURIComponent("" + oldVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetDifferenceLatest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDifferenceLatest(response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>Observable.throw(response_);
        });
    }

    protected processGetDifferenceLatest(response: Response): Observable<DocumentHistoryDifference | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistoryDifference | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifference.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentHistoryDifference | null>(<any>null);
    }

    getDifference(id: string, oldVersion: number, newVersion: number): Observable<DocumentHistoryDifference | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}/Difference/{OldVersion}/{NewVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{OldVersion}", encodeURIComponent("" + oldVersion)); 
        if (newVersion === undefined || newVersion === null)
            throw new Error("The parameter 'newVersion' must be defined.");
        url_ = url_.replace("{NewVersion}", encodeURIComponent("" + newVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetDifference(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDifference(response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>Observable.throw(response_);
        });
    }

    protected processGetDifference(response: Response): Observable<DocumentHistoryDifference | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistoryDifference | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifference.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentHistoryDifference | null>(<any>null);
    }
}

@Injectable()
export class JsonSchemaService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Json Schema
     * @schemaId Schema Id
     * @return JsonSchemaViewItem
     */
    get(schemaId: string): Observable<any | null> {
        let url_ = this.baseUrl + "/V1/JsonSchemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<any | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: any | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any | null>(<any>null);
    }
}

@Injectable()
export class ListItemService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create Single
     * @listItem List item create request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    create(listItem: ListItemCreateRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ListItemDetail | null> {
        let url_ = this.baseUrl + "/V1/ListItems?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItem);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ListItemDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListItemDetail | null>(<any>null);
    }

    /**
     * Create Many
     * @objects A list of ListItemCreateRequests.
     * @return BusinessProcess
     */
    createMany(objects: ListItemCreateRequest[] | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objects);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processCreateMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Delete Many
     * @ids The list item id list.
     * @return BusinessProcess
     */
    deleteMany(ids: string[] | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeleteMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDeleteMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Update Many
     * @objects A list of ListItemUpdateRequests.
     * @return BusinessProcess
     */
    updateMany(objects: ListItemUpdateRequest[] | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objects);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Aggregate
     * @listItemAggregationRequest The list item aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest | null): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregate(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Search
     * @listItemSearchRequest The list item search request.
     * @return List item result set.
     */
    search(listItemSearchRequest: ListItemSearchRequest | null): Observable<ListItemSearchResult | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<ListItemSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<ListItemSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListItemSearchResult | null>(<any>null);
    }

    /**
     * Delete Single
     * @objectId The list item id.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     */
    delete(objectId: string, timeout: number): Observable<void> {
        let url_ = this.baseUrl + "/V1/ListItems/{ObjectId}?";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{ObjectId}", encodeURIComponent("" + objectId)); 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Get Single
     * @listItemId The list item id.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    get(listItemId: string, resolve: boolean, patterns: string[] | null): Observable<ListItemDetail | null> {
        let url_ = this.baseUrl + "/V1/ListItems/{ListItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{ListItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ListItemDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListItemDetail | null>(<any>null);
    }

    /**
     * Update Single
     * @listItemId The list item id.
     * @updateRequest The list item update request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    update(listItemId: string, updateRequest: ListItemUpdateRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Observable<ListItemDetail | null> {
        let url_ = this.baseUrl + "/V1/ListItems/{ListItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{ListItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ListItemDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListItemDetail | null>(<any>null);
    }

    /**
     * Wait For States
     * @processId The business process id.
     * @states Comma-separated list of business process states to wait for.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string[] | null, timeout: number): Observable<BusinessProcessWaitResult | null> {
        let url_ = this.baseUrl + "/V1/ListItems/{ProcessId}/Wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processWaitForStates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processWaitForStates(response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessWaitResult>><any>Observable.throw(response_);
        });
    }

    protected processWaitForStates(response: Response): Observable<BusinessProcessWaitResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessWaitResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcessWaitResult | null>(<any>null);
    }

    /**
     * Import
     * @contentId The content id.
     * @fileTransferId The file transfer id.
     * @includeObjects Imports list items defined in the json import file.
     */
    import(contentId: string | null, fileTransferId: string | null, includeObjects: boolean): Observable<void> {
        let url_ = this.baseUrl + "/V1/ListItems/Import?";
        if (contentId === undefined)
            throw new Error("The parameter 'contentId' must be defined.");
        else
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&"; 
        if (fileTransferId === undefined)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        else
            url_ += "fileTransferId=" + encodeURIComponent("" + fileTransferId) + "&"; 
        if (includeObjects === undefined || includeObjects === null)
            throw new Error("The parameter 'includeObjects' must be defined and cannot be null.");
        else
            url_ += "includeObjects=" + encodeURIComponent("" + includeObjects) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processImport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImport(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processImport(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LiveStreamService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    search(liveStreamSearchRequest: LiveStreamSearchRequest | null): Observable<ObjectSearchResult | null> {
        let url_ = this.baseUrl + "/V1/LiveStream/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(liveStreamSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<ObjectSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<ObjectSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ObjectSearchResult | null>(<any>null);
    }
}

@Injectable()
export class SchemaService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Many
     * @ids Comma separated list of schema ids
     * @return SchemaDetail
     */
    getAll(ids: string[] | null): Observable<SchemaDetail[] | null> {
        let url_ = this.baseUrl + "/V1/Schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<SchemaDetail[] | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: SchemaDetail[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SchemaDetail.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SchemaDetail[] | null>(<any>null);
    }

    /**
     * Create Single
     * @schema The schema create request.
     * @return BusinessProcess
     */
    create(schema: SchemaCreateRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Schemas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Get Single
     * @schemaId The schema id.
     * @return SchemaDetail
     */
    get(schemaId: string): Observable<SchemaDetail | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SchemaDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SchemaDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: SchemaDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SchemaDetail | null>(<any>null);
    }

    /**
     * Update Single
     * @schemaId The schema id.
     * @schema The schema update request.
     * @return BusinessProcess
     */
    update(schemaId: string, schema: SchemaUpdateRequest | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Delete Single
     * @schemaId The schema id.
     * @return BusinessProcess
     */
    delete(schemaId: string): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Exists
     * @schemaId The schema id.
     * @fieldId The optional field id.
     * @return ExistsResponse
     */
    exists(schemaId: string, fieldId: string | null): Observable<ExistsResponse | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}/Exists?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId === undefined)
            throw new Error("The parameter 'fieldId' must be defined.");
        else
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processExists(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExists(response_);
                } catch (e) {
                    return <Observable<ExistsResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExistsResponse>><any>Observable.throw(response_);
        });
    }

    protected processExists(response: Response): Observable<ExistsResponse | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ExistsResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExistsResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExistsResponse | null>(<any>null);
    }

    /**
     * Search
     * @schemaSearchRequest The schema search request.
     * @return Schema result set.
     */
    search(schemaSearchRequest: SchemaSearchRequest | null): Observable<SchemaSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Schemas/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<SchemaSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<SchemaSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: SchemaSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SchemaSearchResult | null>(<any>null);
    }
}

@Injectable()
export class PermissionService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get UserRight validation result
     * @permission The UserRight to validate
     * @return Boolean - user has permission
     */
    getUserPermissions(permission: UserRight): Observable<boolean | null> {
        let url_ = this.baseUrl + "/V1/Permission/UserPermissions/{Permission}";
        if (permission === undefined || permission === null)
            throw new Error("The parameter 'permission' must be defined.");
        url_ = url_.replace("{Permission}", encodeURIComponent("" + permission)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetUserPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserPermissions(response_);
                } catch (e) {
                    return <Observable<boolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<boolean>><any>Observable.throw(response_);
        });
    }

    protected processGetUserPermissions(response: Response): Observable<boolean | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: boolean | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<boolean | null>(<any>null);
    }

    /**
     * Search Content Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchContentPermissions(request: PermissionSetSearchRequest | null): Observable<PermissionSetSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Permission/ContentPermissionSets/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchContentPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchContentPermissions(response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchContentPermissions(response: Response): Observable<PermissionSetSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: PermissionSetSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PermissionSetSearchResult | null>(<any>null);
    }

    /**
     * Get Content Permission Single
     * @permissionSetId The content permission set id.
     * @return ContentPermissionSetDetail
     */
    getContentPermissions(permissionSetId: string): Observable<ContentPermissionSetDetail | null> {
        let url_ = this.baseUrl + "/V1/Permission/ContentPermissionSets/{PermissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{PermissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetContentPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContentPermissions(response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetContentPermissions(response: Response): Observable<ContentPermissionSetDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ContentPermissionSetDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentPermissionSetDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentPermissionSetDetail | null>(<any>null);
    }

    /**
     * Search Schema Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchSchemaPermissions(request: PermissionSetSearchRequest | null): Observable<PermissionSetSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Permission/SchemaPermissionSets/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchSchemaPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchSchemaPermissions(response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchSchemaPermissions(response: Response): Observable<PermissionSetSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: PermissionSetSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PermissionSetSearchResult | null>(<any>null);
    }

    /**
     * Get Schema Permission Single
     * @permissionSetId The schema permission set id.
     * @return SchemaPermissionSetDetail
     */
    getSchemaPermissions(permissionSetId: string): Observable<SchemaPermissionSetDetail | null> {
        let url_ = this.baseUrl + "/V1/Permission/SchemaPermissionSets/{PermissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{PermissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetSchemaPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSchemaPermissions(response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetSchemaPermissions(response: Response): Observable<SchemaPermissionSetDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: SchemaPermissionSetDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaPermissionSetDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SchemaPermissionSetDetail | null>(<any>null);
    }
}

@Injectable()
export class PublicAccessService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    getVersion(): Observable<VersionInfo | null> {
        let url_ = this.baseUrl + "/V1/PublicAccess/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetVersion(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetVersion(response_);
                } catch (e) {
                    return <Observable<VersionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<VersionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetVersion(response: Response): Observable<VersionInfo | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: VersionInfo | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VersionInfo.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<VersionInfo | null>(<any>null);
    }

    getShare(token: string | null): Observable<ShareBaseDetail | null> {
        let url_ = this.baseUrl + "/V1/PublicAccess/GetShare?";
        if (token === undefined)
            throw new Error("The parameter 'token' must be defined.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetShare(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetShare(response_);
                } catch (e) {
                    return <Observable<ShareBaseDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareBaseDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetShare(response: Response): Observable<ShareBaseDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ShareBaseDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareBaseDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ShareBaseDetail | null>(<any>null);
    }
}

@Injectable()
export class ShareService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Update Single - Share
     * @id The share id.
     * @updateRequest The share update request.
     * @resolve Resolves the data of referenced list items into the shares content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return Share
     */
    update(id: string, updateRequest: ShareBaseUpdateRequest | null, resolve: boolean, timeout: number | null): Observable<BaseResultOfShareBase | null> {
        let url_ = this.baseUrl + "/V1/Shares/{Id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<BaseResultOfShareBase>><any>Observable.throw(e);
                }
            } else
                return <Observable<BaseResultOfShareBase>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<BaseResultOfShareBase | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BaseResultOfShareBase | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseResultOfShareBase.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BaseResultOfShareBase | null>(<any>null);
    }

    /**
     * Get share by id (basic or embed)
     * @id Share Id (not token, use PublicAccess to get share by token)
     * @return Polymorph share
     */
    get(id: string): Observable<ShareBaseDetail | null> {
        let url_ = this.baseUrl + "/V1/Shares/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ShareBaseDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareBaseDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ShareBaseDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ShareBaseDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareBaseDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ShareBaseDetail | null>(<any>null);
    }

    /**
     * Delete Many
     * @shareIds A list of ListItemCreateRequests.
     * @return BusinessProcess
     */
    deleteMany(shareIds: string[] | null): Observable<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Shares/DeleteMany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(shareIds);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeleteMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDeleteMany(response: Response): Observable<BusinessProcess | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcess | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BusinessProcess | null>(<any>null);
    }

    /**
     * Aggregates own shares
     * @request Aggregation request
     * @return AggregationResult
     */
    aggregate(request: ShareAggregationRequest | null): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/Shares/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregate(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Create a new share (basic or embed).
     * @request Polymorph create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest | null): Observable<CreateShareResult | null> {
        let url_ = this.baseUrl + "/V1/Shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<CreateShareResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateShareResult>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<CreateShareResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 404) {
            const _responseText = response.text();
            let result404: ContentNotFoundException | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: CreateShareResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateShareResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateShareResult | null>(<any>null);
    }

    /**
     * Search shares
     * @request Search request
     * @return Share search result
     */
    search(request: ContentSearchRequest | null): Observable<ShareSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Shares/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<ShareSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<ShareSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ShareSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ShareSearchResult | null>(<any>null);
    }
}

@Injectable()
export class TransferService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    deleteFiles(request: FileTransferDeleteRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeleteFiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteFiles(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteFiles(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    getBlacklist(): Observable<Blacklist | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/Blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetBlacklist(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBlacklist(response_);
                } catch (e) {
                    return <Observable<Blacklist>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blacklist>><any>Observable.throw(response_);
        });
    }

    protected processGetBlacklist(response: Response): Observable<Blacklist | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Blacklist | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Blacklist.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Blacklist | null>(<any>null);
    }

    /**
     * Cancels an active batch. Valid states: TODO
     */
    cancelBatch(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/Cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCancelBatch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCancelBatch(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCancelBatch(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    create(request: CreateTransferRequest | null): Observable<Transfer | null> {
        let url_ = this.baseUrl + "/V1/Transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<Transfer>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transfer>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<Transfer | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: Transfer | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Transfer | null>(<any>null);
    }

    delete(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    get(transferId: string): Observable<TransferDetail | null> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TransferDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TransferDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TransferDetail | null>(<any>null);
    }

    getFile(fileTransferId: string): Observable<FileTransferDetail | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/{FileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{FileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetFile(response_);
                } catch (e) {
                    return <Observable<FileTransferDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileTransferDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetFile(response: Response): Observable<FileTransferDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: FileTransferDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FileTransferDetail | null>(<any>null);
    }

    importBatch(transferId: string, request: FileTransfer2ContentCreateRequest | null): Observable<Transfer | null> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/Import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processImportBatch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImportBatch(response_);
                } catch (e) {
                    return <Observable<Transfer>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transfer>><any>Observable.throw(response_);
        });
    }

    protected processImportBatch(response: Response): Observable<Transfer | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: Transfer | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Transfer | null>(<any>null);
    }

    partialImport(transferId: string, request: FileTransferPartial2ContentCreateRequest | null): Observable<Transfer | null> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/PartialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processPartialImport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPartialImport(response_);
                } catch (e) {
                    return <Observable<Transfer>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transfer>><any>Observable.throw(response_);
        });
    }

    protected processPartialImport(response: Response): Observable<Transfer | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: Transfer | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Transfer | null>(<any>null);
    }

    search(request: TransferSearchRequest | null): Observable<TransferSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<TransferSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<TransferSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TransferSearchResult | null>(<any>null);
    }

    searchFiles(request: FileTransferSearchRequest | null): Observable<FileTransferSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchFiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchFiles(response_);
                } catch (e) {
                    return <Observable<FileTransferSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileTransferSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchFiles(response: Response): Observable<FileTransferSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: FileTransferSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FileTransferSearchResult | null>(<any>null);
    }

    /**
     * @flowChunkNumber Starts with 1
     */
    uploadFile(formFile: FileParameter | null, flowRelativePath: string | null, flowChunkNumber: number, flowCurrentChunkSize: number, flowTotalSize: number, flowTotalChunks: number, transferId: string, identifier: string): Observable<void> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/Files/{Identifier}/Upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{Identifier}", encodeURIComponent("" + identifier)); 
        if (flowRelativePath !== undefined)
            url_ += "flowRelativePath=" + encodeURIComponent("" + flowRelativePath) + "&"; 
        if (flowChunkNumber === null)
            throw new Error("The parameter 'flowChunkNumber' cannot be null.");
        else if (flowChunkNumber !== undefined)
            url_ += "flowChunkNumber=" + encodeURIComponent("" + flowChunkNumber) + "&"; 
        if (flowCurrentChunkSize === null)
            throw new Error("The parameter 'flowCurrentChunkSize' cannot be null.");
        else if (flowCurrentChunkSize !== undefined)
            url_ += "flowCurrentChunkSize=" + encodeURIComponent("" + flowCurrentChunkSize) + "&"; 
        if (flowTotalSize === null)
            throw new Error("The parameter 'flowTotalSize' cannot be null.");
        else if (flowTotalSize !== undefined)
            url_ += "flowTotalSize=" + encodeURIComponent("" + flowTotalSize) + "&"; 
        if (flowTotalChunks === null)
            throw new Error("The parameter 'flowTotalChunks' cannot be null.");
        else if (flowTotalChunks !== undefined)
            url_ += "flowTotalChunks=" + encodeURIComponent("" + flowTotalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUploadFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUploadFile(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUploadFile(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    search(searchRequest: UserSearchRequest | null): Observable<UserSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Users/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<UserSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<UserSearchResult | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: UserSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserSearchResult | null>(<any>null);
    }

    getUser(userId: string): Observable<UserDetail | null> {
        let url_ = this.baseUrl + "/V1/Users/GetUser/{UserId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUser(response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetUser(response: Response): Observable<UserDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: UserDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDetail | null>(<any>null);
    }

    getProfile(): Observable<UserProfile | null> {
        let url_ = this.baseUrl + "/V1/Users/GetProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfile(response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfile>><any>Observable.throw(response_);
        });
    }

    protected processGetProfile(response: Response): Observable<UserProfile | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: UserProfile | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfile.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfile | null>(<any>null);
    }

    getByOwnerToken(tokenId: string): Observable<UserDetail | null> {
        let url_ = this.baseUrl + "/V1/Users/Owner/{TokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{TokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetByOwnerToken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetByOwnerToken(response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetByOwnerToken(response: Response): Observable<UserDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: UserDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDetail | null>(<any>null);
    }

    getChannels(): Observable<Channel[] | null> {
        let url_ = this.baseUrl + "/V1/Users/Channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetChannels(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetChannels(response_);
                } catch (e) {
                    return <Observable<Channel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Channel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetChannels(response: Response): Observable<Channel[] | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: Channel[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Channel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Channel[] | null>(<any>null);
    }
}

@Injectable()
export class OutputService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get outputs by contentIds
     * @contentsByIdsRequest Contains the list of contentIds for which the outputs are requested
     * @return The Result containing a list of OutputDetail's
     */
    getByContentIds(contentsByIdsRequest: ContentsByIdsRequest | null): Observable<OutputDetail[] | null> {
        let url_ = this.baseUrl + "/V1/Outputs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentsByIdsRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetByContentIds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetByContentIds(response_);
                } catch (e) {
                    return <Observable<OutputDetail[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<OutputDetail[]>><any>Observable.throw(response_);
        });
    }

    protected processGetByContentIds(response: Response): Observable<OutputDetail[] | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: OutputDetail[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OutputDetail.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OutputDetail[] | null>(<any>null);
    }

    /**
     * Get Single
     * @outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Observable<OutputDetail | null> {
        let url_ = this.baseUrl + "/V1/Outputs/{OutputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{OutputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<OutputDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<OutputDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<OutputDetail | null> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 404) {
            const _responseText = response.text();
            let result404: OutputNotFoundException | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? OutputNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: OutputDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutputDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OutputDetail | null>(<any>null);
    }
}

export class ContentOwnershipTransferRequest implements IContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string | undefined;

    constructor(data?: IContentOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.transferUserId = data["transferUserId"];
        }
    }

    static fromJS(data: any): ContentOwnershipTransferRequest {
        let result = new ContentOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["transferUserId"] = this.transferUserId;
        return data; 
    }
}

export interface IContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string | undefined;
}

export class ContentDetail implements IContentDetail {
    /** Document audit information with information regarding document creation and modification. */
    audit?: StoreAudit | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** The content type of a content document. */
    contentType: ContentType;
    /** The content type of a content document. */
    contentTypeId: number;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The content id. */
    id?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** A list of rendering ouputs for contents with an underlying digital file. */
    outputs?: Output[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;

    constructor(data?: IContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.content = data["content"];
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
            this.contentSchemaId = data["contentSchemaId"];
            this.contentType = data["contentType"];
            this.contentTypeId = data["contentTypeId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.id = data["id"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["outputs"] && data["outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["outputs"])
                    this.outputs.push(Output.fromJS(item));
            }
            this.ownerTokenId = data["ownerTokenId"];
            this.trashed = data["trashed"];
        }
    }

    static fromJS(data: any): ContentDetail {
        let result = new ContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["content"] = this.content;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        data["contentSchemaId"] = this.contentSchemaId;
        data["contentType"] = this.contentType;
        data["contentTypeId"] = this.contentTypeId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["id"] = this.id;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.outputs && this.outputs.constructor === Array) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["ownerTokenId"] = this.ownerTokenId;
        data["trashed"] = this.trashed;
        return data; 
    }
}

export interface IContentDetail {
    /** Document audit information with information regarding document creation and modification. */
    audit?: StoreAudit | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** The content type of a content document. */
    contentType: ContentType;
    /** The content type of a content document. */
    contentTypeId: number;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The content id. */
    id?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** A list of rendering ouputs for contents with an underlying digital file. */
    outputs?: Output[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;
}

export class StoreAudit implements IStoreAudit {
    creationDate: Date;
    createdByUser?: UserItem | undefined;
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;

    constructor(data?: IStoreAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creationDate = data["creationDate"] ? new Date(data["creationDate"].toString()) : <any>undefined;
            this.createdByUser = data["createdByUser"] ? UserItem.fromJS(data["createdByUser"]) : <any>undefined;
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = data["modifiedByUser"] ? UserItem.fromJS(data["modifiedByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreAudit {
        let result = new StoreAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["modifiedByUser"] = this.modifiedByUser ? this.modifiedByUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStoreAudit {
    creationDate: Date;
    createdByUser?: UserItem | undefined;
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;
}

export class UserItem implements IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUserItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UserItem {
        let result = new UserItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export enum ContentType {
    Unknown = <any>"Unknown", 
    Bitmap = <any>"Bitmap", 
    VectorGraphic = <any>"VectorGraphic", 
    RawImage = <any>"RawImage", 
    InterchangeDocument = <any>"InterchangeDocument", 
    WordProcessingDocument = <any>"WordProcessingDocument", 
    TextDocument = <any>"TextDocument", 
    DesktopPublishingDocument = <any>"DesktopPublishingDocument", 
    Presentation = <any>"Presentation", 
    Spreadsheet = <any>"Spreadsheet", 
    Archive = <any>"Archive", 
    Audio = <any>"Audio", 
    Video = <any>"Video", 
    Font = <any>"Font", 
    Multimedia = <any>"Multimedia", 
    Application = <any>"Application", 
    SourceCode = <any>"SourceCode", 
    Database = <any>"Database", 
    Cad = <any>"Cad", 
    Model3d = <any>"Model3d", 
}

export class DisplayValueDictionary implements IDisplayValueDictionary {

    [key: string]: string | any; 

    constructor(data?: IDisplayValueDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DisplayValueDictionary {
        let result = new DisplayValueDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface IDisplayValueDictionary {

    [key: string]: string | any; 
}

export enum EntityType {
    Content = <any>"Content", 
    BasicShare = <any>"BasicShare", 
    EmbedShare = <any>"EmbedShare", 
    Metadata = <any>"Metadata", 
    FileTransfer = <any>"FileTransfer", 
}

export class DataDictionary implements IDataDictionary {

    [key: string]: any; 

    constructor(data?: IDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DataDictionary {
        let result = new DataDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface IDataDictionary {

    [key: string]: any; 
}

export class Output implements IOutput {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;

    protected _discriminator: string;

    constructor(data?: IOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Output";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.outputFormatId = data["outputFormatId"];
            this.contentId = data["contentId"];
            this.detail = data["detail"] ? OutputDetailBase.fromJS(data["detail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Output {
        if (data["kind"] === "OutputDetail") {
            let result = new OutputDetail();
            result.init(data);
            return result;
        }
        let result = new Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["outputFormatId"] = this.outputFormatId;
        data["contentId"] = this.contentId;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOutput {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;
}

export class OutputDetailBase implements IOutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IOutputDetailBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputDetailBase";
    }

    init(data?: any) {
        if (data) {
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
        }
    }

    static fromJS(data: any): OutputDetailBase {
        if (data["kind"] === "OutputDetailImage") {
            let result = new OutputDetailImage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailAudio") {
            let result = new OutputDetailAudio();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailVideo") {
            let result = new OutputDetailVideo();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailDocument") {
            let result = new OutputDetailDocument();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailDefault") {
            let result = new OutputDetailDefault();
            result.init(data);
            return result;
        }
        let result = new OutputDetailBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        return data; 
    }
}

export interface IOutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
}

export class OutputDetailImage extends OutputDetailBase implements IOutputDetailImage {
    width: number;
    height: number;

    constructor(data?: IOutputDetailImage) {
        super(data);
        this._discriminator = "OutputDetailImage";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): OutputDetailImage {
        let result = new OutputDetailImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailImage extends IOutputDetailBase {
    width: number;
    height: number;
}

export class OutputDetailAudio extends OutputDetailBase implements IOutputDetailAudio {
    durationInSeconds?: number | undefined;

    constructor(data?: IOutputDetailAudio) {
        super(data);
        this._discriminator = "OutputDetailAudio";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
        }
    }

    static fromJS(data: any): OutputDetailAudio {
        let result = new OutputDetailAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailAudio extends IOutputDetailBase {
    durationInSeconds?: number | undefined;
}

export class OutputDetailVideo extends OutputDetailBase implements IOutputDetailVideo {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;

    constructor(data?: IOutputDetailVideo) {
        super(data);
        this._discriminator = "OutputDetailVideo";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
            this.width = data["width"];
            this.height = data["height"];
            if (data["sprites"] && data["sprites"].constructor === Array) {
                this.sprites = [];
                for (let item of data["sprites"])
                    this.sprites.push(Sprite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputDetailVideo {
        let result = new OutputDetailVideo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        data["width"] = this.width;
        data["height"] = this.height;
        if (this.sprites && this.sprites.constructor === Array) {
            data["sprites"] = [];
            for (let item of this.sprites)
                data["sprites"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailVideo extends IOutputDetailBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;
}

export class Sprite implements ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;

    constructor(data?: ISprite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.y = data["y"];
            this.x = data["x"];
            this.start = data["start"];
            this.end = data["end"];
        }
    }

    static fromJS(data: any): Sprite {
        let result = new Sprite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["y"] = this.y;
        data["x"] = this.x;
        data["start"] = this.start;
        data["end"] = this.end;
        return data; 
    }
}

export interface ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;
}

export class OutputDetailDocument extends OutputDetailBase implements IOutputDetailDocument {
    pageCount: number;

    constructor(data?: IOutputDetailDocument) {
        super(data);
        this._discriminator = "OutputDetailDocument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pageCount = data["pageCount"];
        }
    }

    static fromJS(data: any): OutputDetailDocument {
        let result = new OutputDetailDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailDocument extends IOutputDetailBase {
    pageCount: number;
}

export class OutputDetailDefault extends OutputDetailBase implements IOutputDetailDefault {

    constructor(data?: IOutputDetailDefault) {
        super(data);
        this._discriminator = "OutputDetailDefault";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetailDefault {
        let result = new OutputDetailDefault();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailDefault extends IOutputDetailBase {
}

export class OutputDetail extends Output implements IOutputDetail {

    constructor(data?: IOutputDetail) {
        super(data);
        this._discriminator = "OutputDetail";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetail {
        let result = new OutputDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetail extends IOutput {
}

export class Exception implements IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.innerException = data["innerException"] ? Exception.fromJS(data["innerException"]) : <any>undefined;
            this.stackTrace = data["stackTrace"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): Exception {
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["innerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["stackTrace"] = this.stackTrace;
        data["source"] = this.source;
        return data; 
    }
}

export interface IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;

    protected _discriminator: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this._discriminator = "PictureparkException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.traceLevel = data["traceLevel"];
            this.traceId = data["traceId"];
            this.traceJobId = data["traceJobId"];
            this.httpStatusCode = data["httpStatusCode"];
        }
    }

    static fromJS(data: any): PictureparkException {
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionException") {
            let result = new PermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentNotFoundException") {
            let result = new DocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DriveRequestException") {
            let result = new DriveRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidCustomerException") {
            let result = new InvalidCustomerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkInvalidMetadataException") {
            let result = new PictureparkInvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUserOrPasswordException") {
            let result = new InvalidUserOrPasswordException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkMappingException") {
            let result = new PictureparkMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MessagePerformerTaskCanceledException") {
            let result = new MessagePerformerTaskCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFoundException") {
            let result = new NotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationTimeoutException") {
            let result = new OperationTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingJobItemNotSetException") {
            let result = new RenderingJobItemNotSetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenValidationException") {
            let result = new TokenValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPermanentlyRemovedException") {
            let result = new UserPermanentlyRemovedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesRightsAssignedException") {
            let result = new UserRolesRightsAssignedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["traceLevel"] = this.traceLevel;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        data["httpStatusCode"] = this.httpStatusCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkException extends IException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;
}

export enum TraceLevel {
    Critical = <any>"Critical", 
    Error = <any>"Error", 
    Warning = <any>"Warning", 
    Information = <any>"Information", 
    Verbose = <any>"Verbose", 
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this._discriminator = "PictureparkBusinessException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
            this.customerAlias = data["customerAlias"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): PictureparkBusinessException {
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionException") {
            let result = new PermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentNotFoundException") {
            let result = new DocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DriveRequestException") {
            let result = new DriveRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkInvalidMetadataException") {
            let result = new PictureparkInvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkMappingException") {
            let result = new PictureparkMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFoundException") {
            let result = new NotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationTimeoutException") {
            let result = new OperationTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingJobItemNotSetException") {
            let result = new RenderingJobItemNotSetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenValidationException") {
            let result = new TokenValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPermanentlyRemovedException") {
            let result = new UserPermanentlyRemovedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesRightsAssignedException") {
            let result = new UserRolesRightsAssignedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerAlias"] = this.customerAlias;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export class PictureparkApplicationException extends PictureparkBusinessException implements IPictureparkApplicationException {

    constructor(data?: IPictureparkApplicationException) {
        super(data);
        this._discriminator = "PictureparkApplicationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkApplicationException {
        let result = new PictureparkApplicationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkApplicationException extends IPictureparkBusinessException {
}

export class PictureparkArgumentNullException extends PictureparkBusinessException implements IPictureparkArgumentNullException {
    argumentName?: string | undefined;

    constructor(data?: IPictureparkArgumentNullException) {
        super(data);
        this._discriminator = "PictureparkArgumentNullException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["argumentName"];
        }
    }

    static fromJS(data: any): PictureparkArgumentNullException {
        let result = new PictureparkArgumentNullException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkArgumentNullException extends IPictureparkBusinessException {
    argumentName?: string | undefined;
}

export class ContentNotFoundException extends PictureparkBusinessException implements IContentNotFoundException {
    contentId?: string | undefined;

    constructor(data?: IContentNotFoundException) {
        super(data);
        this._discriminator = "ContentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): ContentNotFoundException {
        let result = new ContentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
}

export class BusinessProcessDefinitionCreateException extends PictureparkBusinessException implements IBusinessProcessDefinitionCreateException {
    processDefinitionIds?: string[] | undefined;

    constructor(data?: IBusinessProcessDefinitionCreateException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["processDefinitionIds"] && data["processDefinitionIds"].constructor === Array) {
                this.processDefinitionIds = [];
                for (let item of data["processDefinitionIds"])
                    this.processDefinitionIds.push(item);
            }
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionCreateException {
        let result = new BusinessProcessDefinitionCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.processDefinitionIds && this.processDefinitionIds.constructor === Array) {
            data["processDefinitionIds"] = [];
            for (let item of this.processDefinitionIds)
                data["processDefinitionIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionCreateException extends IPictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export class BusinessProcessDefinitionNotFoundException extends PictureparkBusinessException implements IBusinessProcessDefinitionNotFoundException {
    processDefinitionId?: string | undefined;

    constructor(data?: IBusinessProcessDefinitionNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.processDefinitionId = data["processDefinitionId"];
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        let result = new BusinessProcessDefinitionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefinitionId"] = this.processDefinitionId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionNotFoundException extends IPictureparkBusinessException {
    processDefinitionId?: string | undefined;
}

export class BusinessProcessNotFoundException extends PictureparkBusinessException implements IBusinessProcessNotFoundException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcessNotFoundException {
        let result = new BusinessProcessNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessNotFoundException extends IPictureparkBusinessException {
    businessProcessId?: string | undefined;
}

export class CustomerHostNotFoundException extends PictureparkException implements ICustomerHostNotFoundException {
    hostName?: string | undefined;

    constructor(data?: ICustomerHostNotFoundException) {
        super(data);
        this._discriminator = "CustomerHostNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.hostName = data["hostName"];
        }
    }

    static fromJS(data: any): CustomerHostNotFoundException {
        let result = new CustomerHostNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerHostNotFoundException extends IPictureparkException {
    hostName?: string | undefined;
}

export class CustomerNotFoundException extends PictureparkException implements ICustomerNotFoundException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotFoundException) {
        super(data);
        this._discriminator = "CustomerNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CustomerNotFoundException {
        let result = new CustomerNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerNotFoundException extends IPictureparkException {
    customerId?: string | undefined;
}

export class DocumentNotFoundException extends PictureparkBusinessException implements IDocumentNotFoundException {
    documentId?: string | undefined;

    constructor(data?: IDocumentNotFoundException) {
        super(data);
        this._discriminator = "DocumentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
        }
    }

    static fromJS(data: any): DocumentNotFoundException {
        let result = new DocumentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentNotFoundException extends IPictureparkBusinessException {
    documentId?: string | undefined;
}

export class DocumentVersionNotFoundException extends PictureparkBusinessException implements IDocumentVersionNotFoundException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;

    constructor(data?: IDocumentVersionNotFoundException) {
        super(data);
        this._discriminator = "DocumentVersionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
        }
    }

    static fromJS(data: any): DocumentVersionNotFoundException {
        let result = new DocumentVersionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentVersionNotFoundException extends IPictureparkBusinessException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export class DriveRequestException extends PictureparkBusinessException implements IDriveRequestException {

    constructor(data?: IDriveRequestException) {
        super(data);
        this._discriminator = "DriveRequestException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DriveRequestException {
        let result = new DriveRequestException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDriveRequestException extends IPictureparkBusinessException {
}

export class DuplicateRightException extends PictureparkBusinessException implements IDuplicateRightException {
    permissionSetId?: string | undefined;

    constructor(data?: IDuplicateRightException) {
        super(data);
        this._discriminator = "DuplicateRightException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permissionSetId = data["permissionSetId"];
        }
    }

    static fromJS(data: any): DuplicateRightException {
        let result = new DuplicateRightException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateRightException extends IPictureparkBusinessException {
    permissionSetId?: string | undefined;
}

export class DuplicateDocumentException extends PictureparkBusinessException implements IDuplicateDocumentException {
    documentId?: string | undefined;
    documentType?: string | undefined;

    constructor(data?: IDuplicateDocumentException) {
        super(data);
        this._discriminator = "DuplicateDocumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): DuplicateDocumentException {
        let result = new DuplicateDocumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateDocumentException extends IPictureparkBusinessException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export class DuplicateAggregatorException extends PictureparkBusinessException implements IDuplicateAggregatorException {
    aggregatorName?: string | undefined;

    constructor(data?: IDuplicateAggregatorException) {
        super(data);
        this._discriminator = "DuplicateAggregatorException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregatorName = data["aggregatorName"];
        }
    }

    static fromJS(data: any): DuplicateAggregatorException {
        let result = new DuplicateAggregatorException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateAggregatorException extends IPictureparkBusinessException {
    aggregatorName?: string | undefined;
}

export class FailedToLockException extends PictureparkBusinessException implements IFailedToLockException {
    resourceId?: string | undefined;

    constructor(data?: IFailedToLockException) {
        super(data);
        this._discriminator = "FailedToLockException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
        }
    }

    static fromJS(data: any): FailedToLockException {
        let result = new FailedToLockException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFailedToLockException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class IndexException extends PictureparkBusinessException implements IIndexException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexException) {
        super(data);
        this._discriminator = "IndexException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["indexName"];
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): IndexException {
        let result = new IndexException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class InvalidArgumentException extends PictureparkBusinessException implements IInvalidArgumentException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;

    constructor(data?: IInvalidArgumentException) {
        super(data);
        this._discriminator = "InvalidArgumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["argumentName"];
            this.argumentValue = data["argumentValue"];
        }
    }

    static fromJS(data: any): InvalidArgumentException {
        let result = new InvalidArgumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        data["argumentValue"] = this.argumentValue;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidArgumentException extends IPictureparkBusinessException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export class InvalidCustomerException extends PictureparkException implements IInvalidCustomerException {
    customerId?: string | undefined;

    constructor(data?: IInvalidCustomerException) {
        super(data);
        this._discriminator = "InvalidCustomerException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): InvalidCustomerException {
        let result = new InvalidCustomerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidCustomerException extends IPictureparkException {
    customerId?: string | undefined;
}

export class PictureparkInvalidMetadataException extends PictureparkBusinessException implements IPictureparkInvalidMetadataException {
    metadataErrors?: MetadataError[] | undefined;

    constructor(data?: IPictureparkInvalidMetadataException) {
        super(data);
        this._discriminator = "PictureparkInvalidMetadataException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["metadataErrors"] && data["metadataErrors"].constructor === Array) {
                this.metadataErrors = [];
                for (let item of data["metadataErrors"])
                    this.metadataErrors.push(MetadataError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PictureparkInvalidMetadataException {
        let result = new PictureparkInvalidMetadataException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.metadataErrors && this.metadataErrors.constructor === Array) {
            data["metadataErrors"] = [];
            for (let item of this.metadataErrors)
                data["metadataErrors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkInvalidMetadataException extends IPictureparkBusinessException {
    metadataErrors?: MetadataError[] | undefined;
}

export class MetadataError implements IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IMetadataError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorType = data["errorType"];
            this.lineNumber = data["lineNumber"];
            this.linePosition = data["linePosition"];
            this.path = data["path"];
            this.message = data["message"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataError {
        let result = new MetadataError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorType"] = this.errorType;
        data["lineNumber"] = this.lineNumber;
        data["linePosition"] = this.linePosition;
        data["path"] = this.path;
        data["message"] = this.message;
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

export interface IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidStateException extends PictureparkBusinessException implements IInvalidStateException {
    resourceId?: string | undefined;
    state?: string | undefined;

    constructor(data?: IInvalidStateException) {
        super(data);
        this._discriminator = "InvalidStateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): InvalidStateException {
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        let result = new InvalidStateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["state"] = this.state;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export class InvalidStateTransitionException extends InvalidStateException implements IInvalidStateTransitionException {
    transition?: string | undefined;

    constructor(data?: IInvalidStateTransitionException) {
        super(data);
        this._discriminator = "InvalidStateTransitionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transition = data["transition"];
        }
    }

    static fromJS(data: any): InvalidStateTransitionException {
        let result = new InvalidStateTransitionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transition"] = this.transition;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateTransitionException extends IInvalidStateException {
    transition?: string | undefined;
}

export class InvalidUserOrPasswordException extends PictureparkException implements IInvalidUserOrPasswordException {
    customerId?: string | undefined;

    constructor(data?: IInvalidUserOrPasswordException) {
        super(data);
        this._discriminator = "InvalidUserOrPasswordException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): InvalidUserOrPasswordException {
        let result = new InvalidUserOrPasswordException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidUserOrPasswordException extends IPictureparkException {
    customerId?: string | undefined;
}

export class PictureparkMappingException extends PictureparkBusinessException implements IPictureparkMappingException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IPictureparkMappingException) {
        super(data);
        this._discriminator = "PictureparkMappingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["indexName"];
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): PictureparkMappingException {
        let result = new PictureparkMappingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkMappingException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class MessagePerformerTaskCanceledException extends PictureparkException implements IMessagePerformerTaskCanceledException {
    messageId?: string | undefined;
    customerId?: string | undefined;

    constructor(data?: IMessagePerformerTaskCanceledException) {
        super(data);
        this._discriminator = "MessagePerformerTaskCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.messageId = data["messageId"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): MessagePerformerTaskCanceledException {
        let result = new MessagePerformerTaskCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IMessagePerformerTaskCanceledException extends IPictureparkException {
    messageId?: string | undefined;
    customerId?: string | undefined;
}

export class NotFoundException extends PictureparkBusinessException implements INotFoundException {
    reference?: string | undefined;

    constructor(data?: INotFoundException) {
        super(data);
        this._discriminator = "NotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.reference = data["reference"];
        }
    }

    static fromJS(data: any): NotFoundException {
        let result = new NotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data; 
    }
}

export interface INotFoundException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class ObjectStoreException extends PictureparkBusinessException implements IObjectStoreException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreException) {
        super(data);
        this._discriminator = "ObjectStoreException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["rowErrorMessages"];
            this.errorMessage = data["errorMessage"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ObjectStoreException {
        let result = new ObjectStoreException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["errorMessage"] = this.errorMessage;
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
    message?: string | undefined;
}

export class ObjectStoreResponseException extends PictureparkBusinessException implements IObjectStoreResponseException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreResponseException) {
        super(data);
        this._discriminator = "ObjectStoreResponseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["rowErrorMessages"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ObjectStoreResponseException {
        let result = new ObjectStoreResponseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreResponseException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export class PictureparkOperationCanceledException extends PictureparkBusinessException implements IPictureparkOperationCanceledException {
    cancellationToken?: string | undefined;

    constructor(data?: IPictureparkOperationCanceledException) {
        super(data);
        this._discriminator = "PictureparkOperationCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cancellationToken = data["cancellationToken"];
        }
    }

    static fromJS(data: any): PictureparkOperationCanceledException {
        let result = new PictureparkOperationCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cancellationToken"] = this.cancellationToken;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkOperationCanceledException extends IPictureparkBusinessException {
    cancellationToken?: string | undefined;
}

export class OperationTimeoutException extends PictureparkBusinessException implements IOperationTimeoutException {
    messageId?: string | undefined;

    constructor(data?: IOperationTimeoutException) {
        super(data);
        this._discriminator = "OperationTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.messageId = data["messageId"];
        }
    }

    static fromJS(data: any): OperationTimeoutException {
        let result = new OperationTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOperationTimeoutException extends IPictureparkBusinessException {
    messageId?: string | undefined;
}

export class OutputNotFoundException extends PictureparkBusinessException implements IOutputNotFoundException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputNotFoundException) {
        super(data);
        this._discriminator = "OutputNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
        }
    }

    static fromJS(data: any): OutputNotFoundException {
        let result = new OutputNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class PermissionException extends PictureparkBusinessException implements IPermissionException {
    permission?: string | undefined;
    operation?: string | undefined;

    constructor(data?: IPermissionException) {
        super(data);
        this._discriminator = "PermissionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permission = data["permission"];
            this.operation = data["operation"];
        }
    }

    static fromJS(data: any): PermissionException {
        let result = new PermissionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["operation"] = this.operation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionException extends IPictureparkBusinessException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export class QueryException extends PictureparkBusinessException implements IQueryException {
    debugInformation?: string | undefined;

    constructor(data?: IQueryException) {
        super(data);
        this._discriminator = "QueryException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): QueryException {
        let result = new QueryException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IQueryException extends IPictureparkBusinessException {
    debugInformation?: string | undefined;
}

export class RenderingException extends PictureparkBusinessException implements IRenderingException {

    constructor(data?: IRenderingException) {
        super(data);
        this._discriminator = "RenderingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingException {
        let result = new RenderingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingException extends IPictureparkBusinessException {
}

export class RenderingJobItemNotSetException extends PictureparkBusinessException implements IRenderingJobItemNotSetException {

    constructor(data?: IRenderingJobItemNotSetException) {
        super(data);
        this._discriminator = "RenderingJobItemNotSetException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingJobItemNotSetException {
        let result = new RenderingJobItemNotSetException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingJobItemNotSetException extends IPictureparkBusinessException {
}

export class ServiceProviderCreateException extends PictureparkException implements IServiceProviderCreateException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderCreateException) {
        super(data);
        this._discriminator = "ServiceProviderCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userId = data["userId"];
            this.externalId = data["externalId"];
            this.virtualHost = data["virtualHost"];
            this.detailErrorMessage = data["detailErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderCreateException {
        let result = new ServiceProviderCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["externalId"] = this.externalId;
        data["virtualHost"] = this.virtualHost;
        data["detailErrorMessage"] = this.detailErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderCreateException extends IPictureparkException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export class ServiceProviderDeleteException extends PictureparkException implements IServiceProviderDeleteException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderDeleteException) {
        super(data);
        this._discriminator = "ServiceProviderDeleteException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serviceProviderId = data["serviceProviderId"];
            this.detailedErrorMessage = data["detailedErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderDeleteException {
        let result = new ServiceProviderDeleteException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["detailedErrorMessage"] = this.detailedErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderDeleteException extends IPictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export class ServiceProviderNotFoundException extends PictureparkException implements IServiceProviderNotFoundException {
    missingServiceProviderId?: string | undefined;

    constructor(data?: IServiceProviderNotFoundException) {
        super(data);
        this._discriminator = "ServiceProviderNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingServiceProviderId = data["missingServiceProviderId"];
        }
    }

    static fromJS(data: any): ServiceProviderNotFoundException {
        let result = new ServiceProviderNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingServiceProviderId"] = this.missingServiceProviderId;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderNotFoundException extends IPictureparkException {
    missingServiceProviderId?: string | undefined;
}

export class TokenValidationException extends PictureparkBusinessException implements ITokenValidationException {

    constructor(data?: ITokenValidationException) {
        super(data);
        this._discriminator = "TokenValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TokenValidationException {
        let result = new TokenValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITokenValidationException extends IPictureparkBusinessException {
}

export class UnknownException extends PictureparkBusinessException implements IUnknownException {
    exceptionDetail?: string | undefined;

    constructor(data?: IUnknownException) {
        super(data);
        this._discriminator = "UnknownException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.exceptionDetail = data["exceptionDetail"];
        }
    }

    static fromJS(data: any): UnknownException {
        let result = new UnknownException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionDetail"] = this.exceptionDetail;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnknownException extends IPictureparkBusinessException {
    exceptionDetail?: string | undefined;
}

export class UserNotFoundException extends PictureparkBusinessException implements IUserNotFoundException {
    missingUserId?: string | undefined;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this._discriminator = "UserNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingUserId = data["missingUserId"];
        }
    }

    static fromJS(data: any): UserNotFoundException {
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingUserId"] = this.missingUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserNotFoundException extends IPictureparkBusinessException {
    missingUserId?: string | undefined;
}

export class UserPermanentlyRemovedException extends PictureparkBusinessException implements IUserPermanentlyRemovedException {
    removedUserId?: string | undefined;

    constructor(data?: IUserPermanentlyRemovedException) {
        super(data);
        this._discriminator = "UserPermanentlyRemovedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.removedUserId = data["removedUserId"];
        }
    }

    static fromJS(data: any): UserPermanentlyRemovedException {
        let result = new UserPermanentlyRemovedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["removedUserId"] = this.removedUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserPermanentlyRemovedException extends IPictureparkBusinessException {
    removedUserId?: string | undefined;
}

export class UserRoleAssignedException extends PictureparkBusinessException implements IUserRoleAssignedException {
    userRoleId?: string | undefined;

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this._discriminator = "UserRoleAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userRoleId = data["userRoleId"];
        }
    }

    static fromJS(data: any): UserRoleAssignedException {
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRoleAssignedException extends IPictureparkBusinessException {
    userRoleId?: string | undefined;
}

export class UserRolesRightsAssignedException extends PictureparkBusinessException implements IUserRolesRightsAssignedException {
    contentPermissionSetId?: string | undefined;

    constructor(data?: IUserRolesRightsAssignedException) {
        super(data);
        this._discriminator = "UserRolesRightsAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentPermissionSetId = data["contentPermissionSetId"];
        }
    }

    static fromJS(data: any): UserRolesRightsAssignedException {
        let result = new UserRolesRightsAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentPermissionSetId"] = this.contentPermissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRolesRightsAssignedException extends IPictureparkBusinessException {
    contentPermissionSetId?: string | undefined;
}

export class ContentsOwnershipTransferRequest implements IContentsOwnershipTransferRequest {
    /** The content ids. */
    contentIds?: string[] | undefined;
    /** The id of user to whom the content documents have to be transfered to. */
    transferUserId?: string | undefined;

    constructor(data?: IContentsOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.transferUserId = data["transferUserId"];
        }
    }

    static fromJS(data: any): ContentsOwnershipTransferRequest {
        let result = new ContentsOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["transferUserId"] = this.transferUserId;
        return data; 
    }
}

export interface IContentsOwnershipTransferRequest {
    /** The content ids. */
    contentIds?: string[] | undefined;
    /** The id of user to whom the content documents have to be transfered to. */
    transferUserId?: string | undefined;
}

export class BusinessProcess implements IBusinessProcess {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    notificationId?: string | undefined;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCylce;
    startDate: Date;
    endDate: Date;
    stateHistory?: BusinessProcessStateItem[] | undefined;
    processDefinitionName?: string | undefined;
    currentState?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcess";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.processDefinitionId = data["processDefinitionId"];
            this.referenceId = data["referenceId"];
            this.referenceDocType = data["referenceDocType"];
            this.notificationId = data["notificationId"];
            this.businessProcessScope = data["businessProcessScope"];
            this.lifeCycle = data["lifeCycle"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            if (data["stateHistory"] && data["stateHistory"].constructor === Array) {
                this.stateHistory = [];
                for (let item of data["stateHistory"])
                    this.stateHistory.push(BusinessProcessStateItem.fromJS(item));
            }
            this.processDefinitionName = data["processDefinitionName"];
            this.currentState = data["currentState"];
        }
    }

    static fromJS(data: any): BusinessProcess {
        if (data["kind"] === "BusinessProcessBulkResponse") {
            let result = new BusinessProcessBulkResponse();
            result.init(data);
            return result;
        }
        let result = new BusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["processDefinitionId"] = this.processDefinitionId;
        data["referenceId"] = this.referenceId;
        data["referenceDocType"] = this.referenceDocType;
        data["notificationId"] = this.notificationId;
        data["businessProcessScope"] = this.businessProcessScope;
        data["lifeCycle"] = this.lifeCycle;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (this.stateHistory && this.stateHistory.constructor === Array) {
            data["stateHistory"] = [];
            for (let item of this.stateHistory)
                data["stateHistory"].push(item.toJSON());
        }
        data["processDefinitionName"] = this.processDefinitionName;
        data["currentState"] = this.currentState;
        return data; 
    }
}

export interface IBusinessProcess {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    notificationId?: string | undefined;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCylce;
    startDate: Date;
    endDate: Date;
    stateHistory?: BusinessProcessStateItem[] | undefined;
    processDefinitionName?: string | undefined;
    currentState?: string | undefined;
}

export enum BusinessProcessScope {
    System = <any>"System", 
    User = <any>"User", 
}

export enum BusinessProcessLifeCylce {
    Draft = <any>"Draft", 
    Started = <any>"Started", 
    Ended = <any>"Ended", 
    Cancelled = <any>"Cancelled", 
}

export class BusinessProcessStateItem implements IBusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: ErrorResponse | undefined;

    constructor(data?: IBusinessProcessStateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.error = data["error"] ? ErrorResponse.fromJS(data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessStateItem {
        let result = new BusinessProcessStateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: ErrorResponse | undefined;
}

export class ErrorResponse implements IErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exception = data["exception"];
            this.traceId = data["traceId"];
            this.traceJobId = data["traceJobId"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exception"] = this.exception;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        return data; 
    }
}

export interface IErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
}

export class BusinessProcessBulkResponse extends BusinessProcess implements IBusinessProcessBulkResponse {
    response?: BulkResponse | undefined;

    constructor(data?: IBusinessProcessBulkResponse) {
        super(data);
        this._discriminator = "BusinessProcessBulkResponse";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.response = data["response"] ? BulkResponse.fromJS(data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessBulkResponse {
        let result = new BusinessProcessBulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessBulkResponse extends IBusinessProcess {
    response?: BulkResponse | undefined;
}

export class BulkResponse implements IBulkResponse {
    rows?: BulkResponseRow[] | undefined;

    constructor(data?: IBulkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["rows"] && data["rows"].constructor === Array) {
                this.rows = [];
                for (let item of data["rows"])
                    this.rows.push(BulkResponseRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkResponse {
        let result = new BulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rows && this.rows.constructor === Array) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBulkResponse {
    rows?: BulkResponseRow[] | undefined;
}

export class BulkResponseRow implements IBulkResponseRow {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;

    constructor(data?: IBulkResponseRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.version = data["version"];
            this.error = data["error"];
            this.reason = data["reason"];
            this.succeeded = data["succeeded"];
        }
    }

    static fromJS(data: any): BulkResponseRow {
        let result = new BulkResponseRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["error"] = this.error;
        data["reason"] = this.reason;
        data["succeeded"] = this.succeeded;
        return data; 
    }
}

export interface IBulkResponseRow {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;
}

export class ContentAggregationRequest implements IContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IContentAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.channelId = data["channelId"];
            this.displayLanguage = data["displayLanguage"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["collectionId"];
            this.lifeCycleFilter = data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): ContentAggregationRequest {
        let result = new ContentAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["channelId"] = this.channelId;
        data["displayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** The FilterBase is the base class for all filters. */
export class FilterBase implements IFilterBase {

    protected _discriminator: string;

    getDisplayName(locale: string): string | null {
        return null;
    }

    constructor(data?: IFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FilterBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): FilterBase {
        if (data["kind"] === "AggregationFilter") {
            let result = new AggregationFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AndFilter") {
            let result = new AndFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrFilter") {
            let result = new OrFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFilter") {
            let result = new NotFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DateRangeFilter") {
            let result = new DateRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ExistsFilter") {
            let result = new ExistsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoBoundingBoxFilter") {
            let result = new GeoBoundingBoxFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceFilter") {
            let result = new GeoDistanceFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceRangeFilter") {
            let result = new GeoDistanceRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedFilter") {
            let result = new NestedFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeFilter") {
            let result = new NumericRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PrefixFilter") {
            let result = new PrefixFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermFilter") {
            let result = new TermFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsFilter") {
            let result = new TermsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChildFilter") {
            let result = new ChildFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ParentFilter") {
            let result = new ParentFilter();
            result.init(data);
            return result;
        }
        let result = new FilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

/** The FilterBase is the base class for all filters. */
export interface IFilterBase {
}

export class AndFilter extends FilterBase implements IAndFilter {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IAndFilter) {
        super(data);
        this._discriminator = "AndFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AndFilter {
        let result = new AndFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAndFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

export class OrFilter extends FilterBase implements IOrFilter {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IOrFilter) {
        super(data);
        this._discriminator = "OrFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrFilter {
        let result = new OrFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOrFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

export class NotFilter extends FilterBase implements INotFilter {
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: INotFilter) {
        super(data);
        this._discriminator = "NotFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotFilter {
        let result = new NotFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface INotFilter extends IFilterBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

export class DateRangeFilter extends FilterBase implements IDateRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange | undefined;

    getDisplayName(locale: string) {
        return this.range && this.range.names ? this.range.names.translate(locale) : "n/a";
    }

    constructor(data?: IDateRangeFilter) {
        super(data);
        this._discriminator = "DateRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.range = data["range"] ? DateRange.fromJS(data["range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeFilter {
        let result = new DateRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDateRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange | undefined;
}

/** The date range class used in aggregators and filters. */
export class DateRange implements IDateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): DateRange {
        let result = new DateRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

/** The date range class used in aggregators and filters. */
export interface IDateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

export class TranslatedStringDictionary implements ITranslatedStringDictionary {

    [key: string]: string | any; 

    translate(locale: string) {
        let language = locale.split("-")[0];
        return this[language] ? this[language] : this[Object.keys(this)[0]];
    }

    constructor(data?: ITranslatedStringDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): TranslatedStringDictionary {
        let result = new TranslatedStringDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface ITranslatedStringDictionary {

    [key: string]: string | any; 
}

export class ExistsFilter extends FilterBase implements IExistsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;

    constructor(data?: IExistsFilter) {
        super(data);
        this._discriminator = "ExistsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
        }
    }

    static fromJS(data: any): ExistsFilter {
        let result = new ExistsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        super.toJSON(data);
        return data; 
    }
}

export interface IExistsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
}

export class GeoBoundingBoxFilter extends FilterBase implements IGeoBoundingBoxFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation | undefined;

    constructor(data?: IGeoBoundingBoxFilter) {
        super(data);
        this._discriminator = "GeoBoundingBoxFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.topLeft = data["topLeft"] ? GeoLocation.fromJS(data["topLeft"]) : <any>undefined;
            this.bottomRight = data["bottomRight"] ? GeoLocation.fromJS(data["bottomRight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeoBoundingBoxFilter {
        let result = new GeoBoundingBoxFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["topLeft"] = this.topLeft ? this.topLeft.toJSON() : <any>undefined;
        data["bottomRight"] = this.bottomRight ? this.bottomRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IGeoBoundingBoxFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation | undefined;
}

export class GeoLocation implements IGeoLocation {
    lat: number;
    lon: number;

    constructor(data?: IGeoLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["lat"];
            this.lon = data["lon"];
        }
    }

    static fromJS(data: any): GeoLocation {
        let result = new GeoLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data; 
    }
}

export interface IGeoLocation {
    lat: number;
    lon: number;
}

export class GeoDistanceFilter extends FilterBase implements IGeoDistanceFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;

    constructor(data?: IGeoDistanceFilter) {
        super(data);
        this._discriminator = "GeoDistanceFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : <any>undefined;
            this.distance = data["distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        super.toJSON(data);
        return data; 
    }
}

export interface IGeoDistanceFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;
}

export class GeoDistanceRangeFilter extends FilterBase implements IGeoDistanceRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The numeric range. */
    range?: NumericRange | undefined;

    constructor(data?: IGeoDistanceRangeFilter) {
        super(data);
        this._discriminator = "GeoDistanceRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : <any>undefined;
            this.range = data["range"] ? NumericRange.fromJS(data["range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeoDistanceRangeFilter {
        let result = new GeoDistanceRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IGeoDistanceRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The numeric range. */
    range?: NumericRange | undefined;
}

export class NumericRange implements INumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): NumericRange {
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

export interface INumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

export class NestedFilter extends FilterBase implements INestedFilter {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: INestedFilter) {
        super(data);
        this._discriminator = "NestedFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["path"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NestedFilter {
        let result = new NestedFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface INestedFilter extends IFilterBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

export class NumericRangeFilter extends FilterBase implements INumericRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: NumericRange | undefined;

    constructor(data?: INumericRangeFilter) {
        super(data);
        this._discriminator = "NumericRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.range = data["range"] ? NumericRange.fromJS(data["range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NumericRangeFilter {
        let result = new NumericRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface INumericRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: NumericRange | undefined;
}

export class PrefixFilter extends FilterBase implements IPrefixFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;

    constructor(data?: IPrefixFilter) {
        super(data);
        this._discriminator = "PrefixFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.prefix = data["prefix"];
        }
    }

    static fromJS(data: any): PrefixFilter {
        let result = new PrefixFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["prefix"] = this.prefix;
        super.toJSON(data);
        return data; 
    }
}

export interface IPrefixFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;
}

export class TermFilter extends FilterBase implements ITermFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;

    constructor(data?: ITermFilter) {
        super(data);
        this._discriminator = "TermFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.term = data["term"];
        }
    }

    static fromJS(data: any): TermFilter {
        let result = new TermFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["term"] = this.term;
        super.toJSON(data);
        return data; 
    }
}

export interface ITermFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;
}

export class TermsFilter extends FilterBase implements ITermsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;

    constructor(data?: ITermsFilter) {
        super(data);
        this._discriminator = "TermsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["terms"] && data["terms"].constructor === Array) {
                this.terms = [];
                for (let item of data["terms"])
                    this.terms.push(item);
            }
        }
    }

    static fromJS(data: any): TermsFilter {
        let result = new TermsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.terms && this.terms.constructor === Array) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITermsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export class AggregationFilter extends FilterBase implements IAggregationFilter {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceRangeFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;

    constructor(data?: IAggregationFilter) {
        super(data);
        this._discriminator = "AggregationFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregationName = data["aggregationName"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.temporaryAggregatorRequestId = data["temporaryAggregatorRequestId"];
        }
    }

    static fromJS(data: any): AggregationFilter {
        let result = new AggregationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["temporaryAggregatorRequestId"] = this.temporaryAggregatorRequestId;
        super.toJSON(data);
        return data; 
    }
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export interface IAggregationFilter extends IFilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceRangeFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;
}

export class ChildFilter extends FilterBase implements IChildFilter {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;

    constructor(data?: IChildFilter) {
        super(data);
        this._discriminator = "ChildFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.childType = data["childType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChildFilter {
        let result = new ChildFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childType"] = this.childType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IChildFilter extends IFilterBase {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

export class ParentFilter extends FilterBase implements IParentFilter {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;

    constructor(data?: IParentFilter) {
        super(data);
        this._discriminator = "ParentFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentType = data["parentType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParentFilter {
        let result = new ParentFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentType"] = this.parentType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IParentFilter extends IFilterBase {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

/** The AggregatorBase is the base class for all aggregators. */
export class AggregatorBase implements IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;

    protected _discriminator: string;

    constructor(data?: IAggregatorBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AggregatorBase";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregatorBase {
        if (data["kind"] === "DateRangeAggregator") {
            let result = new DateRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FilterAggregator") {
            let result = new FilterAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceAggregator") {
            let result = new GeoDistanceAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedAggregator") {
            let result = new NestedAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeAggregator") {
            let result = new NumericRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsAggregator") {
            let result = new TermsAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new AggregatorBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        return data; 
    }
}

/** The AggregatorBase is the base class for all aggregators. */
export interface IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
}

export class DateRangeAggregator extends AggregatorBase implements IDateRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRange[] | undefined;

    constructor(data?: IDateRangeAggregator) {
        super(data);
        this._discriminator = "DateRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(DateRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateRangeAggregator {
        let result = new DateRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDateRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRange[] | undefined;
}

export class FilterAggregator extends AggregatorBase implements IFilterAggregator {
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFilterAggregator) {
        super(data);
        this._discriminator = "FilterAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FilterAggregator {
        let result = new FilterAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFilterAggregator extends IAggregatorBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

export class GeoDistanceAggregator extends AggregatorBase implements IGeoDistanceAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: NumericRange[] | undefined;

    constructor(data?: IGeoDistanceAggregator) {
        super(data);
        this._discriminator = "GeoDistanceAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : <any>undefined;
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(NumericRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeoDistanceAggregator {
        let result = new GeoDistanceAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IGeoDistanceAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: NumericRange[] | undefined;
}

export class NestedAggregator extends AggregatorBase implements INestedAggregator {
    /** The path pointing to the nested object. */
    path?: string | undefined;

    constructor(data?: INestedAggregator) {
        super(data);
        this._discriminator = "NestedAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["path"];
        }
    }

    static fromJS(data: any): NestedAggregator {
        let result = new NestedAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        super.toJSON(data);
        return data; 
    }
}

export interface INestedAggregator extends IAggregatorBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
}

export class NumericRangeAggregator extends AggregatorBase implements INumericRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: NumericRange[] | undefined;

    constructor(data?: INumericRangeAggregator) {
        super(data);
        this._discriminator = "NumericRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(NumericRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NumericRangeAggregator {
        let result = new NumericRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface INumericRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: NumericRange[] | undefined;
}

export class TermsAggregator extends AggregatorBase implements ITermsAggregator {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;

    constructor(data?: ITermsAggregator) {
        super(data);
        this._discriminator = "TermsAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.size = data["size"];
            if (data["includes"] && data["includes"].constructor === Array) {
                this.includes = [];
                for (let item of data["includes"])
                    this.includes.push(item);
            }
            if (data["excludes"] && data["excludes"].constructor === Array) {
                this.excludes = [];
                for (let item of data["excludes"])
                    this.excludes.push(item);
            }
        }
    }

    static fromJS(data: any): TermsAggregator {
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new TermsAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["size"] = this.size;
        if (this.includes && this.includes.constructor === Array) {
            data["includes"] = [];
            for (let item of this.includes)
                data["includes"].push(item);
        }
        if (this.excludes && this.excludes.constructor === Array) {
            data["excludes"] = [];
            for (let item of this.excludes)
                data["excludes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITermsAggregator extends IAggregatorBase {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
}

export class TermsRelationAggregator extends TermsAggregator implements ITermsRelationAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;

    constructor(data?: ITermsRelationAggregator) {
        super(data);
        this._discriminator = "TermsRelationAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): TermsRelationAggregator {
        let result = new TermsRelationAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

export interface ITermsRelationAggregator extends ITermsAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    Schema = <any>"Schema", 
    User = <any>"User", 
    ContentPermissionSet = <any>"ContentPermissionSet", 
}

export class TermsEnumAggregator extends TermsAggregator implements ITermsEnumAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;

    constructor(data?: ITermsEnumAggregator) {
        super(data);
        this._discriminator = "TermsEnumAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.enumType = data["enumType"];
        }
    }

    static fromJS(data: any): TermsEnumAggregator {
        let result = new TermsEnumAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumType"] = this.enumType;
        super.toJSON(data);
        return data; 
    }
}

export interface ITermsEnumAggregator extends ITermsAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly", 
    All = <any>"All", 
    InactiveOnly = <any>"InactiveOnly", 
}

export class ObjectAggregationResult implements IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: IObjectAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectAggregationResult {
        let result = new ObjectAggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[] | undefined;
}

export class AggregationResult implements IAggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: AggregationResultItem[] | undefined;

    constructor(data?: IAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.sumOtherDocCount = data["sumOtherDocCount"];
            this.temporaryRequestId = data["temporaryRequestId"];
            if (data["aggregationResultItems"] && data["aggregationResultItems"].constructor === Array) {
                this.aggregationResultItems = [];
                for (let item of data["aggregationResultItems"])
                    this.aggregationResultItems.push(AggregationResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResult {
        let result = new AggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sumOtherDocCount"] = this.sumOtherDocCount;
        data["temporaryRequestId"] = this.temporaryRequestId;
        if (this.aggregationResultItems && this.aggregationResultItems.constructor === Array) {
            data["aggregationResultItems"] = [];
            for (let item of this.aggregationResultItems)
                data["aggregationResultItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: AggregationResultItem[] | undefined;
}

export class AggregationResultItem implements IAggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: AggregationResult[] | undefined;

    getDisplayName(locale: string) {
      let displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null; 
      return displayName ? displayName : this.name;
    }

    constructor(data?: IAggregationResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.count = data["count"];
            this.filter = data["filter"] ? AggregationFilter.fromJS(data["filter"]) : <any>undefined;
            this.active = data["active"];
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResultItem {
        let result = new AggregationResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["count"] = this.count;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["active"] = this.active;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: AggregationResult[] | undefined;
}

export class ContentBatchDownloadRequest implements IContentBatchDownloadRequest {
    contents?: ContentDownloadItem[] | undefined;

    constructor(data?: IContentBatchDownloadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contents"] && data["contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["contents"])
                    this.contents.push(ContentDownloadItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentBatchDownloadRequest {
        let result = new ContentBatchDownloadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contents && this.contents.constructor === Array) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContentBatchDownloadRequest {
    contents?: ContentDownloadItem[] | undefined;
}

export class ContentDownloadItem implements IContentDownloadItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IContentDownloadItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
        }
    }

    static fromJS(data: any): ContentDownloadItem {
        let result = new ContentDownloadItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        return data; 
    }
}

export interface IContentDownloadItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class DownloadItem implements IDownloadItem {

    constructor(data?: IDownloadItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): DownloadItem {
        let result = new DownloadItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IDownloadItem {
}

export class ContentBatchDownloadItem extends DownloadItem implements IContentBatchDownloadItem {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;

    constructor(data?: IContentBatchDownloadItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.downloadToken = data["downloadToken"];
            this.downloadUrl = data["downloadUrl"];
        }
    }

    static fromJS(data: any): ContentBatchDownloadItem {
        let result = new ContentBatchDownloadItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadToken"] = this.downloadToken;
        data["downloadUrl"] = this.downloadUrl;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentBatchDownloadItem extends IDownloadItem {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;
}

/** A request structure for creating a content document. */
export class CreateContentRequest implements ICreateContentRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: ICreateContentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"];
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateContentRequest {
        let result = new CreateContentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

/** A request structure for creating a content document. */
export interface ICreateContentRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;
}

export enum ThumbnailSize {
    Small = <any>"Small", 
    Medium = <any>"Medium", 
    Large = <any>"Large", 
}

export class UpdateContentPermissionsRequest implements IUpdateContentPermissionsRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IUpdateContentPermissionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateContentPermissionsRequest {
        let result = new UpdateContentPermissionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateContentPermissionsRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class ContentSearchRequest implements IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;

    constructor(data?: IContentSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["channelIds"] && data["channelIds"].constructor === Array) {
                this.channelIds = [];
                for (let item of data["channelIds"])
                    this.channelIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["collectionId"];
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.lifeCycleFilter = data["lifeCycleFilter"];
            if (data["rightsFilter"] && data["rightsFilter"].constructor === Array) {
                this.rightsFilter = [];
                for (let item of data["rightsFilter"])
                    this.rightsFilter.push(item);
            }
        }
    }

    static fromJS(data: any): ContentSearchRequest {
        let result = new ContentSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.channelIds && this.channelIds.constructor === Array) {
            data["channelIds"] = [];
            for (let item of this.channelIds)
                data["channelIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        if (this.rightsFilter && this.rightsFilter.constructor === Array) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        return data; 
    }
}

export interface IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
}

export class SortInfo implements ISortInfo {
    field?: string | undefined;
    direction: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): SortInfo {
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface ISortInfo {
    field?: string | undefined;
    direction: SortDirection;
}

export enum SortDirection {
    Asc = <any>"Asc", 
    Desc = <any>"Desc", 
}

export enum ContentRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Update = <any>"Update", 
    Manage = <any>"Manage", 
    Trash = <any>"Trash", 
}

export class BaseResultOfContent implements IBaseResultOfContent {
    totalResults: number;
    results?: Content[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Content.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfContent {
        let result = new BaseResultOfContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfContent {
    totalResults: number;
    results?: Content[] | undefined;
    pageToken?: string | undefined;
}

export class ContentSearchResult extends BaseResultOfContent implements IContentSearchResult {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;

    constructor(data?: IContentSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ContentSearchResult {
        let result = new ContentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentSearchResult extends IBaseResultOfContent {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;
}

export class Content implements IContent {
    audit?: StoreAudit | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["displayValues"]) {
                this.displayValues = {};
                for (let key in data["displayValues"]) {
                    if (data["displayValues"].hasOwnProperty(key))
                        this.displayValues[key] = data["displayValues"][key];
                }
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Content {
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayValues) {
            data["displayValues"] = {};
            for (let key in this.displayValues) {
                if (this.displayValues.hasOwnProperty(key))
                    data["displayValues"][key] = this.displayValues[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IContent {
    audit?: StoreAudit | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;
}

export class ContentFileUpdateRequest implements IContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;

    constructor(data?: IContentFileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.fileTransferId = data["fileTransferId"];
        }
    }

    static fromJS(data: any): ContentFileUpdateRequest {
        let result = new ContentFileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["fileTransferId"] = this.fileTransferId;
        return data; 
    }
}

export interface IContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;
}

export class UpdateContentMetadataRequest implements IUpdateContentMetadataRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: DataDictionary | undefined;

    constructor(data?: IUpdateContentMetadataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateContentMetadataRequest {
        let result = new UpdateContentMetadataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateContentMetadataRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: DataDictionary | undefined;
}

export class ContentDeactivationRequest implements IContentDeactivationRequest {
    contentIds?: string[] | undefined;

    constructor(data?: IContentDeactivationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentDeactivationRequest {
        let result = new ContentDeactivationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        return data; 
    }
}

export interface IContentDeactivationRequest {
    contentIds?: string[] | undefined;
}

export class ContentReactivationRequest implements IContentReactivationRequest {
    contentIds?: string[] | undefined;

    constructor(data?: IContentReactivationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentReactivationRequest {
        let result = new ContentReactivationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        return data; 
    }
}

export interface IContentReactivationRequest {
    contentIds?: string[] | undefined;
}

export class MetadataValuesChangeRequestBase implements IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeRequestBase";
    }

    init(data?: any) {
        if (data) {
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MetadataValuesChangeRequestBase {
        if (data["kind"] === "ContentsMetadataUpdateRequest") {
            let result = new ContentsMetadataUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FilterContentsMetadataUpdateRequest") {
            let result = new FilterContentsMetadataUpdateRequest();
            result.init(data);
            return result;
        }
        let result = new MetadataValuesChangeRequestBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
}

export class ContentsMetadataUpdateRequest extends MetadataValuesChangeRequestBase implements IContentsMetadataUpdateRequest {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;

    constructor(data?: IContentsMetadataUpdateRequest) {
        super(data);
        this._discriminator = "ContentsMetadataUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentsMetadataUpdateRequest {
        let result = new ContentsMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentsMetadataUpdateRequest extends IMetadataValuesChangeRequestBase {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;
}

/** The base class for metadata value change commands. */
export class MetadataValuesChangeCommandBase implements IMetadataValuesChangeCommandBase {

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeCommandBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeCommandBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): MetadataValuesChangeCommandBase {
        if (data["kind"] === "MetadataValuesSchemaUpdateCommand") {
            let result = new MetadataValuesSchemaUpdateCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaUpsertCommand") {
            let result = new MetadataValuesSchemaUpsertCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaRemoveCommand") {
            let result = new MetadataValuesSchemaRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesFieldRemoveCommand") {
            let result = new MetadataValuesFieldRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemAddCommand") {
            let result = new MetadataValuesSchemaItemAddCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemRemoveCommand") {
            let result = new MetadataValuesSchemaItemRemoveCommand();
            result.init(data);
            return result;
        }
        let result = new MetadataValuesChangeCommandBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

/** The base class for metadata value change commands. */
export interface IMetadataValuesChangeCommandBase {
}

/** Updates schema values. */
export class MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpdateCommand {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;

    constructor(data?: IMetadataValuesSchemaUpdateCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpdateCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        let result = new MetadataValuesSchemaUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Updates schema values. */
export interface IMetadataValuesSchemaUpdateCommand extends IMetadataValuesChangeCommandBase {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;
}

/** Adds or updates schema values. */
export class MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpsertCommand {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;

    constructor(data?: IMetadataValuesSchemaUpsertCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpsertCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        let result = new MetadataValuesSchemaUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Adds or updates schema values. */
export interface IMetadataValuesSchemaUpsertCommand extends IMetadataValuesChangeCommandBase {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;
}

/** Removes schema values. */
export class MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaRemoveCommand {
    /** The id of the schema with type layer to be removed. */
    schemaId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        let result = new MetadataValuesSchemaRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

/** Removes schema values. */
export interface IMetadataValuesSchemaRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The id of the schema with type layer to be removed. */
    schemaId?: string | undefined;
}

/** Removes a field and its value from the schema values. */
export class MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesFieldRemoveCommand {
    /** The fully qualified field name of the field to be removed, e.g. "Data.SchemaId.FieldId". */
    fieldNamespace?: string | undefined;

    constructor(data?: IMetadataValuesFieldRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesFieldRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldNamespace = data["fieldNamespace"];
        }
    }

    static fromJS(data: any): MetadataValuesFieldRemoveCommand {
        let result = new MetadataValuesFieldRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldNamespace"] = this.fieldNamespace;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a field and its value from the schema values. */
export interface IMetadataValuesFieldRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The fully qualified field name of the field to be removed, e.g. "Data.SchemaId.FieldId". */
    fieldNamespace?: string | undefined;
}

/** Adds a list item id reference to a multi tagbox. */
export class MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemAddCommand {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaItemAddCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemAddCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldNamespace = data["fieldNamespace"];
            this.referenceId = data["referenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        let result = new MetadataValuesSchemaItemAddCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Adds a list item id reference to a multi tagbox. */
export interface IMetadataValuesSchemaItemAddCommand extends IMetadataValuesChangeCommandBase {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;
}

/** Removes a list item id reference from a multi tagbox. */
export class MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemRemoveCommand {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaItemRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldNamespace = data["fieldNamespace"];
            this.referenceId = data["referenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        let result = new MetadataValuesSchemaItemRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a list item id reference from a multi tagbox. */
export interface IMetadataValuesSchemaItemRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;
}

export class FilterContentsMetadataUpdateRequest extends MetadataValuesChangeRequestBase implements IFilterContentsMetadataUpdateRequest {
    contentSearchRequest?: ContentSearchRequest | undefined;
    totalItemsCount: number;

    constructor(data?: IFilterContentsMetadataUpdateRequest) {
        super(data);
        this._discriminator = "FilterContentsMetadataUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentSearchRequest = data["contentSearchRequest"] ? ContentSearchRequest.fromJS(data["contentSearchRequest"]) : <any>undefined;
            this.totalItemsCount = data["totalItemsCount"];
        }
    }

    static fromJS(data: any): FilterContentsMetadataUpdateRequest {
        let result = new FilterContentsMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSearchRequest"] = this.contentSearchRequest ? this.contentSearchRequest.toJSON() : <any>undefined;
        data["totalItemsCount"] = this.totalItemsCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IFilterContentsMetadataUpdateRequest extends IMetadataValuesChangeRequestBase {
    contentSearchRequest?: ContentSearchRequest | undefined;
    totalItemsCount: number;
}

export class BaseResultOfBusinessProcess implements IBaseResultOfBusinessProcess {
    totalResults: number;
    results?: BusinessProcess[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(BusinessProcess.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfBusinessProcess {
        let result = new BaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfBusinessProcess {
    totalResults: number;
    results?: BusinessProcess[] | undefined;
    pageToken?: string | undefined;
}

export class BusinessProcessSearchResult extends BaseResultOfBusinessProcess implements IBusinessProcessSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IBusinessProcessSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): BusinessProcessSearchResult {
        let result = new BusinessProcessSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessSearchResult extends IBaseResultOfBusinessProcess {
    elapsedMilliseconds: number;
}

export class StartProcessRequest implements IStartProcessRequest {
    variables?: any | undefined;

    constructor(data?: IStartProcessRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.variables = data["variables"];
        }
    }

    static fromJS(data: any): StartProcessRequest {
        let result = new StartProcessRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variables"] = this.variables;
        return data; 
    }
}

export interface IStartProcessRequest {
    variables?: any | undefined;
}

export class SendMessageRequest implements ISendMessageRequest {
    messageName?: string | undefined;
    variables?: any | undefined;

    constructor(data?: ISendMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.messageName = data["messageName"];
            this.variables = data["variables"];
        }
    }

    static fromJS(data: any): SendMessageRequest {
        let result = new SendMessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageName"] = this.messageName;
        data["variables"] = this.variables;
        return data; 
    }
}

export interface ISendMessageRequest {
    messageName?: string | undefined;
    variables?: any | undefined;
}

export class BusinessProcessWaitResult implements IBusinessProcessWaitResult {
    hasStateHit: boolean;
    processEnded: boolean;
    stateHit?: string | undefined;
    businessProcess?: BusinessProcess | undefined;

    constructor(data?: IBusinessProcessWaitResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasStateHit = data["hasStateHit"];
            this.processEnded = data["processEnded"];
            this.stateHit = data["stateHit"];
            this.businessProcess = data["businessProcess"] ? BusinessProcess.fromJS(data["businessProcess"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessWaitResult {
        let result = new BusinessProcessWaitResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasStateHit"] = this.hasStateHit;
        data["processEnded"] = this.processEnded;
        data["stateHit"] = this.stateHit;
        data["businessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessWaitResult {
    hasStateHit: boolean;
    processEnded: boolean;
    stateHit?: string | undefined;
    businessProcess?: BusinessProcess | undefined;
}

export class DocumentHistorySearchRequest implements IDocumentHistorySearchRequest {
    from: Date;
    to: Date;
    start: number;
    limit: number;
    pageToken?: string | undefined;
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;

    constructor(data?: IDocumentHistorySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.start = data["start"];
            this.limit = data["limit"];
            this.pageToken = data["pageToken"];
            this.id = data["id"];
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): DocumentHistorySearchRequest {
        let result = new DocumentHistorySearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        return data; 
    }
}

export interface IDocumentHistorySearchRequest {
    from: Date;
    to: Date;
    start: number;
    limit: number;
    pageToken?: string | undefined;
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
}

export class DocumentHistorySearchResult implements IDocumentHistorySearchResult {
    totalResults: number;
    results?: DocumentHistory[] | undefined;
    pageToken?: string | undefined;
    elapsedMilliseconds: number;

    constructor(data?: IDocumentHistorySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(DocumentHistory.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): DocumentHistorySearchResult {
        let result = new DocumentHistorySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        return data; 
    }
}

export interface IDocumentHistorySearchResult {
    totalResults: number;
    results?: DocumentHistory[] | undefined;
    pageToken?: string | undefined;
    elapsedMilliseconds: number;
}

export class DocumentHistory implements IDocumentHistory {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentTypeContract?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: HistoryAudit | undefined;
    deleted: boolean;

    constructor(data?: IDocumentHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
            this.documentType = data["documentType"];
            this.documentTypeContract = data["documentTypeContract"];
            this.documentDate = data["documentDate"] ? new Date(data["documentDate"].toString()) : <any>undefined;
            this.document = data["document"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.audit = data["audit"] ? HistoryAudit.fromJS(data["audit"]) : <any>undefined;
            this.deleted = data["deleted"];
        }
    }

    static fromJS(data: any): DocumentHistory {
        let result = new DocumentHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        data["documentTypeContract"] = this.documentTypeContract;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["document"] = this.document;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        return data; 
    }
}

export interface IDocumentHistory {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentTypeContract?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: HistoryAudit | undefined;
    deleted: boolean;
}

export class HistoryAudit implements IHistoryAudit {
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;

    constructor(data?: IHistoryAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = data["modifiedByUser"] ? UserItem.fromJS(data["modifiedByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HistoryAudit {
        let result = new HistoryAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["modifiedByUser"] = this.modifiedByUser ? this.modifiedByUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHistoryAudit {
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;
}

export class DocumentHistoryDifference implements IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;

    constructor(data?: IDocumentHistoryDifference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.oldDocumentVersion = data["oldDocumentVersion"];
            this.newDocumentVersion = data["newDocumentVersion"];
            this.oldValues = data["oldValues"];
            this.newValues = data["newValues"];
        }
    }

    static fromJS(data: any): DocumentHistoryDifference {
        let result = new DocumentHistoryDifference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["oldDocumentVersion"] = this.oldDocumentVersion;
        data["newDocumentVersion"] = this.newDocumentVersion;
        data["oldValues"] = this.oldValues;
        data["newValues"] = this.newValues;
        return data; 
    }
}

export interface IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;
}

/** A request structure for creating a list item document. */
export class ListItemCreateRequest implements IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;

    constructor(data?: IListItemCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.listItemId = data["listItemId"];
        }
    }

    static fromJS(data: any): ListItemCreateRequest {
        let result = new ListItemCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["listItemId"] = this.listItemId;
        return data; 
    }
}

/** A request structure for creating a list item document. */
export interface IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;
}

/** The detail view item for the list item. */
export class ListItemDetail implements IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItemDetail {
        let result = new ListItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["id"] = this.id;
        return data; 
    }
}

/** The detail view item for the list item. */
export interface IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;
}

export class ListItemAggregationRequest implements IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;

    constructor(data?: IListItemAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemAggregationRequest {
        let result = new ListItemAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data; 
    }
}

export interface IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
}

export class ListItemSearchRequest implements IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;

    constructor(data?: IListItemSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.includeMetadata = data["includeMetadata"];
        }
    }

    static fromJS(data: any): ListItemSearchRequest {
        let result = new ListItemSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["includeMetadata"] = this.includeMetadata;
        return data; 
    }
}

export interface IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;
}

export class BaseResultOfListItem implements IBaseResultOfListItem {
    totalResults: number;
    results?: ListItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(ListItem.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfListItem {
        let result = new BaseResultOfListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfListItem {
    totalResults: number;
    results?: ListItem[] | undefined;
    pageToken?: string | undefined;
}

export class ListItemSearchResult extends BaseResultOfListItem implements IListItemSearchResult {

    constructor(data?: IListItemSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListItemSearchResult {
        let result = new ListItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemSearchResult extends IBaseResultOfListItem {
}

export class ListItem implements IListItem {
    /** The list item id. */
    id?: string | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The content data of the list item. */
    content?: DataDictionary | undefined;
    /** The entity type of a list item is metadata. */
    entityType: EntityType;

    constructor(data?: IListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contentSchemaId = data["contentSchemaId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
            this.content = data["content"] ? DataDictionary.fromJS(data["content"]) : <any>undefined;
            this.entityType = data["entityType"];
        }
    }

    static fromJS(data: any): ListItem {
        let result = new ListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        return data; 
    }
}

export interface IListItem {
    /** The list item id. */
    id?: string | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The content data of the list item. */
    content?: DataDictionary | undefined;
    /** The entity type of a list item is metadata. */
    entityType: EntityType;
}

/** A request structure for updating a list item. */
export class ListItemUpdateRequest implements IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItemUpdateRequest {
        let result = new ListItemUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["id"] = this.id;
        return data; 
    }
}

/** A request structure for updating a list item. */
export interface IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;
}

export class LiveStreamSearchRequest implements ILiveStreamSearchRequest {
    from: Date;
    to: Date;
    start: number;
    limit: number;
    pageToken?: string | undefined;

    constructor(data?: ILiveStreamSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.start = data["start"];
            this.limit = data["limit"];
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): LiveStreamSearchRequest {
        let result = new LiveStreamSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface ILiveStreamSearchRequest {
    from: Date;
    to: Date;
    start: number;
    limit: number;
    pageToken?: string | undefined;
}

export class BaseResultOfObject implements IBaseResultOfObject {
    totalResults: number;
    results?: any[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(item);
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfObject {
        let result = new BaseResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfObject {
    totalResults: number;
    results?: any[] | undefined;
    pageToken?: string | undefined;
}

export class ObjectSearchResult extends BaseResultOfObject implements IObjectSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IObjectSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ObjectSearchResult {
        let result = new ObjectSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectSearchResult extends IBaseResultOfObject {
    elapsedMilliseconds: number;
}

export class SchemaDetail implements ISchemaDetail {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: StoreAudit | undefined;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: SearchFieldCount | undefined;

    constructor(data?: ISchemaDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["sortOrder"];
            this.system = data["system"];
            this.ownerTokenId = data["ownerTokenId"];
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["descendantSchemaIds"] && data["descendantSchemaIds"].constructor === Array) {
                this.descendantSchemaIds = [];
                for (let item of data["descendantSchemaIds"])
                    this.descendantSchemaIds.push(item);
            }
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.searchFieldCount = data["searchFieldCount"] ? SearchFieldCount.fromJS(data["searchFieldCount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaDetail {
        let result = new SchemaDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        data["system"] = this.system;
        data["ownerTokenId"] = this.ownerTokenId;
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (this.descendantSchemaIds && this.descendantSchemaIds.constructor === Array) {
            data["descendantSchemaIds"] = [];
            for (let item of this.descendantSchemaIds)
                data["descendantSchemaIds"].push(item);
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["searchFieldCount"] = this.searchFieldCount ? this.searchFieldCount.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaDetail {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: StoreAudit | undefined;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: SearchFieldCount | undefined;
}

export enum SchemaType {
    Content = <any>"Content", 
    Layer = <any>"Layer", 
    List = <any>"List", 
    Struct = <any>"Struct", 
}

export class DisplayPattern implements IDisplayPattern {
    id?: string | undefined;
    templateEngine: TemplateEngine;
    displayPatternType: DisplayPatternType;
    templates?: TranslatedStringDictionary | undefined;

    constructor(data?: IDisplayPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.templateEngine = data["templateEngine"];
            this.displayPatternType = data["displayPatternType"];
            this.templates = data["templates"] ? TranslatedStringDictionary.fromJS(data["templates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DisplayPattern {
        let result = new DisplayPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateEngine"] = this.templateEngine;
        data["displayPatternType"] = this.displayPatternType;
        data["templates"] = this.templates ? this.templates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDisplayPattern {
    id?: string | undefined;
    templateEngine: TemplateEngine;
    displayPatternType: DisplayPatternType;
    templates?: TranslatedStringDictionary | undefined;
}

export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid", 
}

export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail", 
    List = <any>"List", 
    Detail = <any>"Detail", 
    Custom = <any>"Custom", 
    Name = <any>"Name", 
}

export class FieldBase implements IFieldBase {
    id?: string | undefined;
    indexId?: string | undefined;
    fieldNamespace?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    required: boolean;
    fixed: boolean;
    index: boolean;
    simpleSearch: boolean;
    boost: number;

    protected _discriminator: string;

    constructor(data?: IFieldBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FieldBase";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.indexId = data["indexId"];
            this.fieldNamespace = data["fieldNamespace"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            this.required = data["required"];
            this.fixed = data["fixed"];
            this.index = data["index"];
            this.simpleSearch = data["simpleSearch"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldBase {
        if (data["kind"] === "FieldBoolean") {
            let result = new FieldBoolean();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDate") {
            let result = new FieldDate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTime") {
            let result = new FieldDateTime();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDecimal") {
            let result = new FieldDecimal();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionary") {
            let result = new FieldDictionary();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldGeoPoint") {
            let result = new FieldGeoPoint();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLong") {
            let result = new FieldLong();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleFieldset") {
            let result = new FieldSingleFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiFieldset") {
            let result = new FieldMultiFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleTagbox") {
            let result = new FieldSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiTagbox") {
            let result = new FieldMultiTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldString") {
            let result = new FieldString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldTranslatedString") {
            let result = new FieldTranslatedString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleRelation") {
            let result = new FieldSingleRelation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiRelation") {
            let result = new FieldMultiRelation();
            result.init(data);
            return result;
        }
        let result = new FieldBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["indexId"] = this.indexId;
        data["fieldNamespace"] = this.fieldNamespace;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["required"] = this.required;
        data["fixed"] = this.fixed;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["boost"] = this.boost;
        return data; 
    }
}

export interface IFieldBase {
    id?: string | undefined;
    indexId?: string | undefined;
    fieldNamespace?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    required: boolean;
    fixed: boolean;
    index: boolean;
    simpleSearch: boolean;
    boost: number;
}

export class FieldBoolean extends FieldBase implements IFieldBoolean {

    constructor(data?: IFieldBoolean) {
        super(data);
        this._discriminator = "FieldBoolean";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): FieldBoolean {
        let result = new FieldBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldBoolean extends IFieldBase {
}

export class FieldDate extends FieldBase implements IFieldDate {
    format?: string | undefined;

    constructor(data?: IFieldDate) {
        super(data);
        this._discriminator = "FieldDate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["format"];
        }
    }

    static fromJS(data: any): FieldDate {
        let result = new FieldDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDate extends IFieldBase {
    format?: string | undefined;
}

export class FieldDateTime extends FieldBase implements IFieldDateTime {
    format?: string | undefined;

    constructor(data?: IFieldDateTime) {
        super(data);
        this._discriminator = "FieldDateTime";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["format"];
        }
    }

    static fromJS(data: any): FieldDateTime {
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        let result = new FieldDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDateTime extends IFieldBase {
    format?: string | undefined;
}

export class FieldDateTimeArray extends FieldDateTime implements IFieldDateTimeArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldDateTimeArray) {
        super(data);
        this._discriminator = "FieldDateTimeArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldDateTimeArray {
        let result = new FieldDateTimeArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDateTimeArray extends IFieldDateTime {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldDecimal extends FieldBase implements IFieldDecimal {
    pattern?: string | undefined;
    minimum?: number | undefined;
    maximum?: number | undefined;

    constructor(data?: IFieldDecimal) {
        super(data);
        this._discriminator = "FieldDecimal";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimum = data["minimum"];
            this.maximum = data["maximum"];
        }
    }

    static fromJS(data: any): FieldDecimal {
        let result = new FieldDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDecimal extends IFieldBase {
    pattern?: string | undefined;
    minimum?: number | undefined;
    maximum?: number | undefined;
}

export class FieldDictionary extends FieldBase implements IFieldDictionary {

    constructor(data?: IFieldDictionary) {
        super(data);
        this._discriminator = "FieldDictionary";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): FieldDictionary {
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        let result = new FieldDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDictionary extends IFieldBase {
}

export class FieldDictionaryArray extends FieldDictionary implements IFieldDictionaryArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldDictionaryArray) {
        super(data);
        this._discriminator = "FieldDictionaryArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldDictionaryArray {
        let result = new FieldDictionaryArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDictionaryArray extends IFieldDictionary {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldGeoPoint extends FieldBase implements IFieldGeoPoint {

    constructor(data?: IFieldGeoPoint) {
        super(data);
        this._discriminator = "FieldGeoPoint";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): FieldGeoPoint {
        let result = new FieldGeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldGeoPoint extends IFieldBase {
}

export class FieldLong extends FieldBase implements IFieldLong {
    pattern?: string | undefined;
    minimum?: number | undefined;
    maximum?: number | undefined;

    constructor(data?: IFieldLong) {
        super(data);
        this._discriminator = "FieldLong";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimum = data["minimum"];
            this.maximum = data["maximum"];
        }
    }

    static fromJS(data: any): FieldLong {
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        let result = new FieldLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldLong extends IFieldBase {
    pattern?: string | undefined;
    minimum?: number | undefined;
    maximum?: number | undefined;
}

export class FieldLongArray extends FieldLong implements IFieldLongArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldLongArray) {
        super(data);
        this._discriminator = "FieldLongArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldLongArray {
        let result = new FieldLongArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldLongArray extends IFieldLong {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldSingleFieldset extends FieldBase implements IFieldSingleFieldset {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;

    constructor(data?: IFieldSingleFieldset) {
        super(data);
        this._discriminator = "FieldSingleFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.maxRecursion = data["maxRecursion"];
        }
    }

    static fromJS(data: any): FieldSingleFieldset {
        let result = new FieldSingleFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maxRecursion"] = this.maxRecursion;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleFieldset extends IFieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
}

export class SchemaIndexingInfo implements ISchemaIndexingInfo {
    fields?: FieldIndexingInfo[] | undefined;

    constructor(data?: ISchemaIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldIndexingInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaIndexingInfo {
        let result = new SchemaIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISchemaIndexingInfo {
    fields?: FieldIndexingInfo[] | undefined;
}

export class FieldIndexingInfo implements IFieldIndexingInfo {
    id?: string | undefined;
    index: boolean;
    simpleSearch: boolean;
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.index = data["index"];
            this.simpleSearch = data["simpleSearch"];
            this.relatedSchemaIndexing = data["relatedSchemaIndexing"] ? SchemaIndexingInfo.fromJS(data["relatedSchemaIndexing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldIndexingInfo {
        let result = new FieldIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["relatedSchemaIndexing"] = this.relatedSchemaIndexing ? this.relatedSchemaIndexing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFieldIndexingInfo {
    id?: string | undefined;
    index: boolean;
    simpleSearch: boolean;
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;
}

export class FieldMultiFieldset extends FieldBase implements IFieldMultiFieldset {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiFieldset) {
        super(data);
        this._discriminator = "FieldMultiFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.maxRecursion = data["maxRecursion"];
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiFieldset {
        let result = new FieldMultiFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maxRecursion"] = this.maxRecursion;
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiFieldset extends IFieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldSingleTagbox extends FieldBase implements IFieldSingleTagbox {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    filter?: FilterBase | undefined;
    listItemCreateTemplate?: string | undefined;

    constructor(data?: IFieldSingleTagbox) {
        super(data);
        this._discriminator = "FieldSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.maxRecursion = data["maxRecursion"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldSingleTagbox {
        let result = new FieldSingleTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maxRecursion"] = this.maxRecursion;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleTagbox extends IFieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    filter?: FilterBase | undefined;
    listItemCreateTemplate?: string | undefined;
}

export class FieldMultiTagbox extends FieldBase implements IFieldMultiTagbox {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
    filter?: FilterBase | undefined;
    listItemCreateTemplate?: string | undefined;

    constructor(data?: IFieldMultiTagbox) {
        super(data);
        this._discriminator = "FieldMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.maxRecursion = data["maxRecursion"];
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldMultiTagbox {
        let result = new FieldMultiTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maxRecursion"] = this.maxRecursion;
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiTagbox extends IFieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
    filter?: FilterBase | undefined;
    listItemCreateTemplate?: string | undefined;
}

export class FieldString extends FieldBase implements IFieldString {
    template?: string | undefined;
    keepFieldValue: boolean;
    pattern?: string | undefined;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
    analyzers?: AnalyzerBase[] | undefined;
    multiLine: boolean;
    grantedValues?: string[] | undefined;

    constructor(data?: IFieldString) {
        super(data);
        this._discriminator = "FieldString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.template = data["template"];
            this.keepFieldValue = data["keepFieldValue"];
            this.pattern = data["pattern"];
            this.minimumLength = data["minimumLength"];
            this.maximumLength = data["maximumLength"];
            if (data["analyzers"] && data["analyzers"].constructor === Array) {
                this.analyzers = [];
                for (let item of data["analyzers"])
                    this.analyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["multiLine"];
            if (data["grantedValues"] && data["grantedValues"].constructor === Array) {
                this.grantedValues = [];
                for (let item of data["grantedValues"])
                    this.grantedValues.push(item);
            }
        }
    }

    static fromJS(data: any): FieldString {
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        let result = new FieldString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["keepFieldValue"] = this.keepFieldValue;
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (this.analyzers && this.analyzers.constructor === Array) {
            data["analyzers"] = [];
            for (let item of this.analyzers)
                data["analyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (this.grantedValues && this.grantedValues.constructor === Array) {
            data["grantedValues"] = [];
            for (let item of this.grantedValues)
                data["grantedValues"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldString extends IFieldBase {
    template?: string | undefined;
    keepFieldValue: boolean;
    pattern?: string | undefined;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
    analyzers?: AnalyzerBase[] | undefined;
    multiLine: boolean;
    grantedValues?: string[] | undefined;
}

/** The analyzer base class. */
export class AnalyzerBase implements IAnalyzerBase {
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;

    protected _discriminator: string;

    constructor(data?: IAnalyzerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AnalyzerBase";
    }

    init(data?: any) {
        if (data) {
            this.simpleSearch = data["simpleSearch"];
        }
    }

    static fromJS(data: any): AnalyzerBase {
        if (data["kind"] === "EdgeNGramAnalyzer") {
            let result = new EdgeNGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageAnalyzer") {
            let result = new LanguageAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NGramAnalyzer") {
            let result = new NGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PathHierarchyAnalyzer") {
            let result = new PathHierarchyAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SimpleAnalyzer") {
            let result = new SimpleAnalyzer();
            result.init(data);
            return result;
        }
        let result = new AnalyzerBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["simpleSearch"] = this.simpleSearch;
        return data; 
    }
}

/** The analyzer base class. */
export interface IAnalyzerBase {
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export class EdgeNGramAnalyzer extends AnalyzerBase implements IEdgeNGramAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: IEdgeNGramAnalyzer) {
        super(data);
        this._discriminator = "EdgeNGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): EdgeNGramAnalyzer {
        let result = new EdgeNGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export interface IEdgeNGramAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export class LanguageAnalyzer extends AnalyzerBase implements ILanguageAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: ILanguageAnalyzer) {
        super(data);
        this._discriminator = "LanguageAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): LanguageAnalyzer {
        let result = new LanguageAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export interface ILanguageAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export class NGramAnalyzer extends AnalyzerBase implements INGramAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: INGramAnalyzer) {
        super(data);
        this._discriminator = "NGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): NGramAnalyzer {
        let result = new NGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export interface INGramAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export class PathHierarchyAnalyzer extends AnalyzerBase implements IPathHierarchyAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: IPathHierarchyAnalyzer) {
        super(data);
        this._discriminator = "PathHierarchyAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): PathHierarchyAnalyzer {
        let result = new PathHierarchyAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export interface IPathHierarchyAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export class SimpleAnalyzer extends AnalyzerBase implements ISimpleAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: ISimpleAnalyzer) {
        super(data);
        this._discriminator = "SimpleAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): SimpleAnalyzer {
        let result = new SimpleAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export interface ISimpleAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

export class FieldStringArray extends FieldString implements IFieldStringArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldStringArray) {
        super(data);
        this._discriminator = "FieldStringArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldStringArray {
        let result = new FieldStringArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldStringArray extends IFieldString {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldTranslatedString extends FieldBase implements IFieldTranslatedString {
    pattern?: string | undefined;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
    analyzers?: AnalyzerBase[] | undefined;
    multiLine: boolean;
    requiredMetadataLanguages?: string[] | undefined;
    template?: string | undefined;
    keepFieldValue: boolean;

    constructor(data?: IFieldTranslatedString) {
        super(data);
        this._discriminator = "FieldTranslatedString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimumLength = data["minimumLength"];
            this.maximumLength = data["maximumLength"];
            if (data["analyzers"] && data["analyzers"].constructor === Array) {
                this.analyzers = [];
                for (let item of data["analyzers"])
                    this.analyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["multiLine"];
            if (data["requiredMetadataLanguages"] && data["requiredMetadataLanguages"].constructor === Array) {
                this.requiredMetadataLanguages = [];
                for (let item of data["requiredMetadataLanguages"])
                    this.requiredMetadataLanguages.push(item);
            }
            this.template = data["template"];
            this.keepFieldValue = data["keepFieldValue"];
        }
    }

    static fromJS(data: any): FieldTranslatedString {
        let result = new FieldTranslatedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (this.analyzers && this.analyzers.constructor === Array) {
            data["analyzers"] = [];
            for (let item of this.analyzers)
                data["analyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (this.requiredMetadataLanguages && this.requiredMetadataLanguages.constructor === Array) {
            data["requiredMetadataLanguages"] = [];
            for (let item of this.requiredMetadataLanguages)
                data["requiredMetadataLanguages"].push(item);
        }
        data["template"] = this.template;
        data["keepFieldValue"] = this.keepFieldValue;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldTranslatedString extends IFieldBase {
    pattern?: string | undefined;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
    analyzers?: AnalyzerBase[] | undefined;
    multiLine: boolean;
    requiredMetadataLanguages?: string[] | undefined;
    template?: string | undefined;
    keepFieldValue: boolean;
}

export class FieldSingleRelation extends FieldBase implements IFieldSingleRelation {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    relationTypes?: RelationType[] | undefined;
    maxRecursion: number;

    constructor(data?: IFieldSingleRelation) {
        super(data);
        this._discriminator = "FieldSingleRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            if (data["relationTypes"] && data["relationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["relationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
            this.maxRecursion = data["maxRecursion"];
        }
    }

    static fromJS(data: any): FieldSingleRelation {
        let result = new FieldSingleRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        data["maxRecursion"] = this.maxRecursion;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleRelation extends IFieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    relationTypes?: RelationType[] | undefined;
    maxRecursion: number;
}

export class RelationType implements IRelationType {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    targetContext: TargetContext;
    schemaId?: string | undefined;
    filter?: FilterBase | undefined;

    constructor(data?: IRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.targetContext = data["targetContext"];
            this.schemaId = data["schemaId"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RelationType {
        let result = new RelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["targetContext"] = this.targetContext;
        data["schemaId"] = this.schemaId;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRelationType {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    targetContext: TargetContext;
    schemaId?: string | undefined;
    filter?: FilterBase | undefined;
}

export enum TargetContext {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    User = <any>"User", 
    Custom = <any>"Custom", 
}

export class FieldMultiRelation extends FieldBase implements IFieldMultiRelation {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    relationTypes?: RelationType[] | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiRelation) {
        super(data);
        this._discriminator = "FieldMultiRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            if (data["relationTypes"] && data["relationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["relationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
            this.maxRecursion = data["maxRecursion"];
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiRelation {
        let result = new FieldMultiRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        data["maxRecursion"] = this.maxRecursion;
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiRelation extends IFieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    relationTypes?: RelationType[] | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

/** Count info of fields for search operations */
export class SearchFieldCount implements ISearchFieldCount {
    /** The number of fields generated by the schema in the Search index. */
    dataField: number;
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;

    constructor(data?: ISearchFieldCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dataField = data["dataField"];
            this.indexedField = data["indexedField"];
            this.simpleSearchField = data["simpleSearchField"];
        }
    }

    static fromJS(data: any): SearchFieldCount {
        let result = new SearchFieldCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataField"] = this.dataField;
        data["indexedField"] = this.indexedField;
        data["simpleSearchField"] = this.simpleSearchField;
        return data; 
    }
}

/** Count info of fields for search operations */
export interface ISearchFieldCount {
    /** The number of fields generated by the schema in the Search index. */
    dataField: number;
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;
}

export class ExistsResponse implements IExistsResponse {
    exists: boolean;

    constructor(data?: IExistsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exists = data["exists"];
        }
    }

    static fromJS(data: any): ExistsResponse {
        let result = new ExistsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        return data; 
    }
}

export interface IExistsResponse {
    exists: boolean;
}

export class SchemaCreateRequest implements ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["sortOrder"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaCreateRequest {
        let result = new SchemaCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        return data; 
    }
}

export interface ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

export class SchemaUpdateRequest implements ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;

    constructor(data?: ISchemaUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["sortOrder"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaUpdateRequest {
        let result = new SchemaUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        return data; 
    }
}

export interface ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;
}

export class SchemaSearchRequest implements ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;

    constructor(data?: ISchemaSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaSearchRequest {
        let result = new SchemaSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;
}

export class BaseResultOfSchema implements IBaseResultOfSchema {
    totalResults: number;
    results?: Schema[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Schema.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfSchema {
        let result = new BaseResultOfSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfSchema {
    totalResults: number;
    results?: Schema[] | undefined;
    pageToken?: string | undefined;
}

export class SchemaSearchResult extends BaseResultOfSchema implements ISchemaSearchResult {

    constructor(data?: ISchemaSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaSearchResult {
        let result = new SchemaSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaSearchResult extends IBaseResultOfSchema {
}

export class Schema implements ISchema {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;

    constructor(data?: ISchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.fieldCount = data["fieldCount"];
            this.childCount = data["childCount"];
            this.level = data["level"];
            this.system = data["system"];
        }
    }

    static fromJS(data: any): Schema {
        let result = new Schema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["fieldCount"] = this.fieldCount;
        data["childCount"] = this.childCount;
        data["level"] = this.level;
        data["system"] = this.system;
        return data; 
    }
}

export interface ISchema {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;
}

export enum UserRight {
    ManageContent = <any>"ManageContent", 
    ManageSharings = <any>"ManageSharings", 
    ManageDrives = <any>"ManageDrives", 
    ManageTransfer = <any>"ManageTransfer", 
    ManageAnalytics = <any>"ManageAnalytics", 
    ManageChannels = <any>"ManageChannels", 
    ManageSchemas = <any>"ManageSchemas", 
    ManageUsers = <any>"ManageUsers", 
    ManageUserRoles = <any>"ManageUserRoles", 
    ManagePermissions = <any>"ManagePermissions", 
    ManageSearchIndexes = <any>"ManageSearchIndexes", 
    ManageRecipients = <any>"ManageRecipients", 
    ManageCollections = <any>"ManageCollections", 
    ManageListItems = <any>"ManageListItems", 
    ManageServiceProviders = <any>"ManageServiceProviders", 
    ManageEmbeds = <any>"ManageEmbeds", 
}

export class PermissionSetSearchRequest implements IPermissionSetSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    rightFilter?: PermissionSetRight | undefined;

    constructor(data?: IPermissionSetSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.rightFilter = data["rightFilter"];
        }
    }

    static fromJS(data: any): PermissionSetSearchRequest {
        let result = new PermissionSetSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["rightFilter"] = this.rightFilter;
        return data; 
    }
}

export interface IPermissionSetSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    rightFilter?: PermissionSetRight | undefined;
}

export enum PermissionSetRight {
    Apply = <any>"Apply", 
}

export class BaseResultOfPermissionSet implements IBaseResultOfPermissionSet {
    totalResults: number;
    results?: PermissionSet[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(PermissionSet.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfPermissionSet {
        let result = new BaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfPermissionSet {
    totalResults: number;
    results?: PermissionSet[] | undefined;
    pageToken?: string | undefined;
}

export class PermissionSetSearchResult extends BaseResultOfPermissionSet implements IPermissionSetSearchResult {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;

    constructor(data?: IPermissionSetSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): PermissionSetSearchResult {
        let result = new PermissionSetSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionSetSearchResult extends IBaseResultOfPermissionSet {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;
}

export class PermissionSet implements IPermissionSet {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;

    constructor(data?: IPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.trashed = data["trashed"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionSet {
        let result = new PermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trashed"] = this.trashed;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPermissionSet {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;
}

export class PermissionSetDetailOfContentRight implements IPermissionSetDetailOfContentRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;

    constructor(data?: IPermissionSetDetailOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.trashed = data["trashed"];
            if (data["userRolesRights"] && data["userRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["userRolesRights"])
                    this.userRolesRights.push(PermissionUserRoleRightsOfContentRight.fromJS(item));
            }
            if (data["userRolesPermissionSetRights"] && data["userRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["exclusive"];
        }
    }

    static fromJS(data: any): PermissionSetDetailOfContentRight {
        let result = new PermissionSetDetailOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        return data; 
    }
}

export interface IPermissionSetDetailOfContentRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export class ContentPermissionSetDetail extends PermissionSetDetailOfContentRight implements IContentPermissionSetDetail {

    constructor(data?: IContentPermissionSetDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ContentPermissionSetDetail {
        let result = new ContentPermissionSetDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IContentPermissionSetDetail extends IPermissionSetDetailOfContentRight {
}

export class PermissionUserRoleRightsOfContentRight implements IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfContentRight {
        let result = new PermissionUserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;
}

export class PermissionUserRoleRightsOfPermissionSetRight implements IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfPermissionSetRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfPermissionSetRight {
        let result = new PermissionUserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;
}

export class PermissionSetDetailOfMetadataRight implements IPermissionSetDetailOfMetadataRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;

    constructor(data?: IPermissionSetDetailOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.trashed = data["trashed"];
            if (data["userRolesRights"] && data["userRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["userRolesRights"])
                    this.userRolesRights.push(PermissionUserRoleRightsOfMetadataRight.fromJS(item));
            }
            if (data["userRolesPermissionSetRights"] && data["userRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["exclusive"];
        }
    }

    static fromJS(data: any): PermissionSetDetailOfMetadataRight {
        let result = new PermissionSetDetailOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        return data; 
    }
}

export interface IPermissionSetDetailOfMetadataRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export class SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight implements ISchemaPermissionSetDetail {

    constructor(data?: ISchemaPermissionSetDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaPermissionSetDetail {
        let result = new SchemaPermissionSetDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaPermissionSetDetail extends IPermissionSetDetailOfMetadataRight {
}

export class PermissionUserRoleRightsOfMetadataRight implements IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfMetadataRight {
        let result = new PermissionUserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;
}

export enum MetadataRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Manage = <any>"Manage", 
}

export class VersionInfo implements IVersionInfo {
    comments?: string | undefined;
    event?: Event | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;

    constructor(data?: IVersionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.modifier = data["modifier"];
            this.modifyDate = data["modifyDate"] ? new Date(data["modifyDate"].toString()) : <any>undefined;
            this.version = data["version"];
        }
    }

    static fromJS(data: any): VersionInfo {
        let result = new VersionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["modifier"] = this.modifier;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IVersionInfo {
    comments?: string | undefined;
    event?: Event | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;
}

export class Event implements IEvent {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.changed = data["changed"];
            this.instanceID = data["instanceID"];
            this.parameters = data["parameters"];
            this.softwareAgent = data["softwareAgent"];
            this.when = data["when"] ? new Date(data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Event {
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["changed"] = this.changed;
        data["instanceID"] = this.instanceID;
        data["parameters"] = this.parameters;
        data["softwareAgent"] = this.softwareAgent;
        data["when"] = this.when ? this.when.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEvent {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;
}

/** Corresponds to stEvt.ActionChoice */
export enum EventAction {
    Converted = <any>"Converted", 
    Copied = <any>"Copied", 
    Created = <any>"Created", 
    Cropped = <any>"Cropped", 
    Edited = <any>"Edited", 
    Filtered = <any>"Filtered", 
    Formatted = <any>"Formatted", 
    VersionUpdated = <any>"VersionUpdated", 
    Printed = <any>"Printed", 
    Published = <any>"Published", 
    Managed = <any>"Managed", 
    Produced = <any>"Produced", 
    Resized = <any>"Resized", 
    Saved = <any>"Saved", 
    Derived = <any>"Derived", 
}

export class ShareBaseDetail implements IShareBaseDetail {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
    contentSelections?: ContentDetail2[] | undefined;
    layerSchemaIds?: string[] | undefined;
    mailTemplateId?: string | undefined;
    expirationDate?: Date | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBaseDetail";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.entityType = data["entityType"];
            if (data["contentSelections"] && data["contentSelections"].constructor === Array) {
                this.contentSelections = [];
                for (let item of data["contentSelections"])
                    this.contentSelections.push(ContentDetail2.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.mailTemplateId = data["mailTemplateId"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseDetail {
        if (data["kind"] === "ShareBasicDetail") {
            let result = new ShareBasicDetail();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedDetail") {
            let result = new ShareEmbedDetail();
            result.init(data);
            return result;
        }
        let result = new ShareBaseDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        if (this.contentSelections && this.contentSelections.constructor === Array) {
            data["contentSelections"] = [];
            for (let item of this.contentSelections)
                data["contentSelections"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["mailTemplateId"] = this.mailTemplateId;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseDetail {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
    contentSelections?: ContentDetail2[] | undefined;
    layerSchemaIds?: string[] | undefined;
    mailTemplateId?: string | undefined;
    expirationDate?: Date | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export class ContentDetail2 implements IContentDetail2 {
    contentTypeId: number;
    trashed: boolean;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: DataDictionary | undefined;
    metadata?: DataDictionary | undefined;
    id?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    outputs?: Output[] | undefined;
    audit?: StoreAudit | undefined;
    ownerTokenId?: string | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;

    constructor(data?: IContentDetail2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentTypeId = data["contentTypeId"];
            this.trashed = data["trashed"];
            this.entityType = data["entityType"];
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"] ? DataDictionary.fromJS(data["content"]) : <any>undefined;
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            this.id = data["id"];
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
            if (data["outputs"] && data["outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["outputs"])
                    this.outputs.push(Output.fromJS(item));
            }
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.ownerTokenId = data["ownerTokenId"];
            this.contentType = data["contentType"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentDetail2 {
        let result = new ContentDetail2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentTypeId"] = this.contentTypeId;
        data["trashed"] = this.trashed;
        data["entityType"] = this.entityType;
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        if (this.outputs && this.outputs.constructor === Array) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["ownerTokenId"] = this.ownerTokenId;
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentDetail2 {
    contentTypeId: number;
    trashed: boolean;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: DataDictionary | undefined;
    metadata?: DataDictionary | undefined;
    id?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    outputs?: Output[] | undefined;
    audit?: StoreAudit | undefined;
    ownerTokenId?: string | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
}

export class TemplateBase implements ITemplateBase {
    width?: number | undefined;
    height?: number | undefined;

    protected _discriminator: string;

    constructor(data?: ITemplateBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "TemplateBase";
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): TemplateBase {
        if (data["kind"] === "CardTemplate") {
            let result = new CardTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListTemplate") {
            let result = new ListTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BasicTemplate") {
            let result = new BasicTemplate();
            result.init(data);
            return result;
        }
        let result = new TemplateBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ITemplateBase {
    width?: number | undefined;
    height?: number | undefined;
}

export class CardTemplate extends TemplateBase implements ICardTemplate {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;

    constructor(data?: ICardTemplate) {
        super(data);
        this._discriminator = "CardTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.showNavigation = data["showNavigation"];
            this.showOverlay = data["showOverlay"];
            this.showLogo = data["showLogo"];
            this.showFooter = data["showFooter"];
        }
    }

    static fromJS(data: any): CardTemplate {
        let result = new CardTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showNavigation"] = this.showNavigation;
        data["showOverlay"] = this.showOverlay;
        data["showLogo"] = this.showLogo;
        data["showFooter"] = this.showFooter;
        super.toJSON(data);
        return data; 
    }
}

export interface ICardTemplate extends ITemplateBase {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;
}

export class ListTemplate extends TemplateBase implements IListTemplate {

    constructor(data?: IListTemplate) {
        super(data);
        this._discriminator = "ListTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListTemplate {
        let result = new ListTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IListTemplate extends ITemplateBase {
}

export class BasicTemplate extends TemplateBase implements IBasicTemplate {

    constructor(data?: IBasicTemplate) {
        super(data);
        this._discriminator = "BasicTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): BasicTemplate {
        let result = new BasicTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IBasicTemplate extends ITemplateBase {
}

export enum OutputAccess {
    Full = <any>"Full", 
    Preview = <any>"Preview", 
    None = <any>"None", 
}

export class ShareBasicDetail extends ShareBaseDetail implements IShareBasicDetail {
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    languageCode?: string | undefined;

    constructor(data?: IShareBasicDetail) {
        super(data);
        this._discriminator = "ShareBasicDetail";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["mailRecipients"] && data["mailRecipients"].constructor === Array) {
                this.mailRecipients = [];
                for (let item of data["mailRecipients"])
                    this.mailRecipients.push(MailRecipient.fromJS(item));
            }
            if (data["internalRecipients"] && data["internalRecipients"].constructor === Array) {
                this.internalRecipients = [];
                for (let item of data["internalRecipients"])
                    this.internalRecipients.push(InternalRecipient.fromJS(item));
            }
            this.languageCode = data["languageCode"];
        }
    }

    static fromJS(data: any): ShareBasicDetail {
        let result = new ShareBasicDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.mailRecipients && this.mailRecipients.constructor === Array) {
            data["mailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["mailRecipients"].push(item.toJSON());
        }
        if (this.internalRecipients && this.internalRecipients.constructor === Array) {
            data["internalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["internalRecipients"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicDetail extends IShareBaseDetail {
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    languageCode?: string | undefined;
}

export class MailRecipient implements IMailRecipient {
    userEmail?: UserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMailRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userEmail = data["userEmail"] ? UserEmail.fromJS(data["userEmail"]) : <any>undefined;
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MailRecipient {
        let result = new MailRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail ? this.userEmail.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMailRecipient {
    userEmail?: UserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class UserEmail implements IUserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UserEmail {
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export class InternalRecipient implements IInternalRecipient {
    recipient?: UserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IInternalRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recipient = data["recipient"] ? UserItem.fromJS(data["recipient"]) : <any>undefined;
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): InternalRecipient {
        let result = new InternalRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IInternalRecipient {
    recipient?: UserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class ShareEmbedDetail extends ShareBaseDetail implements IShareEmbedDetail {
    embedContentItems?: EmbedContentDetail[] | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IShareEmbedDetail) {
        super(data);
        this._discriminator = "ShareEmbedDetail";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["embedContentItems"] && data["embedContentItems"].constructor === Array) {
                this.embedContentItems = [];
                for (let item of data["embedContentItems"])
                    this.embedContentItems.push(EmbedContentDetail.fromJS(item));
            }
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ShareEmbedDetail {
        let result = new ShareEmbedDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.embedContentItems && this.embedContentItems.constructor === Array) {
            data["embedContentItems"] = [];
            for (let item of this.embedContentItems)
                data["embedContentItems"].push(item.toJSON());
        }
        data["token"] = this.token;
        data["url"] = this.url;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedDetail extends IShareBaseDetail {
    embedContentItems?: EmbedContentDetail[] | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class EmbedContentDetail implements IEmbedContentDetail {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IEmbedContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): EmbedContentDetail {
        let result = new EmbedContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IEmbedContentDetail {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class ShareBaseUpdateRequest implements IShareBaseUpdateRequest {
    id?: string | undefined;
    name?: string | undefined;
    expirationDate?: Date | undefined;
    description?: string | undefined;
    shareContentItems?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBaseUpdateRequest";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.description = data["description"];
            if (data["shareContentItems"] && data["shareContentItems"].constructor === Array) {
                this.shareContentItems = [];
                for (let item of data["shareContentItems"])
                    this.shareContentItems.push(ShareContent.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseUpdateRequest {
        if (data["kind"] === "ShareBasicUpdateRequest") {
            let result = new ShareBasicUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedUpdateRequest") {
            let result = new ShareEmbedUpdateRequest();
            result.init(data);
            return result;
        }
        let result = new ShareBaseUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (this.shareContentItems && this.shareContentItems.constructor === Array) {
            data["shareContentItems"] = [];
            for (let item of this.shareContentItems)
                data["shareContentItems"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseUpdateRequest {
    id?: string | undefined;
    name?: string | undefined;
    expirationDate?: Date | undefined;
    description?: string | undefined;
    shareContentItems?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export class ShareContent implements IShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;

    constructor(data?: IShareContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            if (data["outputFormatIds"] && data["outputFormatIds"].constructor === Array) {
                this.outputFormatIds = [];
                for (let item of data["outputFormatIds"])
                    this.outputFormatIds.push(item);
            }
        }
    }

    static fromJS(data: any): ShareContent {
        let result = new ShareContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (this.outputFormatIds && this.outputFormatIds.constructor === Array) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        return data; 
    }
}

export interface IShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;
}

export class ShareBasicUpdateRequest extends ShareBaseUpdateRequest implements IShareBasicUpdateRequest {

    constructor(data?: IShareBasicUpdateRequest) {
        super(data);
        this._discriminator = "ShareBasicUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareBasicUpdateRequest {
        let result = new ShareBasicUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicUpdateRequest extends IShareBaseUpdateRequest {
}

export class ShareEmbedUpdateRequest extends ShareBaseUpdateRequest implements IShareEmbedUpdateRequest {

    constructor(data?: IShareEmbedUpdateRequest) {
        super(data);
        this._discriminator = "ShareEmbedUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedUpdateRequest {
        let result = new ShareEmbedUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedUpdateRequest extends IShareBaseUpdateRequest {
}

export class BaseResultOfShareBase implements IBaseResultOfShareBase {
    totalResults: number;
    results?: ShareBase[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfShareBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(ShareBase.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfShareBase {
        let result = new BaseResultOfShareBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfShareBase {
    totalResults: number;
    results?: ShareBase[] | undefined;
    pageToken?: string | undefined;
}

export class ShareBase implements IShareBase {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
    expirationDate?: Date | undefined;

    protected _discriminator: string;

    constructor(data?: IShareBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBase";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.id = data["id"];
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShareBase {
        if (data["kind"] === "ShareBasic") {
            let result = new ShareBasic();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbed") {
            let result = new ShareEmbed();
            result.init(data);
            return result;
        }
        let result = new ShareBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["id"] = this.id;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IShareBase {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
    expirationDate?: Date | undefined;
}

export class ShareBasic extends ShareBase implements IShareBasic {
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    description?: string | undefined;

    constructor(data?: IShareBasic) {
        super(data);
        this._discriminator = "ShareBasic";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["mailRecipients"] && data["mailRecipients"].constructor === Array) {
                this.mailRecipients = [];
                for (let item of data["mailRecipients"])
                    this.mailRecipients.push(MailRecipient.fromJS(item));
            }
            if (data["internalRecipients"] && data["internalRecipients"].constructor === Array) {
                this.internalRecipients = [];
                for (let item of data["internalRecipients"])
                    this.internalRecipients.push(InternalRecipient.fromJS(item));
            }
            this.description = data["description"];
        }
    }

    static fromJS(data: any): ShareBasic {
        let result = new ShareBasic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.mailRecipients && this.mailRecipients.constructor === Array) {
            data["mailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["mailRecipients"].push(item.toJSON());
        }
        if (this.internalRecipients && this.internalRecipients.constructor === Array) {
            data["internalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["internalRecipients"].push(item.toJSON());
        }
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasic extends IShareBase {
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    description?: string | undefined;
}

export class ShareEmbed extends ShareBase implements IShareEmbed {

    constructor(data?: IShareEmbed) {
        super(data);
        this._discriminator = "ShareEmbed";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbed {
        let result = new ShareEmbed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbed extends IShareBase {
}

export class ShareAggregationRequest implements IShareAggregationRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;

    constructor(data?: IShareAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.displayLanguage = data["displayLanguage"];
        }
    }

    static fromJS(data: any): ShareAggregationRequest {
        let result = new ShareAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["displayLanguage"] = this.displayLanguage;
        return data; 
    }
}

export interface IShareAggregationRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;
}

export class ShareBaseCreateRequest implements IShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBaseCreateRequest";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            if (data["contents"] && data["contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["contents"])
                    this.contents.push(ShareContent.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseCreateRequest {
        if (data["kind"] === "ShareBasicCreateRequest") {
            let result = new ShareBasicCreateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedCreateRequest") {
            let result = new ShareEmbedCreateRequest();
            result.init(data);
            return result;
        }
        let result = new ShareBaseCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["description"] = this.description;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (this.contents && this.contents.constructor === Array) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export class ShareBasicCreateRequest extends ShareBaseCreateRequest implements IShareBasicCreateRequest {
    recipientsEmail?: UserEmail[] | undefined;
    recipientsUser?: UserItem[] | undefined;
    recipientsGroup?: UserRole[] | undefined;
    languageCode?: string | undefined;
    mailTemplateId?: string | undefined;

    constructor(data?: IShareBasicCreateRequest) {
        super(data);
        this._discriminator = "ShareBasicCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["recipientsEmail"] && data["recipientsEmail"].constructor === Array) {
                this.recipientsEmail = [];
                for (let item of data["recipientsEmail"])
                    this.recipientsEmail.push(UserEmail.fromJS(item));
            }
            if (data["recipientsUser"] && data["recipientsUser"].constructor === Array) {
                this.recipientsUser = [];
                for (let item of data["recipientsUser"])
                    this.recipientsUser.push(UserItem.fromJS(item));
            }
            if (data["recipientsGroup"] && data["recipientsGroup"].constructor === Array) {
                this.recipientsGroup = [];
                for (let item of data["recipientsGroup"])
                    this.recipientsGroup.push(UserRole.fromJS(item));
            }
            this.languageCode = data["languageCode"];
            this.mailTemplateId = data["mailTemplateId"];
        }
    }

    static fromJS(data: any): ShareBasicCreateRequest {
        let result = new ShareBasicCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.recipientsEmail && this.recipientsEmail.constructor === Array) {
            data["recipientsEmail"] = [];
            for (let item of this.recipientsEmail)
                data["recipientsEmail"].push(item.toJSON());
        }
        if (this.recipientsUser && this.recipientsUser.constructor === Array) {
            data["recipientsUser"] = [];
            for (let item of this.recipientsUser)
                data["recipientsUser"].push(item.toJSON());
        }
        if (this.recipientsGroup && this.recipientsGroup.constructor === Array) {
            data["recipientsGroup"] = [];
            for (let item of this.recipientsGroup)
                data["recipientsGroup"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        data["mailTemplateId"] = this.mailTemplateId;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicCreateRequest extends IShareBaseCreateRequest {
    recipientsEmail?: UserEmail[] | undefined;
    recipientsUser?: UserItem[] | undefined;
    recipientsGroup?: UserRole[] | undefined;
    languageCode?: string | undefined;
    mailTemplateId?: string | undefined;
}

export class UserRole implements IUserRole {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.trashed = data["trashed"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["userRights"] && data["userRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["userRights"])
                    this.userRights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRole {
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trashed"] = this.trashed;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.userRights && this.userRights.constructor === Array) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        return data; 
    }
}

export interface IUserRole {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;
}

export class ShareEmbedCreateRequest extends ShareBaseCreateRequest implements IShareEmbedCreateRequest {

    constructor(data?: IShareEmbedCreateRequest) {
        super(data);
        this._discriminator = "ShareEmbedCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedCreateRequest {
        let result = new ShareEmbedCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedCreateRequest extends IShareBaseCreateRequest {
}

export class CreateShareResult implements ICreateShareResult {
    shareId?: string | undefined;

    constructor(data?: ICreateShareResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shareId = data["shareId"];
        }
    }

    static fromJS(data: any): CreateShareResult {
        let result = new CreateShareResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        return data; 
    }
}

export interface ICreateShareResult {
    shareId?: string | undefined;
}

export class ShareSearchResult extends BaseResultOfShareBase implements IShareSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IShareSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ShareSearchResult {
        let result = new ShareSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareSearchResult extends IBaseResultOfShareBase {
    elapsedMilliseconds: number;
}

export class FileTransferDeleteRequest implements IFileTransferDeleteRequest {
    transferId?: string | undefined;
    fileTransferIds?: string[] | undefined;

    constructor(data?: IFileTransferDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["fileTransferIds"] && data["fileTransferIds"].constructor === Array) {
                this.fileTransferIds = [];
                for (let item of data["fileTransferIds"])
                    this.fileTransferIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferDeleteRequest {
        let result = new FileTransferDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.fileTransferIds && this.fileTransferIds.constructor === Array) {
            data["fileTransferIds"] = [];
            for (let item of this.fileTransferIds)
                data["fileTransferIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransferDeleteRequest {
    transferId?: string | undefined;
    fileTransferIds?: string[] | undefined;
}

export class Blacklist implements IBlacklist {
    items?: BlacklistItem[] | undefined;

    constructor(data?: IBlacklist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BlacklistItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Blacklist {
        let result = new Blacklist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBlacklist {
    items?: BlacklistItem[] | undefined;
}

export class BlacklistItem implements IBlacklistItem {
    name?: string | undefined;
    match?: string | undefined;

    constructor(data?: IBlacklistItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.match = data["match"];
        }
    }

    static fromJS(data: any): BlacklistItem {
        let result = new BlacklistItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["match"] = this.match;
        return data; 
    }
}

export interface IBlacklistItem {
    name?: string | undefined;
    match?: string | undefined;
}

export class CreateTransferRequest implements ICreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: TransferUploadFile[] | undefined;
    driveFiles?: TransferDriveFile[] | undefined;
    webLinks?: TransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;

    constructor(data?: ICreateTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.transferType = data["transferType"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(TransferUploadFile.fromJS(item));
            }
            if (data["driveFiles"] && data["driveFiles"].constructor === Array) {
                this.driveFiles = [];
                for (let item of data["driveFiles"])
                    this.driveFiles.push(TransferDriveFile.fromJS(item));
            }
            if (data["webLinks"] && data["webLinks"].constructor === Array) {
                this.webLinks = [];
                for (let item of data["webLinks"])
                    this.webLinks.push(TransferWebLink.fromJS(item));
            }
            this.collectionName = data["collectionName"];
            this.createCollection = data["createCollection"];
        }
    }

    static fromJS(data: any): CreateTransferRequest {
        let result = new CreateTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["transferType"] = this.transferType;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (this.driveFiles && this.driveFiles.constructor === Array) {
            data["driveFiles"] = [];
            for (let item of this.driveFiles)
                data["driveFiles"].push(item.toJSON());
        }
        if (this.webLinks && this.webLinks.constructor === Array) {
            data["webLinks"] = [];
            for (let item of this.webLinks)
                data["webLinks"].push(item.toJSON());
        }
        data["collectionName"] = this.collectionName;
        data["createCollection"] = this.createCollection;
        return data; 
    }
}

export interface ICreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: TransferUploadFile[] | undefined;
    driveFiles?: TransferDriveFile[] | undefined;
    webLinks?: TransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;
}

export enum TransferType {
    FileUpload = <any>"FileUpload", 
    DriveImport = <any>"DriveImport", 
    DriveExport = <any>"DriveExport", 
    WebDownload = <any>"WebDownload", 
    SchemaImport = <any>"SchemaImport", 
}

export class TransferFile implements ITransferFile {
    identifier?: string | undefined;

    constructor(data?: ITransferFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.identifier = data["identifier"];
        }
    }

    static fromJS(data: any): TransferFile {
        let result = new TransferFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        return data; 
    }
}

export interface ITransferFile {
    identifier?: string | undefined;
}

export class TransferUploadFile extends TransferFile implements ITransferUploadFile {
    fileName?: string | undefined;

    constructor(data?: ITransferUploadFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): TransferUploadFile {
        let result = new TransferUploadFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferUploadFile extends ITransferFile {
    fileName?: string | undefined;
}

export class TransferDriveFile extends TransferFile implements ITransferDriveFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;

    constructor(data?: ITransferDriveFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.driveId = data["driveId"];
            this.fileId = data["fileId"];
            this.name = data["name"];
            this.externalOutputFolderId = data["externalOutputFolderId"];
        }
    }

    static fromJS(data: any): TransferDriveFile {
        let result = new TransferDriveFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driveId"] = this.driveId;
        data["fileId"] = this.fileId;
        data["name"] = this.name;
        data["externalOutputFolderId"] = this.externalOutputFolderId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferDriveFile extends ITransferFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;
}

export class TransferWebLink extends TransferFile implements ITransferWebLink {
    url?: string | undefined;

    constructor(data?: ITransferWebLink) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): TransferWebLink {
        let result = new TransferWebLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferWebLink extends ITransferFile {
    url?: string | undefined;
}

export class Transfer implements ITransfer {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;

    constructor(data?: ITransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.state = data["state"];
            this.transferType = data["transferType"];
            this.businessProcessId = data["businessProcessId"];
            this.fileTransferCount = data["fileTransferCount"];
        }
    }

    static fromJS(data: any): Transfer {
        let result = new Transfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["transferType"] = this.transferType;
        data["businessProcessId"] = this.businessProcessId;
        data["fileTransferCount"] = this.fileTransferCount;
        return data; 
    }
}

export interface ITransfer {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;
}

export enum TransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    ImportFailed = <any>"ImportFailed", 
    Created = <any>"Created", 
    UploadFailed = <any>"UploadFailed", 
    Deleted = <any>"Deleted", 
    TransferReady = <any>"TransferReady", 
    FileDeleteInProgress = <any>"FileDeleteInProgress", 
    TransferCleanup = <any>"TransferCleanup", 
}

export class TransferDetail implements ITransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: StoreAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;

    constructor(data?: ITransferDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rev = data["rev"];
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.name = data["name"];
            this.state = data["state"];
            this.businessProcessId = data["businessProcessId"];
            this.transferType = data["transferType"];
            this.itemProgress = data["itemProgress"];
            this.itemCount = data["itemCount"];
            this.itemsFailed = data["itemsFailed"];
            this.itemsCancelled = data["itemsCancelled"];
            this.lastProgressStamp = data["lastProgressStamp"];
            this.fileTransferCount = data["fileTransferCount"];
        }
    }

    static fromJS(data: any): TransferDetail {
        let result = new TransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rev"] = this.rev;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["state"] = this.state;
        data["businessProcessId"] = this.businessProcessId;
        data["transferType"] = this.transferType;
        data["itemProgress"] = this.itemProgress;
        data["itemCount"] = this.itemCount;
        data["itemsFailed"] = this.itemsFailed;
        data["itemsCancelled"] = this.itemsCancelled;
        data["lastProgressStamp"] = this.lastProgressStamp;
        data["fileTransferCount"] = this.fileTransferCount;
        return data; 
    }
}

export interface ITransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: StoreAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;
}

export class FileTransferDetail implements IFileTransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: StoreAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: DriveMetadata | undefined;
    outputItems?: OutputItem[] | undefined;
    contentId?: string | undefined;

    constructor(data?: IFileTransferDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rev = data["rev"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.audit = data["audit"] ? StoreAudit.fromJS(data["audit"]) : <any>undefined;
            this.transferId = data["transferId"];
            this.state = data["state"];
            this.entityType = data["entityType"];
            this.fileMetadata = data["fileMetadata"] ? FileMetadata.fromJS(data["fileMetadata"]) : <any>undefined;
            this.driveMetadata = data["driveMetadata"] ? DriveMetadata.fromJS(data["driveMetadata"]) : <any>undefined;
            if (data["outputItems"] && data["outputItems"].constructor === Array) {
                this.outputItems = [];
                for (let item of data["outputItems"])
                    this.outputItems.push(OutputItem.fromJS(item));
            }
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): FileTransferDetail {
        let result = new FileTransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rev"] = this.rev;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        data["entityType"] = this.entityType;
        data["fileMetadata"] = this.fileMetadata ? this.fileMetadata.toJSON() : <any>undefined;
        data["driveMetadata"] = this.driveMetadata ? this.driveMetadata.toJSON() : <any>undefined;
        if (this.outputItems && this.outputItems.constructor === Array) {
            data["outputItems"] = [];
            for (let item of this.outputItems)
                data["outputItems"].push(item.toJSON());
        }
        data["contentId"] = this.contentId;
        return data; 
    }
}

export interface IFileTransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: StoreAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: DriveMetadata | undefined;
    outputItems?: OutputItem[] | undefined;
    contentId?: string | undefined;
}

export enum FileTransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    DataExtractionInProgress = <any>"DataExtractionInProgress", 
    DataExtractionDone = <any>"DataExtractionDone", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    UploadFailed = <any>"UploadFailed", 
    ImportFailed = <any>"ImportFailed", 
    DeleteInProgress = <any>"DeleteInProgress", 
    Deleted = <any>"Deleted", 
    CleanupInProgress = <any>"CleanupInProgress", 
    CleanupCompleted = <any>"CleanupCompleted", 
}

export class FileMetadata implements IFileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: XmpMetadata | undefined;
    exifMetadata?: ExifMetadata | undefined;
    language?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IFileMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FileMetadata";
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
            this.xmpMetadata = data["xmpMetadata"] ? XmpMetadata.fromJS(data["xmpMetadata"]) : <any>undefined;
            this.exifMetadata = data["exifMetadata"] ? ExifMetadata.fromJS(data["exifMetadata"]) : <any>undefined;
            this.language = data["language"];
        }
    }

    static fromJS(data: any): FileMetadata {
        if (data["kind"] === "AudioMetadata") {
            let result = new AudioMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentMetadata") {
            let result = new DocumentMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageMetadata") {
            let result = new ImageMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoMetadata") {
            let result = new VideoMetadata();
            result.init(data);
            return result;
        }
        let result = new FileMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        data["xmpMetadata"] = this.xmpMetadata ? this.xmpMetadata.toJSON() : <any>undefined;
        data["exifMetadata"] = this.exifMetadata ? this.exifMetadata.toJSON() : <any>undefined;
        data["language"] = this.language;
        return data; 
    }
}

export interface IFileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: XmpMetadata | undefined;
    exifMetadata?: ExifMetadata | undefined;
    language?: string | undefined;
}

export class XmpMetadata implements IXmpMetadata {
    dc?: Dc | undefined;
    crs?: Crs | undefined;
    iptcCore?: IptcCore | undefined;
    iptcExt?: IptcExt | undefined;
    iptcIIM?: IptcIIM | undefined;
    lr?: Lr | undefined;
    pdf?: Pdf | undefined;
    photoshop?: Photoshop | undefined;
    plus?: Plus | undefined;
    tiff?: Tiff | undefined;
    xmp?: Xmp | undefined;
    xmpBJ?: XmpBJ | undefined;
    xmpDM?: XmpDM | undefined;
    xmpG?: XmpG | undefined;
    xmpGImg?: XmpGImg | undefined;
    xmpidq?: Xmpidq | undefined;
    xmpMM?: XmpMM | undefined;
    xmpNote?: XmpNote | undefined;
    xmpRights?: XmpRights | undefined;
    xmpTPg?: XmpTPg | undefined;

    constructor(data?: IXmpMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dc = data["dc"] ? Dc.fromJS(data["dc"]) : <any>undefined;
            this.crs = data["crs"] ? Crs.fromJS(data["crs"]) : <any>undefined;
            this.iptcCore = data["iptcCore"] ? IptcCore.fromJS(data["iptcCore"]) : <any>undefined;
            this.iptcExt = data["iptcExt"] ? IptcExt.fromJS(data["iptcExt"]) : <any>undefined;
            this.iptcIIM = data["iptcIIM"] ? IptcIIM.fromJS(data["iptcIIM"]) : <any>undefined;
            this.lr = data["lr"] ? Lr.fromJS(data["lr"]) : <any>undefined;
            this.pdf = data["pdf"] ? Pdf.fromJS(data["pdf"]) : <any>undefined;
            this.photoshop = data["photoshop"] ? Photoshop.fromJS(data["photoshop"]) : <any>undefined;
            this.plus = data["plus"] ? Plus.fromJS(data["plus"]) : <any>undefined;
            this.tiff = data["tiff"] ? Tiff.fromJS(data["tiff"]) : <any>undefined;
            this.xmp = data["xmp"] ? Xmp.fromJS(data["xmp"]) : <any>undefined;
            this.xmpBJ = data["xmpBJ"] ? XmpBJ.fromJS(data["xmpBJ"]) : <any>undefined;
            this.xmpDM = data["xmpDM"] ? XmpDM.fromJS(data["xmpDM"]) : <any>undefined;
            this.xmpG = data["xmpG"] ? XmpG.fromJS(data["xmpG"]) : <any>undefined;
            this.xmpGImg = data["xmpGImg"] ? XmpGImg.fromJS(data["xmpGImg"]) : <any>undefined;
            this.xmpidq = data["xmpidq"] ? Xmpidq.fromJS(data["xmpidq"]) : <any>undefined;
            this.xmpMM = data["xmpMM"] ? XmpMM.fromJS(data["xmpMM"]) : <any>undefined;
            this.xmpNote = data["xmpNote"] ? XmpNote.fromJS(data["xmpNote"]) : <any>undefined;
            this.xmpRights = data["xmpRights"] ? XmpRights.fromJS(data["xmpRights"]) : <any>undefined;
            this.xmpTPg = data["xmpTPg"] ? XmpTPg.fromJS(data["xmpTPg"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XmpMetadata {
        let result = new XmpMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dc"] = this.dc ? this.dc.toJSON() : <any>undefined;
        data["crs"] = this.crs ? this.crs.toJSON() : <any>undefined;
        data["iptcCore"] = this.iptcCore ? this.iptcCore.toJSON() : <any>undefined;
        data["iptcExt"] = this.iptcExt ? this.iptcExt.toJSON() : <any>undefined;
        data["iptcIIM"] = this.iptcIIM ? this.iptcIIM.toJSON() : <any>undefined;
        data["lr"] = this.lr ? this.lr.toJSON() : <any>undefined;
        data["pdf"] = this.pdf ? this.pdf.toJSON() : <any>undefined;
        data["photoshop"] = this.photoshop ? this.photoshop.toJSON() : <any>undefined;
        data["plus"] = this.plus ? this.plus.toJSON() : <any>undefined;
        data["tiff"] = this.tiff ? this.tiff.toJSON() : <any>undefined;
        data["xmp"] = this.xmp ? this.xmp.toJSON() : <any>undefined;
        data["xmpBJ"] = this.xmpBJ ? this.xmpBJ.toJSON() : <any>undefined;
        data["xmpDM"] = this.xmpDM ? this.xmpDM.toJSON() : <any>undefined;
        data["xmpG"] = this.xmpG ? this.xmpG.toJSON() : <any>undefined;
        data["xmpGImg"] = this.xmpGImg ? this.xmpGImg.toJSON() : <any>undefined;
        data["xmpidq"] = this.xmpidq ? this.xmpidq.toJSON() : <any>undefined;
        data["xmpMM"] = this.xmpMM ? this.xmpMM.toJSON() : <any>undefined;
        data["xmpNote"] = this.xmpNote ? this.xmpNote.toJSON() : <any>undefined;
        data["xmpRights"] = this.xmpRights ? this.xmpRights.toJSON() : <any>undefined;
        data["xmpTPg"] = this.xmpTPg ? this.xmpTPg.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IXmpMetadata {
    dc?: Dc | undefined;
    crs?: Crs | undefined;
    iptcCore?: IptcCore | undefined;
    iptcExt?: IptcExt | undefined;
    iptcIIM?: IptcIIM | undefined;
    lr?: Lr | undefined;
    pdf?: Pdf | undefined;
    photoshop?: Photoshop | undefined;
    plus?: Plus | undefined;
    tiff?: Tiff | undefined;
    xmp?: Xmp | undefined;
    xmpBJ?: XmpBJ | undefined;
    xmpDM?: XmpDM | undefined;
    xmpG?: XmpG | undefined;
    xmpGImg?: XmpGImg | undefined;
    xmpidq?: Xmpidq | undefined;
    xmpMM?: XmpMM | undefined;
    xmpNote?: XmpNote | undefined;
    xmpRights?: XmpRights | undefined;
    xmpTPg?: XmpTPg | undefined;
}

export class Dc implements IDc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;

    constructor(data?: IDc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contributor"] && data["contributor"].constructor === Array) {
                this.contributor = [];
                for (let item of data["contributor"])
                    this.contributor.push(item);
            }
            this.coverage = data["coverage"];
            if (data["creator"] && data["creator"].constructor === Array) {
                this.creator = [];
                for (let item of data["creator"])
                    this.creator.push(item);
            }
            if (data["date"] && data["date"].constructor === Array) {
                this.date = [];
                for (let item of data["date"])
                    this.date.push(new Date(item));
            }
            if (data["description"]) {
                this.description = {};
                for (let key in data["description"]) {
                    if (data["description"].hasOwnProperty(key))
                        this.description[key] = data["description"][key];
                }
            }
            this.format = data["format"];
            this.identifier = data["identifier"];
            if (data["language"] && data["language"].constructor === Array) {
                this.language = [];
                for (let item of data["language"])
                    this.language.push(item);
            }
            if (data["publisher"] && data["publisher"].constructor === Array) {
                this.publisher = [];
                for (let item of data["publisher"])
                    this.publisher.push(item);
            }
            if (data["relation"] && data["relation"].constructor === Array) {
                this.relation = [];
                for (let item of data["relation"])
                    this.relation.push(item);
            }
            if (data["rights"]) {
                this.rights = {};
                for (let key in data["rights"]) {
                    if (data["rights"].hasOwnProperty(key))
                        this.rights[key] = data["rights"][key];
                }
            }
            this.source = data["source"];
            if (data["subject"] && data["subject"].constructor === Array) {
                this.subject = [];
                for (let item of data["subject"])
                    this.subject.push(item);
            }
            if (data["title"]) {
                this.title = {};
                for (let key in data["title"]) {
                    if (data["title"].hasOwnProperty(key))
                        this.title[key] = data["title"][key];
                }
            }
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Dc {
        let result = new Dc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contributor && this.contributor.constructor === Array) {
            data["contributor"] = [];
            for (let item of this.contributor)
                data["contributor"].push(item);
        }
        data["coverage"] = this.coverage;
        if (this.creator && this.creator.constructor === Array) {
            data["creator"] = [];
            for (let item of this.creator)
                data["creator"].push(item);
        }
        if (this.date && this.date.constructor === Array) {
            data["date"] = [];
            for (let item of this.date)
                data["date"].push(item.toISOString());
        }
        if (this.description) {
            data["description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    data["description"][key] = this.description[key];
            }
        }
        data["format"] = this.format;
        data["identifier"] = this.identifier;
        if (this.language && this.language.constructor === Array) {
            data["language"] = [];
            for (let item of this.language)
                data["language"].push(item);
        }
        if (this.publisher && this.publisher.constructor === Array) {
            data["publisher"] = [];
            for (let item of this.publisher)
                data["publisher"].push(item);
        }
        if (this.relation && this.relation.constructor === Array) {
            data["relation"] = [];
            for (let item of this.relation)
                data["relation"].push(item);
        }
        if (this.rights) {
            data["rights"] = {};
            for (let key in this.rights) {
                if (this.rights.hasOwnProperty(key))
                    data["rights"][key] = this.rights[key];
            }
        }
        data["source"] = this.source;
        if (this.subject && this.subject.constructor === Array) {
            data["subject"] = [];
            for (let item of this.subject)
                data["subject"].push(item);
        }
        if (this.title) {
            data["title"] = {};
            for (let key in this.title) {
                if (this.title.hasOwnProperty(key))
                    data["title"][key] = this.title[key];
            }
        }
        data["type"] = this.type;
        return data; 
    }
}

export interface IDc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;
}

export class Crs implements ICrs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;

    constructor(data?: ICrs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoBrightness = data["autoBrightness"];
            this.autoContrast = data["autoContrast"];
            this.autoExposure = data["autoExposure"];
            this.autoShadows = data["autoShadows"];
            this.blueHue = data["blueHue"];
            this.blueSaturation = data["blueSaturation"];
            this.brightness = data["brightness"];
            this.cameraProfile = data["cameraProfile"];
            this.chromaticAberrationB = data["chromaticAberrationB"];
            this.chromaticAberrationR = data["chromaticAberrationR"];
            this.colorNoiseReduction = data["colorNoiseReduction"];
            this.contrast = data["contrast"];
            this.cropTop = data["cropTop"];
            this.cropLeft = data["cropLeft"];
            this.cropBottom = data["cropBottom"];
            this.cropRight = data["cropRight"];
            this.cropAngle = data["cropAngle"];
            this.cropWidth = data["cropWidth"];
            this.cropHeight = data["cropHeight"];
            this.cropUnits = data["cropUnits"];
            this.exposure = data["exposure"];
            this.greenHue = data["greenHue"];
            this.greenSaturation = data["greenSaturation"];
            this.hasCrop = data["hasCrop"];
            this.hasSettings = data["hasSettings"];
            this.luminanceSmoothing = data["luminanceSmoothing"];
            this.rawFileName = data["rawFileName"];
            this.redHue = data["redHue"];
            this.redSaturation = data["redSaturation"];
            this.saturation = data["saturation"];
            this.shadows = data["shadows"];
            this.shadowTint = data["shadowTint"];
            this.sharpness = data["sharpness"];
            this.temperature = data["temperature"];
            this.tint = data["tint"];
            if (data["toneCurve"] && data["toneCurve"].constructor === Array) {
                this.toneCurve = [];
                for (let item of data["toneCurve"])
                    this.toneCurve.push(item);
            }
            this.toneCurveName = data["toneCurveName"];
            this.version = data["version"];
            this.vignetteAmount = data["vignetteAmount"];
            this.vignetteMidpoint = data["vignetteMidpoint"];
            this.whiteBalance = data["whiteBalance"];
        }
    }

    static fromJS(data: any): Crs {
        let result = new Crs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoBrightness"] = this.autoBrightness;
        data["autoContrast"] = this.autoContrast;
        data["autoExposure"] = this.autoExposure;
        data["autoShadows"] = this.autoShadows;
        data["blueHue"] = this.blueHue;
        data["blueSaturation"] = this.blueSaturation;
        data["brightness"] = this.brightness;
        data["cameraProfile"] = this.cameraProfile;
        data["chromaticAberrationB"] = this.chromaticAberrationB;
        data["chromaticAberrationR"] = this.chromaticAberrationR;
        data["colorNoiseReduction"] = this.colorNoiseReduction;
        data["contrast"] = this.contrast;
        data["cropTop"] = this.cropTop;
        data["cropLeft"] = this.cropLeft;
        data["cropBottom"] = this.cropBottom;
        data["cropRight"] = this.cropRight;
        data["cropAngle"] = this.cropAngle;
        data["cropWidth"] = this.cropWidth;
        data["cropHeight"] = this.cropHeight;
        data["cropUnits"] = this.cropUnits;
        data["exposure"] = this.exposure;
        data["greenHue"] = this.greenHue;
        data["greenSaturation"] = this.greenSaturation;
        data["hasCrop"] = this.hasCrop;
        data["hasSettings"] = this.hasSettings;
        data["luminanceSmoothing"] = this.luminanceSmoothing;
        data["rawFileName"] = this.rawFileName;
        data["redHue"] = this.redHue;
        data["redSaturation"] = this.redSaturation;
        data["saturation"] = this.saturation;
        data["shadows"] = this.shadows;
        data["shadowTint"] = this.shadowTint;
        data["sharpness"] = this.sharpness;
        data["temperature"] = this.temperature;
        data["tint"] = this.tint;
        if (this.toneCurve && this.toneCurve.constructor === Array) {
            data["toneCurve"] = [];
            for (let item of this.toneCurve)
                data["toneCurve"].push(item);
        }
        data["toneCurveName"] = this.toneCurveName;
        data["version"] = this.version;
        data["vignetteAmount"] = this.vignetteAmount;
        data["vignetteMidpoint"] = this.vignetteMidpoint;
        data["whiteBalance"] = this.whiteBalance;
        return data; 
    }
}

export interface ICrs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;
}

/** Corresponds to crs.CropUnitsChoice */
export enum CropUnit {
    Pixels = <any>"Pixels", 
    Inches = <any>"Inches", 
    Centimeters = <any>"Centimeters", 
}

/** Corresponds to crs.ToneCurveNameChoice */
export enum ToneCurve {
    Linear = <any>"Linear", 
    MediumContrast = <any>"MediumContrast", 
    StrongContrast = <any>"StrongContrast", 
    Custom = <any>"Custom", 
}

/** Corresponds to crs.WhiteBalanceChoice */
export enum WhiteBalance {
    AsShot = <any>"AsShot", 
    Auto = <any>"Auto", 
    Daylight = <any>"Daylight", 
    Cloudy = <any>"Cloudy", 
    Shade = <any>"Shade", 
    Tungsten = <any>"Tungsten", 
    Fluorescent = <any>"Fluorescent", 
    Flash = <any>"Flash", 
    Custom = <any>"Custom", 
}

export class IptcCore implements IIptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: CreatorContactInfo | undefined;

    constructor(data?: IIptcCore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryCode = data["countryCode"];
            this.intellectualGenre = data["intellectualGenre"];
            if (data["scene"] && data["scene"].constructor === Array) {
                this.scene = [];
                for (let item of data["scene"])
                    this.scene.push(item);
            }
            if (data["subjectCode"] && data["subjectCode"].constructor === Array) {
                this.subjectCode = [];
                for (let item of data["subjectCode"])
                    this.subjectCode.push(item);
            }
            this.location = data["location"];
            this.creatorContactInfo = data["creatorContactInfo"] ? CreatorContactInfo.fromJS(data["creatorContactInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IptcCore {
        let result = new IptcCore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["intellectualGenre"] = this.intellectualGenre;
        if (this.scene && this.scene.constructor === Array) {
            data["scene"] = [];
            for (let item of this.scene)
                data["scene"].push(item);
        }
        if (this.subjectCode && this.subjectCode.constructor === Array) {
            data["subjectCode"] = [];
            for (let item of this.subjectCode)
                data["subjectCode"].push(item);
        }
        data["location"] = this.location;
        data["creatorContactInfo"] = this.creatorContactInfo ? this.creatorContactInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: CreatorContactInfo | undefined;
}

export class CreatorContactInfo implements ICreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreatorContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"];
            this.city = data["city"];
            this.country = data["country"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.postalCode = data["postalCode"];
            this.region = data["region"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): CreatorContactInfo {
        let result = new CreatorContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["country"] = this.country;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["postalCode"] = this.postalCode;
        data["region"] = this.region;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    url?: string | undefined;
}

export class IptcExt implements IIptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: ArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: LocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: RegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: LocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;

    constructor(data?: IIptcExt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionalModelInformation = data["additionalModelInformation"];
            if (data["artworkOrObject"] && data["artworkOrObject"].constructor === Array) {
                this.artworkOrObject = [];
                for (let item of data["artworkOrObject"])
                    this.artworkOrObject.push(ArtworkOrObjectInfo.fromJS(item));
            }
            if (data["organisationInImageCode"] && data["organisationInImageCode"].constructor === Array) {
                this.organisationInImageCode = [];
                for (let item of data["organisationInImageCode"])
                    this.organisationInImageCode.push(item);
            }
            if (data["controlledVocabularyTerm"] && data["controlledVocabularyTerm"].constructor === Array) {
                this.controlledVocabularyTerm = [];
                for (let item of data["controlledVocabularyTerm"])
                    this.controlledVocabularyTerm.push(item);
            }
            if (data["locationShown"] && data["locationShown"].constructor === Array) {
                this.locationShown = [];
                for (let item of data["locationShown"])
                    this.locationShown.push(LocationInfo.fromJS(item));
            }
            if (data["modelAge"] && data["modelAge"].constructor === Array) {
                this.modelAge = [];
                for (let item of data["modelAge"])
                    this.modelAge.push(item);
            }
            if (data["organisationInImageName"] && data["organisationInImageName"].constructor === Array) {
                this.organisationInImageName = [];
                for (let item of data["organisationInImageName"])
                    this.organisationInImageName.push(item);
            }
            if (data["personInImage"] && data["personInImage"].constructor === Array) {
                this.personInImage = [];
                for (let item of data["personInImage"])
                    this.personInImage.push(item);
            }
            this.digitalImageGUID = data["digitalImageGUID"];
            this.digitalSourceType = data["digitalSourceType"];
            if (data["event"]) {
                this.event = {};
                for (let key in data["event"]) {
                    if (data["event"].hasOwnProperty(key))
                        this.event[key] = data["event"][key];
                }
            }
            if (data["imageRegistryEntry"] && data["imageRegistryEntry"].constructor === Array) {
                this.imageRegistryEntry = [];
                for (let item of data["imageRegistryEntry"])
                    this.imageRegistryEntry.push(RegistryEntryInfo.fromJS(item));
            }
            this.metadataLastEdited = data["metadataLastEdited"] ? new Date(data["metadataLastEdited"].toString()) : <any>undefined;
            if (data["locationCreated"] && data["locationCreated"].constructor === Array) {
                this.locationCreated = [];
                for (let item of data["locationCreated"])
                    this.locationCreated.push(LocationInfo.fromJS(item));
            }
            this.maxAvailHeight = data["maxAvailHeight"];
            this.maxAvailWidth = data["maxAvailWidth"];
        }
    }

    static fromJS(data: any): IptcExt {
        let result = new IptcExt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalModelInformation"] = this.additionalModelInformation;
        if (this.artworkOrObject && this.artworkOrObject.constructor === Array) {
            data["artworkOrObject"] = [];
            for (let item of this.artworkOrObject)
                data["artworkOrObject"].push(item.toJSON());
        }
        if (this.organisationInImageCode && this.organisationInImageCode.constructor === Array) {
            data["organisationInImageCode"] = [];
            for (let item of this.organisationInImageCode)
                data["organisationInImageCode"].push(item);
        }
        if (this.controlledVocabularyTerm && this.controlledVocabularyTerm.constructor === Array) {
            data["controlledVocabularyTerm"] = [];
            for (let item of this.controlledVocabularyTerm)
                data["controlledVocabularyTerm"].push(item);
        }
        if (this.locationShown && this.locationShown.constructor === Array) {
            data["locationShown"] = [];
            for (let item of this.locationShown)
                data["locationShown"].push(item.toJSON());
        }
        if (this.modelAge && this.modelAge.constructor === Array) {
            data["modelAge"] = [];
            for (let item of this.modelAge)
                data["modelAge"].push(item);
        }
        if (this.organisationInImageName && this.organisationInImageName.constructor === Array) {
            data["organisationInImageName"] = [];
            for (let item of this.organisationInImageName)
                data["organisationInImageName"].push(item);
        }
        if (this.personInImage && this.personInImage.constructor === Array) {
            data["personInImage"] = [];
            for (let item of this.personInImage)
                data["personInImage"].push(item);
        }
        data["digitalImageGUID"] = this.digitalImageGUID;
        data["digitalSourceType"] = this.digitalSourceType;
        if (this.event) {
            data["event"] = {};
            for (let key in this.event) {
                if (this.event.hasOwnProperty(key))
                    data["event"][key] = this.event[key];
            }
        }
        if (this.imageRegistryEntry && this.imageRegistryEntry.constructor === Array) {
            data["imageRegistryEntry"] = [];
            for (let item of this.imageRegistryEntry)
                data["imageRegistryEntry"].push(item.toJSON());
        }
        data["metadataLastEdited"] = this.metadataLastEdited ? this.metadataLastEdited.toISOString() : <any>undefined;
        if (this.locationCreated && this.locationCreated.constructor === Array) {
            data["locationCreated"] = [];
            for (let item of this.locationCreated)
                data["locationCreated"].push(item.toJSON());
        }
        data["maxAvailHeight"] = this.maxAvailHeight;
        data["maxAvailWidth"] = this.maxAvailWidth;
        return data; 
    }
}

export interface IIptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: ArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: LocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: RegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: LocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;
}

export class ArtworkOrObjectInfo implements IArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;

    constructor(data?: IArtworkOrObjectInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.copyrightNotice = data["copyrightNotice"];
            if (data["creator"] && data["creator"].constructor === Array) {
                this.creator = [];
                for (let item of data["creator"])
                    this.creator.push(item);
            }
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>undefined;
            this.source = data["source"];
            this.sourceInventoryNumber = data["sourceInventoryNumber"];
            if (data["title"]) {
                this.title = {};
                for (let key in data["title"]) {
                    if (data["title"].hasOwnProperty(key))
                        this.title[key] = data["title"][key];
                }
            }
        }
    }

    static fromJS(data: any): ArtworkOrObjectInfo {
        let result = new ArtworkOrObjectInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["copyrightNotice"] = this.copyrightNotice;
        if (this.creator && this.creator.constructor === Array) {
            data["creator"] = [];
            for (let item of this.creator)
                data["creator"].push(item);
        }
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["source"] = this.source;
        data["sourceInventoryNumber"] = this.sourceInventoryNumber;
        if (this.title) {
            data["title"] = {};
            for (let key in this.title) {
                if (this.title.hasOwnProperty(key))
                    data["title"][key] = this.title[key];
            }
        }
        return data; 
    }
}

export interface IArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;
}

export class LocationInfo implements ILocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;

    constructor(data?: ILocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.city = data["city"];
            this.countryCode = data["countryCode"];
            this.countryName = data["countryName"];
            this.provinceState = data["provinceState"];
            this.sublocation = data["sublocation"];
            this.worldRegion = data["worldRegion"];
        }
    }

    static fromJS(data: any): LocationInfo {
        let result = new LocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["provinceState"] = this.provinceState;
        data["sublocation"] = this.sublocation;
        data["worldRegion"] = this.worldRegion;
        return data; 
    }
}

export interface ILocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;
}

export class RegistryEntryInfo implements IRegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;

    constructor(data?: IRegistryEntryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registryItemIdentifier = data["registryItemIdentifier"];
            this.registryOrganisationIdentifier = data["registryOrganisationIdentifier"];
        }
    }

    static fromJS(data: any): RegistryEntryInfo {
        let result = new RegistryEntryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registryItemIdentifier"] = this.registryItemIdentifier;
        data["registryOrganisationIdentifier"] = this.registryOrganisationIdentifier;
        return data; 
    }
}

export interface IRegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;
}

export class IptcIIM implements IIptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uno?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;

    constructor(data?: IIptcIIM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelVersion = data["modelVersion"];
            if (data["destination"] && data["destination"].constructor === Array) {
                this.destination = [];
                for (let item of data["destination"])
                    this.destination.push(item);
            }
            this.fileFormat = data["fileFormat"];
            this.fileFormatVersion = data["fileFormatVersion"];
            this.serviceIdentifier = data["serviceIdentifier"];
            this.envelopeNumber = data["envelopeNumber"];
            if (data["productID"] && data["productID"].constructor === Array) {
                this.productID = [];
                for (let item of data["productID"])
                    this.productID.push(item);
            }
            this.envelopePriority = data["envelopePriority"];
            this.dateSent = data["dateSent"] ? new Date(data["dateSent"].toString()) : <any>undefined;
            this.timeSent = data["timeSent"] ? new Date(data["timeSent"].toString()) : <any>undefined;
            this.uno = data["uno"];
            this.recordVersion = data["recordVersion"];
            this.objectTypeReference = data["objectTypeReference"];
            this.objectAttributeReference = data["objectAttributeReference"];
            if (data["objectName"]) {
                this.objectName = {};
                for (let key in data["objectName"]) {
                    if (data["objectName"].hasOwnProperty(key))
                        this.objectName[key] = data["objectName"][key];
                }
            }
            this.editStatus = data["editStatus"];
            this.urgency = data["urgency"];
            if (data["subjectReference"] && data["subjectReference"].constructor === Array) {
                this.subjectReference = [];
                for (let item of data["subjectReference"])
                    this.subjectReference.push(item);
            }
            this.category = data["category"];
            if (data["supplementalCategory"] && data["supplementalCategory"].constructor === Array) {
                this.supplementalCategory = [];
                for (let item of data["supplementalCategory"])
                    this.supplementalCategory.push(item);
            }
            this.fixtureIdentifier = data["fixtureIdentifier"];
            if (data["keywords"] && data["keywords"].constructor === Array) {
                this.keywords = [];
                for (let item of data["keywords"])
                    this.keywords.push(item);
            }
            if (data["contentLocationCode"] && data["contentLocationCode"].constructor === Array) {
                this.contentLocationCode = [];
                for (let item of data["contentLocationCode"])
                    this.contentLocationCode.push(item);
            }
            if (data["contentLocationName"] && data["contentLocationName"].constructor === Array) {
                this.contentLocationName = [];
                for (let item of data["contentLocationName"])
                    this.contentLocationName.push(item);
            }
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            this.releaseTime = data["releaseTime"] ? new Date(data["releaseTime"].toString()) : <any>undefined;
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.expirationTime = data["expirationTime"] ? new Date(data["expirationTime"].toString()) : <any>undefined;
            this.specialInstruction = data["specialInstruction"];
            this.actionAdvised = data["actionAdvised"];
            this.referenceService = data["referenceService"];
            this.referenceDate = data["referenceDate"] ? new Date(data["referenceDate"].toString()) : <any>undefined;
            this.referenceNumber = data["referenceNumber"];
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>undefined;
            this.timeCreated = data["timeCreated"] ? new Date(data["timeCreated"].toString()) : <any>undefined;
            this.digitalCreationDate = data["digitalCreationDate"] ? new Date(data["digitalCreationDate"].toString()) : <any>undefined;
            this.digitalCreationTime = data["digitalCreationTime"] ? new Date(data["digitalCreationTime"].toString()) : <any>undefined;
            this.originatingProgram = data["originatingProgram"];
            this.programVersion = data["programVersion"];
            if (data["byline"] && data["byline"].constructor === Array) {
                this.byline = [];
                for (let item of data["byline"])
                    this.byline.push(item);
            }
            this.bylineTitle = data["bylineTitle"];
            this.city = data["city"];
            this.sublocation = data["sublocation"];
            this.provinceState = data["provinceState"];
            this.countryPrimaryLocationCode = data["countryPrimaryLocationCode"];
            this.countryPrimaryLocationName = data["countryPrimaryLocationName"];
            this.originalTransmissionReference = data["originalTransmissionReference"];
            this.headline = data["headline"];
            this.credit = data["credit"];
            this.source = data["source"];
            if (data["copyrightNotice"]) {
                this.copyrightNotice = {};
                for (let key in data["copyrightNotice"]) {
                    if (data["copyrightNotice"].hasOwnProperty(key))
                        this.copyrightNotice[key] = data["copyrightNotice"][key];
                }
            }
            if (data["captionAbstract"]) {
                this.captionAbstract = {};
                for (let key in data["captionAbstract"]) {
                    if (data["captionAbstract"].hasOwnProperty(key))
                        this.captionAbstract[key] = data["captionAbstract"][key];
                }
            }
            this.writerEditor = data["writerEditor"];
            this.imageType = data["imageType"];
            this.imageOrientation = data["imageOrientation"];
            this.languageIdentifier = data["languageIdentifier"];
        }
    }

    static fromJS(data: any): IptcIIM {
        let result = new IptcIIM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelVersion"] = this.modelVersion;
        if (this.destination && this.destination.constructor === Array) {
            data["destination"] = [];
            for (let item of this.destination)
                data["destination"].push(item);
        }
        data["fileFormat"] = this.fileFormat;
        data["fileFormatVersion"] = this.fileFormatVersion;
        data["serviceIdentifier"] = this.serviceIdentifier;
        data["envelopeNumber"] = this.envelopeNumber;
        if (this.productID && this.productID.constructor === Array) {
            data["productID"] = [];
            for (let item of this.productID)
                data["productID"].push(item);
        }
        data["envelopePriority"] = this.envelopePriority;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["timeSent"] = this.timeSent ? this.timeSent.toISOString() : <any>undefined;
        data["uno"] = this.uno;
        data["recordVersion"] = this.recordVersion;
        data["objectTypeReference"] = this.objectTypeReference;
        data["objectAttributeReference"] = this.objectAttributeReference;
        if (this.objectName) {
            data["objectName"] = {};
            for (let key in this.objectName) {
                if (this.objectName.hasOwnProperty(key))
                    data["objectName"][key] = this.objectName[key];
            }
        }
        data["editStatus"] = this.editStatus;
        data["urgency"] = this.urgency;
        if (this.subjectReference && this.subjectReference.constructor === Array) {
            data["subjectReference"] = [];
            for (let item of this.subjectReference)
                data["subjectReference"].push(item);
        }
        data["category"] = this.category;
        if (this.supplementalCategory && this.supplementalCategory.constructor === Array) {
            data["supplementalCategory"] = [];
            for (let item of this.supplementalCategory)
                data["supplementalCategory"].push(item);
        }
        data["fixtureIdentifier"] = this.fixtureIdentifier;
        if (this.keywords && this.keywords.constructor === Array) {
            data["keywords"] = [];
            for (let item of this.keywords)
                data["keywords"].push(item);
        }
        if (this.contentLocationCode && this.contentLocationCode.constructor === Array) {
            data["contentLocationCode"] = [];
            for (let item of this.contentLocationCode)
                data["contentLocationCode"].push(item);
        }
        if (this.contentLocationName && this.contentLocationName.constructor === Array) {
            data["contentLocationName"] = [];
            for (let item of this.contentLocationName)
                data["contentLocationName"].push(item);
        }
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["releaseTime"] = this.releaseTime ? this.releaseTime.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["specialInstruction"] = this.specialInstruction;
        data["actionAdvised"] = this.actionAdvised;
        data["referenceService"] = this.referenceService;
        data["referenceDate"] = this.referenceDate ? this.referenceDate.toISOString() : <any>undefined;
        data["referenceNumber"] = this.referenceNumber;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["timeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["digitalCreationDate"] = this.digitalCreationDate ? this.digitalCreationDate.toISOString() : <any>undefined;
        data["digitalCreationTime"] = this.digitalCreationTime ? this.digitalCreationTime.toISOString() : <any>undefined;
        data["originatingProgram"] = this.originatingProgram;
        data["programVersion"] = this.programVersion;
        if (this.byline && this.byline.constructor === Array) {
            data["byline"] = [];
            for (let item of this.byline)
                data["byline"].push(item);
        }
        data["bylineTitle"] = this.bylineTitle;
        data["city"] = this.city;
        data["sublocation"] = this.sublocation;
        data["provinceState"] = this.provinceState;
        data["countryPrimaryLocationCode"] = this.countryPrimaryLocationCode;
        data["countryPrimaryLocationName"] = this.countryPrimaryLocationName;
        data["originalTransmissionReference"] = this.originalTransmissionReference;
        data["headline"] = this.headline;
        data["credit"] = this.credit;
        data["source"] = this.source;
        if (this.copyrightNotice) {
            data["copyrightNotice"] = {};
            for (let key in this.copyrightNotice) {
                if (this.copyrightNotice.hasOwnProperty(key))
                    data["copyrightNotice"][key] = this.copyrightNotice[key];
            }
        }
        if (this.captionAbstract) {
            data["captionAbstract"] = {};
            for (let key in this.captionAbstract) {
                if (this.captionAbstract.hasOwnProperty(key))
                    data["captionAbstract"][key] = this.captionAbstract[key];
            }
        }
        data["writerEditor"] = this.writerEditor;
        data["imageType"] = this.imageType;
        data["imageOrientation"] = this.imageOrientation;
        data["languageIdentifier"] = this.languageIdentifier;
        return data; 
    }
}

export interface IIptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uno?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;
}

export class Lr implements ILr {
    hierarchicalSubject?: string[] | undefined;

    constructor(data?: ILr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["hierarchicalSubject"] && data["hierarchicalSubject"].constructor === Array) {
                this.hierarchicalSubject = [];
                for (let item of data["hierarchicalSubject"])
                    this.hierarchicalSubject.push(item);
            }
        }
    }

    static fromJS(data: any): Lr {
        let result = new Lr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.hierarchicalSubject && this.hierarchicalSubject.constructor === Array) {
            data["hierarchicalSubject"] = [];
            for (let item of this.hierarchicalSubject)
                data["hierarchicalSubject"].push(item);
        }
        return data; 
    }
}

export interface ILr {
    hierarchicalSubject?: string[] | undefined;
}

export class Pdf implements IPdf {
    keywords?: string | undefined;
    pdfVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;

    constructor(data?: IPdf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keywords = data["keywords"];
            this.pdfVersion = data["pdfVersion"];
            this.producer = data["producer"];
            this.trapped = data["trapped"];
        }
    }

    static fromJS(data: any): Pdf {
        let result = new Pdf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords;
        data["pdfVersion"] = this.pdfVersion;
        data["producer"] = this.producer;
        data["trapped"] = this.trapped;
        return data; 
    }
}

export interface IPdf {
    keywords?: string | undefined;
    pdfVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;
}

export class Photoshop implements IPhotoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iccProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: PhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;

    constructor(data?: IPhotoshop) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authorsPosition = data["authorsPosition"];
            this.captionWriter = data["captionWriter"];
            this.category = data["category"];
            this.city = data["city"];
            this.colorMode = data["colorMode"];
            this.country = data["country"];
            this.credit = data["credit"];
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>undefined;
            if (data["documentAncestors"] && data["documentAncestors"].constructor === Array) {
                this.documentAncestors = [];
                for (let item of data["documentAncestors"])
                    this.documentAncestors.push(item);
            }
            this.headline = data["headline"];
            this.history = data["history"];
            this.iccProfile = data["iccProfile"];
            this.instructions = data["instructions"];
            this.source = data["source"];
            this.state = data["state"];
            if (data["supplementalCategories"] && data["supplementalCategories"].constructor === Array) {
                this.supplementalCategories = [];
                for (let item of data["supplementalCategories"])
                    this.supplementalCategories.push(item);
            }
            if (data["textLayers"] && data["textLayers"].constructor === Array) {
                this.textLayers = [];
                for (let item of data["textLayers"])
                    this.textLayers.push(PhotoshopLayer.fromJS(item));
            }
            this.transmissionReference = data["transmissionReference"];
            this.urgency = data["urgency"];
            this.legacyIPTCDigest = data["legacyIPTCDigest"];
        }
    }

    static fromJS(data: any): Photoshop {
        let result = new Photoshop();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorsPosition"] = this.authorsPosition;
        data["captionWriter"] = this.captionWriter;
        data["category"] = this.category;
        data["city"] = this.city;
        data["colorMode"] = this.colorMode;
        data["country"] = this.country;
        data["credit"] = this.credit;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        if (this.documentAncestors && this.documentAncestors.constructor === Array) {
            data["documentAncestors"] = [];
            for (let item of this.documentAncestors)
                data["documentAncestors"].push(item);
        }
        data["headline"] = this.headline;
        data["history"] = this.history;
        data["iccProfile"] = this.iccProfile;
        data["instructions"] = this.instructions;
        data["source"] = this.source;
        data["state"] = this.state;
        if (this.supplementalCategories && this.supplementalCategories.constructor === Array) {
            data["supplementalCategories"] = [];
            for (let item of this.supplementalCategories)
                data["supplementalCategories"].push(item);
        }
        if (this.textLayers && this.textLayers.constructor === Array) {
            data["textLayers"] = [];
            for (let item of this.textLayers)
                data["textLayers"].push(item.toJSON());
        }
        data["transmissionReference"] = this.transmissionReference;
        data["urgency"] = this.urgency;
        data["legacyIPTCDigest"] = this.legacyIPTCDigest;
        return data; 
    }
}

export interface IPhotoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iccProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: PhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;
}

/** Corresponds to photoshop.ColorModeChoice */
export enum ColorMode {
    Bitmap = <any>"Bitmap", 
    Grayscale = <any>"Grayscale", 
    Indexed = <any>"Indexed", 
    RGB = <any>"RGB", 
    CMYK = <any>"CMYK", 
    Multichannel = <any>"Multichannel", 
    Duotone = <any>"Duotone", 
    LAB = <any>"LAB", 
}

export class PhotoshopLayer implements IPhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;

    constructor(data?: IPhotoshopLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layerName = data["layerName"];
            this.layerText = data["layerText"];
        }
    }

    static fromJS(data: any): PhotoshopLayer {
        let result = new PhotoshopLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerName"] = this.layerName;
        data["layerText"] = this.layerText;
        return data; 
    }
}

export interface IPhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;
}

export class Plus implements IPlus {
    version?: string | undefined;
    licensee?: LicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: EndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: LicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: CopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: ImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: ImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;

    constructor(data?: IPlus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            if (data["licensee"] && data["licensee"].constructor === Array) {
                this.licensee = [];
                for (let item of data["licensee"])
                    this.licensee.push(LicenseeInfo.fromJS(item));
            }
            this.licenseeID = data["licenseeID"];
            this.licenseeName = data["licenseeName"];
            if (data["endUser"] && data["endUser"].constructor === Array) {
                this.endUser = [];
                for (let item of data["endUser"])
                    this.endUser.push(EndUserInfo.fromJS(item));
            }
            this.endUserID = data["endUserID"];
            this.endUserName = data["endUserName"];
            if (data["licensor"] && data["licensor"].constructor === Array) {
                this.licensor = [];
                for (let item of data["licensor"])
                    this.licensor.push(LicensorInfo.fromJS(item));
            }
            if (data["licensorNotes"]) {
                this.licensorNotes = {};
                for (let key in data["licensorNotes"]) {
                    if (data["licensorNotes"].hasOwnProperty(key))
                        this.licensorNotes[key] = data["licensorNotes"][key];
                }
            }
            this.mediaSummaryCode = data["mediaSummaryCode"];
            this.licenseStartDate = data["licenseStartDate"] ? new Date(data["licenseStartDate"].toString()) : <any>undefined;
            this.licenseEndDate = data["licenseEndDate"] ? new Date(data["licenseEndDate"].toString()) : <any>undefined;
            if (data["mediaConstraints"]) {
                this.mediaConstraints = {};
                for (let key in data["mediaConstraints"]) {
                    if (data["mediaConstraints"].hasOwnProperty(key))
                        this.mediaConstraints[key] = data["mediaConstraints"][key];
                }
            }
            if (data["regionConstraints"]) {
                this.regionConstraints = {};
                for (let key in data["regionConstraints"]) {
                    if (data["regionConstraints"].hasOwnProperty(key))
                        this.regionConstraints[key] = data["regionConstraints"][key];
                }
            }
            if (data["productOrServiceConstraints"]) {
                this.productOrServiceConstraints = {};
                for (let key in data["productOrServiceConstraints"]) {
                    if (data["productOrServiceConstraints"].hasOwnProperty(key))
                        this.productOrServiceConstraints[key] = data["productOrServiceConstraints"][key];
                }
            }
            if (data["imageFileConstraints"] && data["imageFileConstraints"].constructor === Array) {
                this.imageFileConstraints = [];
                for (let item of data["imageFileConstraints"])
                    this.imageFileConstraints.push(item);
            }
            if (data["imageAlterationConstraints"] && data["imageAlterationConstraints"].constructor === Array) {
                this.imageAlterationConstraints = [];
                for (let item of data["imageAlterationConstraints"])
                    this.imageAlterationConstraints.push(item);
            }
            this.imageDuplicationConstraints = data["imageDuplicationConstraints"];
            this.modelReleaseStatus = data["modelReleaseStatus"];
            if (data["modelReleaseID"] && data["modelReleaseID"].constructor === Array) {
                this.modelReleaseID = [];
                for (let item of data["modelReleaseID"])
                    this.modelReleaseID.push(item);
            }
            this.minorModelAgeDisclosure = data["minorModelAgeDisclosure"];
            this.propertyReleaseStatus = data["propertyReleaseStatus"];
            if (data["propertyReleaseID"] && data["propertyReleaseID"].constructor === Array) {
                this.propertyReleaseID = [];
                for (let item of data["propertyReleaseID"])
                    this.propertyReleaseID.push(item);
            }
            if (data["otherConstraints"]) {
                this.otherConstraints = {};
                for (let key in data["otherConstraints"]) {
                    if (data["otherConstraints"].hasOwnProperty(key))
                        this.otherConstraints[key] = data["otherConstraints"][key];
                }
            }
            this.creditLineRequired = data["creditLineRequired"];
            this.adultContentWarning = data["adultContentWarning"];
            if (data["otherLicenseRequirements"]) {
                this.otherLicenseRequirements = {};
                for (let key in data["otherLicenseRequirements"]) {
                    if (data["otherLicenseRequirements"].hasOwnProperty(key))
                        this.otherLicenseRequirements[key] = data["otherLicenseRequirements"][key];
                }
            }
            if (data["termsAndConditionsText"]) {
                this.termsAndConditionsText = {};
                for (let key in data["termsAndConditionsText"]) {
                    if (data["termsAndConditionsText"].hasOwnProperty(key))
                        this.termsAndConditionsText[key] = data["termsAndConditionsText"][key];
                }
            }
            this.termsAndConditionsURL = data["termsAndConditionsURL"];
            if (data["otherConditions"]) {
                this.otherConditions = {};
                for (let key in data["otherConditions"]) {
                    if (data["otherConditions"].hasOwnProperty(key))
                        this.otherConditions[key] = data["otherConditions"][key];
                }
            }
            this.imageType = data["imageType"];
            this.licensorImageID = data["licensorImageID"];
            this.fileNameAsDelivered = data["fileNameAsDelivered"];
            this.imageFileFormatAsDelivered = data["imageFileFormatAsDelivered"];
            this.imageFileSizeAsDelivered = data["imageFileSizeAsDelivered"];
            this.copyrightStatus = data["copyrightStatus"];
            this.copyrightRegistrationNumber = data["copyrightRegistrationNumber"];
            this.firstPublicationDate = data["firstPublicationDate"] ? new Date(data["firstPublicationDate"].toString()) : <any>undefined;
            if (data["copyrightOwner"] && data["copyrightOwner"].constructor === Array) {
                this.copyrightOwner = [];
                for (let item of data["copyrightOwner"])
                    this.copyrightOwner.push(CopyrightOwnerInfo.fromJS(item));
            }
            this.copyrightOwnerImageID = data["copyrightOwnerImageID"];
            if (data["imageCreator"] && data["imageCreator"].constructor === Array) {
                this.imageCreator = [];
                for (let item of data["imageCreator"])
                    this.imageCreator.push(ImageCreatorInfo.fromJS(item));
            }
            this.imageCreatorImageID = data["imageCreatorImageID"];
            if (data["imageSupplier"] && data["imageSupplier"].constructor === Array) {
                this.imageSupplier = [];
                for (let item of data["imageSupplier"])
                    this.imageSupplier.push(ImageSupplierInfo.fromJS(item));
            }
            this.imageSupplierImageID = data["imageSupplierImageID"];
            this.licenseeImageID = data["licenseeImageID"];
            if (data["licenseeImageNotes"]) {
                this.licenseeImageNotes = {};
                for (let key in data["licenseeImageNotes"]) {
                    if (data["licenseeImageNotes"].hasOwnProperty(key))
                        this.licenseeImageNotes[key] = data["licenseeImageNotes"][key];
                }
            }
            if (data["otherImageInfo"]) {
                this.otherImageInfo = {};
                for (let key in data["otherImageInfo"]) {
                    if (data["otherImageInfo"].hasOwnProperty(key))
                        this.otherImageInfo[key] = data["otherImageInfo"][key];
                }
            }
            this.licenseID = data["licenseID"];
            if (data["licensorTransactionID"] && data["licensorTransactionID"].constructor === Array) {
                this.licensorTransactionID = [];
                for (let item of data["licensorTransactionID"])
                    this.licensorTransactionID.push(item);
            }
            if (data["licenseeTransactionID"] && data["licenseeTransactionID"].constructor === Array) {
                this.licenseeTransactionID = [];
                for (let item of data["licenseeTransactionID"])
                    this.licenseeTransactionID.push(item);
            }
            if (data["licenseeProjectReference"] && data["licenseeProjectReference"].constructor === Array) {
                this.licenseeProjectReference = [];
                for (let item of data["licenseeProjectReference"])
                    this.licenseeProjectReference.push(item);
            }
            this.licenseTransactionDate = data["licenseTransactionDate"] ? new Date(data["licenseTransactionDate"].toString()) : <any>undefined;
            this.reuse = data["reuse"];
            if (data["otherLicenseDocuments"] && data["otherLicenseDocuments"].constructor === Array) {
                this.otherLicenseDocuments = [];
                for (let item of data["otherLicenseDocuments"])
                    this.otherLicenseDocuments.push(item);
            }
            if (data["otherLicenseInfo"]) {
                this.otherLicenseInfo = {};
                for (let key in data["otherLicenseInfo"]) {
                    if (data["otherLicenseInfo"].hasOwnProperty(key))
                        this.otherLicenseInfo[key] = data["otherLicenseInfo"][key];
                }
            }
            if (data["custom1"] && data["custom1"].constructor === Array) {
                this.custom1 = [];
                for (let item of data["custom1"])
                    this.custom1.push(item);
            }
            if (data["custom2"] && data["custom2"].constructor === Array) {
                this.custom2 = [];
                for (let item of data["custom2"])
                    this.custom2.push(item);
            }
            if (data["custom3"] && data["custom3"].constructor === Array) {
                this.custom3 = [];
                for (let item of data["custom3"])
                    this.custom3.push(item);
            }
            if (data["custom4"] && data["custom4"].constructor === Array) {
                this.custom4 = [];
                for (let item of data["custom4"])
                    this.custom4.push(item);
            }
            if (data["custom5"] && data["custom5"].constructor === Array) {
                this.custom5 = [];
                for (let item of data["custom5"])
                    this.custom5.push(item);
            }
            if (data["custom6"] && data["custom6"].constructor === Array) {
                this.custom6 = [];
                for (let item of data["custom6"])
                    this.custom6.push(item);
            }
            if (data["custom7"] && data["custom7"].constructor === Array) {
                this.custom7 = [];
                for (let item of data["custom7"])
                    this.custom7.push(item);
            }
            if (data["custom8"] && data["custom8"].constructor === Array) {
                this.custom8 = [];
                for (let item of data["custom8"])
                    this.custom8.push(item);
            }
            if (data["custom9"] && data["custom9"].constructor === Array) {
                this.custom9 = [];
                for (let item of data["custom9"])
                    this.custom9.push(item);
            }
            if (data["custom10"] && data["custom10"].constructor === Array) {
                this.custom10 = [];
                for (let item of data["custom10"])
                    this.custom10.push(item);
            }
        }
    }

    static fromJS(data: any): Plus {
        let result = new Plus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        if (this.licensee && this.licensee.constructor === Array) {
            data["licensee"] = [];
            for (let item of this.licensee)
                data["licensee"].push(item.toJSON());
        }
        data["licenseeID"] = this.licenseeID;
        data["licenseeName"] = this.licenseeName;
        if (this.endUser && this.endUser.constructor === Array) {
            data["endUser"] = [];
            for (let item of this.endUser)
                data["endUser"].push(item.toJSON());
        }
        data["endUserID"] = this.endUserID;
        data["endUserName"] = this.endUserName;
        if (this.licensor && this.licensor.constructor === Array) {
            data["licensor"] = [];
            for (let item of this.licensor)
                data["licensor"].push(item.toJSON());
        }
        if (this.licensorNotes) {
            data["licensorNotes"] = {};
            for (let key in this.licensorNotes) {
                if (this.licensorNotes.hasOwnProperty(key))
                    data["licensorNotes"][key] = this.licensorNotes[key];
            }
        }
        data["mediaSummaryCode"] = this.mediaSummaryCode;
        data["licenseStartDate"] = this.licenseStartDate ? this.licenseStartDate.toISOString() : <any>undefined;
        data["licenseEndDate"] = this.licenseEndDate ? this.licenseEndDate.toISOString() : <any>undefined;
        if (this.mediaConstraints) {
            data["mediaConstraints"] = {};
            for (let key in this.mediaConstraints) {
                if (this.mediaConstraints.hasOwnProperty(key))
                    data["mediaConstraints"][key] = this.mediaConstraints[key];
            }
        }
        if (this.regionConstraints) {
            data["regionConstraints"] = {};
            for (let key in this.regionConstraints) {
                if (this.regionConstraints.hasOwnProperty(key))
                    data["regionConstraints"][key] = this.regionConstraints[key];
            }
        }
        if (this.productOrServiceConstraints) {
            data["productOrServiceConstraints"] = {};
            for (let key in this.productOrServiceConstraints) {
                if (this.productOrServiceConstraints.hasOwnProperty(key))
                    data["productOrServiceConstraints"][key] = this.productOrServiceConstraints[key];
            }
        }
        if (this.imageFileConstraints && this.imageFileConstraints.constructor === Array) {
            data["imageFileConstraints"] = [];
            for (let item of this.imageFileConstraints)
                data["imageFileConstraints"].push(item);
        }
        if (this.imageAlterationConstraints && this.imageAlterationConstraints.constructor === Array) {
            data["imageAlterationConstraints"] = [];
            for (let item of this.imageAlterationConstraints)
                data["imageAlterationConstraints"].push(item);
        }
        data["imageDuplicationConstraints"] = this.imageDuplicationConstraints;
        data["modelReleaseStatus"] = this.modelReleaseStatus;
        if (this.modelReleaseID && this.modelReleaseID.constructor === Array) {
            data["modelReleaseID"] = [];
            for (let item of this.modelReleaseID)
                data["modelReleaseID"].push(item);
        }
        data["minorModelAgeDisclosure"] = this.minorModelAgeDisclosure;
        data["propertyReleaseStatus"] = this.propertyReleaseStatus;
        if (this.propertyReleaseID && this.propertyReleaseID.constructor === Array) {
            data["propertyReleaseID"] = [];
            for (let item of this.propertyReleaseID)
                data["propertyReleaseID"].push(item);
        }
        if (this.otherConstraints) {
            data["otherConstraints"] = {};
            for (let key in this.otherConstraints) {
                if (this.otherConstraints.hasOwnProperty(key))
                    data["otherConstraints"][key] = this.otherConstraints[key];
            }
        }
        data["creditLineRequired"] = this.creditLineRequired;
        data["adultContentWarning"] = this.adultContentWarning;
        if (this.otherLicenseRequirements) {
            data["otherLicenseRequirements"] = {};
            for (let key in this.otherLicenseRequirements) {
                if (this.otherLicenseRequirements.hasOwnProperty(key))
                    data["otherLicenseRequirements"][key] = this.otherLicenseRequirements[key];
            }
        }
        if (this.termsAndConditionsText) {
            data["termsAndConditionsText"] = {};
            for (let key in this.termsAndConditionsText) {
                if (this.termsAndConditionsText.hasOwnProperty(key))
                    data["termsAndConditionsText"][key] = this.termsAndConditionsText[key];
            }
        }
        data["termsAndConditionsURL"] = this.termsAndConditionsURL;
        if (this.otherConditions) {
            data["otherConditions"] = {};
            for (let key in this.otherConditions) {
                if (this.otherConditions.hasOwnProperty(key))
                    data["otherConditions"][key] = this.otherConditions[key];
            }
        }
        data["imageType"] = this.imageType;
        data["licensorImageID"] = this.licensorImageID;
        data["fileNameAsDelivered"] = this.fileNameAsDelivered;
        data["imageFileFormatAsDelivered"] = this.imageFileFormatAsDelivered;
        data["imageFileSizeAsDelivered"] = this.imageFileSizeAsDelivered;
        data["copyrightStatus"] = this.copyrightStatus;
        data["copyrightRegistrationNumber"] = this.copyrightRegistrationNumber;
        data["firstPublicationDate"] = this.firstPublicationDate ? this.firstPublicationDate.toISOString() : <any>undefined;
        if (this.copyrightOwner && this.copyrightOwner.constructor === Array) {
            data["copyrightOwner"] = [];
            for (let item of this.copyrightOwner)
                data["copyrightOwner"].push(item.toJSON());
        }
        data["copyrightOwnerImageID"] = this.copyrightOwnerImageID;
        if (this.imageCreator && this.imageCreator.constructor === Array) {
            data["imageCreator"] = [];
            for (let item of this.imageCreator)
                data["imageCreator"].push(item.toJSON());
        }
        data["imageCreatorImageID"] = this.imageCreatorImageID;
        if (this.imageSupplier && this.imageSupplier.constructor === Array) {
            data["imageSupplier"] = [];
            for (let item of this.imageSupplier)
                data["imageSupplier"].push(item.toJSON());
        }
        data["imageSupplierImageID"] = this.imageSupplierImageID;
        data["licenseeImageID"] = this.licenseeImageID;
        if (this.licenseeImageNotes) {
            data["licenseeImageNotes"] = {};
            for (let key in this.licenseeImageNotes) {
                if (this.licenseeImageNotes.hasOwnProperty(key))
                    data["licenseeImageNotes"][key] = this.licenseeImageNotes[key];
            }
        }
        if (this.otherImageInfo) {
            data["otherImageInfo"] = {};
            for (let key in this.otherImageInfo) {
                if (this.otherImageInfo.hasOwnProperty(key))
                    data["otherImageInfo"][key] = this.otherImageInfo[key];
            }
        }
        data["licenseID"] = this.licenseID;
        if (this.licensorTransactionID && this.licensorTransactionID.constructor === Array) {
            data["licensorTransactionID"] = [];
            for (let item of this.licensorTransactionID)
                data["licensorTransactionID"].push(item);
        }
        if (this.licenseeTransactionID && this.licenseeTransactionID.constructor === Array) {
            data["licenseeTransactionID"] = [];
            for (let item of this.licenseeTransactionID)
                data["licenseeTransactionID"].push(item);
        }
        if (this.licenseeProjectReference && this.licenseeProjectReference.constructor === Array) {
            data["licenseeProjectReference"] = [];
            for (let item of this.licenseeProjectReference)
                data["licenseeProjectReference"].push(item);
        }
        data["licenseTransactionDate"] = this.licenseTransactionDate ? this.licenseTransactionDate.toISOString() : <any>undefined;
        data["reuse"] = this.reuse;
        if (this.otherLicenseDocuments && this.otherLicenseDocuments.constructor === Array) {
            data["otherLicenseDocuments"] = [];
            for (let item of this.otherLicenseDocuments)
                data["otherLicenseDocuments"].push(item);
        }
        if (this.otherLicenseInfo) {
            data["otherLicenseInfo"] = {};
            for (let key in this.otherLicenseInfo) {
                if (this.otherLicenseInfo.hasOwnProperty(key))
                    data["otherLicenseInfo"][key] = this.otherLicenseInfo[key];
            }
        }
        if (this.custom1 && this.custom1.constructor === Array) {
            data["custom1"] = [];
            for (let item of this.custom1)
                data["custom1"].push(item);
        }
        if (this.custom2 && this.custom2.constructor === Array) {
            data["custom2"] = [];
            for (let item of this.custom2)
                data["custom2"].push(item);
        }
        if (this.custom3 && this.custom3.constructor === Array) {
            data["custom3"] = [];
            for (let item of this.custom3)
                data["custom3"].push(item);
        }
        if (this.custom4 && this.custom4.constructor === Array) {
            data["custom4"] = [];
            for (let item of this.custom4)
                data["custom4"].push(item);
        }
        if (this.custom5 && this.custom5.constructor === Array) {
            data["custom5"] = [];
            for (let item of this.custom5)
                data["custom5"].push(item);
        }
        if (this.custom6 && this.custom6.constructor === Array) {
            data["custom6"] = [];
            for (let item of this.custom6)
                data["custom6"].push(item);
        }
        if (this.custom7 && this.custom7.constructor === Array) {
            data["custom7"] = [];
            for (let item of this.custom7)
                data["custom7"].push(item);
        }
        if (this.custom8 && this.custom8.constructor === Array) {
            data["custom8"] = [];
            for (let item of this.custom8)
                data["custom8"].push(item);
        }
        if (this.custom9 && this.custom9.constructor === Array) {
            data["custom9"] = [];
            for (let item of this.custom9)
                data["custom9"].push(item);
        }
        if (this.custom10 && this.custom10.constructor === Array) {
            data["custom10"] = [];
            for (let item of this.custom10)
                data["custom10"].push(item);
        }
        return data; 
    }
}

export interface IPlus {
    version?: string | undefined;
    licensee?: LicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: EndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: LicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: CopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: ImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: ImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;
}

export class LicenseeInfo implements ILicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;

    constructor(data?: ILicenseeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.licenseeName = data["licenseeName"];
            this.licenseeID = data["licenseeID"];
        }
    }

    static fromJS(data: any): LicenseeInfo {
        let result = new LicenseeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licenseeName"] = this.licenseeName;
        data["licenseeID"] = this.licenseeID;
        return data; 
    }
}

export interface ILicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;
}

export class EndUserInfo implements IEndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;

    constructor(data?: IEndUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.endUserName = data["endUserName"];
            this.endUserID = data["endUserID"];
        }
    }

    static fromJS(data: any): EndUserInfo {
        let result = new EndUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endUserName"] = this.endUserName;
        data["endUserID"] = this.endUserID;
        return data; 
    }
}

export interface IEndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;
}

export class LicensorInfo implements ILicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;

    constructor(data?: ILicensorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.licensorName = data["licensorName"];
            this.licensorID = data["licensorID"];
            this.licensorStreetAddress = data["licensorStreetAddress"];
            this.licensorExtendedAddress = data["licensorExtendedAddress"];
            this.licensorCity = data["licensorCity"];
            this.licensorRegion = data["licensorRegion"];
            this.licensorPostalCode = data["licensorPostalCode"];
            this.licensorCountry = data["licensorCountry"];
            this.licensorTelephoneType1 = data["licensorTelephoneType1"];
            this.licensorTelephone1 = data["licensorTelephone1"];
            this.licensorTelephoneType2 = data["licensorTelephoneType2"];
            this.licensorTelephone2 = data["licensorTelephone2"];
            this.licensorEmail = data["licensorEmail"];
            this.licensorURL = data["licensorURL"];
        }
    }

    static fromJS(data: any): LicensorInfo {
        let result = new LicensorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licensorName"] = this.licensorName;
        data["licensorID"] = this.licensorID;
        data["licensorStreetAddress"] = this.licensorStreetAddress;
        data["licensorExtendedAddress"] = this.licensorExtendedAddress;
        data["licensorCity"] = this.licensorCity;
        data["licensorRegion"] = this.licensorRegion;
        data["licensorPostalCode"] = this.licensorPostalCode;
        data["licensorCountry"] = this.licensorCountry;
        data["licensorTelephoneType1"] = this.licensorTelephoneType1;
        data["licensorTelephone1"] = this.licensorTelephone1;
        data["licensorTelephoneType2"] = this.licensorTelephoneType2;
        data["licensorTelephone2"] = this.licensorTelephone2;
        data["licensorEmail"] = this.licensorEmail;
        data["licensorURL"] = this.licensorURL;
        return data; 
    }
}

export interface ILicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;
}

export class CopyrightOwnerInfo implements ICopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;

    constructor(data?: ICopyrightOwnerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.copyrightOwnerName = data["copyrightOwnerName"];
            this.copyrightOwnerID = data["copyrightOwnerID"];
        }
    }

    static fromJS(data: any): CopyrightOwnerInfo {
        let result = new CopyrightOwnerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["copyrightOwnerName"] = this.copyrightOwnerName;
        data["copyrightOwnerID"] = this.copyrightOwnerID;
        return data; 
    }
}

export interface ICopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;
}

export class ImageCreatorInfo implements IImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;

    constructor(data?: IImageCreatorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageCreatorName = data["imageCreatorName"];
            this.imageCreatorID = data["imageCreatorID"];
        }
    }

    static fromJS(data: any): ImageCreatorInfo {
        let result = new ImageCreatorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageCreatorName"] = this.imageCreatorName;
        data["imageCreatorID"] = this.imageCreatorID;
        return data; 
    }
}

export interface IImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;
}

export class ImageSupplierInfo implements IImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;

    constructor(data?: IImageSupplierInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageSupplierName = data["imageSupplierName"];
            this.imageSupplierID = data["imageSupplierID"];
        }
    }

    static fromJS(data: any): ImageSupplierInfo {
        let result = new ImageSupplierInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageSupplierName"] = this.imageSupplierName;
        data["imageSupplierID"] = this.imageSupplierID;
        return data; 
    }
}

export interface IImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;
}

export class Tiff implements ITiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;

    constructor(data?: ITiff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.artist = data["artist"];
            if (data["bitsPerSample"] && data["bitsPerSample"].constructor === Array) {
                this.bitsPerSample = [];
                for (let item of data["bitsPerSample"])
                    this.bitsPerSample.push(item);
            }
            this.compression = data["compression"];
            if (data["copyright"]) {
                this.copyright = {};
                for (let key in data["copyright"]) {
                    if (data["copyright"].hasOwnProperty(key))
                        this.copyright[key] = data["copyright"][key];
                }
            }
            this.dateTime = data["dateTime"] ? new Date(data["dateTime"].toString()) : <any>undefined;
            if (data["imageDescription"]) {
                this.imageDescription = {};
                for (let key in data["imageDescription"]) {
                    if (data["imageDescription"].hasOwnProperty(key))
                        this.imageDescription[key] = data["imageDescription"][key];
                }
            }
            this.imageLength = data["imageLength"];
            this.imageWidth = data["imageWidth"];
            this.make = data["make"];
            this.model = data["model"];
            this.orientation = data["orientation"];
            this.photometricInterpretation = data["photometricInterpretation"];
            this.planarConfiguration = data["planarConfiguration"];
            if (data["primaryChromaticities"] && data["primaryChromaticities"].constructor === Array) {
                this.primaryChromaticities = [];
                for (let item of data["primaryChromaticities"])
                    this.primaryChromaticities.push(item);
            }
            if (data["referenceBlackWhite"] && data["referenceBlackWhite"].constructor === Array) {
                this.referenceBlackWhite = [];
                for (let item of data["referenceBlackWhite"])
                    this.referenceBlackWhite.push(item);
            }
            this.resolutionUnit = data["resolutionUnit"];
            this.samplesPerPixel = data["samplesPerPixel"];
            this.software = data["software"];
            if (data["transferFunction"] && data["transferFunction"].constructor === Array) {
                this.transferFunction = [];
                for (let item of data["transferFunction"])
                    this.transferFunction.push(item);
            }
            if (data["whitePoint"] && data["whitePoint"].constructor === Array) {
                this.whitePoint = [];
                for (let item of data["whitePoint"])
                    this.whitePoint.push(item);
            }
            this.xResolution = data["xResolution"];
            this.yResolution = data["yResolution"];
            if (data["yCbCrCoefficients"] && data["yCbCrCoefficients"].constructor === Array) {
                this.yCbCrCoefficients = [];
                for (let item of data["yCbCrCoefficients"])
                    this.yCbCrCoefficients.push(item);
            }
            this.yCbCrPositioning = data["yCbCrPositioning"];
            this.yCbCrSubSampling = data["yCbCrSubSampling"];
            this.nativeDigest = data["nativeDigest"];
        }
    }

    static fromJS(data: any): Tiff {
        let result = new Tiff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artist"] = this.artist;
        if (this.bitsPerSample && this.bitsPerSample.constructor === Array) {
            data["bitsPerSample"] = [];
            for (let item of this.bitsPerSample)
                data["bitsPerSample"].push(item);
        }
        data["compression"] = this.compression;
        if (this.copyright) {
            data["copyright"] = {};
            for (let key in this.copyright) {
                if (this.copyright.hasOwnProperty(key))
                    data["copyright"][key] = this.copyright[key];
            }
        }
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        if (this.imageDescription) {
            data["imageDescription"] = {};
            for (let key in this.imageDescription) {
                if (this.imageDescription.hasOwnProperty(key))
                    data["imageDescription"][key] = this.imageDescription[key];
            }
        }
        data["imageLength"] = this.imageLength;
        data["imageWidth"] = this.imageWidth;
        data["make"] = this.make;
        data["model"] = this.model;
        data["orientation"] = this.orientation;
        data["photometricInterpretation"] = this.photometricInterpretation;
        data["planarConfiguration"] = this.planarConfiguration;
        if (this.primaryChromaticities && this.primaryChromaticities.constructor === Array) {
            data["primaryChromaticities"] = [];
            for (let item of this.primaryChromaticities)
                data["primaryChromaticities"].push(item);
        }
        if (this.referenceBlackWhite && this.referenceBlackWhite.constructor === Array) {
            data["referenceBlackWhite"] = [];
            for (let item of this.referenceBlackWhite)
                data["referenceBlackWhite"].push(item);
        }
        data["resolutionUnit"] = this.resolutionUnit;
        data["samplesPerPixel"] = this.samplesPerPixel;
        data["software"] = this.software;
        if (this.transferFunction && this.transferFunction.constructor === Array) {
            data["transferFunction"] = [];
            for (let item of this.transferFunction)
                data["transferFunction"].push(item);
        }
        if (this.whitePoint && this.whitePoint.constructor === Array) {
            data["whitePoint"] = [];
            for (let item of this.whitePoint)
                data["whitePoint"].push(item);
        }
        data["xResolution"] = this.xResolution;
        data["yResolution"] = this.yResolution;
        if (this.yCbCrCoefficients && this.yCbCrCoefficients.constructor === Array) {
            data["yCbCrCoefficients"] = [];
            for (let item of this.yCbCrCoefficients)
                data["yCbCrCoefficients"].push(item);
        }
        data["yCbCrPositioning"] = this.yCbCrPositioning;
        data["yCbCrSubSampling"] = this.yCbCrSubSampling;
        data["nativeDigest"] = this.nativeDigest;
        return data; 
    }
}

export interface ITiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;
}

/** Corresponds to tiff.CompressionChoice */
export enum Compression {
    Uncompressed = <any>"Uncompressed", 
    CCITT = <any>"CCITT", 
    T4 = <any>"T4", 
    T6 = <any>"T6", 
    LZW = <any>"LZW", 
    OJPEG = <any>"OJPEG", 
    JPEG = <any>"JPEG", 
    Deflate = <any>"Deflate", 
    T82 = <any>"T82", 
    T43 = <any>"T43", 
    NeXT = <any>"NeXT", 
    ARW = <any>"ARW", 
    RAW = <any>"RAW", 
    SRW = <any>"SRW", 
    Group3_1D = <any>"Group3_1D", 
    PackBits = <any>"PackBits", 
    ThunderScan = <any>"ThunderScan", 
    KDC = <any>"KDC", 
    RasterPadding = <any>"RasterPadding", 
    LineWork = <any>"LineWork", 
    HighContinuous = <any>"HighContinuous", 
    BinaryLineWork = <any>"BinaryLineWork", 
    PixarFilm = <any>"PixarFilm", 
    PixarLog = <any>"PixarLog", 
    DCS = <any>"DCS", 
    JBIG = <any>"JBIG", 
    JPEG2000 = <any>"JPEG2000", 
    NEF = <any>"NEF", 
    JBIG2 = <any>"JBIG2", 
    DCR = <any>"DCR", 
    PEF = <any>"PEF", 
}

/** Corresponds to tiff.OrientationChoice */
export enum Orientation {
    None = <any>"None", 
    TopRowLeftColumn = <any>"TopRowLeftColumn", 
    TopRowRightColumn = <any>"TopRowRightColumn", 
    BottomRowLeftColumn = <any>"BottomRowLeftColumn", 
    BottomRowRightColumn = <any>"BottomRowRightColumn", 
    LeftRowTopColumn = <any>"LeftRowTopColumn", 
    RightRowTopColumn = <any>"RightRowTopColumn", 
    RightRowBottomColumn = <any>"RightRowBottomColumn", 
    LeftRowBottomColumn = <any>"LeftRowBottomColumn", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to tiff.PhotometricInterpretationChoice */
export enum PhotometricInterpretation {
    WhiteIsZero = <any>"WhiteIsZero", 
    BlackIsZero = <any>"BlackIsZero", 
    RGB = <any>"RGB", 
    Palette = <any>"Palette", 
    TransparencyMask = <any>"TransparencyMask", 
    CMYK = <any>"CMYK", 
    YCbCr = <any>"YCbCr", 
    CIELab = <any>"CIELab", 
    ICCLab = <any>"ICCLab", 
    ITULab = <any>"ITULab", 
    ColorFilterArray = <any>"ColorFilterArray", 
    LogL = <any>"LogL", 
    LogLUV = <any>"LogLUV", 
    LinearRaw = <any>"LinearRaw", 
}

/** Corresponds to tiff.PlanarConfigurationChoice */
export enum PlanarConfiguration {
    Chunky = <any>"Chunky", 
    Planar = <any>"Planar", 
    Line = <any>"Line", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum ResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Centimeter = <any>"Centimeter", 
}

/** Corresponds to tiff.YCbCrPositioningChoice */
export enum YCbCrPositioning {
    Centered = <any>"Centered", 
    Cosited = <any>"Cosited", 
}

/** Corresponds to tiff.YCbCrSubSamplingChoice */
export enum YCbCrSubSampling {
    YCbCr111 = <any>"YCbCr111", 
    YCbCr422 = <any>"YCbCr422", 
    YCbCr420 = <any>"YCbCr420", 
}

export class Xmp implements IXmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: XmpGImg[] | undefined;
    pageInfo?: XmpGImg[] | undefined;

    constructor(data?: IXmp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseURL = data["baseURL"];
            this.createDate = data["createDate"] ? new Date(data["createDate"].toString()) : <any>undefined;
            this.creatorTool = data["creatorTool"];
            if (data["identifier"] && data["identifier"].constructor === Array) {
                this.identifier = [];
                for (let item of data["identifier"])
                    this.identifier.push(item);
            }
            this.label = data["label"];
            this.metadataDate = data["metadataDate"] ? new Date(data["metadataDate"].toString()) : <any>undefined;
            this.modifyDate = data["modifyDate"] ? new Date(data["modifyDate"].toString()) : <any>undefined;
            this.nickname = data["nickname"];
            this.rating = data["rating"];
            if (data["thumbnails"] && data["thumbnails"].constructor === Array) {
                this.thumbnails = [];
                for (let item of data["thumbnails"])
                    this.thumbnails.push(XmpGImg.fromJS(item));
            }
            if (data["pageInfo"] && data["pageInfo"].constructor === Array) {
                this.pageInfo = [];
                for (let item of data["pageInfo"])
                    this.pageInfo.push(XmpGImg.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Xmp {
        let result = new Xmp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseURL"] = this.baseURL;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["creatorTool"] = this.creatorTool;
        if (this.identifier && this.identifier.constructor === Array) {
            data["identifier"] = [];
            for (let item of this.identifier)
                data["identifier"].push(item);
        }
        data["label"] = this.label;
        data["metadataDate"] = this.metadataDate ? this.metadataDate.toISOString() : <any>undefined;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["nickname"] = this.nickname;
        data["rating"] = this.rating;
        if (this.thumbnails && this.thumbnails.constructor === Array) {
            data["thumbnails"] = [];
            for (let item of this.thumbnails)
                data["thumbnails"].push(item.toJSON());
        }
        if (this.pageInfo && this.pageInfo.constructor === Array) {
            data["pageInfo"] = [];
            for (let item of this.pageInfo)
                data["pageInfo"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: XmpGImg[] | undefined;
    pageInfo?: XmpGImg[] | undefined;
}

/** Corresponds to xmp.RatingChoice */
export enum Rating {
    Rejected = <any>"Rejected", 
    Unrated = <any>"Unrated", 
    One = <any>"One", 
    Two = <any>"Two", 
    Three = <any>"Three", 
    Four = <any>"Four", 
    Five = <any>"Five", 
}

export class XmpGImg implements IXmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;

    constructor(data?: IXmpGImg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.format = data["format"];
            this.width = data["width"];
            this.height = data["height"];
            this.image = data["image"];
        }
    }

    static fromJS(data: any): XmpGImg {
        let result = new XmpGImg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["width"] = this.width;
        data["height"] = this.height;
        data["image"] = this.image;
        return data; 
    }
}

export interface IXmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;
}

/** Corresponds to xmpGImg.FormatChoice */
export enum ImgFormat {
    JPEG = <any>"JPEG", 
}

export class XmpBJ implements IXmpBJ {
    jobRef?: Job[] | undefined;

    constructor(data?: IXmpBJ) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["jobRef"] && data["jobRef"].constructor === Array) {
                this.jobRef = [];
                for (let item of data["jobRef"])
                    this.jobRef.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpBJ {
        let result = new XmpBJ();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.jobRef && this.jobRef.constructor === Array) {
            data["jobRef"] = [];
            for (let item of this.jobRef)
                data["jobRef"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmpBJ {
    jobRef?: Job[] | undefined;
}

export class Job implements IJob {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Job {
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface IJob {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class XmpDM implements IXmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: TimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: BeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: Media[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: Time | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: Time | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: Marker[] | undefined;
    outCue?: Time | undefined;
    projectName?: string | undefined;
    projectRef?: ProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: Time | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: ResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: TimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: TimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: Track[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: XmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: Dimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;

    constructor(data?: IXmpDM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.absPeakAudioFilePath = data["absPeakAudioFilePath"];
            this.artist = data["artist"];
            this.album = data["album"];
            this.altTapeName = data["altTapeName"];
            this.altTimecode = data["altTimecode"] ? TimeCode.fromJS(data["altTimecode"]) : <any>undefined;
            this.audioChannelType = data["audioChannelType"];
            this.audioCompressor = data["audioCompressor"];
            this.audioSampleRate = data["audioSampleRate"];
            this.audioSampleType = data["audioSampleType"];
            this.beatSpliceParams = data["beatSpliceParams"] ? BeatSpliceStretch.fromJS(data["beatSpliceParams"]) : <any>undefined;
            this.cameraAngle = data["cameraAngle"];
            this.cameraLabel = data["cameraLabel"];
            this.cameraModel = data["cameraModel"];
            this.cameraMove = data["cameraMove"];
            this.client = data["client"];
            this.comment = data["comment"];
            this.composer = data["composer"];
            if (data["contributedMedia"] && data["contributedMedia"].constructor === Array) {
                this.contributedMedia = [];
                for (let item of data["contributedMedia"])
                    this.contributedMedia.push(Media.fromJS(item));
            }
            this.director = data["director"];
            this.directorPhotography = data["directorPhotography"];
            this.duration = data["duration"] ? Time.fromJS(data["duration"]) : <any>undefined;
            this.engineer = data["engineer"];
            this.fileDataRate = data["fileDataRate"];
            this.genre = data["genre"];
            this.good = data["good"];
            this.instrument = data["instrument"];
            this.introTime = data["introTime"] ? Time.fromJS(data["introTime"]) : <any>undefined;
            this.key = data["key"];
            this.logComment = data["logComment"];
            this.loop = data["loop"];
            this.numberOfBeats = data["numberOfBeats"];
            if (data["markers"] && data["markers"].constructor === Array) {
                this.markers = [];
                for (let item of data["markers"])
                    this.markers.push(Marker.fromJS(item));
            }
            this.outCue = data["outCue"] ? Time.fromJS(data["outCue"]) : <any>undefined;
            this.projectName = data["projectName"];
            this.projectRef = data["projectRef"] ? ProjectLink.fromJS(data["projectRef"]) : <any>undefined;
            this.pullDown = data["pullDown"];
            this.relativePeakAudioFilePath = data["relativePeakAudioFilePath"];
            this.relativeTimestamp = data["relativeTimestamp"] ? Time.fromJS(data["relativeTimestamp"]) : <any>undefined;
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            this.resampleParams = data["resampleParams"] ? ResampleStretch.fromJS(data["resampleParams"]) : <any>undefined;
            this.scaleType = data["scaleType"];
            this.scene = data["scene"];
            this.shotDate = data["shotDate"] ? new Date(data["shotDate"].toString()) : <any>undefined;
            this.shotDay = data["shotDay"];
            this.shotLocation = data["shotLocation"];
            this.shotName = data["shotName"];
            this.shotNumber = data["shotNumber"];
            this.shotSize = data["shotSize"];
            this.speakerPlacement = data["speakerPlacement"];
            this.startTimecode = data["startTimecode"] ? TimeCode.fromJS(data["startTimecode"]) : <any>undefined;
            this.stretchMode = data["stretchMode"];
            this.takeNumber = data["takeNumber"];
            this.tapeName = data["tapeName"];
            this.tempo = data["tempo"];
            this.timeScaleParams = data["timeScaleParams"] ? TimeScaleStretch.fromJS(data["timeScaleParams"]) : <any>undefined;
            this.timeSignature = data["timeSignature"];
            this.trackNumber = data["trackNumber"];
            if (data["tracks"] && data["tracks"].constructor === Array) {
                this.tracks = [];
                for (let item of data["tracks"])
                    this.tracks.push(Track.fromJS(item));
            }
            this.videoAlphaMode = data["videoAlphaMode"];
            this.videoAlphaPremultipleColor = data["videoAlphaPremultipleColor"] ? XmpG.fromJS(data["videoAlphaPremultipleColor"]) : <any>undefined;
            this.videoAlphaUnityIsTransparent = data["videoAlphaUnityIsTransparent"];
            this.videoColorSpace = data["videoColorSpace"];
            this.videoCompressor = data["videoCompressor"];
            this.videoFieldOrder = data["videoFieldOrder"];
            this.videoFrameRate = data["videoFrameRate"];
            this.videoFrameSize = data["videoFrameSize"] ? Dimension.fromJS(data["videoFrameSize"]) : <any>undefined;
            this.videoPixelDepth = data["videoPixelDepth"];
            this.videoPixelAspectRatio = data["videoPixelAspectRatio"];
        }
    }

    static fromJS(data: any): XmpDM {
        let result = new XmpDM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absPeakAudioFilePath"] = this.absPeakAudioFilePath;
        data["artist"] = this.artist;
        data["album"] = this.album;
        data["altTapeName"] = this.altTapeName;
        data["altTimecode"] = this.altTimecode ? this.altTimecode.toJSON() : <any>undefined;
        data["audioChannelType"] = this.audioChannelType;
        data["audioCompressor"] = this.audioCompressor;
        data["audioSampleRate"] = this.audioSampleRate;
        data["audioSampleType"] = this.audioSampleType;
        data["beatSpliceParams"] = this.beatSpliceParams ? this.beatSpliceParams.toJSON() : <any>undefined;
        data["cameraAngle"] = this.cameraAngle;
        data["cameraLabel"] = this.cameraLabel;
        data["cameraModel"] = this.cameraModel;
        data["cameraMove"] = this.cameraMove;
        data["client"] = this.client;
        data["comment"] = this.comment;
        data["composer"] = this.composer;
        if (this.contributedMedia && this.contributedMedia.constructor === Array) {
            data["contributedMedia"] = [];
            for (let item of this.contributedMedia)
                data["contributedMedia"].push(item.toJSON());
        }
        data["director"] = this.director;
        data["directorPhotography"] = this.directorPhotography;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["engineer"] = this.engineer;
        data["fileDataRate"] = this.fileDataRate;
        data["genre"] = this.genre;
        data["good"] = this.good;
        data["instrument"] = this.instrument;
        data["introTime"] = this.introTime ? this.introTime.toJSON() : <any>undefined;
        data["key"] = this.key;
        data["logComment"] = this.logComment;
        data["loop"] = this.loop;
        data["numberOfBeats"] = this.numberOfBeats;
        if (this.markers && this.markers.constructor === Array) {
            data["markers"] = [];
            for (let item of this.markers)
                data["markers"].push(item.toJSON());
        }
        data["outCue"] = this.outCue ? this.outCue.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        data["projectRef"] = this.projectRef ? this.projectRef.toJSON() : <any>undefined;
        data["pullDown"] = this.pullDown;
        data["relativePeakAudioFilePath"] = this.relativePeakAudioFilePath;
        data["relativeTimestamp"] = this.relativeTimestamp ? this.relativeTimestamp.toJSON() : <any>undefined;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["resampleParams"] = this.resampleParams ? this.resampleParams.toJSON() : <any>undefined;
        data["scaleType"] = this.scaleType;
        data["scene"] = this.scene;
        data["shotDate"] = this.shotDate ? this.shotDate.toISOString() : <any>undefined;
        data["shotDay"] = this.shotDay;
        data["shotLocation"] = this.shotLocation;
        data["shotName"] = this.shotName;
        data["shotNumber"] = this.shotNumber;
        data["shotSize"] = this.shotSize;
        data["speakerPlacement"] = this.speakerPlacement;
        data["startTimecode"] = this.startTimecode ? this.startTimecode.toJSON() : <any>undefined;
        data["stretchMode"] = this.stretchMode;
        data["takeNumber"] = this.takeNumber;
        data["tapeName"] = this.tapeName;
        data["tempo"] = this.tempo;
        data["timeScaleParams"] = this.timeScaleParams ? this.timeScaleParams.toJSON() : <any>undefined;
        data["timeSignature"] = this.timeSignature;
        data["trackNumber"] = this.trackNumber;
        if (this.tracks && this.tracks.constructor === Array) {
            data["tracks"] = [];
            for (let item of this.tracks)
                data["tracks"].push(item.toJSON());
        }
        data["videoAlphaMode"] = this.videoAlphaMode;
        data["videoAlphaPremultipleColor"] = this.videoAlphaPremultipleColor ? this.videoAlphaPremultipleColor.toJSON() : <any>undefined;
        data["videoAlphaUnityIsTransparent"] = this.videoAlphaUnityIsTransparent;
        data["videoColorSpace"] = this.videoColorSpace;
        data["videoCompressor"] = this.videoCompressor;
        data["videoFieldOrder"] = this.videoFieldOrder;
        data["videoFrameRate"] = this.videoFrameRate;
        data["videoFrameSize"] = this.videoFrameSize ? this.videoFrameSize.toJSON() : <any>undefined;
        data["videoPixelDepth"] = this.videoPixelDepth;
        data["videoPixelAspectRatio"] = this.videoPixelAspectRatio;
        return data; 
    }
}

export interface IXmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: TimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: BeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: Media[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: Time | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: Time | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: Marker[] | undefined;
    outCue?: Time | undefined;
    projectName?: string | undefined;
    projectRef?: ProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: Time | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: ResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: TimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: TimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: Track[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: XmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: Dimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;
}

export class TimeCode implements ITimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;

    constructor(data?: ITimeCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeFormat = data["timeFormat"];
            this.timeValue = data["timeValue"];
        }
    }

    static fromJS(data: any): TimeCode {
        let result = new TimeCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeFormat"] = this.timeFormat;
        data["timeValue"] = this.timeValue;
        return data; 
    }
}

export interface ITimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;
}

/** Corresponds to Timecode.TimeFormatChoice */
export enum TimeFormat {
    Timecode24 = <any>"Timecode24", 
    Timecode25 = <any>"Timecode25", 
    Timecode2997Drop = <any>"Timecode2997Drop", 
    Timecode2997NonDrop = <any>"Timecode2997NonDrop", 
    Timecode30 = <any>"Timecode30", 
    Timecode50 = <any>"Timecode50", 
    Timecode5994Drop = <any>"Timecode5994Drop", 
    Timecode5994NonDrop = <any>"Timecode5994NonDrop", 
    Timecode60 = <any>"Timecode60", 
    Timecode23976 = <any>"Timecode23976", 
}

/** Corresponds to xmpDM.AudioChannelTypeChoice */
export enum AudioChannelType {
    CHANNEL_MONO = <any>"CHANNEL_MONO", 
    CHANNEL_STEREO = <any>"CHANNEL_STEREO", 
    CHANNEL_5_1 = <any>"CHANNEL_5_1", 
    CHANNEL_7_1 = <any>"CHANNEL_7_1", 
    CHANNEL_16 = <any>"CHANNEL_16", 
    CHANNEL_OTHER = <any>"CHANNEL_OTHER", 
}

/** Corresponds to xmpDM.AudioSampleTypeChoice */
export enum AudioSampleType {
    SAMPLE_8_INT = <any>"SAMPLE_8_INT", 
    SAMPLE_16_INT = <any>"SAMPLE_16_INT", 
    SAMPLE_24_INT = <any>"SAMPLE_24_INT", 
    SAMPLE_32_INT = <any>"SAMPLE_32_INT", 
    SAMPLE_32_FLOAT = <any>"SAMPLE_32_FLOAT", 
    SAMPLE_COMPRESSED = <any>"SAMPLE_COMPRESSED", 
    SAMPLE_PACKED = <any>"SAMPLE_PACKED", 
    SAMPLE_OTHER = <any>"SAMPLE_OTHER", 
}

export class BeatSpliceStretch implements IBeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: Time | undefined;
    useFileBeatsMarker?: boolean | undefined;

    constructor(data?: IBeatSpliceStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.riseInDecibel = data["riseInDecibel"];
            this.riseInTimeDuration = data["riseInTimeDuration"] ? Time.fromJS(data["riseInTimeDuration"]) : <any>undefined;
            this.useFileBeatsMarker = data["useFileBeatsMarker"];
        }
    }

    static fromJS(data: any): BeatSpliceStretch {
        let result = new BeatSpliceStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riseInDecibel"] = this.riseInDecibel;
        data["riseInTimeDuration"] = this.riseInTimeDuration ? this.riseInTimeDuration.toJSON() : <any>undefined;
        data["useFileBeatsMarker"] = this.useFileBeatsMarker;
        return data; 
    }
}

export interface IBeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: Time | undefined;
    useFileBeatsMarker?: boolean | undefined;
}

export class Time implements ITime {
    scale?: string | undefined;
    value?: number | undefined;

    constructor(data?: ITime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scale = data["scale"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): Time {
        let result = new Time();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scale"] = this.scale;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITime {
    scale?: string | undefined;
    value?: number | undefined;
}

/** Corresponds to xmpDM.CameraAngleChoice */
export enum CameraAngle {
    ANGLE_LOW = <any>"ANGLE_LOW", 
    ANGLE_EYE_LEVEL = <any>"ANGLE_EYE_LEVEL", 
    ANGLE_HIGH = <any>"ANGLE_HIGH", 
    ANGLE_OVERHEAD_SHOT = <any>"ANGLE_OVERHEAD_SHOT", 
    ANGLE_BIRDS_EYE_SHOT = <any>"ANGLE_BIRDS_EYE_SHOT", 
    ANGLE_DUTCH = <any>"ANGLE_DUTCH", 
    ANGLE_POV = <any>"ANGLE_POV", 
    ANGLE_OVER_THE_SHOULDER = <any>"ANGLE_OVER_THE_SHOULDER", 
    ANGLE_REACTION_SHOT = <any>"ANGLE_REACTION_SHOT", 
}

/** Corresponds to xmpDM.CameraMoveChoice */
export enum CameraMove {
    MOVE_AERIAL = <any>"MOVE_AERIAL", 
    MOVE_BOOM_UP = <any>"MOVE_BOOM_UP", 
    MOVE_BOOM_DOWN = <any>"MOVE_BOOM_DOWN", 
    MOVE_CRANE_UP = <any>"MOVE_CRANE_UP", 
    MOVE_CRANE_DOWN = <any>"MOVE_CRANE_DOWN", 
    MOVE_DOLLY_IN = <any>"MOVE_DOLLY_IN", 
    MOVE_DOLLY_OUT = <any>"MOVE_DOLLY_OUT", 
    MOVE_PAN_LEFT = <any>"MOVE_PAN_LEFT", 
    MOVE_PAN_RIGHT = <any>"MOVE_PAN_RIGHT", 
    MOVE_PEDESTAL_UP = <any>"MOVE_PEDESTAL_UP", 
    MOVE_PEDESTAL_DOWN = <any>"MOVE_PEDESTAL_DOWN", 
    MOVE_TILT_UP = <any>"MOVE_TILT_UP", 
    MOVE_TILT_DOWN = <any>"MOVE_TILT_DOWN", 
    MOVE_TRACKING = <any>"MOVE_TRACKING", 
    MOVE_TRUCK_LEFT = <any>"MOVE_TRUCK_LEFT", 
    MOVE_TRUCK_RIGHT = <any>"MOVE_TRUCK_RIGHT", 
    MOVE_ZOOM_IN = <any>"MOVE_ZOOM_IN", 
    MOVE_ZOOM_OUT = <any>"MOVE_ZOOM_OUT", 
}

export class Media implements IMedia {
    duration?: Time | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: Time | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.duration = data["duration"] ? Time.fromJS(data["duration"]) : <any>undefined;
            this.managed = data["managed"];
            this.path = data["path"];
            this.startTime = data["startTime"] ? Time.fromJS(data["startTime"]) : <any>undefined;
            this.track = data["track"];
            this.webStatement = data["webStatement"];
        }
    }

    static fromJS(data: any): Media {
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["managed"] = this.managed;
        data["path"] = this.path;
        data["startTime"] = this.startTime ? this.startTime.toJSON() : <any>undefined;
        data["track"] = this.track;
        data["webStatement"] = this.webStatement;
        return data; 
    }
}

export interface IMedia {
    duration?: Time | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: Time | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;
}

/** Corresponds to xmpDM.AudioMusicalKeyChoice */
export enum AudioMusicalKey {
    KEY_C = <any>"KEY_C", 
    KEY_C_SHARP = <any>"KEY_C_SHARP", 
    KEY_D = <any>"KEY_D", 
    KEY_D_SHARP = <any>"KEY_D_SHARP", 
    KEY_E = <any>"KEY_E", 
    KEY_F = <any>"KEY_F", 
    KEY_F_SHARP = <any>"KEY_F_SHARP", 
    KEY_G = <any>"KEY_G", 
    KEY_G_SHARP = <any>"KEY_G_SHARP", 
    KEY_A = <any>"KEY_A", 
    KEY_A_SHARP = <any>"KEY_A_SHARP", 
    KEY_B = <any>"KEY_B", 
}

export class Marker implements IMarker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;

    constructor(data?: IMarker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            if (data["cuePointParams"]) {
                this.cuePointParams = {};
                for (let key in data["cuePointParams"]) {
                    if (data["cuePointParams"].hasOwnProperty(key))
                        this.cuePointParams[key] = data["cuePointParams"][key];
                }
            }
            this.cuePointType = data["cuePointType"];
            this.duration = data["duration"];
            this.location = data["location"];
            this.name = data["name"];
            this.probability = data["probability"];
            this.speaker = data["speaker"];
            this.startTime = data["startTime"];
            this.target = data["target"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Marker {
        let result = new Marker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        if (this.cuePointParams) {
            data["cuePointParams"] = {};
            for (let key in this.cuePointParams) {
                if (this.cuePointParams.hasOwnProperty(key))
                    data["cuePointParams"][key] = this.cuePointParams[key];
            }
        }
        data["cuePointType"] = this.cuePointType;
        data["duration"] = this.duration;
        data["location"] = this.location;
        data["name"] = this.name;
        data["probability"] = this.probability;
        data["speaker"] = this.speaker;
        data["startTime"] = this.startTime;
        data["target"] = this.target;
        data["type"] = this.type;
        return data; 
    }
}

export interface IMarker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;
}

/** Corresponds to Xmp.Media.Marker.TypeChoice */
export enum MarkerType {
    Chapter = <any>"Chapter", 
    Cue = <any>"Cue", 
    Index = <any>"Index", 
    Speech = <any>"Speech", 
    Track = <any>"Track", 
}

export class ProjectLink implements IProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.path = data["path"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ProjectLink {
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["type"] = this.type;
        return data; 
    }
}

export interface IProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;
}

/** Corresponds to Xmp.Media.ProjectLink.TypeChoice */
export enum ProjectLinkType {
    Movie = <any>"Movie", 
    Still = <any>"Still", 
    Audio = <any>"Audio", 
    Custom = <any>"Custom", 
}

/** Corresponds to xmpDM.VideoPullDownChoice */
export enum VideoPullDown {
    PULLDOWN_WSSWW = <any>"PULLDOWN_WSSWW", 
    PULLDOWN_SSWWW = <any>"PULLDOWN_SSWWW", 
    PULLDOWN_SWWWS = <any>"PULLDOWN_SWWWS", 
    PULLDOWN_WWWSS = <any>"PULLDOWN_WWWSS", 
    PULLDOWN_WWSSW = <any>"PULLDOWN_WWSSW", 
    PULLDOWN_WWWSW = <any>"PULLDOWN_WWWSW", 
    PULLDOWN_WWSWW = <any>"PULLDOWN_WWSWW", 
    PULLDOWN_WSWWW = <any>"PULLDOWN_WSWWW", 
    PULLDOWN_SWWWW = <any>"PULLDOWN_SWWWW", 
    PULLDOWN_WWWWS = <any>"PULLDOWN_WWWWS", 
}

export class ResampleStretch implements IResampleStretch {
    quality?: Quality | undefined;

    constructor(data?: IResampleStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quality = data["quality"];
        }
    }

    static fromJS(data: any): ResampleStretch {
        let result = new ResampleStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quality"] = this.quality;
        return data; 
    }
}

export interface IResampleStretch {
    quality?: Quality | undefined;
}

/** Corresponds to Xmp.Media.resampleStretch.QualityChoice and Xmp.Media.timeScaleStretch.QualityChoice */
export enum Quality {
    High = <any>"High", 
    Medium = <any>"Medium", 
    Low = <any>"Low", 
}

/** Corresponds to xmpDM.AudioMusicalScaleTypeChoice */
export enum AudioMusicalScaleType {
    SCALE_MAJOR = <any>"SCALE_MAJOR", 
    SCALE_MINOR = <any>"SCALE_MINOR", 
    SCALE_BOTH = <any>"SCALE_BOTH", 
    SCALE_NEITHER = <any>"SCALE_NEITHER", 
}

/** Corresponds to xmpDM.ShotSizeChoice */
export enum ShotSize {
    SHOT_ECU = <any>"SHOT_ECU", 
    SHOT_MCU = <any>"SHOT_MCU", 
    SHOT_CU = <any>"SHOT_CU", 
    SHOT_MS = <any>"SHOT_MS", 
    SHOT_WS = <any>"SHOT_WS", 
    SHOT_MWS = <any>"SHOT_MWS", 
    SHOT_EWS = <any>"SHOT_EWS", 
}

/** Corresponds to xmpDM.AudioStretchModeChoice */
export enum AudioStretchMode {
    STRETCH_FIXED_LENGTH = <any>"STRETCH_FIXED_LENGTH", 
    STRETCH_TIME_SCALE = <any>"STRETCH_TIME_SCALE", 
    STRETCH_RESAMPLE = <any>"STRETCH_RESAMPLE", 
    STRETCH_BEAT_SPLICE = <any>"STRETCH_BEAT_SPLICE", 
    STRETCH_HYBRID = <any>"STRETCH_HYBRID", 
}

export class TimeScaleStretch implements ITimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;

    constructor(data?: ITimeScaleStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameOverlappingPercentage = data["frameOverlappingPercentage"];
            this.frameSize = data["frameSize"];
            this.quality = data["quality"];
        }
    }

    static fromJS(data: any): TimeScaleStretch {
        let result = new TimeScaleStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameOverlappingPercentage"] = this.frameOverlappingPercentage;
        data["frameSize"] = this.frameSize;
        data["quality"] = this.quality;
        return data; 
    }
}

export interface ITimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;
}

/** Corresponds to xmpDM.TimeSignatureChoice */
export enum TimeSignature {
    TIME_2_4 = <any>"TIME_2_4", 
    TIME_3_4 = <any>"TIME_3_4", 
    TIME_4_4 = <any>"TIME_4_4", 
    TIME_5_4 = <any>"TIME_5_4", 
    TIME_7_4 = <any>"TIME_7_4", 
    TIME_6_8 = <any>"TIME_6_8", 
    TIME_9_8 = <any>"TIME_9_8", 
    TIME_12_8 = <any>"TIME_12_8", 
    TIME_OTHER = <any>"TIME_OTHER", 
}

export class Track implements ITrack {
    frameRate?: string | undefined;
    markers?: Marker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;

    constructor(data?: ITrack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameRate = data["frameRate"];
            if (data["markers"] && data["markers"].constructor === Array) {
                this.markers = [];
                for (let item of data["markers"])
                    this.markers.push(Marker.fromJS(item));
            }
            this.trackName = data["trackName"];
            this.trackType = data["trackType"];
        }
    }

    static fromJS(data: any): Track {
        let result = new Track();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameRate"] = this.frameRate;
        if (this.markers && this.markers.constructor === Array) {
            data["markers"] = [];
            for (let item of this.markers)
                data["markers"].push(item.toJSON());
        }
        data["trackName"] = this.trackName;
        data["trackType"] = this.trackType;
        return data; 
    }
}

export interface ITrack {
    frameRate?: string | undefined;
    markers?: Marker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;
}

/** Corresponds to xmpDM.VideoAlphaModeChoice */
export enum VideoAlphaMode {
    ALPHA_MODE_STRAIGHT = <any>"ALPHA_MODE_STRAIGHT", 
    ALPHA_MODE_PREMULTIPLIED = <any>"ALPHA_MODE_PREMULTIPLIED", 
    ALPHA_MODE_NONE = <any>"ALPHA_MODE_NONE", 
}

export class XmpG implements IXmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;

    constructor(data?: IXmpG) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.a = data["a"];
            this.b = data["b"];
            this.l = data["l"];
            this.black = data["black"];
            this.cyan = data["cyan"];
            this.magenta = data["magenta"];
            this.yellow = data["yellow"];
            this.blue = data["blue"];
            this.green = data["green"];
            this.red = data["red"];
            this.mode = data["mode"];
            this.swatchName = data["swatchName"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): XmpG {
        let result = new XmpG();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["b"] = this.b;
        data["l"] = this.l;
        data["black"] = this.black;
        data["cyan"] = this.cyan;
        data["magenta"] = this.magenta;
        data["yellow"] = this.yellow;
        data["blue"] = this.blue;
        data["green"] = this.green;
        data["red"] = this.red;
        data["mode"] = this.mode;
        data["swatchName"] = this.swatchName;
        data["type"] = this.type;
        return data; 
    }
}

export interface IXmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;
}

/** Corresponds to xmpG.ModeChoice */
export enum ColorantMode {
    CMYK = <any>"CMYK", 
    RGB = <any>"RGB", 
    LAB = <any>"LAB", 
}

/** Corresponds to xmpG.TypeChoice */
export enum ColorantType {
    Process = <any>"Process", 
    Spot = <any>"Spot", 
}

/** Corresponds to xmpDM.VideoColorSpaceChoice */
export enum VideoColorSpace {
    COLOR_SPACE_SRGB = <any>"COLOR_SPACE_SRGB", 
    COLOR_SPACE_CCIR_601 = <any>"COLOR_SPACE_CCIR_601", 
    COLOR_SPACE_CCIR_709 = <any>"COLOR_SPACE_CCIR_709", 
}

/** Corresponds to xmpDM.VideoFieldOrderChoice */
export enum VideoFieldOrder {
    FIELD_ORDER_UPPER = <any>"FIELD_ORDER_UPPER", 
    FIELD_ORDER_LOWER = <any>"FIELD_ORDER_LOWER", 
    FIELD_ORDER_PROGRESSIVE = <any>"FIELD_ORDER_PROGRESSIVE", 
}

/** Corresponds to xmpDM.VideoFrameRateChoice */
export enum VideoFrameRate {
    FRAME_RATE_24 = <any>"FRAME_RATE_24", 
    FRAME_RATE_NTSC = <any>"FRAME_RATE_NTSC", 
    FRAME_RATE_PAL = <any>"FRAME_RATE_PAL", 
}

export class Dimension implements IDimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;

    constructor(data?: IDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.height = data["height"];
            this.width = data["width"];
            this.unit = data["unit"];
        }
    }

    static fromJS(data: any): Dimension {
        let result = new Dimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["height"] = this.height;
        data["width"] = this.width;
        data["unit"] = this.unit;
        return data; 
    }
}

export interface IDimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;
}

/** Corresponds to stDim.UnitChoice */
export enum Unit {
    Inch = <any>"Inch", 
    Millimeter = <any>"Millimeter", 
    Centimeter = <any>"Centimeter", 
    Pixel = <any>"Pixel", 
    Pica = <any>"Pica", 
    Point = <any>"Point", 
}

/** Corresponds to xmpDM.VideoPixelDepthChoice */
export enum VideoPixelDepth {
    PIXEL_DEPTH_8_INT = <any>"PIXEL_DEPTH_8_INT", 
    PIXEL_DEPTH_16_INT = <any>"PIXEL_DEPTH_16_INT", 
    PIXEL_DEPTH_24_INT = <any>"PIXEL_DEPTH_24_INT", 
    PIXEL_DEPTH_32_INT = <any>"PIXEL_DEPTH_32_INT", 
    PIXEL_DEPTH_32_FLOAT = <any>"PIXEL_DEPTH_32_FLOAT", 
    PIXEL_DEPTH_OTHER = <any>"PIXEL_DEPTH_OTHER", 
}

export class Xmpidq implements IXmpidq {
    scheme?: string | undefined;

    constructor(data?: IXmpidq) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheme = data["scheme"];
        }
    }

    static fromJS(data: any): Xmpidq {
        let result = new Xmpidq();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        return data; 
    }
}

export interface IXmpidq {
    scheme?: string | undefined;
}

export class XmpMM implements IXmpMM {
    derivedFrom?: Reference | undefined;
    documentID?: string | undefined;
    history?: Event[] | undefined;
    ingredients?: Reference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: Reference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: VersionInfo[] | undefined;

    constructor(data?: IXmpMM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.derivedFrom = data["derivedFrom"] ? Reference.fromJS(data["derivedFrom"]) : <any>undefined;
            this.documentID = data["documentID"];
            if (data["history"] && data["history"].constructor === Array) {
                this.history = [];
                for (let item of data["history"])
                    this.history.push(Event.fromJS(item));
            }
            if (data["ingredients"] && data["ingredients"].constructor === Array) {
                this.ingredients = [];
                for (let item of data["ingredients"])
                    this.ingredients.push(Reference.fromJS(item));
            }
            this.instanceID = data["instanceID"];
            this.managedFrom = data["managedFrom"] ? Reference.fromJS(data["managedFrom"]) : <any>undefined;
            this.manager = data["manager"];
            this.manageTo = data["manageTo"];
            this.manageUI = data["manageUI"];
            this.managerVariant = data["managerVariant"];
            this.originalDocumentID = data["originalDocumentID"];
            this.renditionClass = data["renditionClass"];
            this.renditionParams = data["renditionParams"];
            this.versionID = data["versionID"];
            if (data["versions"] && data["versions"].constructor === Array) {
                this.versions = [];
                for (let item of data["versions"])
                    this.versions.push(VersionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMM {
        let result = new XmpMM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["derivedFrom"] = this.derivedFrom ? this.derivedFrom.toJSON() : <any>undefined;
        data["documentID"] = this.documentID;
        if (this.history && this.history.constructor === Array) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        if (this.ingredients && this.ingredients.constructor === Array) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["instanceID"] = this.instanceID;
        data["managedFrom"] = this.managedFrom ? this.managedFrom.toJSON() : <any>undefined;
        data["manager"] = this.manager;
        data["manageTo"] = this.manageTo;
        data["manageUI"] = this.manageUI;
        data["managerVariant"] = this.managerVariant;
        data["originalDocumentID"] = this.originalDocumentID;
        data["renditionClass"] = this.renditionClass;
        data["renditionParams"] = this.renditionParams;
        data["versionID"] = this.versionID;
        if (this.versions && this.versions.constructor === Array) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmpMM {
    derivedFrom?: Reference | undefined;
    documentID?: string | undefined;
    history?: Event[] | undefined;
    ingredients?: Reference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: Reference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: VersionInfo[] | undefined;
}

export class Reference implements IReference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["alternatePaths"] && data["alternatePaths"].constructor === Array) {
                this.alternatePaths = [];
                for (let item of data["alternatePaths"])
                    this.alternatePaths.push(item);
            }
            this.documentID = data["documentID"];
            this.filePath = data["filePath"];
            this.fromPart = data["fromPart"];
            this.instanceID = data["instanceID"];
            this.lastModifyDate = data["lastModifyDate"] ? new Date(data["lastModifyDate"].toString()) : <any>undefined;
            this.manager = data["manager"];
            this.managerVariant = data["managerVariant"];
            this.manageTo = data["manageTo"];
            this.manageUI = data["manageUI"];
            this.maskMarkers = data["maskMarkers"];
            this.originalDocumentID = data["originalDocumentID"];
            this.partMapping = data["partMapping"];
            this.renditionClass = data["renditionClass"];
            this.renditionParams = data["renditionParams"];
            this.toPart = data["toPart"];
            this.versionID = data["versionID"];
        }
    }

    static fromJS(data: any): Reference {
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.alternatePaths && this.alternatePaths.constructor === Array) {
            data["alternatePaths"] = [];
            for (let item of this.alternatePaths)
                data["alternatePaths"].push(item);
        }
        data["documentID"] = this.documentID;
        data["filePath"] = this.filePath;
        data["fromPart"] = this.fromPart;
        data["instanceID"] = this.instanceID;
        data["lastModifyDate"] = this.lastModifyDate ? this.lastModifyDate.toISOString() : <any>undefined;
        data["manager"] = this.manager;
        data["managerVariant"] = this.managerVariant;
        data["manageTo"] = this.manageTo;
        data["manageUI"] = this.manageUI;
        data["maskMarkers"] = this.maskMarkers;
        data["originalDocumentID"] = this.originalDocumentID;
        data["partMapping"] = this.partMapping;
        data["renditionClass"] = this.renditionClass;
        data["renditionParams"] = this.renditionParams;
        data["toPart"] = this.toPart;
        data["versionID"] = this.versionID;
        return data; 
    }
}

export interface IReference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;
}

/** Corresponds to stRef.MaskMarkersChoice */
export enum MaskMarkers {
    All = <any>"All", 
    None = <any>"None", 
}

export class XmpNote implements IXmpNote {
    hasExtendedXMP?: string | undefined;

    constructor(data?: IXmpNote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasExtendedXMP = data["hasExtendedXMP"];
        }
    }

    static fromJS(data: any): XmpNote {
        let result = new XmpNote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasExtendedXMP"] = this.hasExtendedXMP;
        return data; 
    }
}

export interface IXmpNote {
    hasExtendedXMP?: string | undefined;
}

export class XmpRights implements IXmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;

    constructor(data?: IXmpRights) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.certificate = data["certificate"];
            this.marked = data["marked"];
            if (data["owner"] && data["owner"].constructor === Array) {
                this.owner = [];
                for (let item of data["owner"])
                    this.owner.push(item);
            }
            if (data["usageTerms"]) {
                this.usageTerms = {};
                for (let key in data["usageTerms"]) {
                    if (data["usageTerms"].hasOwnProperty(key))
                        this.usageTerms[key] = data["usageTerms"][key];
                }
            }
            this.webStatement = data["webStatement"];
        }
    }

    static fromJS(data: any): XmpRights {
        let result = new XmpRights();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificate"] = this.certificate;
        data["marked"] = this.marked;
        if (this.owner && this.owner.constructor === Array) {
            data["owner"] = [];
            for (let item of this.owner)
                data["owner"].push(item);
        }
        if (this.usageTerms) {
            data["usageTerms"] = {};
            for (let key in this.usageTerms) {
                if (this.usageTerms.hasOwnProperty(key))
                    data["usageTerms"][key] = this.usageTerms[key];
            }
        }
        data["webStatement"] = this.webStatement;
        return data; 
    }
}

export interface IXmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;
}

export class XmpTPg implements IXmpTPg {
    colorants?: XmpG[] | undefined;
    fonts?: Font[] | undefined;
    maxPageSize?: Dimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;

    constructor(data?: IXmpTPg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["colorants"] && data["colorants"].constructor === Array) {
                this.colorants = [];
                for (let item of data["colorants"])
                    this.colorants.push(XmpG.fromJS(item));
            }
            if (data["fonts"] && data["fonts"].constructor === Array) {
                this.fonts = [];
                for (let item of data["fonts"])
                    this.fonts.push(Font.fromJS(item));
            }
            this.maxPageSize = data["maxPageSize"] ? Dimension.fromJS(data["maxPageSize"]) : <any>undefined;
            this.nPages = data["nPages"];
            if (data["plateNames"] && data["plateNames"].constructor === Array) {
                this.plateNames = [];
                for (let item of data["plateNames"])
                    this.plateNames.push(item);
            }
        }
    }

    static fromJS(data: any): XmpTPg {
        let result = new XmpTPg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.colorants && this.colorants.constructor === Array) {
            data["colorants"] = [];
            for (let item of this.colorants)
                data["colorants"].push(item.toJSON());
        }
        if (this.fonts && this.fonts.constructor === Array) {
            data["fonts"] = [];
            for (let item of this.fonts)
                data["fonts"].push(item.toJSON());
        }
        data["maxPageSize"] = this.maxPageSize ? this.maxPageSize.toJSON() : <any>undefined;
        data["nPages"] = this.nPages;
        if (this.plateNames && this.plateNames.constructor === Array) {
            data["plateNames"] = [];
            for (let item of this.plateNames)
                data["plateNames"].push(item);
        }
        return data; 
    }
}

export interface IXmpTPg {
    colorants?: XmpG[] | undefined;
    fonts?: Font[] | undefined;
    maxPageSize?: Dimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;
}

export class Font implements IFont {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;

    constructor(data?: IFont) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["childFontFiles"] && data["childFontFiles"].constructor === Array) {
                this.childFontFiles = [];
                for (let item of data["childFontFiles"])
                    this.childFontFiles.push(item);
            }
            this.composite = data["composite"];
            this.fontFace = data["fontFace"];
            this.fontFamily = data["fontFamily"];
            this.fontFileName = data["fontFileName"];
            this.fontName = data["fontName"];
            this.fontType = data["fontType"];
            this.versionString = data["versionString"];
        }
    }

    static fromJS(data: any): Font {
        let result = new Font();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.childFontFiles && this.childFontFiles.constructor === Array) {
            data["childFontFiles"] = [];
            for (let item of this.childFontFiles)
                data["childFontFiles"].push(item);
        }
        data["composite"] = this.composite;
        data["fontFace"] = this.fontFace;
        data["fontFamily"] = this.fontFamily;
        data["fontFileName"] = this.fontFileName;
        data["fontName"] = this.fontName;
        data["fontType"] = this.fontType;
        data["versionString"] = this.versionString;
        return data; 
    }
}

export interface IFont {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;
}

/** Corresponds to stFnt.FontTypeChoice */
export enum FontType {
    TrueType = <any>"TrueType", 
    Type1 = <any>"Type1", 
    OpenType = <any>"OpenType", 
    OpenTypeCFF = <any>"OpenTypeCFF", 
}

export class ExifMetadata implements IExifMetadata {
    exif?: Exif | undefined;
    exifAux?: ExifAux | undefined;

    constructor(data?: IExifMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exif = data["exif"] ? Exif.fromJS(data["exif"]) : <any>undefined;
            this.exifAux = data["exifAux"] ? ExifAux.fromJS(data["exifAux"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExifMetadata {
        let result = new ExifMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exif"] = this.exif ? this.exif.toJSON() : <any>undefined;
        data["exifAux"] = this.exifAux ? this.exifAux.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IExifMetadata {
    exif?: Exif | undefined;
    exifAux?: ExifAux | undefined;
}

export class Exif implements IExif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cfaPattern?: CFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: DeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: Flash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gpsAltitude?: string | undefined;
    gpsAltitudeRef?: GPSAltitudeRef | undefined;
    gpsAreaInformation?: string | undefined;
    gpsDestBearing?: string | undefined;
    gpsDestBearingRef?: GPSDestBearingRef | undefined;
    gpsDestDistance?: string | undefined;
    gpsDestDistanceRef?: GPSDestDistanceRef | undefined;
    gpsDestLatitude?: string | undefined;
    gpsDestLongitude?: string | undefined;
    gpsDifferential?: GPSDifferential | undefined;
    gpsdop?: string | undefined;
    gpsImgDirection?: string | undefined;
    gpsImgDirectionRef?: GPSImgDirectionRef | undefined;
    gpsCoordinate?: GPSCoordinate | undefined;
    gpsLatitude?: string | undefined;
    gpsLongitude?: string | undefined;
    gpsMapDatum?: string | undefined;
    gpsMeasureMode?: string | undefined;
    gpsProcessingMethod?: string | undefined;
    gpsSatellites?: string | undefined;
    gpsSpeed?: string | undefined;
    gpsSpeedRef?: GPSSpeedRef | undefined;
    gpsStatus?: GPSStatus | undefined;
    gpsTimeStamp?: Date | undefined;
    gpsTrack?: string | undefined;
    gpsTrackRef?: string | undefined;
    gpsVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    isoSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oecf?: OECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: SFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;

    constructor(data?: IExif) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apertureValue = data["apertureValue"];
            this.brightnessValue = data["brightnessValue"];
            this.cfaPattern = data["cfaPattern"] ? CFAPattern.fromJS(data["cfaPattern"]) : <any>undefined;
            this.colorSpace = data["colorSpace"];
            if (data["componentsConfiguration"] && data["componentsConfiguration"].constructor === Array) {
                this.componentsConfiguration = [];
                for (let item of data["componentsConfiguration"])
                    this.componentsConfiguration.push(item);
            }
            this.compressedBitsPerPixel = data["compressedBitsPerPixel"];
            this.contrast = data["contrast"];
            this.customRendered = data["customRendered"];
            this.dateTimeOriginal = data["dateTimeOriginal"] ? new Date(data["dateTimeOriginal"].toString()) : <any>undefined;
            this.dateTimeDigitized = data["dateTimeDigitized"] ? new Date(data["dateTimeDigitized"].toString()) : <any>undefined;
            this.deviceSettingDescription = data["deviceSettingDescription"] ? DeviceSettings.fromJS(data["deviceSettingDescription"]) : <any>undefined;
            this.digitalZoomRatio = data["digitalZoomRatio"];
            this.exifVersion = data["exifVersion"];
            this.exposureBiasValue = data["exposureBiasValue"];
            this.exposureIndex = data["exposureIndex"];
            this.exposureMode = data["exposureMode"];
            this.exposureProgram = data["exposureProgram"];
            this.exposureTime = data["exposureTime"];
            this.fileSource = data["fileSource"];
            this.flash = data["flash"] ? Flash.fromJS(data["flash"]) : <any>undefined;
            this.flashEnergy = data["flashEnergy"];
            this.flashpixVersion = data["flashpixVersion"];
            this.fNumber = data["fNumber"];
            this.focalLength = data["focalLength"];
            this.focalLengthIn35mmFilm = data["focalLengthIn35mmFilm"];
            this.focalPlaneResolutionUnit = data["focalPlaneResolutionUnit"];
            this.focalPlaneXResolution = data["focalPlaneXResolution"];
            this.focalPlaneYResolution = data["focalPlaneYResolution"];
            this.gainControl = data["gainControl"];
            this.gpsAltitude = data["gpsAltitude"];
            this.gpsAltitudeRef = data["gpsAltitudeRef"];
            this.gpsAreaInformation = data["gpsAreaInformation"];
            this.gpsDestBearing = data["gpsDestBearing"];
            this.gpsDestBearingRef = data["gpsDestBearingRef"];
            this.gpsDestDistance = data["gpsDestDistance"];
            this.gpsDestDistanceRef = data["gpsDestDistanceRef"];
            this.gpsDestLatitude = data["gpsDestLatitude"];
            this.gpsDestLongitude = data["gpsDestLongitude"];
            this.gpsDifferential = data["gpsDifferential"];
            this.gpsdop = data["gpsdop"];
            this.gpsImgDirection = data["gpsImgDirection"];
            this.gpsImgDirectionRef = data["gpsImgDirectionRef"];
            this.gpsCoordinate = data["gpsCoordinate"] ? GPSCoordinate.fromJS(data["gpsCoordinate"]) : <any>undefined;
            this.gpsLatitude = data["gpsLatitude"];
            this.gpsLongitude = data["gpsLongitude"];
            this.gpsMapDatum = data["gpsMapDatum"];
            this.gpsMeasureMode = data["gpsMeasureMode"];
            this.gpsProcessingMethod = data["gpsProcessingMethod"];
            this.gpsSatellites = data["gpsSatellites"];
            this.gpsSpeed = data["gpsSpeed"];
            this.gpsSpeedRef = data["gpsSpeedRef"];
            this.gpsStatus = data["gpsStatus"];
            this.gpsTimeStamp = data["gpsTimeStamp"] ? new Date(data["gpsTimeStamp"].toString()) : <any>undefined;
            this.gpsTrack = data["gpsTrack"];
            this.gpsTrackRef = data["gpsTrackRef"];
            this.gpsVersionID = data["gpsVersionID"];
            this.imageUniqueID = data["imageUniqueID"];
            if (data["isoSpeedRatings"] && data["isoSpeedRatings"].constructor === Array) {
                this.isoSpeedRatings = [];
                for (let item of data["isoSpeedRatings"])
                    this.isoSpeedRatings.push(item);
            }
            this.lightSource = data["lightSource"];
            this.maxApertureValue = data["maxApertureValue"];
            this.meteringMode = data["meteringMode"];
            this.oecf = data["oecf"] ? OECF.fromJS(data["oecf"]) : <any>undefined;
            this.pixelXDimension = data["pixelXDimension"];
            this.pixelYDimension = data["pixelYDimension"];
            this.relatedSoundFile = data["relatedSoundFile"];
            this.saturation = data["saturation"];
            this.sceneCaptureType = data["sceneCaptureType"];
            this.sceneType = data["sceneType"];
            this.sensingMethod = data["sensingMethod"];
            this.sharpness = data["sharpness"];
            this.shutterSpeedValue = data["shutterSpeedValue"];
            this.spatialFrequencyResponse = data["spatialFrequencyResponse"] ? SFR.fromJS(data["spatialFrequencyResponse"]) : <any>undefined;
            this.spectralSensitivity = data["spectralSensitivity"];
            if (data["subjectArea"] && data["subjectArea"].constructor === Array) {
                this.subjectArea = [];
                for (let item of data["subjectArea"])
                    this.subjectArea.push(item);
            }
            this.subjectDistance = data["subjectDistance"];
            this.subjectDistanceRange = data["subjectDistanceRange"];
            if (data["subjectLocation"] && data["subjectLocation"].constructor === Array) {
                this.subjectLocation = [];
                for (let item of data["subjectLocation"])
                    this.subjectLocation.push(item);
            }
            if (data["userComment"]) {
                this.userComment = {};
                for (let key in data["userComment"]) {
                    if (data["userComment"].hasOwnProperty(key))
                        this.userComment[key] = data["userComment"][key];
                }
            }
            this.whiteBalance = data["whiteBalance"];
            this.nativeDigest = data["nativeDigest"];
        }
    }

    static fromJS(data: any): Exif {
        let result = new Exif();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apertureValue"] = this.apertureValue;
        data["brightnessValue"] = this.brightnessValue;
        data["cfaPattern"] = this.cfaPattern ? this.cfaPattern.toJSON() : <any>undefined;
        data["colorSpace"] = this.colorSpace;
        if (this.componentsConfiguration && this.componentsConfiguration.constructor === Array) {
            data["componentsConfiguration"] = [];
            for (let item of this.componentsConfiguration)
                data["componentsConfiguration"].push(item);
        }
        data["compressedBitsPerPixel"] = this.compressedBitsPerPixel;
        data["contrast"] = this.contrast;
        data["customRendered"] = this.customRendered;
        data["dateTimeOriginal"] = this.dateTimeOriginal ? this.dateTimeOriginal.toISOString() : <any>undefined;
        data["dateTimeDigitized"] = this.dateTimeDigitized ? this.dateTimeDigitized.toISOString() : <any>undefined;
        data["deviceSettingDescription"] = this.deviceSettingDescription ? this.deviceSettingDescription.toJSON() : <any>undefined;
        data["digitalZoomRatio"] = this.digitalZoomRatio;
        data["exifVersion"] = this.exifVersion;
        data["exposureBiasValue"] = this.exposureBiasValue;
        data["exposureIndex"] = this.exposureIndex;
        data["exposureMode"] = this.exposureMode;
        data["exposureProgram"] = this.exposureProgram;
        data["exposureTime"] = this.exposureTime;
        data["fileSource"] = this.fileSource;
        data["flash"] = this.flash ? this.flash.toJSON() : <any>undefined;
        data["flashEnergy"] = this.flashEnergy;
        data["flashpixVersion"] = this.flashpixVersion;
        data["fNumber"] = this.fNumber;
        data["focalLength"] = this.focalLength;
        data["focalLengthIn35mmFilm"] = this.focalLengthIn35mmFilm;
        data["focalPlaneResolutionUnit"] = this.focalPlaneResolutionUnit;
        data["focalPlaneXResolution"] = this.focalPlaneXResolution;
        data["focalPlaneYResolution"] = this.focalPlaneYResolution;
        data["gainControl"] = this.gainControl;
        data["gpsAltitude"] = this.gpsAltitude;
        data["gpsAltitudeRef"] = this.gpsAltitudeRef;
        data["gpsAreaInformation"] = this.gpsAreaInformation;
        data["gpsDestBearing"] = this.gpsDestBearing;
        data["gpsDestBearingRef"] = this.gpsDestBearingRef;
        data["gpsDestDistance"] = this.gpsDestDistance;
        data["gpsDestDistanceRef"] = this.gpsDestDistanceRef;
        data["gpsDestLatitude"] = this.gpsDestLatitude;
        data["gpsDestLongitude"] = this.gpsDestLongitude;
        data["gpsDifferential"] = this.gpsDifferential;
        data["gpsdop"] = this.gpsdop;
        data["gpsImgDirection"] = this.gpsImgDirection;
        data["gpsImgDirectionRef"] = this.gpsImgDirectionRef;
        data["gpsCoordinate"] = this.gpsCoordinate ? this.gpsCoordinate.toJSON() : <any>undefined;
        data["gpsLatitude"] = this.gpsLatitude;
        data["gpsLongitude"] = this.gpsLongitude;
        data["gpsMapDatum"] = this.gpsMapDatum;
        data["gpsMeasureMode"] = this.gpsMeasureMode;
        data["gpsProcessingMethod"] = this.gpsProcessingMethod;
        data["gpsSatellites"] = this.gpsSatellites;
        data["gpsSpeed"] = this.gpsSpeed;
        data["gpsSpeedRef"] = this.gpsSpeedRef;
        data["gpsStatus"] = this.gpsStatus;
        data["gpsTimeStamp"] = this.gpsTimeStamp ? this.gpsTimeStamp.toISOString() : <any>undefined;
        data["gpsTrack"] = this.gpsTrack;
        data["gpsTrackRef"] = this.gpsTrackRef;
        data["gpsVersionID"] = this.gpsVersionID;
        data["imageUniqueID"] = this.imageUniqueID;
        if (this.isoSpeedRatings && this.isoSpeedRatings.constructor === Array) {
            data["isoSpeedRatings"] = [];
            for (let item of this.isoSpeedRatings)
                data["isoSpeedRatings"].push(item);
        }
        data["lightSource"] = this.lightSource;
        data["maxApertureValue"] = this.maxApertureValue;
        data["meteringMode"] = this.meteringMode;
        data["oecf"] = this.oecf ? this.oecf.toJSON() : <any>undefined;
        data["pixelXDimension"] = this.pixelXDimension;
        data["pixelYDimension"] = this.pixelYDimension;
        data["relatedSoundFile"] = this.relatedSoundFile;
        data["saturation"] = this.saturation;
        data["sceneCaptureType"] = this.sceneCaptureType;
        data["sceneType"] = this.sceneType;
        data["sensingMethod"] = this.sensingMethod;
        data["sharpness"] = this.sharpness;
        data["shutterSpeedValue"] = this.shutterSpeedValue;
        data["spatialFrequencyResponse"] = this.spatialFrequencyResponse ? this.spatialFrequencyResponse.toJSON() : <any>undefined;
        data["spectralSensitivity"] = this.spectralSensitivity;
        if (this.subjectArea && this.subjectArea.constructor === Array) {
            data["subjectArea"] = [];
            for (let item of this.subjectArea)
                data["subjectArea"].push(item);
        }
        data["subjectDistance"] = this.subjectDistance;
        data["subjectDistanceRange"] = this.subjectDistanceRange;
        if (this.subjectLocation && this.subjectLocation.constructor === Array) {
            data["subjectLocation"] = [];
            for (let item of this.subjectLocation)
                data["subjectLocation"].push(item);
        }
        if (this.userComment) {
            data["userComment"] = {};
            for (let key in this.userComment) {
                if (this.userComment.hasOwnProperty(key))
                    data["userComment"][key] = this.userComment[key];
            }
        }
        data["whiteBalance"] = this.whiteBalance;
        data["nativeDigest"] = this.nativeDigest;
        return data; 
    }
}

export interface IExif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cfaPattern?: CFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: DeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: Flash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gpsAltitude?: string | undefined;
    gpsAltitudeRef?: GPSAltitudeRef | undefined;
    gpsAreaInformation?: string | undefined;
    gpsDestBearing?: string | undefined;
    gpsDestBearingRef?: GPSDestBearingRef | undefined;
    gpsDestDistance?: string | undefined;
    gpsDestDistanceRef?: GPSDestDistanceRef | undefined;
    gpsDestLatitude?: string | undefined;
    gpsDestLongitude?: string | undefined;
    gpsDifferential?: GPSDifferential | undefined;
    gpsdop?: string | undefined;
    gpsImgDirection?: string | undefined;
    gpsImgDirectionRef?: GPSImgDirectionRef | undefined;
    gpsCoordinate?: GPSCoordinate | undefined;
    gpsLatitude?: string | undefined;
    gpsLongitude?: string | undefined;
    gpsMapDatum?: string | undefined;
    gpsMeasureMode?: string | undefined;
    gpsProcessingMethod?: string | undefined;
    gpsSatellites?: string | undefined;
    gpsSpeed?: string | undefined;
    gpsSpeedRef?: GPSSpeedRef | undefined;
    gpsStatus?: GPSStatus | undefined;
    gpsTimeStamp?: Date | undefined;
    gpsTrack?: string | undefined;
    gpsTrackRef?: string | undefined;
    gpsVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    isoSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oecf?: OECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: SFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;
}

export class CFAPattern implements ICFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;

    constructor(data?: ICFAPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
        }
    }

    static fromJS(data: any): CFAPattern {
        let result = new CFAPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface ICFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;
}

/** Corresponds to exif.ColorSpaceChoice */
export enum ColorSpace {
    None = <any>"None", 
    SRGB = <any>"sRGB", 
    AdobeRGB = <any>"AdobeRGB", 
    Uncalibrated = <any>"Uncalibrated", 
}

/** Corresponds to exif.ContrastChoice */
export enum Contrast {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.CustomRenderedChoice */
export enum CustomRendered {
    NormalProcess = <any>"NormalProcess", 
    CustomProcess = <any>"CustomProcess", 
}

export class DeviceSettings implements IDeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;

    constructor(data?: IDeviceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [];
                for (let item of data["settings"])
                    this.settings.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceSettings {
        let result = new DeviceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item);
        }
        return data; 
    }
}

export interface IDeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;
}

/** Corresponds to exif.ExifVersionChoice */
export enum ExifVersion {
    V210 = <any>"V210", 
    V220 = <any>"V220", 
    V221 = <any>"V221", 
    V222 = <any>"V222", 
    V230 = <any>"V230", 
}

/** Corresponds to exif.ExposureModeChoice */
export enum ExposureMode {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    AutoBracket = <any>"AutoBracket", 
}

/** Corresponds to exif.ExposureProgramChoice */
export enum ExposureProgram {
    Undefined = <any>"Undefined", 
    Manual = <any>"Manual", 
    NormalProgram = <any>"NormalProgram", 
    AperturePriority = <any>"AperturePriority", 
    ShutterPriority = <any>"ShutterPriority", 
    CreativeProgram = <any>"CreativeProgram", 
    ActionProgram = <any>"ActionProgram", 
    PortraitMode = <any>"PortraitMode", 
    LandscapeMode = <any>"LandscapeMode", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.FileSourceChoice */
export enum FileSource {
    Other = <any>"Other", 
    TransparentScanner = <any>"TransparentScanner", 
    ReflexScanner = <any>"ReflexScanner", 
    DSC = <any>"DSC", 
}

export class Flash implements IFlash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;

    constructor(data?: IFlash) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fired = data["fired"];
            this.return = data["return"];
            this.mode = data["mode"];
            this.function = data["function"];
            this.redEyeMode = data["redEyeMode"];
        }
    }

    static fromJS(data: any): Flash {
        let result = new Flash();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fired"] = this.fired;
        data["return"] = this.return;
        data["mode"] = this.mode;
        data["function"] = this.function;
        data["redEyeMode"] = this.redEyeMode;
        return data; 
    }
}

export interface IFlash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;
}

/** Corresponds to Xmp.Structure.Flash.ReturnChoice */
export enum FlashReturn {
    NoStrobeReturnDetection = <any>"NoStrobeReturnDetection", 
    StrobeReturnLightNotDetected = <any>"StrobeReturnLightNotDetected", 
    StrobeReturnLightDetected = <any>"StrobeReturnLightDetected", 
}

/** Corresponds to Xmp.Structure.Flash.ModeChoice */
export enum FlashMode {
    Unknown = <any>"Unknown", 
    CompulsoryFlashFiring = <any>"CompulsoryFlashFiring", 
    CompulsoryFlashSuppression = <any>"CompulsoryFlashSuppression", 
    AutoMode = <any>"AutoMode", 
}

/** Corresponds to exif.FlashpixVersionChoice */
export enum FlashpixVersion {
    V100 = <any>"V100", 
    V101 = <any>"V101", 
    V110 = <any>"V110", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum FocalPlaneResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Meter = <any>"Meter", 
    Centimeter = <any>"Centimeter", 
    Millimeter = <any>"Millimeter", 
    Micrometer = <any>"Micrometer", 
}

/** Corresponds to exif.GainControlChoice */
export enum GainControl {
    None = <any>"None", 
    LowGainUp = <any>"LowGainUp", 
    HighGainUp = <any>"HighGainUp", 
    LowGainDown = <any>"LowGainDown", 
    HighGainDown = <any>"HighGainDown", 
}

/** Corresponds to exif.GPSAltitudeRefChoice */
export enum GPSAltitudeRef {
    AboveSeaLevel = <any>"AboveSeaLevel", 
    BelowSeaLevel = <any>"BelowSeaLevel", 
}

/** Corresponds to exif.GPSDestBearingRefChoice */
export enum GPSDestBearingRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

/** Corresponds to exif.GPSDestDistanceRefChoice */
export enum GPSDestDistanceRef {
    Kilometers = <any>"Kilometers", 
    Miles = <any>"Miles", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSDifferentialChoice */
export enum GPSDifferential {
    WithoutCorrection = <any>"WithoutCorrection", 
    WithCorrection = <any>"WithCorrection", 
}

/** Corresponds to exif.GPSImgDirectionRefChoice */
export enum GPSImgDirectionRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

export class GPSCoordinate implements IGPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;

    constructor(data?: IGPSCoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lon = data["lon"];
            this.lat = data["lat"];
        }
    }

    static fromJS(data: any): GPSCoordinate {
        let result = new GPSCoordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lon"] = this.lon;
        data["lat"] = this.lat;
        return data; 
    }
}

export interface IGPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;
}

/** Corresponds to exif.GPSSpeedRefChoice */
export enum GPSSpeedRef {
    KilometersPerHour = <any>"KilometersPerHour", 
    MilesPerHour = <any>"MilesPerHour", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSStatusChoice */
export enum GPSStatus {
    MeasurementInProgress = <any>"MeasurementInProgress", 
    MeasurementIsInteroperability = <any>"MeasurementIsInteroperability", 
}

/** Corresponds to exif.LightSourceChoice */
export enum LightSource {
    Unidentified = <any>"Unidentified", 
    Daylight = <any>"Daylight", 
    Fluorescent = <any>"Fluorescent", 
    Tungsten = <any>"Tungsten", 
    Flash = <any>"Flash", 
    FineWeather = <any>"FineWeather", 
    CloudyWeather = <any>"CloudyWeather", 
    Shade = <any>"Shade", 
    DaylightFluorescent = <any>"DaylightFluorescent", 
    DayWhiteFluorescent = <any>"DayWhiteFluorescent", 
    CoolWhiteFluorescent = <any>"CoolWhiteFluorescent", 
    WhiteFluorescent = <any>"WhiteFluorescent", 
    StandardIlluminantA = <any>"StandardIlluminantA", 
    StandardIlluminantB = <any>"StandardIlluminantB", 
    StandardIlluminantC = <any>"StandardIlluminantC", 
    D55Illuminant = <any>"D55Illuminant", 
    D65Illuminant = <any>"D65Illuminant", 
    D75Illuminant = <any>"D75Illuminant", 
    D50Illuminant = <any>"D50Illuminant", 
    ISOStudioTungsten = <any>"ISOStudioTungsten", 
    Other = <any>"Other", 
}

/** Corresponds to exif.MeteringModeChoice */
export enum MeteringMode {
    Unidentified = <any>"Unidentified", 
    Average = <any>"Average", 
    CenterWeightedAverage = <any>"CenterWeightedAverage", 
    Spot = <any>"Spot", 
    MultiSpot = <any>"MultiSpot", 
    Pattern = <any>"Pattern", 
    Partial = <any>"Partial", 
    Reserved = <any>"Reserved", 
    Other = <any>"Other", 
}

export class OECF implements IOECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;

    constructor(data?: IOECF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
            if (data["names"] && data["names"].constructor === Array) {
                this.names = [];
                for (let item of data["names"])
                    this.names.push(item);
            }
        }
    }

    static fromJS(data: any): OECF {
        let result = new OECF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        if (this.names && this.names.constructor === Array) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item);
        }
        return data; 
    }
}

export interface IOECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SaturationChoice */
export enum Saturation {
    Normal = <any>"Normal", 
    Low = <any>"Low", 
    High = <any>"High", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.SceneCaptureTypeChoice */
export enum SceneCaptureType {
    Standard = <any>"Standard", 
    Landscape = <any>"Landscape", 
    Portrait = <any>"Portrait", 
    NightScene = <any>"NightScene", 
}

/** Corresponds to exif.SceneTypeChoice */
export enum SceneType {
    DirectlyPhotographedImage = <any>"DirectlyPhotographedImage", 
}

/** Corresponds to exif.SensingMethodChoice */
export enum SensingMethod {
    Undefined = <any>"Undefined", 
    MonochromeArea = <any>"MonochromeArea", 
    OneChipColourAreaSensor = <any>"OneChipColourAreaSensor", 
    TwoChipColourAreaSensor = <any>"TwoChipColourAreaSensor", 
    ThreeChipColourAreaSensor = <any>"ThreeChipColourAreaSensor", 
    ColourSequentialAreaSensor = <any>"ColourSequentialAreaSensor", 
    MonochromeLinearArea = <any>"MonochromeLinearArea", 
    TrilinearSensor = <any>"TrilinearSensor", 
    ColourSequentialLinearSensor = <any>"ColourSequentialLinearSensor", 
}

/** Corresponds to exif.SharpnessChoice */
export enum Sharpness {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

export class SFR implements ISFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;

    constructor(data?: ISFR) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
            if (data["names"] && data["names"].constructor === Array) {
                this.names = [];
                for (let item of data["names"])
                    this.names.push(item);
            }
        }
    }

    static fromJS(data: any): SFR {
        let result = new SFR();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        if (this.names && this.names.constructor === Array) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item);
        }
        return data; 
    }
}

export interface ISFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SubjectDistanceRangeChoice */
export enum SubjectDistanceRange {
    Unknown = <any>"Unknown", 
    Macro = <any>"Macro", 
    CloseView = <any>"CloseView", 
    DistantView = <any>"DistantView", 
}

/** Corresponds to exif.WhiteBalanceChoice */
export enum WhiteBalanceExif {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    Unknown = <any>"Unknown", 
}

export class ExifAux implements IExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;

    constructor(data?: IExifAux) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lens = data["lens"];
            this.serialNumber = data["serialNumber"];
        }
    }

    static fromJS(data: any): ExifAux {
        let result = new ExifAux();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lens"] = this.lens;
        data["serialNumber"] = this.serialNumber;
        return data; 
    }
}

export interface IExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;
}

export class AudioMetadata extends FileMetadata implements IAudioMetadata {
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IAudioMetadata) {
        super(data);
        this._discriminator = "AudioMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["audioStreams"] && data["audioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["audioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AudioMetadata {
        let result = new AudioMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAudioMetadata extends IFileMetadata {
    audioStreams?: AudioStream[] | undefined;
}

export class AudioStream implements IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;

    constructor(data?: IAudioStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["bitRate"];
            this.bitRateMode = data["bitRateMode"];
            this.channels = data["channels"];
            this.channelPositions = data["channelPositions"];
            this.codec = data["codec"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.language = data["language"];
            this.resolution = data["resolution"];
            this.samplingRate = data["samplingRate"];
            this.streamSize = data["streamSize"];
        }
    }

    static fromJS(data: any): AudioStream {
        let result = new AudioStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["bitRateMode"] = this.bitRateMode;
        data["channels"] = this.channels;
        data["channelPositions"] = this.channelPositions;
        data["codec"] = this.codec;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["language"] = this.language;
        data["resolution"] = this.resolution;
        data["samplingRate"] = this.samplingRate;
        data["streamSize"] = this.streamSize;
        return data; 
    }
}

export interface IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export class DocumentMetadata extends FileMetadata implements IDocumentMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;

    constructor(data?: IDocumentMetadata) {
        super(data);
        this._discriminator = "DocumentMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.applicationName = data["applicationName"];
            this.applicationVersion = data["applicationVersion"];
            this.author = data["author"];
            this.creator = data["creator"];
            this.publisher = data["publisher"];
            this.company = data["company"];
            this.documentTitle = data["documentTitle"];
            this.characterCount = data["characterCount"];
            this.characterCountWithSpaces = data["characterCountWithSpaces"];
            this.lineCount = data["lineCount"];
            this.pageCount = data["pageCount"];
            this.slideCount = data["slideCount"];
            this.paragraphCount = data["paragraphCount"];
            this.revisionNumber = data["revisionNumber"];
            if (data["titles"] && data["titles"].constructor === Array) {
                this.titles = [];
                for (let item of data["titles"])
                    this.titles.push(item);
            }
            if (data["imageTitles"] && data["imageTitles"].constructor === Array) {
                this.imageTitles = [];
                for (let item of data["imageTitles"])
                    this.imageTitles.push(item);
            }
            this.epsInfo = data["epsInfo"] ? EpsMetadata.fromJS(data["epsInfo"]) : <any>undefined;
            if (data["embeddedFiles"] && data["embeddedFiles"].constructor === Array) {
                this.embeddedFiles = [];
                for (let item of data["embeddedFiles"])
                    this.embeddedFiles.push(FileMetadata.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentMetadata {
        let result = new DocumentMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["applicationVersion"] = this.applicationVersion;
        data["author"] = this.author;
        data["creator"] = this.creator;
        data["publisher"] = this.publisher;
        data["company"] = this.company;
        data["documentTitle"] = this.documentTitle;
        data["characterCount"] = this.characterCount;
        data["characterCountWithSpaces"] = this.characterCountWithSpaces;
        data["lineCount"] = this.lineCount;
        data["pageCount"] = this.pageCount;
        data["slideCount"] = this.slideCount;
        data["paragraphCount"] = this.paragraphCount;
        data["revisionNumber"] = this.revisionNumber;
        if (this.titles && this.titles.constructor === Array) {
            data["titles"] = [];
            for (let item of this.titles)
                data["titles"].push(item);
        }
        if (this.imageTitles && this.imageTitles.constructor === Array) {
            data["imageTitles"] = [];
            for (let item of this.imageTitles)
                data["imageTitles"].push(item);
        }
        data["epsInfo"] = this.epsInfo ? this.epsInfo.toJSON() : <any>undefined;
        if (this.embeddedFiles && this.embeddedFiles.constructor === Array) {
            data["embeddedFiles"] = [];
            for (let item of this.embeddedFiles)
                data["embeddedFiles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentMetadata extends IFileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;
}

export class EpsMetadata implements IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;

    constructor(data?: IEpsMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isRasterized = data["isRasterized"];
            this.widthInPoints = data["widthInPoints"];
            this.heightInPoints = data["heightInPoints"];
        }
    }

    static fromJS(data: any): EpsMetadata {
        let result = new EpsMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRasterized"] = this.isRasterized;
        data["widthInPoints"] = this.widthInPoints;
        data["heightInPoints"] = this.heightInPoints;
        return data; 
    }
}

export interface IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export class ImageMetadata extends FileMetadata implements IImageMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;

    constructor(data?: IImageMetadata) {
        super(data);
        this._discriminator = "ImageMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.widthInInch = data["widthInInch"];
            this.heightInInch = data["heightInInch"];
            this.widthInCm = data["widthInCm"];
            this.heightInCm = data["heightInCm"];
            this.colorSpace = data["colorSpace"];
            this.colorProfile = data["colorProfile"];
            this.bitsPerPixel = data["bitsPerPixel"];
            this.bitsPerChannel = data["bitsPerChannel"];
            this.channels = data["channels"];
            this.pixelFormat = data["pixelFormat"];
            this.hasAlpha = data["hasAlpha"];
            this.isIndexed = data["isIndexed"];
            this.isExtended = data["isExtended"];
            this.horizontalResolution = data["horizontalResolution"];
            this.verticalResolution = data["verticalResolution"];
            this.totalFrames = data["totalFrames"];
            this.totalUnspecifiedTiffExtraChannels = data["totalUnspecifiedTiffExtraChannels"];
            this.hasExifData = data["hasExifData"];
            this.hasIptcData = data["hasIptcData"];
            this.hasAdobeResourceData = data["hasAdobeResourceData"];
            this.hasXmpData = data["hasXmpData"];
            this.uncompressedSizeInBytes = data["uncompressedSizeInBytes"];
        }
    }

    static fromJS(data: any): ImageMetadata {
        let result = new ImageMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["widthInInch"] = this.widthInInch;
        data["heightInInch"] = this.heightInInch;
        data["widthInCm"] = this.widthInCm;
        data["heightInCm"] = this.heightInCm;
        data["colorSpace"] = this.colorSpace;
        data["colorProfile"] = this.colorProfile;
        data["bitsPerPixel"] = this.bitsPerPixel;
        data["bitsPerChannel"] = this.bitsPerChannel;
        data["channels"] = this.channels;
        data["pixelFormat"] = this.pixelFormat;
        data["hasAlpha"] = this.hasAlpha;
        data["isIndexed"] = this.isIndexed;
        data["isExtended"] = this.isExtended;
        data["horizontalResolution"] = this.horizontalResolution;
        data["verticalResolution"] = this.verticalResolution;
        data["totalFrames"] = this.totalFrames;
        data["totalUnspecifiedTiffExtraChannels"] = this.totalUnspecifiedTiffExtraChannels;
        data["hasExifData"] = this.hasExifData;
        data["hasIptcData"] = this.hasIptcData;
        data["hasAdobeResourceData"] = this.hasAdobeResourceData;
        data["hasXmpData"] = this.hasXmpData;
        data["uncompressedSizeInBytes"] = this.uncompressedSizeInBytes;
        super.toJSON(data);
        return data; 
    }
}

export interface IImageMetadata extends IFileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export class VideoMetadata extends FileMetadata implements IVideoMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IVideoMetadata) {
        super(data);
        this._discriminator = "VideoMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.codec = data["codec"];
            this.overallBitrate = data["overallBitrate"];
            if (data["videoStreams"] && data["videoStreams"].constructor === Array) {
                this.videoStreams = [];
                for (let item of data["videoStreams"])
                    this.videoStreams.push(VideoStream.fromJS(item));
            }
            if (data["audioStreams"] && data["audioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["audioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoMetadata {
        let result = new VideoMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["codec"] = this.codec;
        data["overallBitrate"] = this.overallBitrate;
        if (this.videoStreams && this.videoStreams.constructor === Array) {
            data["videoStreams"] = [];
            for (let item of this.videoStreams)
                data["videoStreams"].push(item.toJSON());
        }
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IVideoMetadata extends IFileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;
}

export class VideoStream implements IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;

    constructor(data?: IVideoStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["bitRate"];
            this.codec = data["codec"];
            this.displayAspectRatio = data["displayAspectRatio"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.frameCount = data["frameCount"];
            this.frameRate = data["frameRate"];
            this.height = data["height"];
            this.language = data["language"];
            this.pixelAspectRatio = data["pixelAspectRatio"];
            this.resolution = data["resolution"];
            this.streamSize = data["streamSize"];
            this.width = data["width"];
            this.rotation = data["rotation"];
        }
    }

    static fromJS(data: any): VideoStream {
        let result = new VideoStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["codec"] = this.codec;
        data["displayAspectRatio"] = this.displayAspectRatio;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["frameCount"] = this.frameCount;
        data["frameRate"] = this.frameRate;
        data["height"] = this.height;
        data["language"] = this.language;
        data["pixelAspectRatio"] = this.pixelAspectRatio;
        data["resolution"] = this.resolution;
        data["streamSize"] = this.streamSize;
        data["width"] = this.width;
        data["rotation"] = this.rotation;
        return data; 
    }
}

export interface IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export class DriveMetadata implements IDriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: DriveMetadataAudit | undefined;
    description?: string | undefined;

    constructor(data?: IDriveMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["location"];
            this.fileType = data["fileType"];
            this.audit = data["audit"] ? DriveMetadataAudit.fromJS(data["audit"]) : <any>undefined;
            this.description = data["description"];
        }
    }

    static fromJS(data: any): DriveMetadata {
        let result = new DriveMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["fileType"] = this.fileType;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: DriveMetadataAudit | undefined;
    description?: string | undefined;
}

export class DriveMetadataAudit implements IDriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;

    constructor(data?: IDriveMetadataAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.owner = data["owner"];
            this.modified = data["modified"];
            this.opened = data["opened"];
            this.created = data["created"];
        }
    }

    static fromJS(data: any): DriveMetadataAudit {
        let result = new DriveMetadataAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["owner"] = this.owner;
        data["modified"] = this.modified;
        data["opened"] = this.opened;
        data["created"] = this.created;
        return data; 
    }
}

export interface IDriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;
}

export class OutputItem implements IOutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;

    constructor(data?: IOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.filePath = data["filePath"];
            this.outputSource = data["outputSource"];
        }
    }

    static fromJS(data: any): OutputItem {
        let result = new OutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["outputSource"] = this.outputSource;
        return data; 
    }
}

export interface IOutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered", 
    Embedded = <any>"Embedded", 
}

export class FileTransfer2ContentCreateRequest implements IFileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransfer2ContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransfer2ContentCreateRequest {
        let result = new FileTransfer2ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class FileTransferPartial2ContentCreateRequest implements IFileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: FileTransferCreateItem[] | undefined;

    constructor(data?: IFileTransferPartial2ContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FileTransferCreateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FileTransferPartial2ContentCreateRequest {
        let result = new FileTransferPartial2ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: FileTransferCreateItem[] | undefined;
}

export class FileTransferCreateItem implements IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransferCreateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileId = data["fileId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferCreateItem {
        let result = new FileTransferCreateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class TransferSearchRequest implements ITransferSearchRequest {
    channel?: string | undefined;
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: ITransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.channel = data["channel"];
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransferSearchRequest {
        let result = new TransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel;
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITransferSearchRequest {
    channel?: string | undefined;
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfTransfer implements IBaseResultOfTransfer {
    totalResults: number;
    results?: Transfer[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Transfer.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfTransfer {
        let result = new BaseResultOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfTransfer {
    totalResults: number;
    results?: Transfer[] | undefined;
    pageToken?: string | undefined;
}

export class TransferSearchResult extends BaseResultOfTransfer implements ITransferSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: ITransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): TransferSearchResult {
        let result = new TransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferSearchResult extends IBaseResultOfTransfer {
    elapsedMilliseconds: number;
}

export class FileTransferSearchRequest implements IFileTransferSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: IFileTransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileTransferSearchRequest {
        let result = new FileTransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFileTransferSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfFileTransfer implements IBaseResultOfFileTransfer {
    totalResults: number;
    results?: FileTransfer[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(FileTransfer.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfFileTransfer {
        let result = new BaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfFileTransfer {
    totalResults: number;
    results?: FileTransfer[] | undefined;
    pageToken?: string | undefined;
}

export class FileTransferSearchResult extends BaseResultOfFileTransfer implements IFileTransferSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IFileTransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): FileTransferSearchResult {
        let result = new FileTransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IFileTransferSearchResult extends IBaseResultOfFileTransfer {
    elapsedMilliseconds: number;
}

export class FileTransfer implements IFileTransfer {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    contentId?: string | undefined;

    constructor(data?: IFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.transferId = data["transferId"];
            this.state = data["state"];
            this.entityType = data["entityType"];
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): FileTransfer {
        let result = new FileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        data["entityType"] = this.entityType;
        data["contentId"] = this.contentId;
        return data; 
    }
}

export interface IFileTransfer {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    contentId?: string | undefined;
}

export class UserSearchRequest implements IUserSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IUserSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.lifeCycleFilter = data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): UserSearchRequest {
        let result = new UserSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IUserSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    lifeCycleFilter: LifeCycleFilter;
}

export class BaseResultOfUser implements IBaseResultOfUser {
    totalResults: number;
    results?: User[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(User.fromJS(item));
            }
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfUser {
        let result = new BaseResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfUser {
    totalResults: number;
    results?: User[] | undefined;
    pageToken?: string | undefined;
}

export class UserSearchResult extends BaseResultOfUser implements IUserSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IUserSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): UserSearchResult {
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserSearchResult extends IBaseResultOfUser {
    elapsedMilliseconds: number;
}

export class User extends UserItem implements IUser {
    userRoleIds?: string[] | undefined;

    constructor(data?: IUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
        }
    }

    static fromJS(data: any): User {
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IUser extends IUserItem {
    userRoleIds?: string[] | undefined;
}

export class UserDetail extends UserItem implements IUserDetail {
    password?: string | undefined;
    userRoles?: UserRole[] | undefined;
    comment?: string | undefined;
    languageCode?: string | undefined;
    address?: UserAddress | undefined;
    drives?: Drive[] | undefined;
    ownerTokens?: OwnerToken[] | undefined;

    constructor(data?: IUserDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.password = data["password"];
            if (data["userRoles"] && data["userRoles"].constructor === Array) {
                this.userRoles = [];
                for (let item of data["userRoles"])
                    this.userRoles.push(UserRole.fromJS(item));
            }
            this.comment = data["comment"];
            this.languageCode = data["languageCode"];
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : <any>undefined;
            if (data["drives"] && data["drives"].constructor === Array) {
                this.drives = [];
                for (let item of data["drives"])
                    this.drives.push(Drive.fromJS(item));
            }
            if (data["ownerTokens"] && data["ownerTokens"].constructor === Array) {
                this.ownerTokens = [];
                for (let item of data["ownerTokens"])
                    this.ownerTokens.push(OwnerToken.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDetail {
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        if (this.userRoles && this.userRoles.constructor === Array) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (this.drives && this.drives.constructor === Array) {
            data["drives"] = [];
            for (let item of this.drives)
                data["drives"].push(item.toJSON());
        }
        if (this.ownerTokens && this.ownerTokens.constructor === Array) {
            data["ownerTokens"] = [];
            for (let item of this.ownerTokens)
                data["ownerTokens"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IUserDetail extends IUserItem {
    password?: string | undefined;
    userRoles?: UserRole[] | undefined;
    comment?: string | undefined;
    languageCode?: string | undefined;
    address?: UserAddress | undefined;
    drives?: Drive[] | undefined;
    ownerTokens?: OwnerToken[] | undefined;
}

export class UserAddress implements IUserAddress {
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.address = data["address"];
            this.alternativeAddress = data["alternativeAddress"];
            this.department = data["department"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.phone = data["phone"];
            this.countryCode = data["countryCode"];
        }
    }

    static fromJS(data: any): UserAddress {
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["address"] = this.address;
        data["alternativeAddress"] = this.alternativeAddress;
        data["department"] = this.department;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["phone"] = this.phone;
        data["countryCode"] = this.countryCode;
        return data; 
    }
}

export interface IUserAddress {
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;
    countryCode?: string | undefined;
}

export class Drive implements IDrive {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDrive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Drive {
        let result = new Drive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDrive {
    id?: string | undefined;
    name?: string | undefined;
}

export class OwnerToken implements IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;

    constructor(data?: IOwnerToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): OwnerToken {
        let result = new OwnerToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;
}

export class UserProfile implements IUserProfile {
    id?: string | undefined;
    emailAddress?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.company = data["company"];
            this.address = data["address"];
            this.alternativeAddress = data["alternativeAddress"];
            this.department = data["department"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.phone = data["phone"];
        }
    }

    static fromJS(data: any): UserProfile {
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["company"] = this.company;
        data["address"] = this.address;
        data["alternativeAddress"] = this.alternativeAddress;
        data["department"] = this.department;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["phone"] = this.phone;
        return data; 
    }
}

export interface IUserProfile {
    id?: string | undefined;
    emailAddress?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;
}

export class Channel implements IChannel {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    entityType: EntityType;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;

    constructor(data?: IChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
            this.searchIndexId = data["searchIndexId"];
            this.entityType = data["entityType"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            if (data["extendedSimpleSearchFields"] && data["extendedSimpleSearchFields"].constructor === Array) {
                this.extendedSimpleSearchFields = [];
                for (let item of data["extendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields.push(item);
            }
        }
    }

    static fromJS(data: any): Channel {
        let result = new Channel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["searchIndexId"] = this.searchIndexId;
        data["entityType"] = this.entityType;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (this.extendedSimpleSearchFields && this.extendedSimpleSearchFields.constructor === Array) {
            data["extendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["extendedSimpleSearchFields"].push(item);
        }
        return data; 
    }
}

export interface IChannel {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    entityType: EntityType;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
}

export class ContentsByIdsRequest implements IContentsByIdsRequest {
    contentIds?: string[] | undefined;

    constructor(data?: IContentsByIdsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentsByIdsRequest {
        let result = new ContentsByIdsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        return data; 
    }
}

export interface IContentsByIdsRequest {
    contentIds?: string[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
	status: number;
    fileName?: string;
	headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
	headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
		super();

        this.message = message;
        this.status = status;
        this.response = response;
		this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}
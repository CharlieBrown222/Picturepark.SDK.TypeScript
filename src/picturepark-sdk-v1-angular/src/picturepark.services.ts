/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.1.2.0 (NJsonSchema v9.2.0.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { Output, EventEmitter } from '@angular/core';
import { PictureparkServiceBase, PICTUREPARK_REFRESH_TOKEN } from './picturepark.servicebase';

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response, RequestOptionsArgs } from '@angular/http';

export const PICTUREPARK_URL = new OpaqueToken('PICTUREPARK_URL');

@Injectable()
export class AuthService {
    private http: Http; 
    private baseUrl: string; 

    private _username: string | null; 
    private _token: string | null = null; 
    private _refreshToken: string | null = null; 
    private _saveCredentials = false;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string, @Optional() @Inject(PICTUREPARK_REFRESH_TOKEN) refreshToken?: boolean) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 

        this.loadCredentials();
        if (refreshToken !== false)
            setInterval(() => this.updateToken(), 10 * 60 * 1000);
    }

    get isLoggedIn() { 
        return this._refreshToken !== null; 
    }
        
    @Output()
    isLoggedInChange = new EventEmitter();

    get username() {
        return this._username; 
    }

    get token() {
        return this._token;
    }

    login(username: string, password: string, saveCredentials?: boolean): Promise<void> {
        let url = this.baseUrl + "/token";
        let content = "grant_type=password&username=" + username + "&password=" + password + "&client_id=Picturepark.Application";

        return this.http.post(url, content, {
            headers: new Headers({
                "Content-Type": "application/x-www-form-urlencoded"
            })
        }).map((response) => {
            var result = response.json();            
            this._username = username; 
            this._token = "Bearer " + result.access_token;
            this._refreshToken = result.refresh_token;      
            this._saveCredentials = saveCredentials === undefined || saveCredentials === true;  
            this.isLoggedInChange.emit(this.isLoggedIn); 

            this.saveCredentials();
        }).toPromise();
    }

    logout(): Promise<void> {
        this._username = null; 
        this._token = null; 
        this._refreshToken = null; 
        this.isLoggedInChange.emit(this.isLoggedIn); 
        
        this.clearStoredCredentials();
        return Promise.resolve(); 
    }

    updateTokenIfRequired() {
        if (this._refreshToken !== null && this._token == null)
            return this.updateToken();
        else
           return Promise.resolve();
    }
    
    clearStoredCredentials() {
        if (localStorage && sessionStorage) {
            localStorage.setItem("picturepark_username", JSON.stringify(null));
            localStorage.setItem("picturepark_refreshToken", JSON.stringify(null));
            sessionStorage.setItem("picturepark_username", JSON.stringify(null));
            sessionStorage.setItem("picturepark_refreshToken", JSON.stringify(null));
        }
    }

    private updateToken() {       
        if (this._refreshToken !== null){
            let url = this.baseUrl + "/token";
            let content = "grant_type=refresh_token&refresh_token=" + this._refreshToken + "&client_id=Picturepark.Application";

            return this.http.post(url, content, {
                headers: new Headers({
                    "Content-Type": "application/x-www-form-urlencoded"
                })
            }).map((response) => {
                var result = response.json();

                this._token = "Bearer " + result.access_token; 
                this._refreshToken = result.refresh_token; 

                this.saveCredentials();
            }).toPromise().catch(() => {
                this.logout();
            });
       } else
           return Promise.resolve();
    }

    private loadCredentials() {
        if (localStorage && sessionStorage) {
            this._username = <string>JSON.parse(localStorage.getItem("picturepark_username")!);
            this._refreshToken = <string>JSON.parse(localStorage.getItem("picturepark_refreshToken")!);
            this._saveCredentials = this._refreshToken !== null;

            if (!this._username) {
                this._username = <string>JSON.parse(sessionStorage.getItem("picturepark_username")!);
                this._refreshToken = <string>JSON.parse(sessionStorage.getItem("picturepark_refreshToken")!);
            }
        }
    }

    private saveCredentials() {
        if (localStorage && sessionStorage) {
            if (this._saveCredentials) {
                localStorage.setItem("picturepark_username", JSON.stringify(this._username));
                localStorage.setItem("picturepark_refreshToken", JSON.stringify(this._refreshToken));
            } else {
                sessionStorage.setItem("picturepark_username", JSON.stringify(this._username));
                sessionStorage.setItem("picturepark_refreshToken", JSON.stringify(this._refreshToken));
            }
        }
    }
}

@Injectable()
export class ContentService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }
    
    private thumbnailCache: { [key: string]: Blob | null; } = {};

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, cache?: boolean): Observable<Blob> {
        let key = contentId + ":" + size;
        if (cache !== false && this.thumbnailCache[key] !== undefined)
            return Observable.of(this.thumbnailCache[key]);

        let response = this.downloadThumbnailCore(contentId, size);
        response.subscribe(blob => {
            this.thumbnailCache[key] = blob;
        });
        return response;
    }

    

    /**
     * Aggregate
     * @contentAggregationRequest The aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/Service/Contents/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregate(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Aggregate By Channel
     * @channelId The channel id
     * @contentAggregationRequest The content aggregation request.
     * @return ObjectAggregationResult
     */
    aggregateByChannel(channelId: string, contentAggregationRequest: ContentAggregationRequest): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ChannelId}/Aggregate";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{ChannelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregateByChannel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregateByChannel(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregateByChannel(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    createDownloadLink(request: ContentBatchDownloadRequest): Observable<ContentBatchDownloadItem | null> {
        let url_ = this.baseUrl + "/Service/Contents/CreateBatchContentDownload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreateDownloadLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateDownloadLink(response_);
                } catch (e) {
                    return <Observable<ContentBatchDownloadItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentBatchDownloadItem>><any>Observable.throw(response_);
        });
    }

    protected processCreateDownloadLink(response: Response): Observable<ContentBatchDownloadItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentBatchDownloadItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentBatchDownloadItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentBatchDownloadItem | null>(<any>null);
    }

    /**
     * Create Single
     * @createRequest The content create request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    createContent(createRequest: CreateContentRequest, resolve: boolean, timeout: number, patterns: string[]): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/Service/Contents?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreateContent(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContent(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processCreateContent(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    download(contentId: string, outputFormatId: string, range: string): Observable<Blob | null> {
        let url_ = this.baseUrl + "/Service/Contents/Downloads/{ContentId}/{OutputFormatId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{OutputFormatId}", encodeURIComponent("" + outputFormatId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Range": range, 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDownload(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownload(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processDownload(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status === 206) {
            return Observable.of(response.blob());
        } else if (status === 404) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText);
            });
        } else if (status === 500) {
            return blobToText(response.blob()).flatMap(_responseText => {
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    protected downloadThumbnailCore(contentId: string, size: ThumbnailSize): Observable<Blob | null> {
        let url_ = this.baseUrl + "/Service/Contents/Thumbnails/{ContentId}/{Size}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{Size}", encodeURIComponent("" + size)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDownloadThumbnail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloadThumbnail(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processDownloadThumbnail(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status === 404) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText);
            });
        } else if (status === 500) {
            return blobToText(response.blob()).flatMap(_responseText => {
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    downloadResized(contentId: string, outputFormatId: string, width: number, height: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/Service/Contents/Downloads/{ContentId}/{OutputFormatId}/{Width}/{Height}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{OutputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined.");
        url_ = url_.replace("{Width}", encodeURIComponent("" + width)); 
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined.");
        url_ = url_.replace("{Height}", encodeURIComponent("" + height)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDownloadResized(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloadResized(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processDownloadResized(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status === 404) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText);
            });
        } else if (status === 500) {
            return blobToText(response.blob()).flatMap(_responseText => {
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    /**
     * Get Single
     * @contentId The content id.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    get(contentId: string, resolve: boolean, patterns: string[]): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ContentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        if (status === 404) {
            const _responseText = response.text();
            let result404: ContentNotFoundException | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result404);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Update Single - Metadata
     * @contentId The content id.
     * @updateRequest The metadata update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    updateMetadata(contentId: string, updateRequest: UpdateContentMetadataRequest, resolve: boolean, timeout: number, patterns: string[]): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ContentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateMetadata(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateMetadata(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMetadata(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Update Single - Permissions
     * @contentId The content id.
     * @updateRequest The content permission update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    updatePermissions(contentId: string, updateRequest: UpdateContentPermissionsRequest, resolve: boolean, timeout: number, patterns: string[]): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ContentId}/Permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdatePermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdatePermissions(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePermissions(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Search
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    search(contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult | null> {
        let url_ = this.baseUrl + "/Service/Contents/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<ContentSearchResult | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentSearchResult | null>(<any>null);
    }

    /**
     * Search By Channel
     * @channelId The channel id.
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    searchByChannel(channelId: string, contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ChannelId}/Search";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{ChannelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchByChannel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchByChannel(response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchByChannel(response: Response): Observable<ContentSearchResult | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentSearchResult | null>(<any>null);
    }

    deactivate(contentId: string, timeout: number): Observable<void> {
        let url_ = this.baseUrl + "/Service/Contents/{ContentId}/Deactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeactivate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeactivate(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Update file
     * @contentId The id of the content to replace
     * @updateRequest Update request
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ContentId}/File";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateFile(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processUpdateFile(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    reactivate(contentId: string, resolve: boolean, timeout: number, patterns: string[]): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/Service/Contents/{ContentId}/Reactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processReactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReactivate(response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processReactivate(response: Response): Observable<ContentDetail | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    deactivateMany(deactivationRequest: ContentDeactivationRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Contents/Many/Deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeactivateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processDeactivateMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    reactivateMany(reactivationRequest: ContentReactivationRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Contents/Many/Reactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reactivationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processReactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReactivateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processReactivateMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Update Many - Metadata
     * @updateRequest The metadata update request.
     * @return BusinessProcessViewItem
     */
    updateMetadataMany(updateRequest: ContentsMetadataUpdateRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Contents/Many/Metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateMetadataMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateMetadataMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMetadataMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Update Many - Permissions
     * @updateRequest The permissions update request.
     * @return BusinessProcessViewItem
     */
    updatePermissionsMany(updateRequest: UpdateContentPermissionsRequest[]): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Contents/Many/Permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdatePermissionsMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdatePermissionsMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePermissionsMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }
}

@Injectable()
export class BusinessProcessService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    start(processDefinitionId: string, request: StartProcessRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/API/V1/BusinessProcesses/ProcessDefinitions/{ProcessDefinitionId}/Start";
        if (processDefinitionId === undefined || processDefinitionId === null)
            throw new Error("The parameter 'processDefinitionId' must be defined.");
        url_ = url_.replace("{ProcessDefinitionId}", encodeURIComponent("" + processDefinitionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processStart(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStart(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processStart(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    markAsEnded(processId: string): Observable<void> {
        let url_ = this.baseUrl + "/API/V1/BusinessProcesses/Processes/{ProcessId}/MarkAsEnded";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processMarkAsEnded(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMarkAsEnded(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAsEnded(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    markAsStarted(processId: string): Observable<void> {
        let url_ = this.baseUrl + "/API/V1/BusinessProcesses/Processes/{ProcessId}/MarkAsStarted";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processMarkAsStarted(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMarkAsStarted(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAsStarted(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    sendMessage(processId: string, request: SendMessageRequest): Observable<void> {
        let url_ = this.baseUrl + "/API/V1/BusinessProcesses/Processes/{ProcessId}/Message";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSendMessage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendMessage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendMessage(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    waitForStates(processId: string, states: string, timeout: number): Observable<BusinessProcessWaitResult | null> {
        let url_ = this.baseUrl + "/API/V1/BusinessProcesses/{ProcessId}/Wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        if (states === undefined)
            throw new Error("The parameter 'states' must be defined.");
        else
            url_ += "states=" + encodeURIComponent("" + states) + "&"; 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processWaitForStates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processWaitForStates(response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessWaitResult>><any>Observable.throw(response_);
        });
    }

    protected processWaitForStates(response: Response): Observable<BusinessProcessWaitResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessWaitResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessWaitResult | null>(<any>null);
    }
}

@Injectable()
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(id: string): Observable<DocumentHistoryViewItem | null> {
        let url_ = this.baseUrl + "/Service/History/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DocumentHistoryViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DocumentHistoryViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistoryViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<DocumentHistoryViewItem | null>(<any>null);
    }

    getVersion(id: string, version: string): Observable<DocumentHistoryViewItem | null> {
        let url_ = this.baseUrl + "/Service/History/{Id}/{Version}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{Version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetVersion(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetVersion(response_);
                } catch (e) {
                    return <Observable<DocumentHistoryViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetVersion(response: Response): Observable<DocumentHistoryViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistoryViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<DocumentHistoryViewItem | null>(<any>null);
    }

    getDifferenceLatest(id: string, oldVersion: number): Observable<DocumentHistoryDifferenceViewItem | null> {
        let url_ = this.baseUrl + "/Service/History/{Id}/Difference/{OldVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{OldVersion}", encodeURIComponent("" + oldVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetDifferenceLatest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDifferenceLatest(response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifferenceViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryDifferenceViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetDifferenceLatest(response: Response): Observable<DocumentHistoryDifferenceViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistoryDifferenceViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifferenceViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<DocumentHistoryDifferenceViewItem | null>(<any>null);
    }

    getDifference(id: string, oldVersion: number, newVersion: number): Observable<DocumentHistoryDifferenceViewItem | null> {
        let url_ = this.baseUrl + "/Service/History/{Id}/Difference/{OldVersion}/{NewVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{OldVersion}", encodeURIComponent("" + oldVersion)); 
        if (newVersion === undefined || newVersion === null)
            throw new Error("The parameter 'newVersion' must be defined.");
        url_ = url_.replace("{NewVersion}", encodeURIComponent("" + newVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetDifference(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDifference(response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifferenceViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryDifferenceViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetDifference(response: Response): Observable<DocumentHistoryDifferenceViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: DocumentHistoryDifferenceViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifferenceViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<DocumentHistoryDifferenceViewItem | null>(<any>null);
    }
}

@Injectable()
export class JsonSchemaService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Json Schema
     * @schemaId Schema Id
     * @return JsonSchemaViewItem
     */
    get(schemaId: string): Observable<any | null> {
        let url_ = this.baseUrl + "/Service/JsonSchemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<any | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: any | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<any | null>(<any>null);
    }
}

@Injectable()
export class ListItemService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Create Single
     * @listItem List item create request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    create(listItem: ListItemCreateRequest, resolve: boolean, timeout: number, patterns: string[]): Observable<ListItemDetail | null> {
        let url_ = this.baseUrl + "/Service/ListItems?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItem);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ListItemDetail | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ListItemDetail | null>(<any>null);
    }

    /**
     * Create Many
     * @objects A list of ListItemCreateRequests.
     * @return BusinessProcessViewItem
     */
    createMany(objects: ListItemCreateRequest[]): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/ListItems/Many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objects);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processCreateMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Delete Many
     * @ids The list item id list.
     * @return BusinessProcessViewItem
     */
    deleteMany(ids: string[]): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/ListItems/Many?";
        if (ids !== undefined)
            ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDeleteMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processDeleteMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Update Many
     * @objects A list of ListItemUpdateRequests.
     * @return BusinessProcessViewItem
     */
    updateMany(objects: ListItemUpdateRequest[]): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/ListItems/Many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objects);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateMany(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMany(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Aggregate
     * @listItemAggregationRequest The list item aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/Service/ListItems/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregate(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Search
     * @listItemSearchRequest The list item search request.
     * @return List item result set.
     */
    search(listItemSearchRequest: ListItemSearchRequest): Observable<BaseResultOfListItem | null> {
        let url_ = this.baseUrl + "/Service/ListItems/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<BaseResultOfListItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BaseResultOfListItem>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<BaseResultOfListItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BaseResultOfListItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseResultOfListItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BaseResultOfListItem | null>(<any>null);
    }

    /**
     * Delete Single
     * @objectId The list item id.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     */
    delete(objectId: string, timeout: number): Observable<void> {
        let url_ = this.baseUrl + "/Service/ListItems/{ObjectId}?";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{ObjectId}", encodeURIComponent("" + objectId)); 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Get Single
     * @listItemId The list item id.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    get(listItemId: string, resolve: boolean, patterns: string[]): Observable<ListItemDetail | null> {
        let url_ = this.baseUrl + "/Service/ListItems/{ListItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{ListItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ListItemDetail | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ListItemDetail | null>(<any>null);
    }

    /**
     * Update Single
     * @listItemId The list item id.
     * @updateRequest The list item update request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    update(listItemId: string, updateRequest: ListItemUpdateRequest, resolve: boolean, timeout: number, patterns: string[]): Observable<ListItemDetail | null> {
        let url_ = this.baseUrl + "/Service/ListItems/{ListItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{ListItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ListItemDetail | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ListItemDetail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ListItemDetail | null>(<any>null);
    }

    /**
     * Wait For States
     * @processId The business process id.
     * @states Comma-separated list of business process states to wait for.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string[], timeout: number): Observable<BusinessProcessWaitResult | null> {
        let url_ = this.baseUrl + "/Service/ListItems/{ProcessId}/Wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processWaitForStates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processWaitForStates(response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessWaitResult>><any>Observable.throw(response_);
        });
    }

    protected processWaitForStates(response: Response): Observable<BusinessProcessWaitResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessWaitResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessWaitResult | null>(<any>null);
    }

    /**
     * Import
     * @contentId The content id.
     * @fileTransferId The file transfer id.
     * @includeObjects Imports list items defined in the json import file.
     */
    import(contentId: string, fileTransferId: string, includeObjects: boolean): Observable<void> {
        let url_ = this.baseUrl + "/Service/ListItems/Import?";
        if (contentId === undefined)
            throw new Error("The parameter 'contentId' must be defined.");
        else
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&"; 
        if (fileTransferId === undefined)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        else
            url_ += "fileTransferId=" + encodeURIComponent("" + fileTransferId) + "&"; 
        if (includeObjects === undefined || includeObjects === null)
            throw new Error("The parameter 'includeObjects' must be defined and cannot be null.");
        else
            url_ += "includeObjects=" + encodeURIComponent("" + includeObjects) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processImport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImport(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processImport(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SchemaService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Single
     * @schemaId The schema id.
     * @return SchemaDetailViewItem
     */
    get(schemaId: string): Observable<SchemaDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SchemaDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SchemaDetailViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: SchemaDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<SchemaDetailViewItem | null>(<any>null);
    }

    /**
     * Update Single
     * @schemaId The schema id.
     * @schema The schema update request.
     * @return BusinessProcessViewItem
     */
    update(schemaId: string, schema: SchemaUpdateRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Delete Single
     * @schemaId The schema id.
     * @return BusinessProcessViewItem
     */
    delete(schemaId: string): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Exists
     * @schemaId The schema id.
     * @fieldId The optional field id.
     * @return ExistsResponse
     */
    exists(schemaId: string, fieldId: string): Observable<ExistsResponse | null> {
        let url_ = this.baseUrl + "/Service/Schemas/{SchemaId}/Exists?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId === undefined)
            throw new Error("The parameter 'fieldId' must be defined.");
        else
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processExists(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExists(response_);
                } catch (e) {
                    return <Observable<ExistsResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExistsResponse>><any>Observable.throw(response_);
        });
    }

    protected processExists(response: Response): Observable<ExistsResponse | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ExistsResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExistsResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ExistsResponse | null>(<any>null);
    }

    /**
     * Create Single
     * @schema The schema create request.
     * @return BusinessProcessViewItem
     */
    create(schema: SchemaCreateRequest): Observable<BusinessProcessViewItem | null> {
        let url_ = this.baseUrl + "/Service/Schemas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<BusinessProcessViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessViewItem>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<BusinessProcessViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BusinessProcessViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BusinessProcessViewItem | null>(<any>null);
    }

    /**
     * Search
     * @schemaSearchRequest The schema search request.
     * @return Schema result set.
     */
    search(schemaSearchRequest: SchemaSearchRequest): Observable<BaseResultOfSchemaViewItem | null> {
        let url_ = this.baseUrl + "/Service/Schemas/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<BaseResultOfSchemaViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BaseResultOfSchemaViewItem>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<BaseResultOfSchemaViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: BaseResultOfSchemaViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseResultOfSchemaViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BaseResultOfSchemaViewItem | null>(<any>null);
    }
}

@Injectable()
export class PermissionService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Search Content Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchContentPermissions(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult | null> {
        let url_ = this.baseUrl + "/Service/Permission/ContentPermissionSets/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchContentPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchContentPermissions(response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchContentPermissions(response: Response): Observable<PermissionSetSearchResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: PermissionSetSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<PermissionSetSearchResult | null>(<any>null);
    }

    /**
     * Get Content Permission Single
     * @permissionSetId The content permission set id.
     * @return ContentPermissionSetDetailViewItem
     */
    getContentPermissions(permissionSetId: string): Observable<ContentPermissionSetDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Permission/ContentPermissionSets/{PermissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{PermissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetContentPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContentPermissions(response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentPermissionSetDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetContentPermissions(response: Response): Observable<ContentPermissionSetDetailViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ContentPermissionSetDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentPermissionSetDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ContentPermissionSetDetailViewItem | null>(<any>null);
    }

    /**
     * Search Schema Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchSchemaPermissions(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult | null> {
        let url_ = this.baseUrl + "/Service/Permission/SchemaPermissionSets/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchSchemaPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchSchemaPermissions(response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchSchemaPermissions(response: Response): Observable<PermissionSetSearchResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: PermissionSetSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<PermissionSetSearchResult | null>(<any>null);
    }

    /**
     * Get Schema Permission Single
     * @permissionSetId The schema permission set id.
     * @return SchemaPermissionSetDetailViewItem
     */
    getSchemaPermissions(permissionSetId: string): Observable<SchemaPermissionSetDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Permission/SchemaPermissionSets/{PermissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{PermissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetSchemaPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSchemaPermissions(response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetSchemaPermissions(response: Response): Observable<SchemaPermissionSetDetailViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: SchemaPermissionSetDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaPermissionSetDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<SchemaPermissionSetDetailViewItem | null>(<any>null);
    }
}

@Injectable()
export class PublicAccessService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getShare(token: string): Observable<ShareBaseDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/PublicAccess/GetShare?";
        if (token === undefined)
            throw new Error("The parameter 'token' must be defined.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetShare(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetShare(response_);
                } catch (e) {
                    return <Observable<ShareBaseDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareBaseDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetShare(response: Response): Observable<ShareBaseDetailViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ShareBaseDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareBaseDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ShareBaseDetailViewItem | null>(<any>null);
    }
}

@Injectable()
export class ShareService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Aggregates own shares
     * @request Aggregation request
     * @return AggregationResult
     */
    aggregate(request: ShareAggregationRequest): Observable<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/Service/Shares/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAggregate(response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: Response): Observable<ObjectAggregationResult | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ObjectAggregationResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Get share by id (basic or embed)
     * @id Share Id (not token, use PublicAccess to get share by token)
     * @return Polymorph share
     */
    get(id: string): Observable<ShareBaseDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Shares/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ShareBaseDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareBaseDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ShareBaseDetailViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ShareBaseDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareBaseDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ShareBaseDetailViewItem | null>(<any>null);
    }

    /**
     * Create a new share (basic or embed).
     * @request Polymorph create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest): Observable<CreateShareResult | null> {
        let url_ = this.baseUrl + "/Service/Shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<CreateShareResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateShareResult>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<CreateShareResult | null> {
        const status = response.status; 

        if (status === 404) {
            const _responseText = response.text();
            let result404: ContentNotFoundException | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result404);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: CreateShareResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateShareResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<CreateShareResult | null>(<any>null);
    }

    /**
     * Search shares
     * @request Search request
     * @return Share search result
     */
    search(request: ContentSearchRequest): Observable<BaseResultOfShareBaseViewItem | null> {
        let url_ = this.baseUrl + "/Service/Shares/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<BaseResultOfShareBaseViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<BaseResultOfShareBaseViewItem>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<BaseResultOfShareBaseViewItem | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BaseResultOfShareBaseViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseResultOfShareBaseViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BaseResultOfShareBaseViewItem | null>(<any>null);
    }
}

@Injectable()
export class TransferService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Cancels an active batch. Valid states: TODO
     */
    cancelBatch(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/Service/Transfers/{TransferId}/Cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCancelBatch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCancelBatch(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCancelBatch(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    create(request: CreateTransferRequest): Observable<TransferViewItem | null> {
        let url_ = this.baseUrl + "/Service/Transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TransferViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferViewItem>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TransferViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TransferViewItem | null>(<any>null);
    }

    delete(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/Service/Transfers/{TransferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }

    get(transferId: string): Observable<TransferDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Transfers/{TransferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TransferDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TransferDetailViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TransferDetailViewItem | null>(<any>null);
    }

    getFile(fileTransferId: string): Observable<FileTransferDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Transfers/Files/{FileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{FileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetFile(response_);
                } catch (e) {
                    return <Observable<FileTransferDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileTransferDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGetFile(response: Response): Observable<FileTransferDetailViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: FileTransferDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<FileTransferDetailViewItem | null>(<any>null);
    }

    importBatch(transferId: string, request: FileTransfer2ContentCreateRequest): Observable<TransferViewItem | null> {
        let url_ = this.baseUrl + "/Service/Transfers/{TransferId}/Import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processImportBatch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImportBatch(response_);
                } catch (e) {
                    return <Observable<TransferViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferViewItem>><any>Observable.throw(response_);
        });
    }

    protected processImportBatch(response: Response): Observable<TransferViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TransferViewItem | null>(<any>null);
    }

    partialImport(transferId: string, request: FileTransferPartial2ContentCreateRequest): Observable<TransferViewItem | null> {
        let url_ = this.baseUrl + "/Service/Transfers/{TransferId}/PartialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processPartialImport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPartialImport(response_);
                } catch (e) {
                    return <Observable<TransferViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferViewItem>><any>Observable.throw(response_);
        });
    }

    protected processPartialImport(response: Response): Observable<TransferViewItem | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TransferViewItem | null>(<any>null);
    }

    search(request: TransferSearchRequest): Observable<TransferSearchResult | null> {
        let url_ = this.baseUrl + "/Service/Transfers/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<TransferSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<TransferSearchResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: TransferSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TransferSearchResult | null>(<any>null);
    }

    searchFiles(request: FileTransferSearchRequest): Observable<FileTransferSearchResult | null> {
        let url_ = this.baseUrl + "/Service/Transfers/Files/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processSearchFiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearchFiles(response_);
                } catch (e) {
                    return <Observable<FileTransferSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileTransferSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchFiles(response: Response): Observable<FileTransferSearchResult | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: FileTransferSearchResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferSearchResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<FileTransferSearchResult | null>(<any>null);
    }

    uploadFile(formFile: FileParameter, flowRelativePath: string, flowChunkNumber: number, flowCurrentChunkSize: number, flowTotalSize: number, flowTotalChunks: number, transferId: string, identifier: string): Observable<void> {
        let url_ = this.baseUrl + "/Service/Transfers/{TransferId}/Files/{Identifier}/Upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{Identifier}", encodeURIComponent("" + identifier)); 
        if (flowRelativePath !== undefined)
            url_ += "FlowRelativePath=" + encodeURIComponent("" + flowRelativePath) + "&"; 
        if (flowChunkNumber === null)
            throw new Error("The parameter 'flowChunkNumber' cannot be null.");
        else if (flowChunkNumber !== undefined)
            url_ += "FlowChunkNumber=" + encodeURIComponent("" + flowChunkNumber) + "&"; 
        if (flowCurrentChunkSize === null)
            throw new Error("The parameter 'flowCurrentChunkSize' cannot be null.");
        else if (flowCurrentChunkSize !== undefined)
            url_ += "FlowCurrentChunkSize=" + encodeURIComponent("" + flowCurrentChunkSize) + "&"; 
        if (flowTotalSize === null)
            throw new Error("The parameter 'flowTotalSize' cannot be null.");
        else if (flowTotalSize !== undefined)
            url_ += "FlowTotalSize=" + encodeURIComponent("" + flowTotalSize) + "&"; 
        if (flowTotalChunks === null)
            throw new Error("The parameter 'flowTotalChunks' cannot be null.");
        else if (flowTotalChunks !== undefined)
            url_ += "FlowTotalChunks=" + encodeURIComponent("" + flowTotalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("FormFile", formFile.data, formFile.fileName ? formFile.fileName : "FormFile");
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processUploadFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUploadFile(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUploadFile(response: Response): Observable<void> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getChannels(): Observable<ChannelViewItem[] | null> {
        let url_ = this.baseUrl + "/Service/Users/Channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGetChannels(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetChannels(response_);
                } catch (e) {
                    return <Observable<ChannelViewItem[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ChannelViewItem[]>><any>Observable.throw(response_);
        });
    }

    protected processGetChannels(response: Response): Observable<ChannelViewItem[] | null> {
        const status = response.status; 

        if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: ChannelViewItem[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChannelViewItem.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ChannelViewItem[] | null>(<any>null);
    }
}

@Injectable()
export class OutputService extends PictureparkServiceBase {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(Http) http: Http, @Optional() @Inject(PICTUREPARK_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Single
     * @outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Observable<OutputDetailViewItem | null> {
        let url_ = this.baseUrl + "/Service/Outputs/{OutputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{OutputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<OutputDetailViewItem>><any>Observable.throw(e);
                }
            } else
                return <Observable<OutputDetailViewItem>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<OutputDetailViewItem | null> {
        const status = response.status; 

        if (status === 404) {
            const _responseText = response.text();
            let result404: OutputNotFoundException | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? OutputNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result404);
        } else if (status === 200) {
            const _responseText = response.text();
            let result200: OutputDetailViewItem | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutputDetailViewItem.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status === 500) {
            const _responseText = response.text();
            let result500: PictureparkException | null = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<OutputDetailViewItem | null>(<any>null);
    }
}

export class ContentAggregationRequest implements IContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IContentAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            if (data["AggregationFilters"] && data["AggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["AggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["Aggregators"] && data["Aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["Aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.channelId = data["ChannelId"];
            this.displayLanguage = data["DisplayLanguage"];
            if (data["SearchLanguages"] && data["SearchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["SearchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["CollectionId"];
            this.lifeCycleFilter = data["LifeCycleFilter"];
        }
    }

    static fromJS(data: any): ContentAggregationRequest {
        let result = new ContentAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["AggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["AggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["Aggregators"] = [];
            for (let item of this.aggregators)
                data["Aggregators"].push(item.toJSON());
        }
        data["ChannelId"] = this.channelId;
        data["DisplayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["SearchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["SearchLanguages"].push(item);
        }
        data["CollectionId"] = this.collectionId;
        data["LifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** The FilterBase is the base class for all filters. */
export class FilterBase implements IFilterBase {

    protected _discriminator: string;

    getDisplayName(locale: string): string | null {
        return null;
    }

    constructor(data?: IFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FilterBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): FilterBase {
        if (data["Kind"] === "AggregationFilter") {
            let result = new AggregationFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "AndFilter") {
            let result = new AndFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OrFilter") {
            let result = new OrFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NotFilter") {
            let result = new NotFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DateRangeFilter") {
            let result = new DateRangeFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ExistsFilter") {
            let result = new ExistsFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "GeoBoundingBoxFilter") {
            let result = new GeoBoundingBoxFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "GeoDistanceFilter") {
            let result = new GeoDistanceFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "GeoDistanceRangeFilter") {
            let result = new GeoDistanceRangeFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NestedFilter") {
            let result = new NestedFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NumericRangeFilter") {
            let result = new NumericRangeFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PrefixFilter") {
            let result = new PrefixFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TermFilter") {
            let result = new TermFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TermsFilter") {
            let result = new TermsFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ChildFilter") {
            let result = new ChildFilter();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ParentFilter") {
            let result = new ParentFilter();
            result.init(data);
            return result;
        }
        let result = new FilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        return data; 
    }
}

/** The FilterBase is the base class for all filters. */
export interface IFilterBase {
}

/** The AndFilter> is a compound filter and returns documents that match all of the specified filters. */
export class AndFilter extends FilterBase implements IAndFilter {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IAndFilter) {
        super(data);
        this._discriminator = "AndFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Filters"] && data["Filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["Filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AndFilter {
        let result = new AndFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["Filters"] = [];
            for (let item of this.filters)
                data["Filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The AndFilter> is a compound filter and returns documents that match all of the specified filters. */
export interface IAndFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export class OrFilter extends FilterBase implements IOrFilter {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IOrFilter) {
        super(data);
        this._discriminator = "OrFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Filters"] && data["Filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["Filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrFilter {
        let result = new OrFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["Filters"] = [];
            for (let item of this.filters)
                data["Filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export interface IOrFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export class NotFilter extends FilterBase implements INotFilter {
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: INotFilter) {
        super(data);
        this._discriminator = "NotFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotFilter {
        let result = new NotFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export interface INotFilter extends IFilterBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export class DateRangeFilter extends FilterBase implements IDateRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange | undefined;

    getDisplayName(locale: string) {
        return this.range && this.range.names ? this.range.names.translate(locale) : "n/a";
    }

    constructor(data?: IDateRangeFilter) {
        super(data);
        this._discriminator = "DateRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.range = data["Range"] ? DateRange.fromJS(data["Range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeFilter {
        let result = new DateRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export interface IDateRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange | undefined;
}

/** The date range class used in aggregators and filters. */
export class DateRange implements IDateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.from = data["From"];
            this.to = data["To"];
        }
    }

    static fromJS(data: any): DateRange {
        let result = new DateRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["From"] = this.from;
        data["To"] = this.to;
        return data; 
    }
}

/** The date range class used in aggregators and filters. */
export interface IDateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** A custom dictionary type to distinguish language specific class properties. */
export class TranslatedStringDictionary implements ITranslatedStringDictionary {

    [key: string]: string | any; 

    translate(locale: string) {
        let language = locale.split("-")[0];
        return this[language] ? this[language] : this[Object.keys(this)[0]];
    }

    constructor(data?: ITranslatedStringDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): TranslatedStringDictionary {
        let result = new TranslatedStringDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

/** A custom dictionary type to distinguish language specific class properties. */
export interface ITranslatedStringDictionary {

    [key: string]: string | any; 
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export class ExistsFilter extends FilterBase implements IExistsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;

    constructor(data?: IExistsFilter) {
        super(data);
        this._discriminator = "ExistsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
        }
    }

    static fromJS(data: any): ExistsFilter {
        let result = new ExistsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        super.toJSON(data);
        return data; 
    }
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export interface IExistsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export class GeoBoundingBoxFilter extends FilterBase implements IGeoBoundingBoxFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation | undefined;

    constructor(data?: IGeoBoundingBoxFilter) {
        super(data);
        this._discriminator = "GeoBoundingBoxFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.topLeft = data["TopLeft"] ? GeoLocation.fromJS(data["TopLeft"]) : <any>undefined;
            this.bottomRight = data["BottomRight"] ? GeoLocation.fromJS(data["BottomRight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeoBoundingBoxFilter {
        let result = new GeoBoundingBoxFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["TopLeft"] = this.topLeft ? this.topLeft.toJSON() : <any>undefined;
        data["BottomRight"] = this.bottomRight ? this.bottomRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export interface IGeoBoundingBoxFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation | undefined;
}

export class GeoLocation implements IGeoLocation {
    lat: number;
    lon: number;

    constructor(data?: IGeoLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["Lat"];
            this.lon = data["Lon"];
        }
    }

    static fromJS(data: any): GeoLocation {
        let result = new GeoLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Lat"] = this.lat;
        data["Lon"] = this.lon;
        return data; 
    }
}

export interface IGeoLocation {
    lat: number;
    lon: number;
}

/** The GeoDistanceRangeFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export class GeoDistanceFilter extends FilterBase implements IGeoDistanceFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;

    constructor(data?: IGeoDistanceFilter) {
        super(data);
        this._discriminator = "GeoDistanceFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.location = data["Location"] ? GeoLocation.fromJS(data["Location"]) : <any>undefined;
            this.distance = data["Distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["Distance"] = this.distance;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceRangeFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export interface IGeoDistanceFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;
}

/** The GeoDistanceRangeFilter returns documents that exists within a range from a specific point. */
export class GeoDistanceRangeFilter extends FilterBase implements IGeoDistanceRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The numeric range. */
    range?: NumericRange | undefined;

    constructor(data?: IGeoDistanceRangeFilter) {
        super(data);
        this._discriminator = "GeoDistanceRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.location = data["Location"] ? GeoLocation.fromJS(data["Location"]) : <any>undefined;
            this.range = data["Range"] ? NumericRange.fromJS(data["Range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeoDistanceRangeFilter {
        let result = new GeoDistanceRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["Range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceRangeFilter returns documents that exists within a range from a specific point. */
export interface IGeoDistanceRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The numeric range. */
    range?: NumericRange | undefined;
}

export class NumericRange implements INumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.from = data["From"];
            this.to = data["To"];
        }
    }

    static fromJS(data: any): NumericRange {
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["From"] = this.from;
        data["To"] = this.to;
        return data; 
    }
}

export interface INumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export class NestedFilter extends FilterBase implements INestedFilter {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: INestedFilter) {
        super(data);
        this._discriminator = "NestedFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["Path"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NestedFilter {
        let result = new NestedFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Path"] = this.path;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export interface INestedFilter extends IFilterBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export class NumericRangeFilter extends FilterBase implements INumericRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: NumericRange | undefined;

    constructor(data?: INumericRangeFilter) {
        super(data);
        this._discriminator = "NumericRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.range = data["Range"] ? NumericRange.fromJS(data["Range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NumericRangeFilter {
        let result = new NumericRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export interface INumericRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: NumericRange | undefined;
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export class PrefixFilter extends FilterBase implements IPrefixFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;

    constructor(data?: IPrefixFilter) {
        super(data);
        this._discriminator = "PrefixFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.prefix = data["Prefix"];
        }
    }

    static fromJS(data: any): PrefixFilter {
        let result = new PrefixFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Prefix"] = this.prefix;
        super.toJSON(data);
        return data; 
    }
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export interface IPrefixFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export class TermFilter extends FilterBase implements ITermFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;

    constructor(data?: ITermFilter) {
        super(data);
        this._discriminator = "TermFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.term = data["Term"];
        }
    }

    static fromJS(data: any): TermFilter {
        let result = new TermFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Term"] = this.term;
        super.toJSON(data);
        return data; 
    }
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export interface ITermFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export class TermsFilter extends FilterBase implements ITermsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;

    constructor(data?: ITermsFilter) {
        super(data);
        this._discriminator = "TermsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            if (data["Terms"] && data["Terms"].constructor === Array) {
                this.terms = [];
                for (let item of data["Terms"])
                    this.terms.push(item);
            }
        }
    }

    static fromJS(data: any): TermsFilter {
        let result = new TermsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        if (this.terms && this.terms.constructor === Array) {
            data["Terms"] = [];
            for (let item of this.terms)
                data["Terms"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export interface ITermsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export class AggregationFilter extends FilterBase implements IAggregationFilter {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceRangeFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;

    constructor(data?: IAggregationFilter) {
        super(data);
        this._discriminator = "AggregationFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregationName = data["AggregationName"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            this.temporaryAggregatorRequestId = data["TemporaryAggregatorRequestId"];
        }
    }

    static fromJS(data: any): AggregationFilter {
        let result = new AggregationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AggregationName"] = this.aggregationName;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["TemporaryAggregatorRequestId"] = this.temporaryAggregatorRequestId;
        super.toJSON(data);
        return data; 
    }
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export interface IAggregationFilter extends IFilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceRangeFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export class ChildFilter extends FilterBase implements IChildFilter {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;

    constructor(data?: IChildFilter) {
        super(data);
        this._discriminator = "ChildFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.childType = data["ChildType"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChildFilter {
        let result = new ChildFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ChildType"] = this.childType;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export interface IChildFilter extends IFilterBase {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export class ParentFilter extends FilterBase implements IParentFilter {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;

    constructor(data?: IParentFilter) {
        super(data);
        this._discriminator = "ParentFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentType = data["ParentType"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParentFilter {
        let result = new ParentFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ParentType"] = this.parentType;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export interface IParentFilter extends IFilterBase {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

/** The AggregatorBase is the base class for all aggregators. */
export class AggregatorBase implements IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;

    protected _discriminator: string;

    constructor(data?: IAggregatorBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AggregatorBase";
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            if (data["Aggregators"] && data["Aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["Aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregatorBase {
        if (data["Kind"] === "DateRangeAggregator") {
            let result = new DateRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FilterAggregator") {
            let result = new FilterAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "GeoDistanceAggregator") {
            let result = new GeoDistanceAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NestedAggregator") {
            let result = new NestedAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NumericRangeAggregator") {
            let result = new NumericRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TermsAggregator") {
            let result = new TermsAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new AggregatorBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Name"] = this.name;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["Aggregators"] = [];
            for (let item of this.aggregators)
                data["Aggregators"].push(item.toJSON());
        }
        return data; 
    }
}

/** The AggregatorBase is the base class for all aggregators. */
export interface IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export class DateRangeAggregator extends AggregatorBase implements IDateRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRange[] | undefined;

    constructor(data?: IDateRangeAggregator) {
        super(data);
        this._discriminator = "DateRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            if (data["Ranges"] && data["Ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["Ranges"])
                    this.ranges.push(DateRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateRangeAggregator {
        let result = new DateRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["Ranges"] = [];
            for (let item of this.ranges)
                data["Ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export interface IDateRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRange[] | undefined;
}

/** The FilterAggregator is a single bucket aggregation of documents that match a specified filter. */
export class FilterAggregator extends AggregatorBase implements IFilterAggregator {
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFilterAggregator) {
        super(data);
        this._discriminator = "FilterAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FilterAggregator {
        let result = new FilterAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The FilterAggregator is a single bucket aggregation of documents that match a specified filter. */
export interface IFilterAggregator extends IAggregatorBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export class GeoDistanceAggregator extends AggregatorBase implements IGeoDistanceAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: NumericRange[] | undefined;

    constructor(data?: IGeoDistanceAggregator) {
        super(data);
        this._discriminator = "GeoDistanceAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.location = data["Location"] ? GeoLocation.fromJS(data["Location"]) : <any>undefined;
            if (data["Ranges"] && data["Ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["Ranges"])
                    this.ranges.push(NumericRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeoDistanceAggregator {
        let result = new GeoDistanceAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (this.ranges && this.ranges.constructor === Array) {
            data["Ranges"] = [];
            for (let item of this.ranges)
                data["Ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export interface IGeoDistanceAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: NumericRange[] | undefined;
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export class NestedAggregator extends AggregatorBase implements INestedAggregator {
    /** The path pointing to the nested object. */
    path?: string | undefined;

    constructor(data?: INestedAggregator) {
        super(data);
        this._discriminator = "NestedAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["Path"];
        }
    }

    static fromJS(data: any): NestedAggregator {
        let result = new NestedAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Path"] = this.path;
        super.toJSON(data);
        return data; 
    }
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export interface INestedAggregator extends IAggregatorBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export class NumericRangeAggregator extends AggregatorBase implements INumericRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: NumericRange[] | undefined;

    constructor(data?: INumericRangeAggregator) {
        super(data);
        this._discriminator = "NumericRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            if (data["Ranges"] && data["Ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["Ranges"])
                    this.ranges.push(NumericRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NumericRangeAggregator {
        let result = new NumericRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["Ranges"] = [];
            for (let item of this.ranges)
                data["Ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export interface INumericRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: NumericRange[] | undefined;
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export class TermsAggregator extends AggregatorBase implements ITermsAggregator {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;

    constructor(data?: ITermsAggregator) {
        super(data);
        this._discriminator = "TermsAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["Field"];
            this.size = data["Size"];
            if (data["Includes"] && data["Includes"].constructor === Array) {
                this.includes = [];
                for (let item of data["Includes"])
                    this.includes.push(item);
            }
            if (data["Excludes"] && data["Excludes"].constructor === Array) {
                this.excludes = [];
                for (let item of data["Excludes"])
                    this.excludes.push(item);
            }
        }
    }

    static fromJS(data: any): TermsAggregator {
        if (data["Kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new TermsAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Size"] = this.size;
        if (this.includes && this.includes.constructor === Array) {
            data["Includes"] = [];
            for (let item of this.includes)
                data["Includes"].push(item);
        }
        if (this.excludes && this.excludes.constructor === Array) {
            data["Excludes"] = [];
            for (let item of this.excludes)
                data["Excludes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export interface ITermsAggregator extends IAggregatorBase {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export class TermsRelationAggregator extends TermsAggregator implements ITermsRelationAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;

    constructor(data?: ITermsRelationAggregator) {
        super(data);
        this._discriminator = "TermsRelationAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentType = data["DocumentType"];
        }
    }

    static fromJS(data: any): TermsRelationAggregator {
        let result = new TermsRelationAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocumentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export interface ITermsRelationAggregator extends ITermsAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    Schema = <any>"Schema", 
    User = <any>"User", 
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export class TermsEnumAggregator extends TermsAggregator implements ITermsEnumAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;

    constructor(data?: ITermsEnumAggregator) {
        super(data);
        this._discriminator = "TermsEnumAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.enumType = data["EnumType"];
        }
    }

    static fromJS(data: any): TermsEnumAggregator {
        let result = new TermsEnumAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EnumType"] = this.enumType;
        super.toJSON(data);
        return data; 
    }
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export interface ITermsEnumAggregator extends ITermsAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly", 
    All = <any>"All", 
    InactiveOnly = <any>"InactiveOnly", 
}

export class ObjectAggregationResult implements IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: IObjectAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.elapsedMilliseconds = data["ElapsedMilliseconds"];
            if (data["AggregationResults"] && data["AggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["AggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectAggregationResult {
        let result = new ObjectAggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ElapsedMilliseconds"] = this.elapsedMilliseconds;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["AggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["AggregationResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[] | undefined;
}

export class AggregationResult implements IAggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: AggregationResultItem[] | undefined;

    constructor(data?: IAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.sumOtherDocCount = data["SumOtherDocCount"];
            this.temporaryRequestId = data["TemporaryRequestId"];
            if (data["AggregationResultItems"] && data["AggregationResultItems"].constructor === Array) {
                this.aggregationResultItems = [];
                for (let item of data["AggregationResultItems"])
                    this.aggregationResultItems.push(AggregationResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResult {
        let result = new AggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["SumOtherDocCount"] = this.sumOtherDocCount;
        data["TemporaryRequestId"] = this.temporaryRequestId;
        if (this.aggregationResultItems && this.aggregationResultItems.constructor === Array) {
            data["AggregationResultItems"] = [];
            for (let item of this.aggregationResultItems)
                data["AggregationResultItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: AggregationResultItem[] | undefined;
}

export class AggregationResultItem implements IAggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: AggregationResult[] | undefined;

    getDisplayName(locale: string) {
      let displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null; 
      return displayName ? displayName : this.name;
    }

    constructor(data?: IAggregationResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.count = data["Count"];
            this.filter = data["Filter"] ? AggregationFilter.fromJS(data["Filter"]) : <any>undefined;
            this.active = data["Active"];
            if (data["AggregationResults"] && data["AggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["AggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResultItem {
        let result = new AggregationResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Count"] = this.count;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["Active"] = this.active;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["AggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["AggregationResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: AggregationResult[] | undefined;
}

export class Exception implements IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["Message"];
            this.innerException = data["InnerException"] ? Exception.fromJS(data["InnerException"]) : <any>undefined;
            this.stackTrace = data["StackTrace"];
            this.source = data["Source"];
        }
    }

    static fromJS(data: any): Exception {
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Source"] = this.source;
        return data; 
    }
}

export interface IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;

    protected _discriminator: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this._discriminator = "PictureparkException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.traceLevel = data["TraceLevel"];
            this.traceId = data["TraceId"];
            this.traceJobId = data["TraceJobId"];
            this.httpStatusCode = data["HttpStatusCode"];
        }
    }

    static fromJS(data: any): PictureparkException {
        if (data["Kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PermissionException") {
            let result = new PermissionException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DocumentNotFoundException") {
            let result = new DocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DriveRequestException") {
            let result = new DriveRequestException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidCustomerException") {
            let result = new InvalidCustomerException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkInvalidMetadataException") {
            let result = new PictureparkInvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidUserOrPasswordException") {
            let result = new InvalidUserOrPasswordException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkMappingException") {
            let result = new PictureparkMappingException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "MessagePerformerTaskCanceledException") {
            let result = new MessagePerformerTaskCanceledException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NotFoundException") {
            let result = new NotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OperationTimeoutException") {
            let result = new OperationTimeoutException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "RenderingJobItemNotSetException") {
            let result = new RenderingJobItemNotSetException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TokenValidationException") {
            let result = new TokenValidationException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserPermanentlyRemovedException") {
            let result = new UserPermanentlyRemovedException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserRolesRightsAssignedException") {
            let result = new UserRolesRightsAssignedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["TraceLevel"] = this.traceLevel;
        data["TraceId"] = this.traceId;
        data["TraceJobId"] = this.traceJobId;
        data["HttpStatusCode"] = this.httpStatusCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkException extends IException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;
}

export enum TraceLevel {
    Critical = <any>"Critical", 
    Error = <any>"Error", 
    Warning = <any>"Warning", 
    Information = <any>"Information", 
    Verbose = <any>"Verbose", 
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this._discriminator = "PictureparkBusinessException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["CustomerId"];
            this.customerAlias = data["CustomerAlias"];
            this.userId = data["UserId"];
        }
    }

    static fromJS(data: any): PictureparkBusinessException {
        if (data["Kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PermissionException") {
            let result = new PermissionException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DocumentNotFoundException") {
            let result = new DocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DriveRequestException") {
            let result = new DriveRequestException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkInvalidMetadataException") {
            let result = new PictureparkInvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkMappingException") {
            let result = new PictureparkMappingException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NotFoundException") {
            let result = new NotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OperationTimeoutException") {
            let result = new OperationTimeoutException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "RenderingJobItemNotSetException") {
            let result = new RenderingJobItemNotSetException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "TokenValidationException") {
            let result = new TokenValidationException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserPermanentlyRemovedException") {
            let result = new UserPermanentlyRemovedException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "UserRolesRightsAssignedException") {
            let result = new UserRolesRightsAssignedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["CustomerAlias"] = this.customerAlias;
        data["UserId"] = this.userId;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export class PictureparkApplicationException extends PictureparkBusinessException implements IPictureparkApplicationException {

    constructor(data?: IPictureparkApplicationException) {
        super(data);
        this._discriminator = "PictureparkApplicationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkApplicationException {
        let result = new PictureparkApplicationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkApplicationException extends IPictureparkBusinessException {
}

export class PictureparkArgumentNullException extends PictureparkBusinessException implements IPictureparkArgumentNullException {
    argumentName?: string | undefined;

    constructor(data?: IPictureparkArgumentNullException) {
        super(data);
        this._discriminator = "PictureparkArgumentNullException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["ArgumentName"];
        }
    }

    static fromJS(data: any): PictureparkArgumentNullException {
        let result = new PictureparkArgumentNullException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArgumentName"] = this.argumentName;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkArgumentNullException extends IPictureparkBusinessException {
    argumentName?: string | undefined;
}

export class ContentNotFoundException extends PictureparkBusinessException implements IContentNotFoundException {
    contentId?: string | undefined;

    constructor(data?: IContentNotFoundException) {
        super(data);
        this._discriminator = "ContentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["ContentId"];
        }
    }

    static fromJS(data: any): ContentNotFoundException {
        let result = new ContentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
}

export class BusinessProcessDefinitionCreateException extends PictureparkBusinessException implements IBusinessProcessDefinitionCreateException {
    processDefinitionIds?: string[] | undefined;

    constructor(data?: IBusinessProcessDefinitionCreateException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ProcessDefinitionIds"] && data["ProcessDefinitionIds"].constructor === Array) {
                this.processDefinitionIds = [];
                for (let item of data["ProcessDefinitionIds"])
                    this.processDefinitionIds.push(item);
            }
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionCreateException {
        let result = new BusinessProcessDefinitionCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.processDefinitionIds && this.processDefinitionIds.constructor === Array) {
            data["ProcessDefinitionIds"] = [];
            for (let item of this.processDefinitionIds)
                data["ProcessDefinitionIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionCreateException extends IPictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export class BusinessProcessDefinitionNotFoundException extends PictureparkBusinessException implements IBusinessProcessDefinitionNotFoundException {
    processDefinitionId?: string | undefined;

    constructor(data?: IBusinessProcessDefinitionNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.processDefinitionId = data["ProcessDefinitionId"];
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        let result = new BusinessProcessDefinitionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProcessDefinitionId"] = this.processDefinitionId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionNotFoundException extends IPictureparkBusinessException {
    processDefinitionId?: string | undefined;
}

export class BusinessProcessNotFoundException extends PictureparkBusinessException implements IBusinessProcessNotFoundException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["BusinessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcessNotFoundException {
        let result = new BusinessProcessNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BusinessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessNotFoundException extends IPictureparkBusinessException {
    businessProcessId?: string | undefined;
}

export class CustomerHostNotFoundException extends PictureparkException implements ICustomerHostNotFoundException {
    hostName?: string | undefined;

    constructor(data?: ICustomerHostNotFoundException) {
        super(data);
        this._discriminator = "CustomerHostNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.hostName = data["HostName"];
        }
    }

    static fromJS(data: any): CustomerHostNotFoundException {
        let result = new CustomerHostNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HostName"] = this.hostName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerHostNotFoundException extends IPictureparkException {
    hostName?: string | undefined;
}

export class CustomerNotFoundException extends PictureparkException implements ICustomerNotFoundException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotFoundException) {
        super(data);
        this._discriminator = "CustomerNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["CustomerId"];
        }
    }

    static fromJS(data: any): CustomerNotFoundException {
        let result = new CustomerNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerNotFoundException extends IPictureparkException {
    customerId?: string | undefined;
}

export class DocumentNotFoundException extends PictureparkBusinessException implements IDocumentNotFoundException {
    documentId?: string | undefined;

    constructor(data?: IDocumentNotFoundException) {
        super(data);
        this._discriminator = "DocumentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["DocumentId"];
        }
    }

    static fromJS(data: any): DocumentNotFoundException {
        let result = new DocumentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocumentId"] = this.documentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentNotFoundException extends IPictureparkBusinessException {
    documentId?: string | undefined;
}

export class DocumentVersionNotFoundException extends PictureparkBusinessException implements IDocumentVersionNotFoundException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;

    constructor(data?: IDocumentVersionNotFoundException) {
        super(data);
        this._discriminator = "DocumentVersionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["DocumentId"];
            this.documentVersion = data["DocumentVersion"];
        }
    }

    static fromJS(data: any): DocumentVersionNotFoundException {
        let result = new DocumentVersionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocumentId"] = this.documentId;
        data["DocumentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentVersionNotFoundException extends IPictureparkBusinessException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export class DriveRequestException extends PictureparkBusinessException implements IDriveRequestException {

    constructor(data?: IDriveRequestException) {
        super(data);
        this._discriminator = "DriveRequestException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DriveRequestException {
        let result = new DriveRequestException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDriveRequestException extends IPictureparkBusinessException {
}

export class DuplicateRightException extends PictureparkBusinessException implements IDuplicateRightException {
    permissionSetId?: string | undefined;

    constructor(data?: IDuplicateRightException) {
        super(data);
        this._discriminator = "DuplicateRightException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permissionSetId = data["PermissionSetId"];
        }
    }

    static fromJS(data: any): DuplicateRightException {
        let result = new DuplicateRightException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PermissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateRightException extends IPictureparkBusinessException {
    permissionSetId?: string | undefined;
}

export class DuplicateDocumentException extends PictureparkBusinessException implements IDuplicateDocumentException {
    documentId?: string | undefined;
    documentType?: string | undefined;

    constructor(data?: IDuplicateDocumentException) {
        super(data);
        this._discriminator = "DuplicateDocumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["DocumentId"];
            this.documentType = data["DocumentType"];
        }
    }

    static fromJS(data: any): DuplicateDocumentException {
        let result = new DuplicateDocumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocumentId"] = this.documentId;
        data["DocumentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateDocumentException extends IPictureparkBusinessException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export class DuplicateAggregatorException extends PictureparkBusinessException implements IDuplicateAggregatorException {
    aggregatorName?: string | undefined;

    constructor(data?: IDuplicateAggregatorException) {
        super(data);
        this._discriminator = "DuplicateAggregatorException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregatorName = data["AggregatorName"];
        }
    }

    static fromJS(data: any): DuplicateAggregatorException {
        let result = new DuplicateAggregatorException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateAggregatorException extends IPictureparkBusinessException {
    aggregatorName?: string | undefined;
}

export class FailedToLockException extends PictureparkBusinessException implements IFailedToLockException {
    resourceId?: string | undefined;

    constructor(data?: IFailedToLockException) {
        super(data);
        this._discriminator = "FailedToLockException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["ResourceId"];
        }
    }

    static fromJS(data: any): FailedToLockException {
        let result = new FailedToLockException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResourceId"] = this.resourceId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFailedToLockException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class IndexException extends PictureparkBusinessException implements IIndexException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexException) {
        super(data);
        this._discriminator = "IndexException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["IndexName"];
            this.debugInformation = data["DebugInformation"];
        }
    }

    static fromJS(data: any): IndexException {
        let result = new IndexException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IndexName"] = this.indexName;
        data["DebugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class InvalidArgumentException extends PictureparkBusinessException implements IInvalidArgumentException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;

    constructor(data?: IInvalidArgumentException) {
        super(data);
        this._discriminator = "InvalidArgumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["ArgumentName"];
            this.argumentValue = data["ArgumentValue"];
        }
    }

    static fromJS(data: any): InvalidArgumentException {
        let result = new InvalidArgumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArgumentName"] = this.argumentName;
        data["ArgumentValue"] = this.argumentValue;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidArgumentException extends IPictureparkBusinessException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export class InvalidCustomerException extends PictureparkException implements IInvalidCustomerException {
    customerId?: string | undefined;

    constructor(data?: IInvalidCustomerException) {
        super(data);
        this._discriminator = "InvalidCustomerException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["CustomerId"];
        }
    }

    static fromJS(data: any): InvalidCustomerException {
        let result = new InvalidCustomerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidCustomerException extends IPictureparkException {
    customerId?: string | undefined;
}

export class PictureparkInvalidMetadataException extends PictureparkBusinessException implements IPictureparkInvalidMetadataException {
    metadataErrors?: MetadataError[] | undefined;

    constructor(data?: IPictureparkInvalidMetadataException) {
        super(data);
        this._discriminator = "PictureparkInvalidMetadataException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["MetadataErrors"] && data["MetadataErrors"].constructor === Array) {
                this.metadataErrors = [];
                for (let item of data["MetadataErrors"])
                    this.metadataErrors.push(MetadataError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PictureparkInvalidMetadataException {
        let result = new PictureparkInvalidMetadataException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.metadataErrors && this.metadataErrors.constructor === Array) {
            data["MetadataErrors"] = [];
            for (let item of this.metadataErrors)
                data["MetadataErrors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkInvalidMetadataException extends IPictureparkBusinessException {
    metadataErrors?: MetadataError[] | undefined;
}

export class MetadataError implements IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IMetadataError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorType = data["ErrorType"];
            this.lineNumber = data["LineNumber"];
            this.linePosition = data["LinePosition"];
            this.path = data["Path"];
            this.message = data["Message"];
            this.schemaId = data["SchemaId"];
        }
    }

    static fromJS(data: any): MetadataError {
        let result = new MetadataError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ErrorType"] = this.errorType;
        data["LineNumber"] = this.lineNumber;
        data["LinePosition"] = this.linePosition;
        data["Path"] = this.path;
        data["Message"] = this.message;
        data["SchemaId"] = this.schemaId;
        return data; 
    }
}

export interface IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidStateException extends PictureparkBusinessException implements IInvalidStateException {
    resourceId?: string | undefined;
    state?: string | undefined;

    constructor(data?: IInvalidStateException) {
        super(data);
        this._discriminator = "InvalidStateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["ResourceId"];
            this.state = data["State"];
        }
    }

    static fromJS(data: any): InvalidStateException {
        if (data["Kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        let result = new InvalidStateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResourceId"] = this.resourceId;
        data["State"] = this.state;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export class InvalidStateTransitionException extends InvalidStateException implements IInvalidStateTransitionException {
    transition?: string | undefined;

    constructor(data?: IInvalidStateTransitionException) {
        super(data);
        this._discriminator = "InvalidStateTransitionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transition = data["Transition"];
        }
    }

    static fromJS(data: any): InvalidStateTransitionException {
        let result = new InvalidStateTransitionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Transition"] = this.transition;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateTransitionException extends IInvalidStateException {
    transition?: string | undefined;
}

export class InvalidUserOrPasswordException extends PictureparkException implements IInvalidUserOrPasswordException {
    customerId?: string | undefined;

    constructor(data?: IInvalidUserOrPasswordException) {
        super(data);
        this._discriminator = "InvalidUserOrPasswordException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["CustomerId"];
        }
    }

    static fromJS(data: any): InvalidUserOrPasswordException {
        let result = new InvalidUserOrPasswordException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidUserOrPasswordException extends IPictureparkException {
    customerId?: string | undefined;
}

export class PictureparkMappingException extends PictureparkBusinessException implements IPictureparkMappingException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IPictureparkMappingException) {
        super(data);
        this._discriminator = "PictureparkMappingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["IndexName"];
            this.debugInformation = data["DebugInformation"];
        }
    }

    static fromJS(data: any): PictureparkMappingException {
        let result = new PictureparkMappingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IndexName"] = this.indexName;
        data["DebugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkMappingException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class MessagePerformerTaskCanceledException extends PictureparkException implements IMessagePerformerTaskCanceledException {
    messageId?: string | undefined;
    customerId?: string | undefined;

    constructor(data?: IMessagePerformerTaskCanceledException) {
        super(data);
        this._discriminator = "MessagePerformerTaskCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.messageId = data["MessageId"];
            this.customerId = data["CustomerId"];
        }
    }

    static fromJS(data: any): MessagePerformerTaskCanceledException {
        let result = new MessagePerformerTaskCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MessageId"] = this.messageId;
        data["CustomerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IMessagePerformerTaskCanceledException extends IPictureparkException {
    messageId?: string | undefined;
    customerId?: string | undefined;
}

export class NotFoundException extends PictureparkBusinessException implements INotFoundException {
    reference?: string | undefined;

    constructor(data?: INotFoundException) {
        super(data);
        this._discriminator = "NotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.reference = data["Reference"];
        }
    }

    static fromJS(data: any): NotFoundException {
        let result = new NotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Reference"] = this.reference;
        super.toJSON(data);
        return data; 
    }
}

export interface INotFoundException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class ObjectStoreException extends PictureparkBusinessException implements IObjectStoreException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreException) {
        super(data);
        this._discriminator = "ObjectStoreException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["RowErrorMessages"];
            this.errorMessage = data["ErrorMessage"];
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): ObjectStoreException {
        let result = new ObjectStoreException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowErrorMessages"] = this.rowErrorMessages;
        data["ErrorMessage"] = this.errorMessage;
        data["Message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
    message?: string | undefined;
}

export class ObjectStoreResponseException extends PictureparkBusinessException implements IObjectStoreResponseException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreResponseException) {
        super(data);
        this._discriminator = "ObjectStoreResponseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["RowErrorMessages"];
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): ObjectStoreResponseException {
        let result = new ObjectStoreResponseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RowErrorMessages"] = this.rowErrorMessages;
        data["Message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreResponseException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export class PictureparkOperationCanceledException extends PictureparkBusinessException implements IPictureparkOperationCanceledException {
    cancellationToken?: string | undefined;

    constructor(data?: IPictureparkOperationCanceledException) {
        super(data);
        this._discriminator = "PictureparkOperationCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.cancellationToken = data["CancellationToken"];
        }
    }

    static fromJS(data: any): PictureparkOperationCanceledException {
        let result = new PictureparkOperationCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CancellationToken"] = this.cancellationToken;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkOperationCanceledException extends IPictureparkBusinessException {
    cancellationToken?: string | undefined;
}

export class OperationTimeoutException extends PictureparkBusinessException implements IOperationTimeoutException {
    messageId?: string | undefined;

    constructor(data?: IOperationTimeoutException) {
        super(data);
        this._discriminator = "OperationTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.messageId = data["MessageId"];
        }
    }

    static fromJS(data: any): OperationTimeoutException {
        let result = new OperationTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MessageId"] = this.messageId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOperationTimeoutException extends IPictureparkBusinessException {
    messageId?: string | undefined;
}

export class OutputNotFoundException extends PictureparkBusinessException implements IOutputNotFoundException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputNotFoundException) {
        super(data);
        this._discriminator = "OutputNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["ContentId"];
            this.outputFormatId = data["OutputFormatId"];
        }
    }

    static fromJS(data: any): OutputNotFoundException {
        let result = new OutputNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        data["OutputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class PermissionException extends PictureparkBusinessException implements IPermissionException {
    permission?: string | undefined;
    operation?: string | undefined;

    constructor(data?: IPermissionException) {
        super(data);
        this._discriminator = "PermissionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permission = data["Permission"];
            this.operation = data["Operation"];
        }
    }

    static fromJS(data: any): PermissionException {
        let result = new PermissionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Permission"] = this.permission;
        data["Operation"] = this.operation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionException extends IPictureparkBusinessException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export class QueryException extends PictureparkBusinessException implements IQueryException {
    debugInformation?: string | undefined;

    constructor(data?: IQueryException) {
        super(data);
        this._discriminator = "QueryException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.debugInformation = data["DebugInformation"];
        }
    }

    static fromJS(data: any): QueryException {
        let result = new QueryException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DebugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IQueryException extends IPictureparkBusinessException {
    debugInformation?: string | undefined;
}

export class RenderingException extends PictureparkBusinessException implements IRenderingException {

    constructor(data?: IRenderingException) {
        super(data);
        this._discriminator = "RenderingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingException {
        let result = new RenderingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingException extends IPictureparkBusinessException {
}

export class RenderingJobItemNotSetException extends PictureparkBusinessException implements IRenderingJobItemNotSetException {

    constructor(data?: IRenderingJobItemNotSetException) {
        super(data);
        this._discriminator = "RenderingJobItemNotSetException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingJobItemNotSetException {
        let result = new RenderingJobItemNotSetException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingJobItemNotSetException extends IPictureparkBusinessException {
}

export class ServiceProviderCreateException extends PictureparkException implements IServiceProviderCreateException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderCreateException) {
        super(data);
        this._discriminator = "ServiceProviderCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userId = data["UserId"];
            this.externalId = data["ExternalId"];
            this.virtualHost = data["VirtualHost"];
            this.detailErrorMessage = data["DetailErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderCreateException {
        let result = new ServiceProviderCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["ExternalId"] = this.externalId;
        data["VirtualHost"] = this.virtualHost;
        data["DetailErrorMessage"] = this.detailErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderCreateException extends IPictureparkException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export class ServiceProviderDeleteException extends PictureparkException implements IServiceProviderDeleteException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderDeleteException) {
        super(data);
        this._discriminator = "ServiceProviderDeleteException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serviceProviderId = data["ServiceProviderId"];
            this.detailedErrorMessage = data["DetailedErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderDeleteException {
        let result = new ServiceProviderDeleteException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ServiceProviderId"] = this.serviceProviderId;
        data["DetailedErrorMessage"] = this.detailedErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderDeleteException extends IPictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export class ServiceProviderNotFoundException extends PictureparkException implements IServiceProviderNotFoundException {
    missingServiceProviderId?: string | undefined;

    constructor(data?: IServiceProviderNotFoundException) {
        super(data);
        this._discriminator = "ServiceProviderNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingServiceProviderId = data["MissingServiceProviderId"];
        }
    }

    static fromJS(data: any): ServiceProviderNotFoundException {
        let result = new ServiceProviderNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MissingServiceProviderId"] = this.missingServiceProviderId;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderNotFoundException extends IPictureparkException {
    missingServiceProviderId?: string | undefined;
}

export class TokenValidationException extends PictureparkBusinessException implements ITokenValidationException {

    constructor(data?: ITokenValidationException) {
        super(data);
        this._discriminator = "TokenValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TokenValidationException {
        let result = new TokenValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITokenValidationException extends IPictureparkBusinessException {
}

export class UnknownException extends PictureparkBusinessException implements IUnknownException {
    exceptionDetail?: string | undefined;

    constructor(data?: IUnknownException) {
        super(data);
        this._discriminator = "UnknownException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.exceptionDetail = data["ExceptionDetail"];
        }
    }

    static fromJS(data: any): UnknownException {
        let result = new UnknownException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ExceptionDetail"] = this.exceptionDetail;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnknownException extends IPictureparkBusinessException {
    exceptionDetail?: string | undefined;
}

export class UserNotFoundException extends PictureparkBusinessException implements IUserNotFoundException {
    missingUserId?: string | undefined;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this._discriminator = "UserNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingUserId = data["MissingUserId"];
        }
    }

    static fromJS(data: any): UserNotFoundException {
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MissingUserId"] = this.missingUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserNotFoundException extends IPictureparkBusinessException {
    missingUserId?: string | undefined;
}

export class UserPermanentlyRemovedException extends PictureparkBusinessException implements IUserPermanentlyRemovedException {
    removedUserId?: string | undefined;

    constructor(data?: IUserPermanentlyRemovedException) {
        super(data);
        this._discriminator = "UserPermanentlyRemovedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.removedUserId = data["RemovedUserId"];
        }
    }

    static fromJS(data: any): UserPermanentlyRemovedException {
        let result = new UserPermanentlyRemovedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RemovedUserId"] = this.removedUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserPermanentlyRemovedException extends IPictureparkBusinessException {
    removedUserId?: string | undefined;
}

export class UserRoleAssignedException extends PictureparkBusinessException implements IUserRoleAssignedException {
    userRoleId?: string | undefined;

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this._discriminator = "UserRoleAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userRoleId = data["UserRoleId"];
        }
    }

    static fromJS(data: any): UserRoleAssignedException {
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRoleAssignedException extends IPictureparkBusinessException {
    userRoleId?: string | undefined;
}

export class UserRolesRightsAssignedException extends PictureparkBusinessException implements IUserRolesRightsAssignedException {
    contentPermissionSetId?: string | undefined;

    constructor(data?: IUserRolesRightsAssignedException) {
        super(data);
        this._discriminator = "UserRolesRightsAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentPermissionSetId = data["ContentPermissionSetId"];
        }
    }

    static fromJS(data: any): UserRolesRightsAssignedException {
        let result = new UserRolesRightsAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentPermissionSetId"] = this.contentPermissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRolesRightsAssignedException extends IPictureparkBusinessException {
    contentPermissionSetId?: string | undefined;
}

export class ContentBatchDownloadRequest implements IContentBatchDownloadRequest {
    contents?: Content[] | undefined;

    constructor(data?: IContentBatchDownloadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Contents"] && data["Contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["Contents"])
                    this.contents.push(Content.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentBatchDownloadRequest {
        let result = new ContentBatchDownloadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contents && this.contents.constructor === Array) {
            data["Contents"] = [];
            for (let item of this.contents)
                data["Contents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContentBatchDownloadRequest {
    contents?: Content[] | undefined;
}

export class Content implements IContent {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["ContentId"];
            this.outputFormatId = data["OutputFormatId"];
        }
    }

    static fromJS(data: any): Content {
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        data["OutputFormatId"] = this.outputFormatId;
        return data; 
    }
}

export interface IContent {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class DownloadItem implements IDownloadItem {

    constructor(data?: IDownloadItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): DownloadItem {
        let result = new DownloadItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IDownloadItem {
}

export class ContentBatchDownloadItem extends DownloadItem implements IContentBatchDownloadItem {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;

    constructor(data?: IContentBatchDownloadItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.downloadToken = data["DownloadToken"];
            this.downloadUrl = data["DownloadUrl"];
        }
    }

    static fromJS(data: any): ContentBatchDownloadItem {
        let result = new ContentBatchDownloadItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DownloadToken"] = this.downloadToken;
        data["DownloadUrl"] = this.downloadUrl;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentBatchDownloadItem extends IDownloadItem {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;
}

/** A request structure for creating a content document. */
export class CreateContentRequest implements ICreateContentRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: ICreateContentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentSchemaId = data["ContentSchemaId"];
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["Content"];
            this.metadata = data["Metadata"] ? DataDictionary.fromJS(data["Metadata"]) : <any>undefined;
            if (data["ContentPermissionSetIds"] && data["ContentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["ContentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateContentRequest {
        let result = new CreateContentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        data["Content"] = this.content;
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["ContentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["ContentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

/** A request structure for creating a content document. */
export interface ICreateContentRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;
}

/** A custom implementation of Dictionary{string, object} */
export class DataDictionary implements IDataDictionary {

    [key: string]: any; 

    constructor(data?: IDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DataDictionary {
        let result = new DataDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

/** A custom implementation of Dictionary{string, object} */
export interface IDataDictionary {

    [key: string]: any; 
}

export class ContentDetail implements IContentDetail {
    /** Document audit information with information regarding document creation and modification. */
    audit?: StoreAudit | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** The content type of a content document. */
    contentType: ContentType;
    /** The content type of a content document. */
    contentTypeId: number;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The content id. */
    id?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** A list of rendering ouputs for contents with an underlying digital file. */
    outputs?: OutputViewItem[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;

    constructor(data?: IContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.content = data["Content"];
            if (data["ContentPermissionSetIds"] && data["ContentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["ContentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
            this.contentSchemaId = data["ContentSchemaId"];
            this.contentType = data["ContentType"];
            this.contentTypeId = data["ContentTypeId"];
            this.displayValues = data["DisplayValues"] ? DisplayValueViewItem.fromJS(data["DisplayValues"]) : <any>undefined;
            this.entityType = data["EntityType"];
            this.id = data["Id"];
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["Metadata"] ? DataDictionary.fromJS(data["Metadata"]) : <any>undefined;
            if (data["Outputs"] && data["Outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["Outputs"])
                    this.outputs.push(OutputViewItem.fromJS(item));
            }
            this.ownerTokenId = data["OwnerTokenId"];
            this.trashed = data["Trashed"];
        }
    }

    static fromJS(data: any): ContentDetail {
        let result = new ContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["Content"] = this.content;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["ContentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["ContentPermissionSetIds"].push(item);
        }
        data["ContentSchemaId"] = this.contentSchemaId;
        data["ContentType"] = this.contentType;
        data["ContentTypeId"] = this.contentTypeId;
        data["DisplayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["EntityType"] = this.entityType;
        data["Id"] = this.id;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.outputs && this.outputs.constructor === Array) {
            data["Outputs"] = [];
            for (let item of this.outputs)
                data["Outputs"].push(item.toJSON());
        }
        data["OwnerTokenId"] = this.ownerTokenId;
        data["Trashed"] = this.trashed;
        return data; 
    }
}

export interface IContentDetail {
    /** Document audit information with information regarding document creation and modification. */
    audit?: StoreAudit | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** The content type of a content document. */
    contentType: ContentType;
    /** The content type of a content document. */
    contentTypeId: number;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The content id. */
    id?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** A list of rendering ouputs for contents with an underlying digital file. */
    outputs?: OutputViewItem[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;
}

export class StoreAudit implements IStoreAudit {
    creationDate: Date;
    createdByUser?: UserItem | undefined;
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;

    constructor(data?: IStoreAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creationDate = data["CreationDate"] ? new Date(data["CreationDate"].toString()) : <any>undefined;
            this.createdByUser = data["CreatedByUser"] ? UserItem.fromJS(data["CreatedByUser"]) : <any>undefined;
            this.modificationDate = data["ModificationDate"] ? new Date(data["ModificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = data["ModifiedByUser"] ? UserItem.fromJS(data["ModifiedByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreAudit {
        let result = new StoreAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CreationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["CreatedByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["ModificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["ModifiedByUser"] = this.modifiedByUser ? this.modifiedByUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStoreAudit {
    creationDate: Date;
    createdByUser?: UserItem | undefined;
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;
}

export class UserItem implements IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUserItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.firstName = data["FirstName"];
            this.lastName = data["LastName"];
            this.emailAddress = data["EmailAddress"];
        }
    }

    static fromJS(data: any): UserItem {
        let result = new UserItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["EmailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export enum ContentType {
    Unknown = <any>"Unknown", 
    Bitmap = <any>"Bitmap", 
    VectorGraphic = <any>"VectorGraphic", 
    RawImage = <any>"RawImage", 
    InterchangeDocument = <any>"InterchangeDocument", 
    WordProcessingDocument = <any>"WordProcessingDocument", 
    TextDocument = <any>"TextDocument", 
    DesktopPublishingDocument = <any>"DesktopPublishingDocument", 
    Presentation = <any>"Presentation", 
    Spreadsheet = <any>"Spreadsheet", 
    Archive = <any>"Archive", 
    Audio = <any>"Audio", 
    Video = <any>"Video", 
    Font = <any>"Font", 
    Multimedia = <any>"Multimedia", 
    Application = <any>"Application", 
    SourceCode = <any>"SourceCode", 
    Database = <any>"Database", 
    Cad = <any>"Cad", 
    Model3d = <any>"Model3d", 
}

export class DisplayValueViewItem implements IDisplayValueViewItem {

    [key: string]: string | any; 

    constructor(data?: IDisplayValueViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DisplayValueViewItem {
        let result = new DisplayValueViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface IDisplayValueViewItem {

    [key: string]: string | any; 
}

export enum EntityType {
    Content = <any>"Content", 
    BasicShare = <any>"BasicShare", 
    EmbedShare = <any>"EmbedShare", 
    Metadata = <any>"Metadata", 
    FileTransfer = <any>"FileTransfer", 
}

export class OutputViewItem implements IOutputViewItem {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;

    protected _discriminator: string;

    constructor(data?: IOutputViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputViewItem";
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.outputFormatId = data["OutputFormatId"];
            this.contentId = data["ContentId"];
            this.detail = data["Detail"] ? OutputDetailBase.fromJS(data["Detail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OutputViewItem {
        if (data["Kind"] === "OutputDetailViewItem") {
            let result = new OutputDetailViewItem();
            result.init(data);
            return result;
        }
        let result = new OutputViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Id"] = this.id;
        data["OutputFormatId"] = this.outputFormatId;
        data["ContentId"] = this.contentId;
        data["Detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOutputViewItem {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;
}

export class OutputDetailBase implements IOutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IOutputDetailBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputDetailBase";
    }

    init(data?: any) {
        if (data) {
            this.fileExtension = data["FileExtension"];
            this.fileName = data["FileName"];
            this.filePath = data["FilePath"];
            this.fileSizeInBytes = data["FileSizeInBytes"];
            this.sha1Hash = data["Sha1Hash"];
        }
    }

    static fromJS(data: any): OutputDetailBase {
        if (data["Kind"] === "OutputDetailImage") {
            let result = new OutputDetailImage();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OutputDetailAudio") {
            let result = new OutputDetailAudio();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OutputDetailVideo") {
            let result = new OutputDetailVideo();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OutputDetailDocument") {
            let result = new OutputDetailDocument();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "OutputDetailDefault") {
            let result = new OutputDetailDefault();
            result.init(data);
            return result;
        }
        let result = new OutputDetailBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["FileExtension"] = this.fileExtension;
        data["FileName"] = this.fileName;
        data["FilePath"] = this.filePath;
        data["FileSizeInBytes"] = this.fileSizeInBytes;
        data["Sha1Hash"] = this.sha1Hash;
        return data; 
    }
}

export interface IOutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
}

export class OutputDetailImage extends OutputDetailBase implements IOutputDetailImage {
    width: number;
    height: number;

    constructor(data?: IOutputDetailImage) {
        super(data);
        this._discriminator = "OutputDetailImage";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["Width"];
            this.height = data["Height"];
        }
    }

    static fromJS(data: any): OutputDetailImage {
        let result = new OutputDetailImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Width"] = this.width;
        data["Height"] = this.height;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailImage extends IOutputDetailBase {
    width: number;
    height: number;
}

export class OutputDetailAudio extends OutputDetailBase implements IOutputDetailAudio {
    durationInSeconds?: number | undefined;

    constructor(data?: IOutputDetailAudio) {
        super(data);
        this._discriminator = "OutputDetailAudio";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["DurationInSeconds"];
        }
    }

    static fromJS(data: any): OutputDetailAudio {
        let result = new OutputDetailAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DurationInSeconds"] = this.durationInSeconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailAudio extends IOutputDetailBase {
    durationInSeconds?: number | undefined;
}

export class OutputDetailVideo extends OutputDetailBase implements IOutputDetailVideo {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;

    constructor(data?: IOutputDetailVideo) {
        super(data);
        this._discriminator = "OutputDetailVideo";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["DurationInSeconds"];
            this.width = data["Width"];
            this.height = data["Height"];
            if (data["Sprites"] && data["Sprites"].constructor === Array) {
                this.sprites = [];
                for (let item of data["Sprites"])
                    this.sprites.push(Sprite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputDetailVideo {
        let result = new OutputDetailVideo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DurationInSeconds"] = this.durationInSeconds;
        data["Width"] = this.width;
        data["Height"] = this.height;
        if (this.sprites && this.sprites.constructor === Array) {
            data["Sprites"] = [];
            for (let item of this.sprites)
                data["Sprites"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailVideo extends IOutputDetailBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;
}

export class Sprite implements ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;

    constructor(data?: ISprite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.width = data["Width"];
            this.height = data["Height"];
            this.y = data["Y"];
            this.x = data["X"];
            this.start = data["Start"];
            this.end = data["End"];
        }
    }

    static fromJS(data: any): Sprite {
        let result = new Sprite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Width"] = this.width;
        data["Height"] = this.height;
        data["Y"] = this.y;
        data["X"] = this.x;
        data["Start"] = this.start;
        data["End"] = this.end;
        return data; 
    }
}

export interface ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;
}

export class OutputDetailDocument extends OutputDetailBase implements IOutputDetailDocument {
    pageCount: number;

    constructor(data?: IOutputDetailDocument) {
        super(data);
        this._discriminator = "OutputDetailDocument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pageCount = data["PageCount"];
        }
    }

    static fromJS(data: any): OutputDetailDocument {
        let result = new OutputDetailDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PageCount"] = this.pageCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailDocument extends IOutputDetailBase {
    pageCount: number;
}

export class OutputDetailDefault extends OutputDetailBase implements IOutputDetailDefault {

    constructor(data?: IOutputDetailDefault) {
        super(data);
        this._discriminator = "OutputDetailDefault";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetailDefault {
        let result = new OutputDetailDefault();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailDefault extends IOutputDetailBase {
}

export class OutputDetailViewItem extends OutputViewItem implements IOutputDetailViewItem {

    constructor(data?: IOutputDetailViewItem) {
        super(data);
        this._discriminator = "OutputDetailViewItem";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetailViewItem {
        let result = new OutputDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailViewItem extends IOutputViewItem {
}

export enum ThumbnailSize {
    Small = <any>"Small", 
    Medium = <any>"Medium", 
    Large = <any>"Large", 
}

export class UpdateContentPermissionsRequest implements IUpdateContentPermissionsRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IUpdateContentPermissionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["ContentId"];
            if (data["ContentPermissionSetIds"] && data["ContentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["ContentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateContentPermissionsRequest {
        let result = new UpdateContentPermissionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["ContentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["ContentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateContentPermissionsRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class ContentSearchRequest implements IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IContentSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ChannelIds"] && data["ChannelIds"].constructor === Array) {
                this.channelIds = [];
                for (let item of data["ChannelIds"])
                    this.channelIds.push(item);
            }
            this.displayLanguage = data["DisplayLanguage"];
            if (data["DisplayPatternIds"] && data["DisplayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["DisplayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            if (data["SearchLanguages"] && data["SearchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["SearchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["CollectionId"];
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["Start"];
            this.limit = data["Limit"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            this.lifeCycleFilter = data["LifeCycleFilter"];
        }
    }

    static fromJS(data: any): ContentSearchRequest {
        let result = new ContentSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.channelIds && this.channelIds.constructor === Array) {
            data["ChannelIds"] = [];
            for (let item of this.channelIds)
                data["ChannelIds"].push(item);
        }
        data["DisplayLanguage"] = this.displayLanguage;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["DisplayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["DisplayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["SearchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["SearchLanguages"].push(item);
        }
        data["CollectionId"] = this.collectionId;
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Start"] = this.start;
        data["Limit"] = this.limit;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["LifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

export class SortInfo implements ISortInfo {
    /** The elastic search index field to sort on. */
    field?: string | undefined;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["Field"];
            this.direction = data["Direction"];
        }
    }

    static fromJS(data: any): SortInfo {
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Field"] = this.field;
        data["Direction"] = this.direction;
        return data; 
    }
}

export interface ISortInfo {
    /** The elastic search index field to sort on. */
    field?: string | undefined;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;
}

export enum SortDirection {
    Asc = <any>"Asc", 
    Desc = <any>"Desc", 
}

export class BaseResultOfContentViewItem implements IBaseResultOfContentViewItem {
    totalResults: number;
    results?: ContentViewItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfContentViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(ContentViewItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfContentViewItem {
        let result = new BaseResultOfContentViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfContentViewItem {
    totalResults: number;
    results?: ContentViewItem[] | undefined;
    pageToken?: string | undefined;
}

export class ContentSearchResult extends BaseResultOfContentViewItem implements IContentSearchResult {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;

    constructor(data?: IContentSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["AggregationResults"] && data["AggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["AggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
            this.elapsedMilliseconds = data["ElapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ContentSearchResult {
        let result = new ContentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["AggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["AggregationResults"].push(item.toJSON());
        }
        data["ElapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentSearchResult extends IBaseResultOfContentViewItem {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;
}

export class ContentViewItem implements IContentViewItem {
    audit?: StoreAudit | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;

    constructor(data?: IContentViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.entityType = data["EntityType"];
            this.contentSchemaId = data["ContentSchemaId"];
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["DisplayValues"]) {
                this.displayValues = {};
                for (let key in data["DisplayValues"]) {
                    if (data["DisplayValues"].hasOwnProperty(key))
                        this.displayValues[key] = data["DisplayValues"][key];
                }
            }
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): ContentViewItem {
        let result = new ContentViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["EntityType"] = this.entityType;
        data["ContentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        if (this.displayValues) {
            data["DisplayValues"] = {};
            for (let key in this.displayValues) {
                if (this.displayValues.hasOwnProperty(key))
                    data["DisplayValues"][key] = this.displayValues[key];
            }
        }
        data["Id"] = this.id;
        return data; 
    }
}

export interface IContentViewItem {
    audit?: StoreAudit | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;
}

export class ContentFileUpdateRequest implements IContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;

    constructor(data?: IContentFileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["ContentId"];
            this.fileTransferId = data["FileTransferId"];
        }
    }

    static fromJS(data: any): ContentFileUpdateRequest {
        let result = new ContentFileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        data["FileTransferId"] = this.fileTransferId;
        return data; 
    }
}

export interface IContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;
}

export class BusinessProcessViewItem implements IBusinessProcessViewItem {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCylce;
    startDate: Date;
    endDate: Date;
    stateHistory?: BusinessProcessStateItem[] | undefined;
    processDefinitionName?: string | undefined;
    currentState?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessProcessViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcessViewItem";
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.processDefinitionId = data["ProcessDefinitionId"];
            this.referenceId = data["ReferenceId"];
            this.referenceDocType = data["ReferenceDocType"];
            this.businessProcessScope = data["BusinessProcessScope"];
            this.lifeCycle = data["LifeCycle"];
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>undefined;
            if (data["StateHistory"] && data["StateHistory"].constructor === Array) {
                this.stateHistory = [];
                for (let item of data["StateHistory"])
                    this.stateHistory.push(BusinessProcessStateItem.fromJS(item));
            }
            this.processDefinitionName = data["ProcessDefinitionName"];
            this.currentState = data["CurrentState"];
        }
    }

    static fromJS(data: any): BusinessProcessViewItem {
        if (data["Kind"] === "BusinessProcessBulkResponseViewItem") {
            let result = new BusinessProcessBulkResponseViewItem();
            result.init(data);
            return result;
        }
        let result = new BusinessProcessViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Id"] = this.id;
        data["ProcessDefinitionId"] = this.processDefinitionId;
        data["ReferenceId"] = this.referenceId;
        data["ReferenceDocType"] = this.referenceDocType;
        data["BusinessProcessScope"] = this.businessProcessScope;
        data["LifeCycle"] = this.lifeCycle;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (this.stateHistory && this.stateHistory.constructor === Array) {
            data["StateHistory"] = [];
            for (let item of this.stateHistory)
                data["StateHistory"].push(item.toJSON());
        }
        data["ProcessDefinitionName"] = this.processDefinitionName;
        data["CurrentState"] = this.currentState;
        return data; 
    }
}

export interface IBusinessProcessViewItem {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCylce;
    startDate: Date;
    endDate: Date;
    stateHistory?: BusinessProcessStateItem[] | undefined;
    processDefinitionName?: string | undefined;
    currentState?: string | undefined;
}

export enum BusinessProcessScope {
    System = <any>"System", 
    User = <any>"User", 
}

export enum BusinessProcessLifeCylce {
    Draft = <any>"Draft", 
    Started = <any>"Started", 
    Ended = <any>"Ended", 
}

export class BusinessProcessStateItem implements IBusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: ErrorResponse | undefined;

    constructor(data?: IBusinessProcessStateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["State"];
            this.timestamp = data["Timestamp"] ? new Date(data["Timestamp"].toString()) : <any>undefined;
            this.error = data["Error"] ? ErrorResponse.fromJS(data["Error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessStateItem {
        let result = new BusinessProcessStateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["State"] = this.state;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["Error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: ErrorResponse | undefined;
}

export class ErrorResponse implements IErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exception = data["Exception"];
            this.traceId = data["TraceId"];
            this.traceJobId = data["TraceJobId"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Exception"] = this.exception;
        data["TraceId"] = this.traceId;
        data["TraceJobId"] = this.traceJobId;
        return data; 
    }
}

export interface IErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
}

export class BusinessProcessBulkResponseViewItem extends BusinessProcessViewItem implements IBusinessProcessBulkResponseViewItem {
    response?: BulkResponseViewItem | undefined;

    constructor(data?: IBusinessProcessBulkResponseViewItem) {
        super(data);
        this._discriminator = "BusinessProcessBulkResponseViewItem";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.response = data["Response"] ? BulkResponseViewItem.fromJS(data["Response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessBulkResponseViewItem {
        let result = new BusinessProcessBulkResponseViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessBulkResponseViewItem extends IBusinessProcessViewItem {
    response?: BulkResponseViewItem | undefined;
}

export class BulkResponseViewItem implements IBulkResponseViewItem {
    rows?: BulkResponseRowViewItem[] | undefined;

    constructor(data?: IBulkResponseViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Rows"] && data["Rows"].constructor === Array) {
                this.rows = [];
                for (let item of data["Rows"])
                    this.rows.push(BulkResponseRowViewItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkResponseViewItem {
        let result = new BulkResponseViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rows && this.rows.constructor === Array) {
            data["Rows"] = [];
            for (let item of this.rows)
                data["Rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBulkResponseViewItem {
    rows?: BulkResponseRowViewItem[] | undefined;
}

export class BulkResponseRowViewItem implements IBulkResponseRowViewItem {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;

    constructor(data?: IBulkResponseRowViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.version = data["Version"];
            this.error = data["Error"];
            this.reason = data["Reason"];
            this.succeeded = data["Succeeded"];
        }
    }

    static fromJS(data: any): BulkResponseRowViewItem {
        let result = new BulkResponseRowViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Version"] = this.version;
        data["Error"] = this.error;
        data["Reason"] = this.reason;
        data["Succeeded"] = this.succeeded;
        return data; 
    }
}

export interface IBulkResponseRowViewItem {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;
}

export class UpdateContentMetadataRequest implements IUpdateContentMetadataRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: DataDictionary | undefined;

    constructor(data?: IUpdateContentMetadataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            if (data["SchemaIds"] && data["SchemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["SchemaIds"])
                    this.schemaIds.push(item);
            }
            this.metadata = data["Metadata"] ? DataDictionary.fromJS(data["Metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateContentMetadataRequest {
        let result = new UpdateContentMetadataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["SchemaIds"] = [];
            for (let item of this.schemaIds)
                data["SchemaIds"].push(item);
        }
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateContentMetadataRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: DataDictionary | undefined;
}

export class ContentDeactivationRequest implements IContentDeactivationRequest {
    contentIds?: string[] | undefined;

    constructor(data?: IContentDeactivationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ContentIds"] && data["ContentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["ContentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentDeactivationRequest {
        let result = new ContentDeactivationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["ContentIds"] = [];
            for (let item of this.contentIds)
                data["ContentIds"].push(item);
        }
        return data; 
    }
}

export interface IContentDeactivationRequest {
    contentIds?: string[] | undefined;
}

export class ContentReactivationRequest implements IContentReactivationRequest {
    contentIds?: string[] | undefined;

    constructor(data?: IContentReactivationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ContentIds"] && data["ContentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["ContentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentReactivationRequest {
        let result = new ContentReactivationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["ContentIds"] = [];
            for (let item of this.contentIds)
                data["ContentIds"].push(item);
        }
        return data; 
    }
}

export interface IContentReactivationRequest {
    contentIds?: string[] | undefined;
}

export class MetadataValuesChangeRequestBase implements IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeRequestBase";
    }

    init(data?: any) {
        if (data) {
            if (data["ChangeCommands"] && data["ChangeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["ChangeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MetadataValuesChangeRequestBase {
        if (data["Kind"] === "ContentsMetadataUpdateRequest") {
            let result = new ContentsMetadataUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FilterContentsMetadataUpdateRequest") {
            let result = new FilterContentsMetadataUpdateRequest();
            result.init(data);
            return result;
        }
        let result = new MetadataValuesChangeRequestBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["ChangeCommands"] = [];
            for (let item of this.changeCommands)
                data["ChangeCommands"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
}

export class ContentsMetadataUpdateRequest extends MetadataValuesChangeRequestBase implements IContentsMetadataUpdateRequest {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;

    constructor(data?: IContentsMetadataUpdateRequest) {
        super(data);
        this._discriminator = "ContentsMetadataUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ContentIds"] && data["ContentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["ContentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentsMetadataUpdateRequest {
        let result = new ContentsMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["ContentIds"] = [];
            for (let item of this.contentIds)
                data["ContentIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentsMetadataUpdateRequest extends IMetadataValuesChangeRequestBase {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;
}

/** The base class for metadata value change commands. */
export class MetadataValuesChangeCommandBase implements IMetadataValuesChangeCommandBase {

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeCommandBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeCommandBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): MetadataValuesChangeCommandBase {
        if (data["Kind"] === "MetadataValuesSchemaUpdateCommand") {
            let result = new MetadataValuesSchemaUpdateCommand();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "MetadataValuesSchemaUpsertCommand") {
            let result = new MetadataValuesSchemaUpsertCommand();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "MetadataValuesSchemaRemoveCommand") {
            let result = new MetadataValuesSchemaRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "MetadataValuesFieldRemoveCommand") {
            let result = new MetadataValuesFieldRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "MetadataValuesSchemaItemAddCommand") {
            let result = new MetadataValuesSchemaItemAddCommand();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "MetadataValuesSchemaItemRemoveCommand") {
            let result = new MetadataValuesSchemaItemRemoveCommand();
            result.init(data);
            return result;
        }
        let result = new MetadataValuesChangeCommandBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        return data; 
    }
}

/** The base class for metadata value change commands. */
export interface IMetadataValuesChangeCommandBase {
}

/** Updates schema values. */
export class MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpdateCommand {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;

    constructor(data?: IMetadataValuesSchemaUpdateCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpdateCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            this.value = data["Value"] ? DataDictionary.fromJS(data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        let result = new MetadataValuesSchemaUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Updates schema values. */
export interface IMetadataValuesSchemaUpdateCommand extends IMetadataValuesChangeCommandBase {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;
}

/** Adds or updates schema values. */
export class MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpsertCommand {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;

    constructor(data?: IMetadataValuesSchemaUpsertCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpsertCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            this.value = data["Value"] ? DataDictionary.fromJS(data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        let result = new MetadataValuesSchemaUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Adds or updates schema values. */
export interface IMetadataValuesSchemaUpsertCommand extends IMetadataValuesChangeCommandBase {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;
}

/** Removes schema values. */
export class MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaRemoveCommand {
    /** The id of the schema with type layer to be removed. */
    schemaId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        let result = new MetadataValuesSchemaRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

/** Removes schema values. */
export interface IMetadataValuesSchemaRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The id of the schema with type layer to be removed. */
    schemaId?: string | undefined;
}

/** Removes a field and its value from the schema values. */
export class MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesFieldRemoveCommand {
    /** The fully qualified field name of the field to be removed, e.g. "Data.SchemaId.FieldId". */
    fieldNamespace?: string | undefined;

    constructor(data?: IMetadataValuesFieldRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesFieldRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldNamespace = data["FieldNamespace"];
        }
    }

    static fromJS(data: any): MetadataValuesFieldRemoveCommand {
        let result = new MetadataValuesFieldRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldNamespace"] = this.fieldNamespace;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a field and its value from the schema values. */
export interface IMetadataValuesFieldRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The fully qualified field name of the field to be removed, e.g. "Data.SchemaId.FieldId". */
    fieldNamespace?: string | undefined;
}

/** Adds a list item id reference to a multi tagbox. */
export class MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemAddCommand {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaItemAddCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemAddCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldNamespace = data["FieldNamespace"];
            this.referenceId = data["ReferenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        let result = new MetadataValuesSchemaItemAddCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldNamespace"] = this.fieldNamespace;
        data["ReferenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Adds a list item id reference to a multi tagbox. */
export interface IMetadataValuesSchemaItemAddCommand extends IMetadataValuesChangeCommandBase {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;
}

/** Removes a list item id reference from a multi tagbox. */
export class MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemRemoveCommand {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaItemRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldNamespace = data["FieldNamespace"];
            this.referenceId = data["ReferenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        let result = new MetadataValuesSchemaItemRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldNamespace"] = this.fieldNamespace;
        data["ReferenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a list item id reference from a multi tagbox. */
export interface IMetadataValuesSchemaItemRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;
}

export class FilterContentsMetadataUpdateRequest extends MetadataValuesChangeRequestBase implements IFilterContentsMetadataUpdateRequest {
    contentSearchRequest?: ContentSearchRequest | undefined;
    totalItemsCount: number;

    constructor(data?: IFilterContentsMetadataUpdateRequest) {
        super(data);
        this._discriminator = "FilterContentsMetadataUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentSearchRequest = data["ContentSearchRequest"] ? ContentSearchRequest.fromJS(data["ContentSearchRequest"]) : <any>undefined;
            this.totalItemsCount = data["TotalItemsCount"];
        }
    }

    static fromJS(data: any): FilterContentsMetadataUpdateRequest {
        let result = new FilterContentsMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentSearchRequest"] = this.contentSearchRequest ? this.contentSearchRequest.toJSON() : <any>undefined;
        data["TotalItemsCount"] = this.totalItemsCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IFilterContentsMetadataUpdateRequest extends IMetadataValuesChangeRequestBase {
    contentSearchRequest?: ContentSearchRequest | undefined;
    totalItemsCount: number;
}

export class StartProcessRequest implements IStartProcessRequest {
    variables?: any | undefined;

    constructor(data?: IStartProcessRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.variables = data["Variables"];
        }
    }

    static fromJS(data: any): StartProcessRequest {
        let result = new StartProcessRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Variables"] = this.variables;
        return data; 
    }
}

export interface IStartProcessRequest {
    variables?: any | undefined;
}

export class SendMessageRequest implements ISendMessageRequest {
    messageName?: string | undefined;
    variables?: any | undefined;

    constructor(data?: ISendMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.messageName = data["MessageName"];
            this.variables = data["Variables"];
        }
    }

    static fromJS(data: any): SendMessageRequest {
        let result = new SendMessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MessageName"] = this.messageName;
        data["Variables"] = this.variables;
        return data; 
    }
}

export interface ISendMessageRequest {
    messageName?: string | undefined;
    variables?: any | undefined;
}

export class BusinessProcessWaitResult implements IBusinessProcessWaitResult {
    hasStateHit: boolean;
    processEnded: boolean;
    stateHit?: string | undefined;
    businessProcess?: BusinessProcessViewItem | undefined;

    constructor(data?: IBusinessProcessWaitResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasStateHit = data["HasStateHit"];
            this.processEnded = data["ProcessEnded"];
            this.stateHit = data["StateHit"];
            this.businessProcess = data["BusinessProcess"] ? BusinessProcessViewItem.fromJS(data["BusinessProcess"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessWaitResult {
        let result = new BusinessProcessWaitResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasStateHit"] = this.hasStateHit;
        data["ProcessEnded"] = this.processEnded;
        data["StateHit"] = this.stateHit;
        data["BusinessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessWaitResult {
    hasStateHit: boolean;
    processEnded: boolean;
    stateHit?: string | undefined;
    businessProcess?: BusinessProcessViewItem | undefined;
}

export class DocumentHistoryViewItem implements IDocumentHistoryViewItem {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: HistoryAudit | undefined;
    deleted: boolean;

    constructor(data?: IDocumentHistoryViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.documentId = data["DocumentId"];
            this.documentVersion = data["DocumentVersion"];
            this.documentType = data["DocumentType"];
            this.documentDate = data["DocumentDate"] ? new Date(data["DocumentDate"].toString()) : <any>undefined;
            this.document = data["Document"];
            this.timestamp = data["Timestamp"] ? new Date(data["Timestamp"].toString()) : <any>undefined;
            this.audit = data["Audit"] ? HistoryAudit.fromJS(data["Audit"]) : <any>undefined;
            this.deleted = data["Deleted"];
        }
    }

    static fromJS(data: any): DocumentHistoryViewItem {
        let result = new DocumentHistoryViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DocumentId"] = this.documentId;
        data["DocumentVersion"] = this.documentVersion;
        data["DocumentType"] = this.documentType;
        data["DocumentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["Document"] = this.document;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["Deleted"] = this.deleted;
        return data; 
    }
}

export interface IDocumentHistoryViewItem {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: HistoryAudit | undefined;
    deleted: boolean;
}

export class HistoryAudit implements IHistoryAudit {
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;

    constructor(data?: IHistoryAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modificationDate = data["ModificationDate"] ? new Date(data["ModificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = data["ModifiedByUser"] ? UserItem.fromJS(data["ModifiedByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HistoryAudit {
        let result = new HistoryAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ModificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["ModifiedByUser"] = this.modifiedByUser ? this.modifiedByUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHistoryAudit {
    modificationDate: Date;
    modifiedByUser?: UserItem | undefined;
}

export class DocumentHistoryDifferenceViewItem implements IDocumentHistoryDifferenceViewItem {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;

    constructor(data?: IDocumentHistoryDifferenceViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["DocumentId"];
            this.oldDocumentVersion = data["OldDocumentVersion"];
            this.newDocumentVersion = data["NewDocumentVersion"];
            this.oldValues = data["OldValues"];
            this.newValues = data["NewValues"];
        }
    }

    static fromJS(data: any): DocumentHistoryDifferenceViewItem {
        let result = new DocumentHistoryDifferenceViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DocumentId"] = this.documentId;
        data["OldDocumentVersion"] = this.oldDocumentVersion;
        data["NewDocumentVersion"] = this.newDocumentVersion;
        data["OldValues"] = this.oldValues;
        data["NewValues"] = this.newValues;
        return data; 
    }
}

export interface IDocumentHistoryDifferenceViewItem {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;
}

/** A request structure for creating a list item document. */
export class ListItemCreateRequest implements IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;

    constructor(data?: IListItemCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["Content"];
            this.contentSchemaId = data["ContentSchemaId"];
            this.listItemId = data["ListItemId"];
        }
    }

    static fromJS(data: any): ListItemCreateRequest {
        let result = new ListItemCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Content"] = this.content;
        data["ContentSchemaId"] = this.contentSchemaId;
        data["ListItemId"] = this.listItemId;
        return data; 
    }
}

/** A request structure for creating a list item document. */
export interface IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;
}

/** The detail view item for the list item. */
export class ListItemDetail implements IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["Content"];
            this.contentSchemaId = data["ContentSchemaId"];
            this.displayValues = data["DisplayValues"] ? DisplayValueViewItem.fromJS(data["DisplayValues"]) : <any>undefined;
            this.entityType = data["EntityType"];
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): ListItemDetail {
        let result = new ListItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Content"] = this.content;
        data["ContentSchemaId"] = this.contentSchemaId;
        data["DisplayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["EntityType"] = this.entityType;
        data["Id"] = this.id;
        return data; 
    }
}

/** The detail view item for the list item. */
export interface IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;
}

export class ListItemAggregationRequest implements IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;

    constructor(data?: IListItemAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            if (data["AggregationFilters"] && data["AggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["AggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["Aggregators"] && data["Aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["Aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.includeAllSchemaChildren = data["IncludeAllSchemaChildren"];
            if (data["SchemaIds"] && data["SchemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["SchemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["DisplayLanguage"];
            if (data["SearchLanguages"] && data["SearchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["SearchLanguages"])
                    this.searchLanguages.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemAggregationRequest {
        let result = new ListItemAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["AggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["AggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["Aggregators"] = [];
            for (let item of this.aggregators)
                data["Aggregators"].push(item.toJSON());
        }
        data["IncludeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["SchemaIds"] = [];
            for (let item of this.schemaIds)
                data["SchemaIds"].push(item);
        }
        data["DisplayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["SearchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["SearchLanguages"].push(item);
        }
        return data; 
    }
}

export interface IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
}

export class ListItemSearchRequest implements IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;

    constructor(data?: IListItemSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["Start"];
            this.limit = data["Limit"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            this.includeAllSchemaChildren = data["IncludeAllSchemaChildren"];
            if (data["SchemaIds"] && data["SchemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["SchemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["DisplayLanguage"];
            if (data["DisplayPatternIds"] && data["DisplayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["DisplayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            if (data["SearchLanguages"] && data["SearchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["SearchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.includeMetadata = data["IncludeMetadata"];
        }
    }

    static fromJS(data: any): ListItemSearchRequest {
        let result = new ListItemSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Start"] = this.start;
        data["Limit"] = this.limit;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["IncludeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["SchemaIds"] = [];
            for (let item of this.schemaIds)
                data["SchemaIds"].push(item);
        }
        data["DisplayLanguage"] = this.displayLanguage;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["DisplayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["DisplayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["SearchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["SearchLanguages"].push(item);
        }
        data["IncludeMetadata"] = this.includeMetadata;
        return data; 
    }
}

export interface IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;
}

export class BaseResultOfListItem implements IBaseResultOfListItem {
    totalResults: number;
    results?: ListItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(ListItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfListItem {
        let result = new BaseResultOfListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfListItem {
    totalResults: number;
    results?: ListItem[] | undefined;
    pageToken?: string | undefined;
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export class ListItem implements IListItem {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["Content"];
            this.contentSchemaId = data["ContentSchemaId"];
            this.displayValues = data["DisplayValues"] ? DisplayValueViewItem.fromJS(data["DisplayValues"]) : <any>undefined;
            this.entityType = data["EntityType"];
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): ListItem {
        let result = new ListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Content"] = this.content;
        data["ContentSchemaId"] = this.contentSchemaId;
        data["DisplayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["EntityType"] = this.entityType;
        data["Id"] = this.id;
        return data; 
    }
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export interface IListItem {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;
}

/** A request structure for updating a list item. */
export class ListItemUpdateRequest implements IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["Content"];
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): ListItemUpdateRequest {
        let result = new ListItemUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Content"] = this.content;
        data["Id"] = this.id;
        return data; 
    }
}

/** A request structure for updating a list item. */
export interface IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;
}

export class SchemaDetailViewItem implements ISchemaDetailViewItem {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: StoreAudit | undefined;

    constructor(data?: ISchemaDetailViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.parentSchemaId = data["ParentSchemaId"];
            if (data["Types"] && data["Types"].constructor === Array) {
                this.types = [];
                for (let item of data["Types"])
                    this.types.push(item);
            }
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.descriptions = data["Descriptions"] ? TranslatedStringDictionary.fromJS(data["Descriptions"]) : <any>undefined;
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["DisplayPatterns"] && data["DisplayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["DisplayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["Fields"] && data["Fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["Fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["Aggregations"] && data["Aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["Aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["SortOrder"];
            this.system = data["System"];
            this.ownerTokenId = data["OwnerTokenId"];
            this.public = data["Public"];
            if (data["SchemaPermissionSetIds"] && data["SchemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["SchemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["ReferencedInContentSchemaIds"] && data["ReferencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["ReferencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["DescendantSchemaIds"] && data["DescendantSchemaIds"].constructor === Array) {
                this.descendantSchemaIds = [];
                for (let item of data["DescendantSchemaIds"])
                    this.descendantSchemaIds.push(item);
            }
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaDetailViewItem {
        let result = new SchemaDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ParentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["Types"] = [];
            for (let item of this.types)
                data["Types"].push(item);
        }
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["DisplayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["DisplayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["Fields"] = [];
            for (let item of this.fields)
                data["Fields"].push(item.toJSON());
        }
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["Aggregations"] = [];
            for (let item of this.aggregations)
                data["Aggregations"].push(item.toJSON());
        }
        data["SortOrder"] = this.sortOrder;
        data["System"] = this.system;
        data["OwnerTokenId"] = this.ownerTokenId;
        data["Public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["SchemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["SchemaPermissionSetIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["ReferencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["ReferencedInContentSchemaIds"].push(item);
        }
        if (this.descendantSchemaIds && this.descendantSchemaIds.constructor === Array) {
            data["DescendantSchemaIds"] = [];
            for (let item of this.descendantSchemaIds)
                data["DescendantSchemaIds"].push(item);
        }
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaDetailViewItem {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: StoreAudit | undefined;
}

export enum SchemaType {
    Content = <any>"Content", 
    Layer = <any>"Layer", 
    List = <any>"List", 
    Struct = <any>"Struct", 
}

export class DisplayPattern implements IDisplayPattern {
    /** The display pattern id. */
    id?: string | undefined;
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary | undefined;

    constructor(data?: IDisplayPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.templateEngine = data["TemplateEngine"];
            this.displayPatternType = data["DisplayPatternType"];
            this.templates = data["Templates"] ? TranslatedStringDictionary.fromJS(data["Templates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DisplayPattern {
        let result = new DisplayPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TemplateEngine"] = this.templateEngine;
        data["DisplayPatternType"] = this.displayPatternType;
        data["Templates"] = this.templates ? this.templates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDisplayPattern {
    /** The display pattern id. */
    id?: string | undefined;
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary | undefined;
}

export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid", 
}

export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail", 
    List = <any>"List", 
    Detail = <any>"Detail", 
    Custom = <any>"Custom", 
    Name = <any>"Name", 
}

/** The field base class. */
export class FieldBase implements IFieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string | undefined;
    /** The index id is auto generated by the system. */
    indexId?: string | undefined;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    protected _discriminator: string;

    constructor(data?: IFieldBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FieldBase";
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.indexId = data["IndexId"];
            this.fieldNamespace = data["FieldNamespace"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.required = data["Required"];
            this.fixed = data["Fixed"];
            this.index = data["Index"];
            this.simpleSearch = data["SimpleSearch"];
            this.boost = data["Boost"];
        }
    }

    static fromJS(data: any): FieldBase {
        if (data["Kind"] === "FieldBoolean") {
            let result = new FieldBoolean();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldDate") {
            let result = new FieldDate();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldDateTime") {
            let result = new FieldDateTime();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldDecimal") {
            let result = new FieldDecimal();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldDictionary") {
            let result = new FieldDictionary();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldGeoPoint") {
            let result = new FieldGeoPoint();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldLong") {
            let result = new FieldLong();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldSingleFieldset") {
            let result = new FieldSingleFieldset();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldMultiFieldset") {
            let result = new FieldMultiFieldset();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldSingleTagbox") {
            let result = new FieldSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldMultiTagbox") {
            let result = new FieldMultiTagbox();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldString") {
            let result = new FieldString();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldTranslatedString") {
            let result = new FieldTranslatedString();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldSingleRelation") {
            let result = new FieldSingleRelation();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "FieldMultiRelation") {
            let result = new FieldMultiRelation();
            result.init(data);
            return result;
        }
        let result = new FieldBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Id"] = this.id;
        data["IndexId"] = this.indexId;
        data["FieldNamespace"] = this.fieldNamespace;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Required"] = this.required;
        data["Fixed"] = this.fixed;
        data["Index"] = this.index;
        data["SimpleSearch"] = this.simpleSearch;
        data["Boost"] = this.boost;
        return data; 
    }
}

/** The field base class. */
export interface IFieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string | undefined;
    /** The index id is auto generated by the system. */
    indexId?: string | undefined;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldBoolean extends FieldBase implements IFieldBoolean {

    constructor(data?: IFieldBoolean) {
        super(data);
        this._discriminator = "FieldBoolean";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): FieldBoolean {
        let result = new FieldBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldBoolean extends IFieldBase {
}

export class FieldDate extends FieldBase implements IFieldDate {
    /** Defines the date format structure. */
    format?: string | undefined;

    constructor(data?: IFieldDate) {
        super(data);
        this._discriminator = "FieldDate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["Format"];
        }
    }

    static fromJS(data: any): FieldDate {
        let result = new FieldDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Format"] = this.format;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDate extends IFieldBase {
    /** Defines the date format structure. */
    format?: string | undefined;
}

export class FieldDateTime extends FieldBase implements IFieldDateTime {
    /** Defines the date time format structure. */
    format?: string | undefined;

    constructor(data?: IFieldDateTime) {
        super(data);
        this._discriminator = "FieldDateTime";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["Format"];
        }
    }

    static fromJS(data: any): FieldDateTime {
        if (data["Kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        let result = new FieldDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Format"] = this.format;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDateTime extends IFieldBase {
    /** Defines the date time format structure. */
    format?: string | undefined;
}

/** For internal use only (system schemas) */
export class FieldDateTimeArray extends FieldDateTime implements IFieldDateTimeArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldDateTimeArray) {
        super(data);
        this._discriminator = "FieldDateTimeArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
        }
    }

    static fromJS(data: any): FieldDateTimeArray {
        let result = new FieldDateTimeArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDateTimeArray extends IFieldDateTime {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldDecimal extends FieldBase implements IFieldDecimal {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;

    constructor(data?: IFieldDecimal) {
        super(data);
        this._discriminator = "FieldDecimal";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["Pattern"];
            this.minimum = data["Minimum"];
            this.maximum = data["Maximum"];
        }
    }

    static fromJS(data: any): FieldDecimal {
        let result = new FieldDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Pattern"] = this.pattern;
        data["Minimum"] = this.minimum;
        data["Maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDecimal extends IFieldBase {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;
}

/** For internal use only (system schemas) */
export class FieldDictionary extends FieldBase implements IFieldDictionary {

    constructor(data?: IFieldDictionary) {
        super(data);
        this._discriminator = "FieldDictionary";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): FieldDictionary {
        if (data["Kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        let result = new FieldDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDictionary extends IFieldBase {
}

/** For internal use only (system schemas) */
export class FieldDictionaryArray extends FieldDictionary implements IFieldDictionaryArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldDictionaryArray) {
        super(data);
        this._discriminator = "FieldDictionaryArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
        }
    }

    static fromJS(data: any): FieldDictionaryArray {
        let result = new FieldDictionaryArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDictionaryArray extends IFieldDictionary {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldGeoPoint extends FieldBase implements IFieldGeoPoint {

    constructor(data?: IFieldGeoPoint) {
        super(data);
        this._discriminator = "FieldGeoPoint";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): FieldGeoPoint {
        let result = new FieldGeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldGeoPoint extends IFieldBase {
}

export class FieldLong extends FieldBase implements IFieldLong {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;

    constructor(data?: IFieldLong) {
        super(data);
        this._discriminator = "FieldLong";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["Pattern"];
            this.minimum = data["Minimum"];
            this.maximum = data["Maximum"];
        }
    }

    static fromJS(data: any): FieldLong {
        if (data["Kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        let result = new FieldLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Pattern"] = this.pattern;
        data["Minimum"] = this.minimum;
        data["Maximum"] = this.maximum;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldLong extends IFieldBase {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;
}

/** For internal use only (system schemas) */
export class FieldLongArray extends FieldLong implements IFieldLongArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldLongArray) {
        super(data);
        this._discriminator = "FieldLongArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
        }
    }

    static fromJS(data: any): FieldLongArray {
        let result = new FieldLongArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldLongArray extends IFieldLong {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldSingleFieldset extends FieldBase implements IFieldSingleFieldset {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;

    constructor(data?: IFieldSingleFieldset) {
        super(data);
        this._discriminator = "FieldSingleFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            this.maxRecursion = data["MaxRecursion"];
        }
    }

    static fromJS(data: any): FieldSingleFieldset {
        let result = new FieldSingleFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        data["MaxRecursion"] = this.maxRecursion;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleFieldset extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
}

export class FieldMultiFieldset extends FieldBase implements IFieldMultiFieldset {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiFieldset) {
        super(data);
        this._discriminator = "FieldMultiFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            this.maxRecursion = data["MaxRecursion"];
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiFieldset {
        let result = new FieldMultiFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        data["MaxRecursion"] = this.maxRecursion;
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiFieldset extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number | undefined;
}

export class FieldSingleTagbox extends FieldBase implements IFieldSingleTagbox {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFieldSingleTagbox) {
        super(data);
        this._discriminator = "FieldSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            this.maxRecursion = data["MaxRecursion"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldSingleTagbox {
        let result = new FieldSingleTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        data["MaxRecursion"] = this.maxRecursion;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleTagbox extends IFieldBase {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
}

export class FieldMultiTagbox extends FieldBase implements IFieldMultiTagbox {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible item count. */
    minimumItems?: number | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFieldMultiTagbox) {
        super(data);
        this._discriminator = "FieldMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            this.maxRecursion = data["MaxRecursion"];
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldMultiTagbox {
        let result = new FieldMultiTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        data["MaxRecursion"] = this.maxRecursion;
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiTagbox extends IFieldBase {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible item count. */
    minimumItems?: number | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
}

export class FieldString extends FieldBase implements IFieldString {
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[] | undefined;

    constructor(data?: IFieldString) {
        super(data);
        this._discriminator = "FieldString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.template = data["Template"];
            this.keepFieldValue = data["KeepFieldValue"];
            this.pattern = data["Pattern"];
            this.minimumLength = data["MinimumLength"];
            this.maximumLength = data["MaximumLength"];
            if (data["Analyzers"] && data["Analyzers"].constructor === Array) {
                this.analyzers = [];
                for (let item of data["Analyzers"])
                    this.analyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["MultiLine"];
            if (data["GrantedValues"] && data["GrantedValues"].constructor === Array) {
                this.grantedValues = [];
                for (let item of data["GrantedValues"])
                    this.grantedValues.push(item);
            }
        }
    }

    static fromJS(data: any): FieldString {
        if (data["Kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        let result = new FieldString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Template"] = this.template;
        data["KeepFieldValue"] = this.keepFieldValue;
        data["Pattern"] = this.pattern;
        data["MinimumLength"] = this.minimumLength;
        data["MaximumLength"] = this.maximumLength;
        if (this.analyzers && this.analyzers.constructor === Array) {
            data["Analyzers"] = [];
            for (let item of this.analyzers)
                data["Analyzers"].push(item.toJSON());
        }
        data["MultiLine"] = this.multiLine;
        if (this.grantedValues && this.grantedValues.constructor === Array) {
            data["GrantedValues"] = [];
            for (let item of this.grantedValues)
                data["GrantedValues"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldString extends IFieldBase {
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[] | undefined;
}

/** The analyzer base class. */
export class AnalyzerBase implements IAnalyzerBase {
    /** The suffix for the analyzed field, e.g. .simple. */
    fieldSuffix?: string | undefined;
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;

    protected _discriminator: string;

    constructor(data?: IAnalyzerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AnalyzerBase";
    }

    init(data?: any) {
        if (data) {
            this.fieldSuffix = data["FieldSuffix"];
            this.simpleSearch = data["SimpleSearch"];
        }
    }

    static fromJS(data: any): AnalyzerBase {
        if (data["Kind"] === "EdgeNGramAnalyzer") {
            let result = new EdgeNGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "LanguageAnalyzer") {
            let result = new LanguageAnalyzer();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "NGramAnalyzer") {
            let result = new NGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "PathHierarchyAnalyzer") {
            let result = new PathHierarchyAnalyzer();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "SimpleAnalyzer") {
            let result = new SimpleAnalyzer();
            result.init(data);
            return result;
        }
        let result = new AnalyzerBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["FieldSuffix"] = this.fieldSuffix;
        data["SimpleSearch"] = this.simpleSearch;
        return data; 
    }
}

/** The analyzer base class. */
export interface IAnalyzerBase {
    /** The suffix for the analyzed field, e.g. .simple. */
    fieldSuffix?: string | undefined;
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export class EdgeNGramAnalyzer extends AnalyzerBase implements IEdgeNGramAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: IEdgeNGramAnalyzer) {
        super(data);
        this._discriminator = "EdgeNGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["FieldSuffix"];
        }
    }

    static fromJS(data: any): EdgeNGramAnalyzer {
        let result = new EdgeNGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export interface IEdgeNGramAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export class LanguageAnalyzer extends AnalyzerBase implements ILanguageAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: ILanguageAnalyzer) {
        super(data);
        this._discriminator = "LanguageAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["FieldSuffix"];
        }
    }

    static fromJS(data: any): LanguageAnalyzer {
        let result = new LanguageAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export interface ILanguageAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export class NGramAnalyzer extends AnalyzerBase implements INGramAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: INGramAnalyzer) {
        super(data);
        this._discriminator = "NGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["FieldSuffix"];
        }
    }

    static fromJS(data: any): NGramAnalyzer {
        let result = new NGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export interface INGramAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export class PathHierarchyAnalyzer extends AnalyzerBase implements IPathHierarchyAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: IPathHierarchyAnalyzer) {
        super(data);
        this._discriminator = "PathHierarchyAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["FieldSuffix"];
        }
    }

    static fromJS(data: any): PathHierarchyAnalyzer {
        let result = new PathHierarchyAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export interface IPathHierarchyAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export class SimpleAnalyzer extends AnalyzerBase implements ISimpleAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: ISimpleAnalyzer) {
        super(data);
        this._discriminator = "SimpleAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["FieldSuffix"];
        }
    }

    static fromJS(data: any): SimpleAnalyzer {
        let result = new SimpleAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export interface ISimpleAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** For internal use only (system schemas) */
export class FieldStringArray extends FieldString implements IFieldStringArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldStringArray) {
        super(data);
        this._discriminator = "FieldStringArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
        }
    }

    static fromJS(data: any): FieldStringArray {
        let result = new FieldStringArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldStringArray extends IFieldString {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldTranslatedString extends FieldBase implements IFieldTranslatedString {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[] | undefined;
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;

    constructor(data?: IFieldTranslatedString) {
        super(data);
        this._discriminator = "FieldTranslatedString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["Pattern"];
            this.minimumLength = data["MinimumLength"];
            this.maximumLength = data["MaximumLength"];
            if (data["Analyzers"] && data["Analyzers"].constructor === Array) {
                this.analyzers = [];
                for (let item of data["Analyzers"])
                    this.analyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["MultiLine"];
            if (data["RequiredMetadataLanguages"] && data["RequiredMetadataLanguages"].constructor === Array) {
                this.requiredMetadataLanguages = [];
                for (let item of data["RequiredMetadataLanguages"])
                    this.requiredMetadataLanguages.push(item);
            }
            this.template = data["Template"];
            this.keepFieldValue = data["KeepFieldValue"];
        }
    }

    static fromJS(data: any): FieldTranslatedString {
        let result = new FieldTranslatedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Pattern"] = this.pattern;
        data["MinimumLength"] = this.minimumLength;
        data["MaximumLength"] = this.maximumLength;
        if (this.analyzers && this.analyzers.constructor === Array) {
            data["Analyzers"] = [];
            for (let item of this.analyzers)
                data["Analyzers"].push(item.toJSON());
        }
        data["MultiLine"] = this.multiLine;
        if (this.requiredMetadataLanguages && this.requiredMetadataLanguages.constructor === Array) {
            data["RequiredMetadataLanguages"] = [];
            for (let item of this.requiredMetadataLanguages)
                data["RequiredMetadataLanguages"].push(item);
        }
        data["Template"] = this.template;
        data["KeepFieldValue"] = this.keepFieldValue;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldTranslatedString extends IFieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[] | undefined;
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
}

export class FieldSingleRelation extends FieldBase implements IFieldSingleRelation {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[] | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;

    constructor(data?: IFieldSingleRelation) {
        super(data);
        this._discriminator = "FieldSingleRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            if (data["RelationTypes"] && data["RelationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["RelationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
            this.maxRecursion = data["MaxRecursion"];
        }
    }

    static fromJS(data: any): FieldSingleRelation {
        let result = new FieldSingleRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["RelationTypes"] = [];
            for (let item of this.relationTypes)
                data["RelationTypes"].push(item.toJSON());
        }
        data["MaxRecursion"] = this.maxRecursion;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleRelation extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[] | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
}

export class RelationType implements IRelationType {
    /** The id property. */
    id?: string | undefined;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines the valid target context. */
    targetContext: TargetContext;
    /** The id of the schema. Limits the content or the list item result set depending on the relation's target context. */
    schemaId?: string | undefined;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase | undefined;

    constructor(data?: IRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.targetContext = data["TargetContext"];
            this.schemaId = data["SchemaId"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RelationType {
        let result = new RelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["TargetContext"] = this.targetContext;
        data["SchemaId"] = this.schemaId;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRelationType {
    /** The id property. */
    id?: string | undefined;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines the valid target context. */
    targetContext: TargetContext;
    /** The id of the schema. Limits the content or the list item result set depending on the relation's target context. */
    schemaId?: string | undefined;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase | undefined;
}

export enum TargetContext {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    User = <any>"User", 
    Custom = <any>"Custom", 
}

export class FieldMultiRelation extends FieldBase implements IFieldMultiRelation {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[] | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Dfines the lowest possible item count. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiRelation) {
        super(data);
        this._discriminator = "FieldMultiRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["SchemaId"];
            if (data["RelationTypes"] && data["RelationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["RelationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
            this.maxRecursion = data["MaxRecursion"];
            this.uniqueItems = data["UniqueItems"];
            this.maximumItems = data["MaximumItems"];
            this.minimumItems = data["MinimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiRelation {
        let result = new FieldMultiRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SchemaId"] = this.schemaId;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["RelationTypes"] = [];
            for (let item of this.relationTypes)
                data["RelationTypes"].push(item.toJSON());
        }
        data["MaxRecursion"] = this.maxRecursion;
        data["UniqueItems"] = this.uniqueItems;
        data["MaximumItems"] = this.maximumItems;
        data["MinimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiRelation extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[] | undefined;
    /** Avoids cyclic dependencies and limits the elastic search index and json schema depth. */
    maxRecursion: number;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Dfines the lowest possible item count. */
    minimumItems?: number | undefined;
}

export class ExistsResponse implements IExistsResponse {
    exists: boolean;

    constructor(data?: IExistsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exists = data["Exists"];
        }
    }

    static fromJS(data: any): ExistsResponse {
        let result = new ExistsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Exists"] = this.exists;
        return data; 
    }
}

export interface IExistsResponse {
    exists: boolean;
}

export class SchemaCreateRequest implements ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.parentSchemaId = data["ParentSchemaId"];
            if (data["Types"] && data["Types"].constructor === Array) {
                this.types = [];
                for (let item of data["Types"])
                    this.types.push(item);
            }
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.descriptions = data["Descriptions"] ? TranslatedStringDictionary.fromJS(data["Descriptions"]) : <any>undefined;
            if (data["DisplayPatterns"] && data["DisplayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["DisplayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["Fields"] && data["Fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["Fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["Aggregations"] && data["Aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["Aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["SortOrder"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["Public"];
            if (data["SchemaPermissionSetIds"] && data["SchemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["SchemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["ReferencedInContentSchemaIds"] && data["ReferencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["ReferencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaCreateRequest {
        let result = new SchemaCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ParentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["Types"] = [];
            for (let item of this.types)
                data["Types"].push(item);
        }
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["DisplayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["DisplayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["Fields"] = [];
            for (let item of this.fields)
                data["Fields"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["Aggregations"] = [];
            for (let item of this.aggregations)
                data["Aggregations"].push(item.toJSON());
        }
        data["SortOrder"] = this.sortOrder;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["SchemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["SchemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["ReferencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["ReferencedInContentSchemaIds"].push(item);
        }
        return data; 
    }
}

export interface ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

export class SchemaUpdateRequest implements ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;

    constructor(data?: ISchemaUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.descriptions = data["Descriptions"] ? TranslatedStringDictionary.fromJS(data["Descriptions"]) : <any>undefined;
            if (data["DisplayPatterns"] && data["DisplayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["DisplayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["Fields"] && data["Fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["Fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["Aggregations"] && data["Aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["Aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["SortOrder"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["Public"];
            if (data["SchemaPermissionSetIds"] && data["SchemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["SchemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["ReferencedInContentSchemaIds"] && data["ReferencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["ReferencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["Types"] && data["Types"].constructor === Array) {
                this.types = [];
                for (let item of data["Types"])
                    this.types.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaUpdateRequest {
        let result = new SchemaUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["DisplayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["DisplayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["Fields"] = [];
            for (let item of this.fields)
                data["Fields"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["Aggregations"] = [];
            for (let item of this.aggregations)
                data["Aggregations"].push(item.toJSON());
        }
        data["SortOrder"] = this.sortOrder;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["SchemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["SchemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["ReferencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["ReferencedInContentSchemaIds"].push(item);
        }
        if (this.types && this.types.constructor === Array) {
            data["Types"] = [];
            for (let item of this.types)
                data["Types"].push(item);
        }
        return data; 
    }
}

export interface ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;
}

export class SchemaSearchRequest implements ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;

    constructor(data?: ISchemaSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["Start"];
            this.limit = data["Limit"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaSearchRequest {
        let result = new SchemaSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Start"] = this.start;
        data["Limit"] = this.limit;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;
}

export class BaseResultOfSchemaViewItem implements IBaseResultOfSchemaViewItem {
    totalResults: number;
    results?: SchemaViewItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfSchemaViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(SchemaViewItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfSchemaViewItem {
        let result = new BaseResultOfSchemaViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfSchemaViewItem {
    totalResults: number;
    results?: SchemaViewItem[] | undefined;
    pageToken?: string | undefined;
}

export class SchemaViewItem implements ISchemaViewItem {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;

    constructor(data?: ISchemaViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.parentSchemaId = data["ParentSchemaId"];
            if (data["Types"] && data["Types"].constructor === Array) {
                this.types = [];
                for (let item of data["Types"])
                    this.types.push(item);
            }
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.descriptions = data["Descriptions"] ? TranslatedStringDictionary.fromJS(data["Descriptions"]) : <any>undefined;
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.fieldCount = data["FieldCount"];
            this.childCount = data["ChildCount"];
            this.level = data["Level"];
            this.system = data["System"];
        }
    }

    static fromJS(data: any): SchemaViewItem {
        let result = new SchemaViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ParentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["Types"] = [];
            for (let item of this.types)
                data["Types"].push(item);
        }
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        data["FieldCount"] = this.fieldCount;
        data["ChildCount"] = this.childCount;
        data["Level"] = this.level;
        data["System"] = this.system;
        return data; 
    }
}

export interface ISchemaViewItem {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;
}

export class PermissionSetSearchRequest implements IPermissionSetSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: IPermissionSetSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["Start"];
            this.limit = data["Limit"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionSetSearchRequest {
        let result = new PermissionSetSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Start"] = this.start;
        data["Limit"] = this.limit;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPermissionSetSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfPermissionSetViewItem implements IBaseResultOfPermissionSetViewItem {
    totalResults: number;
    results?: PermissionSetViewItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfPermissionSetViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(PermissionSetViewItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfPermissionSetViewItem {
        let result = new BaseResultOfPermissionSetViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfPermissionSetViewItem {
    totalResults: number;
    results?: PermissionSetViewItem[] | undefined;
    pageToken?: string | undefined;
}

export class PermissionSetSearchResult extends BaseResultOfPermissionSetViewItem implements IPermissionSetSearchResult {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;

    constructor(data?: IPermissionSetSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["AggregationResults"] && data["AggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["AggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
            this.elapsedMilliseconds = data["ElapsedMilliseconds"];
        }
    }

    static fromJS(data: any): PermissionSetSearchResult {
        let result = new PermissionSetSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["AggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["AggregationResults"].push(item.toJSON());
        }
        data["ElapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionSetSearchResult extends IBaseResultOfPermissionSetViewItem {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;
}

export class PermissionSetViewItem implements IPermissionSetViewItem {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;

    constructor(data?: IPermissionSetViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.trashed = data["Trashed"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionSetViewItem {
        let result = new PermissionSetViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Trashed"] = this.trashed;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPermissionSetViewItem {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;
}

export class PermissionSetDetailViewItemOfContentRight implements IPermissionSetDetailViewItemOfContentRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: UserRoleRightsViewItemOfContentRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsViewItemOfPermissionSetRight[] | undefined;
    exclusive: boolean;

    constructor(data?: IPermissionSetDetailViewItemOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.trashed = data["Trashed"];
            if (data["UserRolesRights"] && data["UserRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["UserRolesRights"])
                    this.userRolesRights.push(UserRoleRightsViewItemOfContentRight.fromJS(item));
            }
            if (data["UserRolesPermissionSetRights"] && data["UserRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["UserRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(UserRoleRightsViewItemOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["Exclusive"];
        }
    }

    static fromJS(data: any): PermissionSetDetailViewItemOfContentRight {
        let result = new PermissionSetDetailViewItemOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["UserRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["UserRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["UserRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["UserRolesPermissionSetRights"].push(item.toJSON());
        }
        data["Exclusive"] = this.exclusive;
        return data; 
    }
}

export interface IPermissionSetDetailViewItemOfContentRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: UserRoleRightsViewItemOfContentRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsViewItemOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export class ContentPermissionSetDetailViewItem extends PermissionSetDetailViewItemOfContentRight implements IContentPermissionSetDetailViewItem {

    constructor(data?: IContentPermissionSetDetailViewItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ContentPermissionSetDetailViewItem {
        let result = new ContentPermissionSetDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IContentPermissionSetDetailViewItem extends IPermissionSetDetailViewItemOfContentRight {
}

export class UserRoleRightsViewItemOfContentRight implements IUserRoleRightsViewItemOfContentRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;

    constructor(data?: IUserRoleRightsViewItemOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["UserRoleId"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            if (data["Rights"] && data["Rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["Rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleRightsViewItemOfContentRight {
        let result = new UserRoleRightsViewItemOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRoleId"] = this.userRoleId;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["Rights"] = [];
            for (let item of this.rights)
                data["Rights"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleRightsViewItemOfContentRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;
}

export enum ContentRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Update = <any>"Update", 
    Manage = <any>"Manage", 
    Trash = <any>"Trash", 
}

export class UserRoleRightsViewItemOfPermissionSetRight implements IUserRoleRightsViewItemOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IUserRoleRightsViewItemOfPermissionSetRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["UserRoleId"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            if (data["Rights"] && data["Rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["Rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleRightsViewItemOfPermissionSetRight {
        let result = new UserRoleRightsViewItemOfPermissionSetRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRoleId"] = this.userRoleId;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["Rights"] = [];
            for (let item of this.rights)
                data["Rights"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleRightsViewItemOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;
}

export enum PermissionSetRight {
    Apply = <any>"Apply", 
}

export class PermissionSetDetailViewItemOfMetadataRight implements IPermissionSetDetailViewItemOfMetadataRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: UserRoleRightsViewItemOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsViewItemOfPermissionSetRight[] | undefined;
    exclusive: boolean;

    constructor(data?: IPermissionSetDetailViewItemOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.trashed = data["Trashed"];
            if (data["UserRolesRights"] && data["UserRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["UserRolesRights"])
                    this.userRolesRights.push(UserRoleRightsViewItemOfMetadataRight.fromJS(item));
            }
            if (data["UserRolesPermissionSetRights"] && data["UserRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["UserRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(UserRoleRightsViewItemOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["Exclusive"];
        }
    }

    static fromJS(data: any): PermissionSetDetailViewItemOfMetadataRight {
        let result = new PermissionSetDetailViewItemOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["UserRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["UserRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["UserRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["UserRolesPermissionSetRights"].push(item.toJSON());
        }
        data["Exclusive"] = this.exclusive;
        return data; 
    }
}

export interface IPermissionSetDetailViewItemOfMetadataRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: UserRoleRightsViewItemOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsViewItemOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export class SchemaPermissionSetDetailViewItem extends PermissionSetDetailViewItemOfMetadataRight implements ISchemaPermissionSetDetailViewItem {

    constructor(data?: ISchemaPermissionSetDetailViewItem) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaPermissionSetDetailViewItem {
        let result = new SchemaPermissionSetDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaPermissionSetDetailViewItem extends IPermissionSetDetailViewItemOfMetadataRight {
}

export class UserRoleRightsViewItemOfMetadataRight implements IUserRoleRightsViewItemOfMetadataRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;

    constructor(data?: IUserRoleRightsViewItemOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["UserRoleId"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            if (data["Rights"] && data["Rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["Rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleRightsViewItemOfMetadataRight {
        let result = new UserRoleRightsViewItemOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRoleId"] = this.userRoleId;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["Rights"] = [];
            for (let item of this.rights)
                data["Rights"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleRightsViewItemOfMetadataRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;
}

export enum MetadataRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Manage = <any>"Manage", 
}

export class ShareBaseDetailViewItem implements IShareBaseDetailViewItem {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
    contentSelections?: ContentDetailViewItem[] | undefined;
    templateId?: string | undefined;
    expirationDate?: Date | undefined;

    protected _discriminator: string;

    constructor(data?: IShareBaseDetailViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBaseDetailViewItem";
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.description = data["Description"];
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.entityType = data["EntityType"];
            if (data["ContentSelections"] && data["ContentSelections"].constructor === Array) {
                this.contentSelections = [];
                for (let item of data["ContentSelections"])
                    this.contentSelections.push(ContentDetailViewItem.fromJS(item));
            }
            this.templateId = data["TemplateId"];
            this.expirationDate = data["ExpirationDate"] ? new Date(data["ExpirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShareBaseDetailViewItem {
        if (data["Kind"] === "ShareBasicDetailViewItem") {
            let result = new ShareBasicDetailViewItem();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ShareEmbedDetailViewItem") {
            let result = new ShareEmbedDetailViewItem();
            result.init(data);
            return result;
        }
        let result = new ShareBaseDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["EntityType"] = this.entityType;
        if (this.contentSelections && this.contentSelections.constructor === Array) {
            data["ContentSelections"] = [];
            for (let item of this.contentSelections)
                data["ContentSelections"].push(item.toJSON());
        }
        data["TemplateId"] = this.templateId;
        data["ExpirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IShareBaseDetailViewItem {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
    contentSelections?: ContentDetailViewItem[] | undefined;
    templateId?: string | undefined;
    expirationDate?: Date | undefined;
}

export class ContentDetailViewItem implements IContentDetailViewItem {
    contentTypeId: number;
    trashed: boolean;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: DataDictionary | undefined;
    metadata?: DataDictionary | undefined;
    id?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    outputs?: OutputViewItem[] | undefined;
    audit?: StoreAudit | undefined;
    ownerTokenId?: string | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;

    constructor(data?: IContentDetailViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentTypeId = data["ContentTypeId"];
            this.trashed = data["Trashed"];
            this.entityType = data["EntityType"];
            this.contentSchemaId = data["ContentSchemaId"];
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["Content"] ? DataDictionary.fromJS(data["Content"]) : <any>undefined;
            this.metadata = data["Metadata"] ? DataDictionary.fromJS(data["Metadata"]) : <any>undefined;
            this.id = data["Id"];
            if (data["ContentPermissionSetIds"] && data["ContentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["ContentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
            if (data["Outputs"] && data["Outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["Outputs"])
                    this.outputs.push(OutputViewItem.fromJS(item));
            }
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.ownerTokenId = data["OwnerTokenId"];
            this.contentType = data["ContentType"];
            this.displayValues = data["DisplayValues"] ? DisplayValueViewItem.fromJS(data["DisplayValues"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentDetailViewItem {
        let result = new ContentDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentTypeId"] = this.contentTypeId;
        data["Trashed"] = this.trashed;
        data["EntityType"] = this.entityType;
        data["ContentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        data["Content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["Id"] = this.id;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["ContentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["ContentPermissionSetIds"].push(item);
        }
        if (this.outputs && this.outputs.constructor === Array) {
            data["Outputs"] = [];
            for (let item of this.outputs)
                data["Outputs"].push(item.toJSON());
        }
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["OwnerTokenId"] = this.ownerTokenId;
        data["ContentType"] = this.contentType;
        data["DisplayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentDetailViewItem {
    contentTypeId: number;
    trashed: boolean;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: DataDictionary | undefined;
    metadata?: DataDictionary | undefined;
    id?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    outputs?: OutputViewItem[] | undefined;
    audit?: StoreAudit | undefined;
    ownerTokenId?: string | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueViewItem | undefined;
}

export class ShareBasicDetailViewItem extends ShareBaseDetailViewItem implements IShareBasicDetailViewItem {
    mailRecipients?: MailRecipientViewItem[] | undefined;
    internalRecipients?: InternalRecipientViewItem[] | undefined;
    languageCode?: string | undefined;

    constructor(data?: IShareBasicDetailViewItem) {
        super(data);
        this._discriminator = "ShareBasicDetailViewItem";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["MailRecipients"] && data["MailRecipients"].constructor === Array) {
                this.mailRecipients = [];
                for (let item of data["MailRecipients"])
                    this.mailRecipients.push(MailRecipientViewItem.fromJS(item));
            }
            if (data["InternalRecipients"] && data["InternalRecipients"].constructor === Array) {
                this.internalRecipients = [];
                for (let item of data["InternalRecipients"])
                    this.internalRecipients.push(InternalRecipientViewItem.fromJS(item));
            }
            this.languageCode = data["LanguageCode"];
        }
    }

    static fromJS(data: any): ShareBasicDetailViewItem {
        let result = new ShareBasicDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.mailRecipients && this.mailRecipients.constructor === Array) {
            data["MailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["MailRecipients"].push(item.toJSON());
        }
        if (this.internalRecipients && this.internalRecipients.constructor === Array) {
            data["InternalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["InternalRecipients"].push(item.toJSON());
        }
        data["LanguageCode"] = this.languageCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicDetailViewItem extends IShareBaseDetailViewItem {
    mailRecipients?: MailRecipientViewItem[] | undefined;
    internalRecipients?: InternalRecipientViewItem[] | undefined;
    languageCode?: string | undefined;
}

export class MailRecipientViewItem implements IMailRecipientViewItem {
    userEmail?: UserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMailRecipientViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userEmail = data["UserEmail"] ? UserEmail.fromJS(data["UserEmail"]) : <any>undefined;
            this.token = data["Token"];
            this.url = data["Url"];
        }
    }

    static fromJS(data: any): MailRecipientViewItem {
        let result = new MailRecipientViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserEmail"] = this.userEmail ? this.userEmail.toJSON() : <any>undefined;
        data["Token"] = this.token;
        data["Url"] = this.url;
        return data; 
    }
}

export interface IMailRecipientViewItem {
    userEmail?: UserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class UserEmail implements IUserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["FirstName"];
            this.lastName = data["LastName"];
            this.emailAddress = data["EmailAddress"];
        }
    }

    static fromJS(data: any): UserEmail {
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["EmailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export class InternalRecipientViewItem implements IInternalRecipientViewItem {
    recipient?: UserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IInternalRecipientViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recipient = data["Recipient"] ? UserItem.fromJS(data["Recipient"]) : <any>undefined;
            this.token = data["Token"];
            this.url = data["Url"];
        }
    }

    static fromJS(data: any): InternalRecipientViewItem {
        let result = new InternalRecipientViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["Token"] = this.token;
        data["Url"] = this.url;
        return data; 
    }
}

export interface IInternalRecipientViewItem {
    recipient?: UserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class ShareEmbedDetailViewItem extends ShareBaseDetailViewItem implements IShareEmbedDetailViewItem {
    embedContentItems?: EmbedContentViewItem[] | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IShareEmbedDetailViewItem) {
        super(data);
        this._discriminator = "ShareEmbedDetailViewItem";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["EmbedContentItems"] && data["EmbedContentItems"].constructor === Array) {
                this.embedContentItems = [];
                for (let item of data["EmbedContentItems"])
                    this.embedContentItems.push(EmbedContentViewItem.fromJS(item));
            }
            this.token = data["Token"];
            this.url = data["Url"];
        }
    }

    static fromJS(data: any): ShareEmbedDetailViewItem {
        let result = new ShareEmbedDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.embedContentItems && this.embedContentItems.constructor === Array) {
            data["EmbedContentItems"] = [];
            for (let item of this.embedContentItems)
                data["EmbedContentItems"].push(item.toJSON());
        }
        data["Token"] = this.token;
        data["Url"] = this.url;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedDetailViewItem extends IShareBaseDetailViewItem {
    embedContentItems?: EmbedContentViewItem[] | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class EmbedContentViewItem implements IEmbedContentViewItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IEmbedContentViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["ContentId"];
            this.outputFormatId = data["OutputFormatId"];
            this.token = data["Token"];
            this.url = data["Url"];
        }
    }

    static fromJS(data: any): EmbedContentViewItem {
        let result = new EmbedContentViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        data["OutputFormatId"] = this.outputFormatId;
        data["Token"] = this.token;
        data["Url"] = this.url;
        return data; 
    }
}

export interface IEmbedContentViewItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class ShareAggregationRequest implements IShareAggregationRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;

    constructor(data?: IShareAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            if (data["AggregationFilters"] && data["AggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["AggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["Aggregators"] && data["Aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["Aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.displayLanguage = data["DisplayLanguage"];
        }
    }

    static fromJS(data: any): ShareAggregationRequest {
        let result = new ShareAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["AggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["AggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["Aggregators"] = [];
            for (let item of this.aggregators)
                data["Aggregators"].push(item.toJSON());
        }
        data["DisplayLanguage"] = this.displayLanguage;
        return data; 
    }
}

export interface IShareAggregationRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;
}

export class ShareBaseCreateRequest implements IShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: ShareContent[] | undefined;

    protected _discriminator: string;

    constructor(data?: IShareBaseCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBaseCreateRequest";
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.description = data["Description"];
            this.expirationDate = data["ExpirationDate"] ? new Date(data["ExpirationDate"].toString()) : <any>undefined;
            if (data["Contents"] && data["Contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["Contents"])
                    this.contents.push(ShareContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShareBaseCreateRequest {
        if (data["Kind"] === "ShareBasicCreateRequest") {
            let result = new ShareBasicCreateRequest();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ShareEmbedCreateRequest") {
            let result = new ShareEmbedCreateRequest();
            result.init(data);
            return result;
        }
        let result = new ShareBaseCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ExpirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (this.contents && this.contents.constructor === Array) {
            data["Contents"] = [];
            for (let item of this.contents)
                data["Contents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: ShareContent[] | undefined;
}

export class ShareContent implements IShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;

    constructor(data?: IShareContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["ContentId"];
            if (data["OutputFormatIds"] && data["OutputFormatIds"].constructor === Array) {
                this.outputFormatIds = [];
                for (let item of data["OutputFormatIds"])
                    this.outputFormatIds.push(item);
            }
        }
    }

    static fromJS(data: any): ShareContent {
        let result = new ShareContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentId"] = this.contentId;
        if (this.outputFormatIds && this.outputFormatIds.constructor === Array) {
            data["OutputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["OutputFormatIds"].push(item);
        }
        return data; 
    }
}

export interface IShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;
}

export class ShareBasicCreateRequest extends ShareBaseCreateRequest implements IShareBasicCreateRequest {
    recipientsEmail?: UserEmail[] | undefined;
    recipientsUser?: UserItem[] | undefined;
    recipientsGroup?: UserRoleViewItem[] | undefined;
    templateId?: string | undefined;

    constructor(data?: IShareBasicCreateRequest) {
        super(data);
        this._discriminator = "ShareBasicCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["RecipientsEmail"] && data["RecipientsEmail"].constructor === Array) {
                this.recipientsEmail = [];
                for (let item of data["RecipientsEmail"])
                    this.recipientsEmail.push(UserEmail.fromJS(item));
            }
            if (data["RecipientsUser"] && data["RecipientsUser"].constructor === Array) {
                this.recipientsUser = [];
                for (let item of data["RecipientsUser"])
                    this.recipientsUser.push(UserItem.fromJS(item));
            }
            if (data["RecipientsGroup"] && data["RecipientsGroup"].constructor === Array) {
                this.recipientsGroup = [];
                for (let item of data["RecipientsGroup"])
                    this.recipientsGroup.push(UserRoleViewItem.fromJS(item));
            }
            this.templateId = data["TemplateId"];
        }
    }

    static fromJS(data: any): ShareBasicCreateRequest {
        let result = new ShareBasicCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.recipientsEmail && this.recipientsEmail.constructor === Array) {
            data["RecipientsEmail"] = [];
            for (let item of this.recipientsEmail)
                data["RecipientsEmail"].push(item.toJSON());
        }
        if (this.recipientsUser && this.recipientsUser.constructor === Array) {
            data["RecipientsUser"] = [];
            for (let item of this.recipientsUser)
                data["RecipientsUser"].push(item.toJSON());
        }
        if (this.recipientsGroup && this.recipientsGroup.constructor === Array) {
            data["RecipientsGroup"] = [];
            for (let item of this.recipientsGroup)
                data["RecipientsGroup"].push(item.toJSON());
        }
        data["TemplateId"] = this.templateId;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicCreateRequest extends IShareBaseCreateRequest {
    recipientsEmail?: UserEmail[] | undefined;
    recipientsUser?: UserItem[] | undefined;
    recipientsGroup?: UserRoleViewItem[] | undefined;
    templateId?: string | undefined;
}

export class UserRoleViewItem implements IUserRoleViewItem {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;

    constructor(data?: IUserRoleViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.trashed = data["Trashed"];
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            if (data["UserRights"] && data["UserRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["UserRights"])
                    this.userRights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleViewItem {
        let result = new UserRoleViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Trashed"] = this.trashed;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.userRights && this.userRights.constructor === Array) {
            data["UserRights"] = [];
            for (let item of this.userRights)
                data["UserRights"].push(item);
        }
        return data; 
    }
}

export interface IUserRoleViewItem {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;
}

export enum UserRight {
    ManageContent = <any>"ManageContent", 
    ManageSharings = <any>"ManageSharings", 
    ManageDrives = <any>"ManageDrives", 
    ManageTransfer = <any>"ManageTransfer", 
    ManageAnalytics = <any>"ManageAnalytics", 
    ManageChannels = <any>"ManageChannels", 
    ManageSchemas = <any>"ManageSchemas", 
    ManageUsers = <any>"ManageUsers", 
    ManageUserRoles = <any>"ManageUserRoles", 
    ManagePermissions = <any>"ManagePermissions", 
    ManageSearchIndexes = <any>"ManageSearchIndexes", 
    ManageRecipients = <any>"ManageRecipients", 
    ManageCollections = <any>"ManageCollections", 
    ManageComments = <any>"ManageComments", 
    ManageListItems = <any>"ManageListItems", 
    ManageServiceProviders = <any>"ManageServiceProviders", 
}

export class ShareEmbedCreateRequest extends ShareBaseCreateRequest implements IShareEmbedCreateRequest {

    constructor(data?: IShareEmbedCreateRequest) {
        super(data);
        this._discriminator = "ShareEmbedCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedCreateRequest {
        let result = new ShareEmbedCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedCreateRequest extends IShareBaseCreateRequest {
}

export class CreateShareResult implements ICreateShareResult {
    shareId?: string | undefined;

    constructor(data?: ICreateShareResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shareId = data["ShareId"];
        }
    }

    static fromJS(data: any): CreateShareResult {
        let result = new CreateShareResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ShareId"] = this.shareId;
        return data; 
    }
}

export interface ICreateShareResult {
    shareId?: string | undefined;
}

export class BaseResultOfShareBaseViewItem implements IBaseResultOfShareBaseViewItem {
    totalResults: number;
    results?: ShareBaseViewItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfShareBaseViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(ShareBaseViewItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfShareBaseViewItem {
        let result = new BaseResultOfShareBaseViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfShareBaseViewItem {
    totalResults: number;
    results?: ShareBaseViewItem[] | undefined;
    pageToken?: string | undefined;
}

export class ShareBaseViewItem implements IShareBaseViewItem {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;

    protected _discriminator: string;

    constructor(data?: IShareBaseViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareBaseViewItem";
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            if (data["ContentIds"] && data["ContentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["ContentIds"])
                    this.contentIds.push(item);
            }
            this.id = data["Id"];
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.entityType = data["EntityType"];
        }
    }

    static fromJS(data: any): ShareBaseViewItem {
        if (data["Kind"] === "ShareBasicViewItem") {
            let result = new ShareBasicViewItem();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ShareEmbedViewItem") {
            let result = new ShareEmbedViewItem();
            result.init(data);
            return result;
        }
        let result = new ShareBaseViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Name"] = this.name;
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["ContentIds"] = [];
            for (let item of this.contentIds)
                data["ContentIds"].push(item);
        }
        data["Id"] = this.id;
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["EntityType"] = this.entityType;
        return data; 
    }
}

export interface IShareBaseViewItem {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: StoreAudit | undefined;
    entityType: EntityType;
}

export class ShareBasicViewItem extends ShareBaseViewItem implements IShareBasicViewItem {
    mailRecipients?: MailRecipientViewItem[] | undefined;
    internalRecipients?: InternalRecipientViewItem[] | undefined;
    description?: string | undefined;

    constructor(data?: IShareBasicViewItem) {
        super(data);
        this._discriminator = "ShareBasicViewItem";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["MailRecipients"] && data["MailRecipients"].constructor === Array) {
                this.mailRecipients = [];
                for (let item of data["MailRecipients"])
                    this.mailRecipients.push(MailRecipientViewItem.fromJS(item));
            }
            if (data["InternalRecipients"] && data["InternalRecipients"].constructor === Array) {
                this.internalRecipients = [];
                for (let item of data["InternalRecipients"])
                    this.internalRecipients.push(InternalRecipientViewItem.fromJS(item));
            }
            this.description = data["Description"];
        }
    }

    static fromJS(data: any): ShareBasicViewItem {
        let result = new ShareBasicViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.mailRecipients && this.mailRecipients.constructor === Array) {
            data["MailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["MailRecipients"].push(item.toJSON());
        }
        if (this.internalRecipients && this.internalRecipients.constructor === Array) {
            data["InternalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["InternalRecipients"].push(item.toJSON());
        }
        data["Description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicViewItem extends IShareBaseViewItem {
    mailRecipients?: MailRecipientViewItem[] | undefined;
    internalRecipients?: InternalRecipientViewItem[] | undefined;
    description?: string | undefined;
}

export class ShareEmbedViewItem extends ShareBaseViewItem implements IShareEmbedViewItem {

    constructor(data?: IShareEmbedViewItem) {
        super(data);
        this._discriminator = "ShareEmbedViewItem";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedViewItem {
        let result = new ShareEmbedViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedViewItem extends IShareBaseViewItem {
}

export class CreateTransferRequest implements ICreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: TransferUploadFile[] | undefined;
    driveFiles?: TransferDriveFile[] | undefined;
    webLinks?: TransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;

    constructor(data?: ICreateTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.transferType = data["TransferType"];
            if (data["Files"] && data["Files"].constructor === Array) {
                this.files = [];
                for (let item of data["Files"])
                    this.files.push(TransferUploadFile.fromJS(item));
            }
            if (data["DriveFiles"] && data["DriveFiles"].constructor === Array) {
                this.driveFiles = [];
                for (let item of data["DriveFiles"])
                    this.driveFiles.push(TransferDriveFile.fromJS(item));
            }
            if (data["WebLinks"] && data["WebLinks"].constructor === Array) {
                this.webLinks = [];
                for (let item of data["WebLinks"])
                    this.webLinks.push(TransferWebLink.fromJS(item));
            }
            this.collectionName = data["CollectionName"];
            this.createCollection = data["CreateCollection"];
        }
    }

    static fromJS(data: any): CreateTransferRequest {
        let result = new CreateTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["TransferType"] = this.transferType;
        if (this.files && this.files.constructor === Array) {
            data["Files"] = [];
            for (let item of this.files)
                data["Files"].push(item.toJSON());
        }
        if (this.driveFiles && this.driveFiles.constructor === Array) {
            data["DriveFiles"] = [];
            for (let item of this.driveFiles)
                data["DriveFiles"].push(item.toJSON());
        }
        if (this.webLinks && this.webLinks.constructor === Array) {
            data["WebLinks"] = [];
            for (let item of this.webLinks)
                data["WebLinks"].push(item.toJSON());
        }
        data["CollectionName"] = this.collectionName;
        data["CreateCollection"] = this.createCollection;
        return data; 
    }
}

export interface ICreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: TransferUploadFile[] | undefined;
    driveFiles?: TransferDriveFile[] | undefined;
    webLinks?: TransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;
}

export enum TransferType {
    FileUpload = <any>"FileUpload", 
    DriveImport = <any>"DriveImport", 
    DriveExport = <any>"DriveExport", 
    WebDownload = <any>"WebDownload", 
    SchemaImport = <any>"SchemaImport", 
}

export class TransferFile implements ITransferFile {
    identifier?: string | undefined;

    constructor(data?: ITransferFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.identifier = data["Identifier"];
        }
    }

    static fromJS(data: any): TransferFile {
        let result = new TransferFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Identifier"] = this.identifier;
        return data; 
    }
}

export interface ITransferFile {
    identifier?: string | undefined;
}

export class TransferUploadFile extends TransferFile implements ITransferUploadFile {
    fileName?: string | undefined;

    constructor(data?: ITransferUploadFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fileName = data["FileName"];
        }
    }

    static fromJS(data: any): TransferUploadFile {
        let result = new TransferUploadFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileName"] = this.fileName;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferUploadFile extends ITransferFile {
    fileName?: string | undefined;
}

export class TransferDriveFile extends TransferFile implements ITransferDriveFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;

    constructor(data?: ITransferDriveFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.driveId = data["DriveId"];
            this.fileId = data["FileId"];
            this.name = data["Name"];
            this.externalOutputFolderId = data["ExternalOutputFolderId"];
        }
    }

    static fromJS(data: any): TransferDriveFile {
        let result = new TransferDriveFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DriveId"] = this.driveId;
        data["FileId"] = this.fileId;
        data["Name"] = this.name;
        data["ExternalOutputFolderId"] = this.externalOutputFolderId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferDriveFile extends ITransferFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;
}

export class TransferWebLink extends TransferFile implements ITransferWebLink {
    url?: string | undefined;

    constructor(data?: ITransferWebLink) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.url = data["Url"];
        }
    }

    static fromJS(data: any): TransferWebLink {
        let result = new TransferWebLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Url"] = this.url;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferWebLink extends ITransferFile {
    url?: string | undefined;
}

export class TransferViewItem implements ITransferViewItem {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;

    constructor(data?: ITransferViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.state = data["State"];
            this.transferType = data["TransferType"];
            this.businessProcessId = data["BusinessProcessId"];
            this.fileTransferCount = data["FileTransferCount"];
        }
    }

    static fromJS(data: any): TransferViewItem {
        let result = new TransferViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["State"] = this.state;
        data["TransferType"] = this.transferType;
        data["BusinessProcessId"] = this.businessProcessId;
        data["FileTransferCount"] = this.fileTransferCount;
        return data; 
    }
}

export interface ITransferViewItem {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;
}

export enum TransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    ImportFailed = <any>"ImportFailed", 
    Created = <any>"Created", 
    UploadFailed = <any>"UploadFailed", 
    Deleted = <any>"Deleted", 
    TransferReady = <any>"TransferReady", 
    FileDeleteInProgress = <any>"FileDeleteInProgress", 
    TransferCleanup = <any>"TransferCleanup", 
}

export class TransferDetailViewItem implements ITransferDetailViewItem {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: StoreAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;

    constructor(data?: ITransferDetailViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.rev = data["Rev"];
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.name = data["Name"];
            this.state = data["State"];
            this.businessProcessId = data["BusinessProcessId"];
            this.transferType = data["TransferType"];
            this.itemProgress = data["ItemProgress"];
            this.itemCount = data["ItemCount"];
            this.itemsFailed = data["ItemsFailed"];
            this.itemsCancelled = data["ItemsCancelled"];
            this.lastProgressStamp = data["LastProgressStamp"];
            this.fileTransferCount = data["FileTransferCount"];
        }
    }

    static fromJS(data: any): TransferDetailViewItem {
        let result = new TransferDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Rev"] = this.rev;
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["State"] = this.state;
        data["BusinessProcessId"] = this.businessProcessId;
        data["TransferType"] = this.transferType;
        data["ItemProgress"] = this.itemProgress;
        data["ItemCount"] = this.itemCount;
        data["ItemsFailed"] = this.itemsFailed;
        data["ItemsCancelled"] = this.itemsCancelled;
        data["LastProgressStamp"] = this.lastProgressStamp;
        data["FileTransferCount"] = this.fileTransferCount;
        return data; 
    }
}

export interface ITransferDetailViewItem {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: StoreAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;
}

export class FileTransferDetailViewItem implements IFileTransferDetailViewItem {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: StoreAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: DriveMetadata | undefined;
    outputItems?: OutputItem[] | undefined;
    contentId?: string | undefined;

    constructor(data?: IFileTransferDetailViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.rev = data["Rev"];
            this.name = data["Name"];
            this.identifier = data["Identifier"];
            this.audit = data["Audit"] ? StoreAudit.fromJS(data["Audit"]) : <any>undefined;
            this.transferId = data["TransferId"];
            this.state = data["State"];
            this.entityType = data["EntityType"];
            this.fileMetadata = data["FileMetadata"] ? FileMetadata.fromJS(data["FileMetadata"]) : <any>undefined;
            this.driveMetadata = data["DriveMetadata"] ? DriveMetadata.fromJS(data["DriveMetadata"]) : <any>undefined;
            if (data["OutputItems"] && data["OutputItems"].constructor === Array) {
                this.outputItems = [];
                for (let item of data["OutputItems"])
                    this.outputItems.push(OutputItem.fromJS(item));
            }
            this.contentId = data["ContentId"];
        }
    }

    static fromJS(data: any): FileTransferDetailViewItem {
        let result = new FileTransferDetailViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Rev"] = this.rev;
        data["Name"] = this.name;
        data["Identifier"] = this.identifier;
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["TransferId"] = this.transferId;
        data["State"] = this.state;
        data["EntityType"] = this.entityType;
        data["FileMetadata"] = this.fileMetadata ? this.fileMetadata.toJSON() : <any>undefined;
        data["DriveMetadata"] = this.driveMetadata ? this.driveMetadata.toJSON() : <any>undefined;
        if (this.outputItems && this.outputItems.constructor === Array) {
            data["OutputItems"] = [];
            for (let item of this.outputItems)
                data["OutputItems"].push(item.toJSON());
        }
        data["ContentId"] = this.contentId;
        return data; 
    }
}

export interface IFileTransferDetailViewItem {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: StoreAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: DriveMetadata | undefined;
    outputItems?: OutputItem[] | undefined;
    contentId?: string | undefined;
}

export enum FileTransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    DataExtractionInProgress = <any>"DataExtractionInProgress", 
    DataExtractionDone = <any>"DataExtractionDone", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    UploadFailed = <any>"UploadFailed", 
    ImportFailed = <any>"ImportFailed", 
    DeleteInProgress = <any>"DeleteInProgress", 
    Deleted = <any>"Deleted", 
    CleanupInProgress = <any>"CleanupInProgress", 
    CleanupCompleted = <any>"CleanupCompleted", 
}

export class FileMetadata implements IFileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: XmpMetadata | undefined;
    exifMetadata?: ExifMetadata | undefined;
    language?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IFileMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FileMetadata";
    }

    init(data?: any) {
        if (data) {
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            this.descriptions = data["Descriptions"] ? TranslatedStringDictionary.fromJS(data["Descriptions"]) : <any>undefined;
            this.fileExtension = data["FileExtension"];
            this.fileName = data["FileName"];
            this.filePath = data["FilePath"];
            this.fileSizeInBytes = data["FileSizeInBytes"];
            this.sha1Hash = data["Sha1Hash"];
            this.xmpMetadata = data["XmpMetadata"] ? XmpMetadata.fromJS(data["XmpMetadata"]) : <any>undefined;
            this.exifMetadata = data["ExifMetadata"] ? ExifMetadata.fromJS(data["ExifMetadata"]) : <any>undefined;
            this.language = data["Language"];
        }
    }

    static fromJS(data: any): FileMetadata {
        if (data["Kind"] === "AudioMetadata") {
            let result = new AudioMetadata();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "DocumentMetadata") {
            let result = new DocumentMetadata();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "ImageMetadata") {
            let result = new ImageMetadata();
            result.init(data);
            return result;
        }
        if (data["Kind"] === "VideoMetadata") {
            let result = new VideoMetadata();
            result.init(data);
            return result;
        }
        let result = new FileMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this._discriminator; 
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["Descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["FileExtension"] = this.fileExtension;
        data["FileName"] = this.fileName;
        data["FilePath"] = this.filePath;
        data["FileSizeInBytes"] = this.fileSizeInBytes;
        data["Sha1Hash"] = this.sha1Hash;
        data["XmpMetadata"] = this.xmpMetadata ? this.xmpMetadata.toJSON() : <any>undefined;
        data["ExifMetadata"] = this.exifMetadata ? this.exifMetadata.toJSON() : <any>undefined;
        data["Language"] = this.language;
        return data; 
    }
}

export interface IFileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: XmpMetadata | undefined;
    exifMetadata?: ExifMetadata | undefined;
    language?: string | undefined;
}

export class XmpMetadata implements IXmpMetadata {
    dc?: Dc | undefined;
    crs?: Crs | undefined;
    iptcCore?: IptcCore | undefined;
    iptcExt?: IptcExt | undefined;
    iptcIIM?: IptcIIM | undefined;
    lr?: Lr | undefined;
    pdf?: Pdf | undefined;
    photoshop?: Photoshop | undefined;
    plus?: Plus | undefined;
    tiff?: Tiff | undefined;
    xmp?: Xmp | undefined;
    xmpBJ?: XmpBJ | undefined;
    xmpDM?: XmpDM | undefined;
    xmpG?: XmpG | undefined;
    xmpGImg?: XmpGImg | undefined;
    xmpidq?: Xmpidq | undefined;
    xmpMM?: XmpMM | undefined;
    xmpNote?: XmpNote | undefined;
    xmpRights?: XmpRights | undefined;
    xmpTPg?: XmpTPg | undefined;

    constructor(data?: IXmpMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dc = data["Dc"] ? Dc.fromJS(data["Dc"]) : <any>undefined;
            this.crs = data["Crs"] ? Crs.fromJS(data["Crs"]) : <any>undefined;
            this.iptcCore = data["IptcCore"] ? IptcCore.fromJS(data["IptcCore"]) : <any>undefined;
            this.iptcExt = data["IptcExt"] ? IptcExt.fromJS(data["IptcExt"]) : <any>undefined;
            this.iptcIIM = data["IptcIIM"] ? IptcIIM.fromJS(data["IptcIIM"]) : <any>undefined;
            this.lr = data["Lr"] ? Lr.fromJS(data["Lr"]) : <any>undefined;
            this.pdf = data["Pdf"] ? Pdf.fromJS(data["Pdf"]) : <any>undefined;
            this.photoshop = data["Photoshop"] ? Photoshop.fromJS(data["Photoshop"]) : <any>undefined;
            this.plus = data["Plus"] ? Plus.fromJS(data["Plus"]) : <any>undefined;
            this.tiff = data["Tiff"] ? Tiff.fromJS(data["Tiff"]) : <any>undefined;
            this.xmp = data["Xmp"] ? Xmp.fromJS(data["Xmp"]) : <any>undefined;
            this.xmpBJ = data["XmpBJ"] ? XmpBJ.fromJS(data["XmpBJ"]) : <any>undefined;
            this.xmpDM = data["XmpDM"] ? XmpDM.fromJS(data["XmpDM"]) : <any>undefined;
            this.xmpG = data["XmpG"] ? XmpG.fromJS(data["XmpG"]) : <any>undefined;
            this.xmpGImg = data["XmpGImg"] ? XmpGImg.fromJS(data["XmpGImg"]) : <any>undefined;
            this.xmpidq = data["Xmpidq"] ? Xmpidq.fromJS(data["Xmpidq"]) : <any>undefined;
            this.xmpMM = data["XmpMM"] ? XmpMM.fromJS(data["XmpMM"]) : <any>undefined;
            this.xmpNote = data["XmpNote"] ? XmpNote.fromJS(data["XmpNote"]) : <any>undefined;
            this.xmpRights = data["XmpRights"] ? XmpRights.fromJS(data["XmpRights"]) : <any>undefined;
            this.xmpTPg = data["XmpTPg"] ? XmpTPg.fromJS(data["XmpTPg"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XmpMetadata {
        let result = new XmpMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Dc"] = this.dc ? this.dc.toJSON() : <any>undefined;
        data["Crs"] = this.crs ? this.crs.toJSON() : <any>undefined;
        data["IptcCore"] = this.iptcCore ? this.iptcCore.toJSON() : <any>undefined;
        data["IptcExt"] = this.iptcExt ? this.iptcExt.toJSON() : <any>undefined;
        data["IptcIIM"] = this.iptcIIM ? this.iptcIIM.toJSON() : <any>undefined;
        data["Lr"] = this.lr ? this.lr.toJSON() : <any>undefined;
        data["Pdf"] = this.pdf ? this.pdf.toJSON() : <any>undefined;
        data["Photoshop"] = this.photoshop ? this.photoshop.toJSON() : <any>undefined;
        data["Plus"] = this.plus ? this.plus.toJSON() : <any>undefined;
        data["Tiff"] = this.tiff ? this.tiff.toJSON() : <any>undefined;
        data["Xmp"] = this.xmp ? this.xmp.toJSON() : <any>undefined;
        data["XmpBJ"] = this.xmpBJ ? this.xmpBJ.toJSON() : <any>undefined;
        data["XmpDM"] = this.xmpDM ? this.xmpDM.toJSON() : <any>undefined;
        data["XmpG"] = this.xmpG ? this.xmpG.toJSON() : <any>undefined;
        data["XmpGImg"] = this.xmpGImg ? this.xmpGImg.toJSON() : <any>undefined;
        data["Xmpidq"] = this.xmpidq ? this.xmpidq.toJSON() : <any>undefined;
        data["XmpMM"] = this.xmpMM ? this.xmpMM.toJSON() : <any>undefined;
        data["XmpNote"] = this.xmpNote ? this.xmpNote.toJSON() : <any>undefined;
        data["XmpRights"] = this.xmpRights ? this.xmpRights.toJSON() : <any>undefined;
        data["XmpTPg"] = this.xmpTPg ? this.xmpTPg.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IXmpMetadata {
    dc?: Dc | undefined;
    crs?: Crs | undefined;
    iptcCore?: IptcCore | undefined;
    iptcExt?: IptcExt | undefined;
    iptcIIM?: IptcIIM | undefined;
    lr?: Lr | undefined;
    pdf?: Pdf | undefined;
    photoshop?: Photoshop | undefined;
    plus?: Plus | undefined;
    tiff?: Tiff | undefined;
    xmp?: Xmp | undefined;
    xmpBJ?: XmpBJ | undefined;
    xmpDM?: XmpDM | undefined;
    xmpG?: XmpG | undefined;
    xmpGImg?: XmpGImg | undefined;
    xmpidq?: Xmpidq | undefined;
    xmpMM?: XmpMM | undefined;
    xmpNote?: XmpNote | undefined;
    xmpRights?: XmpRights | undefined;
    xmpTPg?: XmpTPg | undefined;
}

export class Dc implements IDc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;

    constructor(data?: IDc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Contributor"] && data["Contributor"].constructor === Array) {
                this.contributor = [];
                for (let item of data["Contributor"])
                    this.contributor.push(item);
            }
            this.coverage = data["Coverage"];
            if (data["Creator"] && data["Creator"].constructor === Array) {
                this.creator = [];
                for (let item of data["Creator"])
                    this.creator.push(item);
            }
            if (data["Date"] && data["Date"].constructor === Array) {
                this.date = [];
                for (let item of data["Date"])
                    this.date.push(new Date(item));
            }
            if (data["Description"]) {
                this.description = {};
                for (let key in data["Description"]) {
                    if (data["Description"].hasOwnProperty(key))
                        this.description[key] = data["Description"][key];
                }
            }
            this.format = data["Format"];
            this.identifier = data["Identifier"];
            if (data["Language"] && data["Language"].constructor === Array) {
                this.language = [];
                for (let item of data["Language"])
                    this.language.push(item);
            }
            if (data["Publisher"] && data["Publisher"].constructor === Array) {
                this.publisher = [];
                for (let item of data["Publisher"])
                    this.publisher.push(item);
            }
            if (data["Relation"] && data["Relation"].constructor === Array) {
                this.relation = [];
                for (let item of data["Relation"])
                    this.relation.push(item);
            }
            if (data["Rights"]) {
                this.rights = {};
                for (let key in data["Rights"]) {
                    if (data["Rights"].hasOwnProperty(key))
                        this.rights[key] = data["Rights"][key];
                }
            }
            this.source = data["Source"];
            if (data["Subject"] && data["Subject"].constructor === Array) {
                this.subject = [];
                for (let item of data["Subject"])
                    this.subject.push(item);
            }
            if (data["Title"]) {
                this.title = {};
                for (let key in data["Title"]) {
                    if (data["Title"].hasOwnProperty(key))
                        this.title[key] = data["Title"][key];
                }
            }
            this.type = data["Type"];
        }
    }

    static fromJS(data: any): Dc {
        let result = new Dc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contributor && this.contributor.constructor === Array) {
            data["Contributor"] = [];
            for (let item of this.contributor)
                data["Contributor"].push(item);
        }
        data["Coverage"] = this.coverage;
        if (this.creator && this.creator.constructor === Array) {
            data["Creator"] = [];
            for (let item of this.creator)
                data["Creator"].push(item);
        }
        if (this.date && this.date.constructor === Array) {
            data["Date"] = [];
            for (let item of this.date)
                data["Date"].push(item.toISOString());
        }
        if (this.description) {
            data["Description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    data["Description"][key] = this.description[key];
            }
        }
        data["Format"] = this.format;
        data["Identifier"] = this.identifier;
        if (this.language && this.language.constructor === Array) {
            data["Language"] = [];
            for (let item of this.language)
                data["Language"].push(item);
        }
        if (this.publisher && this.publisher.constructor === Array) {
            data["Publisher"] = [];
            for (let item of this.publisher)
                data["Publisher"].push(item);
        }
        if (this.relation && this.relation.constructor === Array) {
            data["Relation"] = [];
            for (let item of this.relation)
                data["Relation"].push(item);
        }
        if (this.rights) {
            data["Rights"] = {};
            for (let key in this.rights) {
                if (this.rights.hasOwnProperty(key))
                    data["Rights"][key] = this.rights[key];
            }
        }
        data["Source"] = this.source;
        if (this.subject && this.subject.constructor === Array) {
            data["Subject"] = [];
            for (let item of this.subject)
                data["Subject"].push(item);
        }
        if (this.title) {
            data["Title"] = {};
            for (let key in this.title) {
                if (this.title.hasOwnProperty(key))
                    data["Title"][key] = this.title[key];
            }
        }
        data["Type"] = this.type;
        return data; 
    }
}

export interface IDc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;
}

export class Crs implements ICrs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;

    constructor(data?: ICrs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoBrightness = data["AutoBrightness"];
            this.autoContrast = data["AutoContrast"];
            this.autoExposure = data["AutoExposure"];
            this.autoShadows = data["AutoShadows"];
            this.blueHue = data["BlueHue"];
            this.blueSaturation = data["BlueSaturation"];
            this.brightness = data["Brightness"];
            this.cameraProfile = data["CameraProfile"];
            this.chromaticAberrationB = data["ChromaticAberrationB"];
            this.chromaticAberrationR = data["ChromaticAberrationR"];
            this.colorNoiseReduction = data["ColorNoiseReduction"];
            this.contrast = data["Contrast"];
            this.cropTop = data["CropTop"];
            this.cropLeft = data["CropLeft"];
            this.cropBottom = data["CropBottom"];
            this.cropRight = data["CropRight"];
            this.cropAngle = data["CropAngle"];
            this.cropWidth = data["CropWidth"];
            this.cropHeight = data["CropHeight"];
            this.cropUnits = data["CropUnits"];
            this.exposure = data["Exposure"];
            this.greenHue = data["GreenHue"];
            this.greenSaturation = data["GreenSaturation"];
            this.hasCrop = data["HasCrop"];
            this.hasSettings = data["HasSettings"];
            this.luminanceSmoothing = data["LuminanceSmoothing"];
            this.rawFileName = data["RawFileName"];
            this.redHue = data["RedHue"];
            this.redSaturation = data["RedSaturation"];
            this.saturation = data["Saturation"];
            this.shadows = data["Shadows"];
            this.shadowTint = data["ShadowTint"];
            this.sharpness = data["Sharpness"];
            this.temperature = data["Temperature"];
            this.tint = data["Tint"];
            if (data["ToneCurve"] && data["ToneCurve"].constructor === Array) {
                this.toneCurve = [];
                for (let item of data["ToneCurve"])
                    this.toneCurve.push(item);
            }
            this.toneCurveName = data["ToneCurveName"];
            this.version = data["Version"];
            this.vignetteAmount = data["VignetteAmount"];
            this.vignetteMidpoint = data["VignetteMidpoint"];
            this.whiteBalance = data["WhiteBalance"];
        }
    }

    static fromJS(data: any): Crs {
        let result = new Crs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AutoBrightness"] = this.autoBrightness;
        data["AutoContrast"] = this.autoContrast;
        data["AutoExposure"] = this.autoExposure;
        data["AutoShadows"] = this.autoShadows;
        data["BlueHue"] = this.blueHue;
        data["BlueSaturation"] = this.blueSaturation;
        data["Brightness"] = this.brightness;
        data["CameraProfile"] = this.cameraProfile;
        data["ChromaticAberrationB"] = this.chromaticAberrationB;
        data["ChromaticAberrationR"] = this.chromaticAberrationR;
        data["ColorNoiseReduction"] = this.colorNoiseReduction;
        data["Contrast"] = this.contrast;
        data["CropTop"] = this.cropTop;
        data["CropLeft"] = this.cropLeft;
        data["CropBottom"] = this.cropBottom;
        data["CropRight"] = this.cropRight;
        data["CropAngle"] = this.cropAngle;
        data["CropWidth"] = this.cropWidth;
        data["CropHeight"] = this.cropHeight;
        data["CropUnits"] = this.cropUnits;
        data["Exposure"] = this.exposure;
        data["GreenHue"] = this.greenHue;
        data["GreenSaturation"] = this.greenSaturation;
        data["HasCrop"] = this.hasCrop;
        data["HasSettings"] = this.hasSettings;
        data["LuminanceSmoothing"] = this.luminanceSmoothing;
        data["RawFileName"] = this.rawFileName;
        data["RedHue"] = this.redHue;
        data["RedSaturation"] = this.redSaturation;
        data["Saturation"] = this.saturation;
        data["Shadows"] = this.shadows;
        data["ShadowTint"] = this.shadowTint;
        data["Sharpness"] = this.sharpness;
        data["Temperature"] = this.temperature;
        data["Tint"] = this.tint;
        if (this.toneCurve && this.toneCurve.constructor === Array) {
            data["ToneCurve"] = [];
            for (let item of this.toneCurve)
                data["ToneCurve"].push(item);
        }
        data["ToneCurveName"] = this.toneCurveName;
        data["Version"] = this.version;
        data["VignetteAmount"] = this.vignetteAmount;
        data["VignetteMidpoint"] = this.vignetteMidpoint;
        data["WhiteBalance"] = this.whiteBalance;
        return data; 
    }
}

export interface ICrs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;
}

/** Corresponds to crs.CropUnitsChoice */
export enum CropUnit {
    Pixels = <any>"Pixels", 
    Inches = <any>"Inches", 
    Centimeters = <any>"Centimeters", 
}

/** Corresponds to crs.ToneCurveNameChoice */
export enum ToneCurve {
    Linear = <any>"Linear", 
    MediumContrast = <any>"MediumContrast", 
    StrongContrast = <any>"StrongContrast", 
    Custom = <any>"Custom", 
}

/** Corresponds to crs.WhiteBalanceChoice */
export enum WhiteBalance {
    AsShot = <any>"AsShot", 
    Auto = <any>"Auto", 
    Daylight = <any>"Daylight", 
    Cloudy = <any>"Cloudy", 
    Shade = <any>"Shade", 
    Tungsten = <any>"Tungsten", 
    Fluorescent = <any>"Fluorescent", 
    Flash = <any>"Flash", 
    Custom = <any>"Custom", 
}

export class IptcCore implements IIptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: CreatorContactInfo | undefined;

    constructor(data?: IIptcCore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryCode = data["CountryCode"];
            this.intellectualGenre = data["IntellectualGenre"];
            if (data["Scene"] && data["Scene"].constructor === Array) {
                this.scene = [];
                for (let item of data["Scene"])
                    this.scene.push(item);
            }
            if (data["SubjectCode"] && data["SubjectCode"].constructor === Array) {
                this.subjectCode = [];
                for (let item of data["SubjectCode"])
                    this.subjectCode.push(item);
            }
            this.location = data["Location"];
            this.creatorContactInfo = data["CreatorContactInfo"] ? CreatorContactInfo.fromJS(data["CreatorContactInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IptcCore {
        let result = new IptcCore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CountryCode"] = this.countryCode;
        data["IntellectualGenre"] = this.intellectualGenre;
        if (this.scene && this.scene.constructor === Array) {
            data["Scene"] = [];
            for (let item of this.scene)
                data["Scene"].push(item);
        }
        if (this.subjectCode && this.subjectCode.constructor === Array) {
            data["SubjectCode"] = [];
            for (let item of this.subjectCode)
                data["SubjectCode"].push(item);
        }
        data["Location"] = this.location;
        data["CreatorContactInfo"] = this.creatorContactInfo ? this.creatorContactInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: CreatorContactInfo | undefined;
}

export class CreatorContactInfo implements ICreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    uRL?: string | undefined;

    constructor(data?: ICreatorContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["Address"];
            this.city = data["City"];
            this.country = data["Country"];
            this.emailAddress = data["EmailAddress"];
            this.phoneNumber = data["PhoneNumber"];
            this.postalCode = data["PostalCode"];
            this.region = data["Region"];
            this.uRL = data["URL"];
        }
    }

    static fromJS(data: any): CreatorContactInfo {
        let result = new CreatorContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Address"] = this.address;
        data["City"] = this.city;
        data["Country"] = this.country;
        data["EmailAddress"] = this.emailAddress;
        data["PhoneNumber"] = this.phoneNumber;
        data["PostalCode"] = this.postalCode;
        data["Region"] = this.region;
        data["URL"] = this.uRL;
        return data; 
    }
}

export interface ICreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    uRL?: string | undefined;
}

export class IptcExt implements IIptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: ArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: LocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: RegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: LocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;

    constructor(data?: IIptcExt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionalModelInformation = data["AdditionalModelInformation"];
            if (data["ArtworkOrObject"] && data["ArtworkOrObject"].constructor === Array) {
                this.artworkOrObject = [];
                for (let item of data["ArtworkOrObject"])
                    this.artworkOrObject.push(ArtworkOrObjectInfo.fromJS(item));
            }
            if (data["OrganisationInImageCode"] && data["OrganisationInImageCode"].constructor === Array) {
                this.organisationInImageCode = [];
                for (let item of data["OrganisationInImageCode"])
                    this.organisationInImageCode.push(item);
            }
            if (data["ControlledVocabularyTerm"] && data["ControlledVocabularyTerm"].constructor === Array) {
                this.controlledVocabularyTerm = [];
                for (let item of data["ControlledVocabularyTerm"])
                    this.controlledVocabularyTerm.push(item);
            }
            if (data["LocationShown"] && data["LocationShown"].constructor === Array) {
                this.locationShown = [];
                for (let item of data["LocationShown"])
                    this.locationShown.push(LocationInfo.fromJS(item));
            }
            if (data["ModelAge"] && data["ModelAge"].constructor === Array) {
                this.modelAge = [];
                for (let item of data["ModelAge"])
                    this.modelAge.push(item);
            }
            if (data["OrganisationInImageName"] && data["OrganisationInImageName"].constructor === Array) {
                this.organisationInImageName = [];
                for (let item of data["OrganisationInImageName"])
                    this.organisationInImageName.push(item);
            }
            if (data["PersonInImage"] && data["PersonInImage"].constructor === Array) {
                this.personInImage = [];
                for (let item of data["PersonInImage"])
                    this.personInImage.push(item);
            }
            this.digitalImageGUID = data["DigitalImageGUID"];
            this.digitalSourceType = data["DigitalSourceType"];
            if (data["Event"]) {
                this.event = {};
                for (let key in data["Event"]) {
                    if (data["Event"].hasOwnProperty(key))
                        this.event[key] = data["Event"][key];
                }
            }
            if (data["ImageRegistryEntry"] && data["ImageRegistryEntry"].constructor === Array) {
                this.imageRegistryEntry = [];
                for (let item of data["ImageRegistryEntry"])
                    this.imageRegistryEntry.push(RegistryEntryInfo.fromJS(item));
            }
            this.metadataLastEdited = data["MetadataLastEdited"] ? new Date(data["MetadataLastEdited"].toString()) : <any>undefined;
            if (data["LocationCreated"] && data["LocationCreated"].constructor === Array) {
                this.locationCreated = [];
                for (let item of data["LocationCreated"])
                    this.locationCreated.push(LocationInfo.fromJS(item));
            }
            this.maxAvailHeight = data["MaxAvailHeight"];
            this.maxAvailWidth = data["MaxAvailWidth"];
        }
    }

    static fromJS(data: any): IptcExt {
        let result = new IptcExt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AdditionalModelInformation"] = this.additionalModelInformation;
        if (this.artworkOrObject && this.artworkOrObject.constructor === Array) {
            data["ArtworkOrObject"] = [];
            for (let item of this.artworkOrObject)
                data["ArtworkOrObject"].push(item.toJSON());
        }
        if (this.organisationInImageCode && this.organisationInImageCode.constructor === Array) {
            data["OrganisationInImageCode"] = [];
            for (let item of this.organisationInImageCode)
                data["OrganisationInImageCode"].push(item);
        }
        if (this.controlledVocabularyTerm && this.controlledVocabularyTerm.constructor === Array) {
            data["ControlledVocabularyTerm"] = [];
            for (let item of this.controlledVocabularyTerm)
                data["ControlledVocabularyTerm"].push(item);
        }
        if (this.locationShown && this.locationShown.constructor === Array) {
            data["LocationShown"] = [];
            for (let item of this.locationShown)
                data["LocationShown"].push(item.toJSON());
        }
        if (this.modelAge && this.modelAge.constructor === Array) {
            data["ModelAge"] = [];
            for (let item of this.modelAge)
                data["ModelAge"].push(item);
        }
        if (this.organisationInImageName && this.organisationInImageName.constructor === Array) {
            data["OrganisationInImageName"] = [];
            for (let item of this.organisationInImageName)
                data["OrganisationInImageName"].push(item);
        }
        if (this.personInImage && this.personInImage.constructor === Array) {
            data["PersonInImage"] = [];
            for (let item of this.personInImage)
                data["PersonInImage"].push(item);
        }
        data["DigitalImageGUID"] = this.digitalImageGUID;
        data["DigitalSourceType"] = this.digitalSourceType;
        if (this.event) {
            data["Event"] = {};
            for (let key in this.event) {
                if (this.event.hasOwnProperty(key))
                    data["Event"][key] = this.event[key];
            }
        }
        if (this.imageRegistryEntry && this.imageRegistryEntry.constructor === Array) {
            data["ImageRegistryEntry"] = [];
            for (let item of this.imageRegistryEntry)
                data["ImageRegistryEntry"].push(item.toJSON());
        }
        data["MetadataLastEdited"] = this.metadataLastEdited ? this.metadataLastEdited.toISOString() : <any>undefined;
        if (this.locationCreated && this.locationCreated.constructor === Array) {
            data["LocationCreated"] = [];
            for (let item of this.locationCreated)
                data["LocationCreated"].push(item.toJSON());
        }
        data["MaxAvailHeight"] = this.maxAvailHeight;
        data["MaxAvailWidth"] = this.maxAvailWidth;
        return data; 
    }
}

export interface IIptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: ArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: LocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: RegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: LocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;
}

/** Corresponds to Xmp.Structure.ArtworkOrObjectDetails */
export class ArtworkOrObjectInfo implements IArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;

    constructor(data?: IArtworkOrObjectInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.copyrightNotice = data["CopyrightNotice"];
            if (data["Creator"] && data["Creator"].constructor === Array) {
                this.creator = [];
                for (let item of data["Creator"])
                    this.creator.push(item);
            }
            this.dateCreated = data["DateCreated"] ? new Date(data["DateCreated"].toString()) : <any>undefined;
            this.source = data["Source"];
            this.sourceInventoryNumber = data["SourceInventoryNumber"];
            if (data["Title"]) {
                this.title = {};
                for (let key in data["Title"]) {
                    if (data["Title"].hasOwnProperty(key))
                        this.title[key] = data["Title"][key];
                }
            }
        }
    }

    static fromJS(data: any): ArtworkOrObjectInfo {
        let result = new ArtworkOrObjectInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CopyrightNotice"] = this.copyrightNotice;
        if (this.creator && this.creator.constructor === Array) {
            data["Creator"] = [];
            for (let item of this.creator)
                data["Creator"].push(item);
        }
        data["DateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["Source"] = this.source;
        data["SourceInventoryNumber"] = this.sourceInventoryNumber;
        if (this.title) {
            data["Title"] = {};
            for (let key in this.title) {
                if (this.title.hasOwnProperty(key))
                    data["Title"][key] = this.title[key];
            }
        }
        return data; 
    }
}

/** Corresponds to Xmp.Structure.ArtworkOrObjectDetails */
export interface IArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;
}

export class LocationInfo implements ILocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;

    constructor(data?: ILocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.city = data["City"];
            this.countryCode = data["CountryCode"];
            this.countryName = data["CountryName"];
            this.provinceState = data["ProvinceState"];
            this.sublocation = data["Sublocation"];
            this.worldRegion = data["WorldRegion"];
        }
    }

    static fromJS(data: any): LocationInfo {
        let result = new LocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["City"] = this.city;
        data["CountryCode"] = this.countryCode;
        data["CountryName"] = this.countryName;
        data["ProvinceState"] = this.provinceState;
        data["Sublocation"] = this.sublocation;
        data["WorldRegion"] = this.worldRegion;
        return data; 
    }
}

export interface ILocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;
}

export class RegistryEntryInfo implements IRegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;

    constructor(data?: IRegistryEntryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registryItemIdentifier = data["RegistryItemIdentifier"];
            this.registryOrganisationIdentifier = data["RegistryOrganisationIdentifier"];
        }
    }

    static fromJS(data: any): RegistryEntryInfo {
        let result = new RegistryEntryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RegistryItemIdentifier"] = this.registryItemIdentifier;
        data["RegistryOrganisationIdentifier"] = this.registryOrganisationIdentifier;
        return data; 
    }
}

export interface IRegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;
}

export class IptcIIM implements IIptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uNO?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;

    constructor(data?: IIptcIIM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelVersion = data["ModelVersion"];
            if (data["Destination"] && data["Destination"].constructor === Array) {
                this.destination = [];
                for (let item of data["Destination"])
                    this.destination.push(item);
            }
            this.fileFormat = data["FileFormat"];
            this.fileFormatVersion = data["FileFormatVersion"];
            this.serviceIdentifier = data["ServiceIdentifier"];
            this.envelopeNumber = data["EnvelopeNumber"];
            if (data["ProductID"] && data["ProductID"].constructor === Array) {
                this.productID = [];
                for (let item of data["ProductID"])
                    this.productID.push(item);
            }
            this.envelopePriority = data["EnvelopePriority"];
            this.dateSent = data["DateSent"] ? new Date(data["DateSent"].toString()) : <any>undefined;
            this.timeSent = data["TimeSent"] ? new Date(data["TimeSent"].toString()) : <any>undefined;
            this.uNO = data["UNO"];
            this.recordVersion = data["RecordVersion"];
            this.objectTypeReference = data["ObjectTypeReference"];
            this.objectAttributeReference = data["ObjectAttributeReference"];
            if (data["ObjectName"]) {
                this.objectName = {};
                for (let key in data["ObjectName"]) {
                    if (data["ObjectName"].hasOwnProperty(key))
                        this.objectName[key] = data["ObjectName"][key];
                }
            }
            this.editStatus = data["EditStatus"];
            this.urgency = data["Urgency"];
            if (data["SubjectReference"] && data["SubjectReference"].constructor === Array) {
                this.subjectReference = [];
                for (let item of data["SubjectReference"])
                    this.subjectReference.push(item);
            }
            this.category = data["Category"];
            if (data["SupplementalCategory"] && data["SupplementalCategory"].constructor === Array) {
                this.supplementalCategory = [];
                for (let item of data["SupplementalCategory"])
                    this.supplementalCategory.push(item);
            }
            this.fixtureIdentifier = data["FixtureIdentifier"];
            if (data["Keywords"] && data["Keywords"].constructor === Array) {
                this.keywords = [];
                for (let item of data["Keywords"])
                    this.keywords.push(item);
            }
            if (data["ContentLocationCode"] && data["ContentLocationCode"].constructor === Array) {
                this.contentLocationCode = [];
                for (let item of data["ContentLocationCode"])
                    this.contentLocationCode.push(item);
            }
            if (data["ContentLocationName"] && data["ContentLocationName"].constructor === Array) {
                this.contentLocationName = [];
                for (let item of data["ContentLocationName"])
                    this.contentLocationName.push(item);
            }
            this.releaseDate = data["ReleaseDate"] ? new Date(data["ReleaseDate"].toString()) : <any>undefined;
            this.releaseTime = data["ReleaseTime"] ? new Date(data["ReleaseTime"].toString()) : <any>undefined;
            this.expirationDate = data["ExpirationDate"] ? new Date(data["ExpirationDate"].toString()) : <any>undefined;
            this.expirationTime = data["ExpirationTime"] ? new Date(data["ExpirationTime"].toString()) : <any>undefined;
            this.specialInstruction = data["SpecialInstruction"];
            this.actionAdvised = data["ActionAdvised"];
            this.referenceService = data["ReferenceService"];
            this.referenceDate = data["ReferenceDate"] ? new Date(data["ReferenceDate"].toString()) : <any>undefined;
            this.referenceNumber = data["ReferenceNumber"];
            this.dateCreated = data["DateCreated"] ? new Date(data["DateCreated"].toString()) : <any>undefined;
            this.timeCreated = data["TimeCreated"] ? new Date(data["TimeCreated"].toString()) : <any>undefined;
            this.digitalCreationDate = data["DigitalCreationDate"] ? new Date(data["DigitalCreationDate"].toString()) : <any>undefined;
            this.digitalCreationTime = data["DigitalCreationTime"] ? new Date(data["DigitalCreationTime"].toString()) : <any>undefined;
            this.originatingProgram = data["OriginatingProgram"];
            this.programVersion = data["ProgramVersion"];
            if (data["Byline"] && data["Byline"].constructor === Array) {
                this.byline = [];
                for (let item of data["Byline"])
                    this.byline.push(item);
            }
            this.bylineTitle = data["BylineTitle"];
            this.city = data["City"];
            this.sublocation = data["Sublocation"];
            this.provinceState = data["ProvinceState"];
            this.countryPrimaryLocationCode = data["CountryPrimaryLocationCode"];
            this.countryPrimaryLocationName = data["CountryPrimaryLocationName"];
            this.originalTransmissionReference = data["OriginalTransmissionReference"];
            this.headline = data["Headline"];
            this.credit = data["Credit"];
            this.source = data["Source"];
            if (data["CopyrightNotice"]) {
                this.copyrightNotice = {};
                for (let key in data["CopyrightNotice"]) {
                    if (data["CopyrightNotice"].hasOwnProperty(key))
                        this.copyrightNotice[key] = data["CopyrightNotice"][key];
                }
            }
            if (data["CaptionAbstract"]) {
                this.captionAbstract = {};
                for (let key in data["CaptionAbstract"]) {
                    if (data["CaptionAbstract"].hasOwnProperty(key))
                        this.captionAbstract[key] = data["CaptionAbstract"][key];
                }
            }
            this.writerEditor = data["WriterEditor"];
            this.imageType = data["ImageType"];
            this.imageOrientation = data["ImageOrientation"];
            this.languageIdentifier = data["LanguageIdentifier"];
        }
    }

    static fromJS(data: any): IptcIIM {
        let result = new IptcIIM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ModelVersion"] = this.modelVersion;
        if (this.destination && this.destination.constructor === Array) {
            data["Destination"] = [];
            for (let item of this.destination)
                data["Destination"].push(item);
        }
        data["FileFormat"] = this.fileFormat;
        data["FileFormatVersion"] = this.fileFormatVersion;
        data["ServiceIdentifier"] = this.serviceIdentifier;
        data["EnvelopeNumber"] = this.envelopeNumber;
        if (this.productID && this.productID.constructor === Array) {
            data["ProductID"] = [];
            for (let item of this.productID)
                data["ProductID"].push(item);
        }
        data["EnvelopePriority"] = this.envelopePriority;
        data["DateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["TimeSent"] = this.timeSent ? this.timeSent.toISOString() : <any>undefined;
        data["UNO"] = this.uNO;
        data["RecordVersion"] = this.recordVersion;
        data["ObjectTypeReference"] = this.objectTypeReference;
        data["ObjectAttributeReference"] = this.objectAttributeReference;
        if (this.objectName) {
            data["ObjectName"] = {};
            for (let key in this.objectName) {
                if (this.objectName.hasOwnProperty(key))
                    data["ObjectName"][key] = this.objectName[key];
            }
        }
        data["EditStatus"] = this.editStatus;
        data["Urgency"] = this.urgency;
        if (this.subjectReference && this.subjectReference.constructor === Array) {
            data["SubjectReference"] = [];
            for (let item of this.subjectReference)
                data["SubjectReference"].push(item);
        }
        data["Category"] = this.category;
        if (this.supplementalCategory && this.supplementalCategory.constructor === Array) {
            data["SupplementalCategory"] = [];
            for (let item of this.supplementalCategory)
                data["SupplementalCategory"].push(item);
        }
        data["FixtureIdentifier"] = this.fixtureIdentifier;
        if (this.keywords && this.keywords.constructor === Array) {
            data["Keywords"] = [];
            for (let item of this.keywords)
                data["Keywords"].push(item);
        }
        if (this.contentLocationCode && this.contentLocationCode.constructor === Array) {
            data["ContentLocationCode"] = [];
            for (let item of this.contentLocationCode)
                data["ContentLocationCode"].push(item);
        }
        if (this.contentLocationName && this.contentLocationName.constructor === Array) {
            data["ContentLocationName"] = [];
            for (let item of this.contentLocationName)
                data["ContentLocationName"].push(item);
        }
        data["ReleaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["ReleaseTime"] = this.releaseTime ? this.releaseTime.toISOString() : <any>undefined;
        data["ExpirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["ExpirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["SpecialInstruction"] = this.specialInstruction;
        data["ActionAdvised"] = this.actionAdvised;
        data["ReferenceService"] = this.referenceService;
        data["ReferenceDate"] = this.referenceDate ? this.referenceDate.toISOString() : <any>undefined;
        data["ReferenceNumber"] = this.referenceNumber;
        data["DateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["TimeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["DigitalCreationDate"] = this.digitalCreationDate ? this.digitalCreationDate.toISOString() : <any>undefined;
        data["DigitalCreationTime"] = this.digitalCreationTime ? this.digitalCreationTime.toISOString() : <any>undefined;
        data["OriginatingProgram"] = this.originatingProgram;
        data["ProgramVersion"] = this.programVersion;
        if (this.byline && this.byline.constructor === Array) {
            data["Byline"] = [];
            for (let item of this.byline)
                data["Byline"].push(item);
        }
        data["BylineTitle"] = this.bylineTitle;
        data["City"] = this.city;
        data["Sublocation"] = this.sublocation;
        data["ProvinceState"] = this.provinceState;
        data["CountryPrimaryLocationCode"] = this.countryPrimaryLocationCode;
        data["CountryPrimaryLocationName"] = this.countryPrimaryLocationName;
        data["OriginalTransmissionReference"] = this.originalTransmissionReference;
        data["Headline"] = this.headline;
        data["Credit"] = this.credit;
        data["Source"] = this.source;
        if (this.copyrightNotice) {
            data["CopyrightNotice"] = {};
            for (let key in this.copyrightNotice) {
                if (this.copyrightNotice.hasOwnProperty(key))
                    data["CopyrightNotice"][key] = this.copyrightNotice[key];
            }
        }
        if (this.captionAbstract) {
            data["CaptionAbstract"] = {};
            for (let key in this.captionAbstract) {
                if (this.captionAbstract.hasOwnProperty(key))
                    data["CaptionAbstract"][key] = this.captionAbstract[key];
            }
        }
        data["WriterEditor"] = this.writerEditor;
        data["ImageType"] = this.imageType;
        data["ImageOrientation"] = this.imageOrientation;
        data["LanguageIdentifier"] = this.languageIdentifier;
        return data; 
    }
}

export interface IIptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uNO?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;
}

export class Lr implements ILr {
    hierarchicalSubject?: string[] | undefined;

    constructor(data?: ILr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["HierarchicalSubject"] && data["HierarchicalSubject"].constructor === Array) {
                this.hierarchicalSubject = [];
                for (let item of data["HierarchicalSubject"])
                    this.hierarchicalSubject.push(item);
            }
        }
    }

    static fromJS(data: any): Lr {
        let result = new Lr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.hierarchicalSubject && this.hierarchicalSubject.constructor === Array) {
            data["HierarchicalSubject"] = [];
            for (let item of this.hierarchicalSubject)
                data["HierarchicalSubject"].push(item);
        }
        return data; 
    }
}

export interface ILr {
    hierarchicalSubject?: string[] | undefined;
}

export class Pdf implements IPdf {
    keywords?: string | undefined;
    pDFVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;

    constructor(data?: IPdf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keywords = data["Keywords"];
            this.pDFVersion = data["PDFVersion"];
            this.producer = data["Producer"];
            this.trapped = data["Trapped"];
        }
    }

    static fromJS(data: any): Pdf {
        let result = new Pdf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Keywords"] = this.keywords;
        data["PDFVersion"] = this.pDFVersion;
        data["Producer"] = this.producer;
        data["Trapped"] = this.trapped;
        return data; 
    }
}

export interface IPdf {
    keywords?: string | undefined;
    pDFVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;
}

export class Photoshop implements IPhotoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iCCProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: PhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;

    constructor(data?: IPhotoshop) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authorsPosition = data["AuthorsPosition"];
            this.captionWriter = data["CaptionWriter"];
            this.category = data["Category"];
            this.city = data["City"];
            this.colorMode = data["ColorMode"];
            this.country = data["Country"];
            this.credit = data["Credit"];
            this.dateCreated = data["DateCreated"] ? new Date(data["DateCreated"].toString()) : <any>undefined;
            if (data["DocumentAncestors"] && data["DocumentAncestors"].constructor === Array) {
                this.documentAncestors = [];
                for (let item of data["DocumentAncestors"])
                    this.documentAncestors.push(item);
            }
            this.headline = data["Headline"];
            this.history = data["History"];
            this.iCCProfile = data["ICCProfile"];
            this.instructions = data["Instructions"];
            this.source = data["Source"];
            this.state = data["State"];
            if (data["SupplementalCategories"] && data["SupplementalCategories"].constructor === Array) {
                this.supplementalCategories = [];
                for (let item of data["SupplementalCategories"])
                    this.supplementalCategories.push(item);
            }
            if (data["TextLayers"] && data["TextLayers"].constructor === Array) {
                this.textLayers = [];
                for (let item of data["TextLayers"])
                    this.textLayers.push(PhotoshopLayer.fromJS(item));
            }
            this.transmissionReference = data["TransmissionReference"];
            this.urgency = data["Urgency"];
            this.legacyIPTCDigest = data["LegacyIPTCDigest"];
        }
    }

    static fromJS(data: any): Photoshop {
        let result = new Photoshop();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthorsPosition"] = this.authorsPosition;
        data["CaptionWriter"] = this.captionWriter;
        data["Category"] = this.category;
        data["City"] = this.city;
        data["ColorMode"] = this.colorMode;
        data["Country"] = this.country;
        data["Credit"] = this.credit;
        data["DateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        if (this.documentAncestors && this.documentAncestors.constructor === Array) {
            data["DocumentAncestors"] = [];
            for (let item of this.documentAncestors)
                data["DocumentAncestors"].push(item);
        }
        data["Headline"] = this.headline;
        data["History"] = this.history;
        data["ICCProfile"] = this.iCCProfile;
        data["Instructions"] = this.instructions;
        data["Source"] = this.source;
        data["State"] = this.state;
        if (this.supplementalCategories && this.supplementalCategories.constructor === Array) {
            data["SupplementalCategories"] = [];
            for (let item of this.supplementalCategories)
                data["SupplementalCategories"].push(item);
        }
        if (this.textLayers && this.textLayers.constructor === Array) {
            data["TextLayers"] = [];
            for (let item of this.textLayers)
                data["TextLayers"].push(item.toJSON());
        }
        data["TransmissionReference"] = this.transmissionReference;
        data["Urgency"] = this.urgency;
        data["LegacyIPTCDigest"] = this.legacyIPTCDigest;
        return data; 
    }
}

export interface IPhotoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iCCProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: PhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;
}

/** Corresponds to photoshop.ColorModeChoice */
export enum ColorMode {
    Bitmap = <any>"Bitmap", 
    Grayscale = <any>"Grayscale", 
    Indexed = <any>"Indexed", 
    RGB = <any>"RGB", 
    CMYK = <any>"CMYK", 
    Multichannel = <any>"Multichannel", 
    Duotone = <any>"Duotone", 
    LAB = <any>"LAB", 
}

export class PhotoshopLayer implements IPhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;

    constructor(data?: IPhotoshopLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layerName = data["LayerName"];
            this.layerText = data["LayerText"];
        }
    }

    static fromJS(data: any): PhotoshopLayer {
        let result = new PhotoshopLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LayerName"] = this.layerName;
        data["LayerText"] = this.layerText;
        return data; 
    }
}

export interface IPhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;
}

export class Plus implements IPlus {
    version?: string | undefined;
    licensee?: LicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: EndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: LicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: CopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: ImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: ImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;

    constructor(data?: IPlus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["Version"];
            if (data["Licensee"] && data["Licensee"].constructor === Array) {
                this.licensee = [];
                for (let item of data["Licensee"])
                    this.licensee.push(LicenseeInfo.fromJS(item));
            }
            this.licenseeID = data["LicenseeID"];
            this.licenseeName = data["LicenseeName"];
            if (data["EndUser"] && data["EndUser"].constructor === Array) {
                this.endUser = [];
                for (let item of data["EndUser"])
                    this.endUser.push(EndUserInfo.fromJS(item));
            }
            this.endUserID = data["EndUserID"];
            this.endUserName = data["EndUserName"];
            if (data["Licensor"] && data["Licensor"].constructor === Array) {
                this.licensor = [];
                for (let item of data["Licensor"])
                    this.licensor.push(LicensorInfo.fromJS(item));
            }
            if (data["LicensorNotes"]) {
                this.licensorNotes = {};
                for (let key in data["LicensorNotes"]) {
                    if (data["LicensorNotes"].hasOwnProperty(key))
                        this.licensorNotes[key] = data["LicensorNotes"][key];
                }
            }
            this.mediaSummaryCode = data["MediaSummaryCode"];
            this.licenseStartDate = data["LicenseStartDate"] ? new Date(data["LicenseStartDate"].toString()) : <any>undefined;
            this.licenseEndDate = data["LicenseEndDate"] ? new Date(data["LicenseEndDate"].toString()) : <any>undefined;
            if (data["MediaConstraints"]) {
                this.mediaConstraints = {};
                for (let key in data["MediaConstraints"]) {
                    if (data["MediaConstraints"].hasOwnProperty(key))
                        this.mediaConstraints[key] = data["MediaConstraints"][key];
                }
            }
            if (data["RegionConstraints"]) {
                this.regionConstraints = {};
                for (let key in data["RegionConstraints"]) {
                    if (data["RegionConstraints"].hasOwnProperty(key))
                        this.regionConstraints[key] = data["RegionConstraints"][key];
                }
            }
            if (data["ProductOrServiceConstraints"]) {
                this.productOrServiceConstraints = {};
                for (let key in data["ProductOrServiceConstraints"]) {
                    if (data["ProductOrServiceConstraints"].hasOwnProperty(key))
                        this.productOrServiceConstraints[key] = data["ProductOrServiceConstraints"][key];
                }
            }
            if (data["ImageFileConstraints"] && data["ImageFileConstraints"].constructor === Array) {
                this.imageFileConstraints = [];
                for (let item of data["ImageFileConstraints"])
                    this.imageFileConstraints.push(item);
            }
            if (data["ImageAlterationConstraints"] && data["ImageAlterationConstraints"].constructor === Array) {
                this.imageAlterationConstraints = [];
                for (let item of data["ImageAlterationConstraints"])
                    this.imageAlterationConstraints.push(item);
            }
            this.imageDuplicationConstraints = data["ImageDuplicationConstraints"];
            this.modelReleaseStatus = data["ModelReleaseStatus"];
            if (data["ModelReleaseID"] && data["ModelReleaseID"].constructor === Array) {
                this.modelReleaseID = [];
                for (let item of data["ModelReleaseID"])
                    this.modelReleaseID.push(item);
            }
            this.minorModelAgeDisclosure = data["MinorModelAgeDisclosure"];
            this.propertyReleaseStatus = data["PropertyReleaseStatus"];
            if (data["PropertyReleaseID"] && data["PropertyReleaseID"].constructor === Array) {
                this.propertyReleaseID = [];
                for (let item of data["PropertyReleaseID"])
                    this.propertyReleaseID.push(item);
            }
            if (data["OtherConstraints"]) {
                this.otherConstraints = {};
                for (let key in data["OtherConstraints"]) {
                    if (data["OtherConstraints"].hasOwnProperty(key))
                        this.otherConstraints[key] = data["OtherConstraints"][key];
                }
            }
            this.creditLineRequired = data["CreditLineRequired"];
            this.adultContentWarning = data["AdultContentWarning"];
            if (data["OtherLicenseRequirements"]) {
                this.otherLicenseRequirements = {};
                for (let key in data["OtherLicenseRequirements"]) {
                    if (data["OtherLicenseRequirements"].hasOwnProperty(key))
                        this.otherLicenseRequirements[key] = data["OtherLicenseRequirements"][key];
                }
            }
            if (data["TermsAndConditionsText"]) {
                this.termsAndConditionsText = {};
                for (let key in data["TermsAndConditionsText"]) {
                    if (data["TermsAndConditionsText"].hasOwnProperty(key))
                        this.termsAndConditionsText[key] = data["TermsAndConditionsText"][key];
                }
            }
            this.termsAndConditionsURL = data["TermsAndConditionsURL"];
            if (data["OtherConditions"]) {
                this.otherConditions = {};
                for (let key in data["OtherConditions"]) {
                    if (data["OtherConditions"].hasOwnProperty(key))
                        this.otherConditions[key] = data["OtherConditions"][key];
                }
            }
            this.imageType = data["ImageType"];
            this.licensorImageID = data["LicensorImageID"];
            this.fileNameAsDelivered = data["FileNameAsDelivered"];
            this.imageFileFormatAsDelivered = data["ImageFileFormatAsDelivered"];
            this.imageFileSizeAsDelivered = data["ImageFileSizeAsDelivered"];
            this.copyrightStatus = data["CopyrightStatus"];
            this.copyrightRegistrationNumber = data["CopyrightRegistrationNumber"];
            this.firstPublicationDate = data["FirstPublicationDate"] ? new Date(data["FirstPublicationDate"].toString()) : <any>undefined;
            if (data["CopyrightOwner"] && data["CopyrightOwner"].constructor === Array) {
                this.copyrightOwner = [];
                for (let item of data["CopyrightOwner"])
                    this.copyrightOwner.push(CopyrightOwnerInfo.fromJS(item));
            }
            this.copyrightOwnerImageID = data["CopyrightOwnerImageID"];
            if (data["ImageCreator"] && data["ImageCreator"].constructor === Array) {
                this.imageCreator = [];
                for (let item of data["ImageCreator"])
                    this.imageCreator.push(ImageCreatorInfo.fromJS(item));
            }
            this.imageCreatorImageID = data["ImageCreatorImageID"];
            if (data["ImageSupplier"] && data["ImageSupplier"].constructor === Array) {
                this.imageSupplier = [];
                for (let item of data["ImageSupplier"])
                    this.imageSupplier.push(ImageSupplierInfo.fromJS(item));
            }
            this.imageSupplierImageID = data["ImageSupplierImageID"];
            this.licenseeImageID = data["LicenseeImageID"];
            if (data["LicenseeImageNotes"]) {
                this.licenseeImageNotes = {};
                for (let key in data["LicenseeImageNotes"]) {
                    if (data["LicenseeImageNotes"].hasOwnProperty(key))
                        this.licenseeImageNotes[key] = data["LicenseeImageNotes"][key];
                }
            }
            if (data["OtherImageInfo"]) {
                this.otherImageInfo = {};
                for (let key in data["OtherImageInfo"]) {
                    if (data["OtherImageInfo"].hasOwnProperty(key))
                        this.otherImageInfo[key] = data["OtherImageInfo"][key];
                }
            }
            this.licenseID = data["LicenseID"];
            if (data["LicensorTransactionID"] && data["LicensorTransactionID"].constructor === Array) {
                this.licensorTransactionID = [];
                for (let item of data["LicensorTransactionID"])
                    this.licensorTransactionID.push(item);
            }
            if (data["LicenseeTransactionID"] && data["LicenseeTransactionID"].constructor === Array) {
                this.licenseeTransactionID = [];
                for (let item of data["LicenseeTransactionID"])
                    this.licenseeTransactionID.push(item);
            }
            if (data["LicenseeProjectReference"] && data["LicenseeProjectReference"].constructor === Array) {
                this.licenseeProjectReference = [];
                for (let item of data["LicenseeProjectReference"])
                    this.licenseeProjectReference.push(item);
            }
            this.licenseTransactionDate = data["LicenseTransactionDate"] ? new Date(data["LicenseTransactionDate"].toString()) : <any>undefined;
            this.reuse = data["Reuse"];
            if (data["OtherLicenseDocuments"] && data["OtherLicenseDocuments"].constructor === Array) {
                this.otherLicenseDocuments = [];
                for (let item of data["OtherLicenseDocuments"])
                    this.otherLicenseDocuments.push(item);
            }
            if (data["OtherLicenseInfo"]) {
                this.otherLicenseInfo = {};
                for (let key in data["OtherLicenseInfo"]) {
                    if (data["OtherLicenseInfo"].hasOwnProperty(key))
                        this.otherLicenseInfo[key] = data["OtherLicenseInfo"][key];
                }
            }
            if (data["Custom1"] && data["Custom1"].constructor === Array) {
                this.custom1 = [];
                for (let item of data["Custom1"])
                    this.custom1.push(item);
            }
            if (data["Custom2"] && data["Custom2"].constructor === Array) {
                this.custom2 = [];
                for (let item of data["Custom2"])
                    this.custom2.push(item);
            }
            if (data["Custom3"] && data["Custom3"].constructor === Array) {
                this.custom3 = [];
                for (let item of data["Custom3"])
                    this.custom3.push(item);
            }
            if (data["Custom4"] && data["Custom4"].constructor === Array) {
                this.custom4 = [];
                for (let item of data["Custom4"])
                    this.custom4.push(item);
            }
            if (data["Custom5"] && data["Custom5"].constructor === Array) {
                this.custom5 = [];
                for (let item of data["Custom5"])
                    this.custom5.push(item);
            }
            if (data["Custom6"] && data["Custom6"].constructor === Array) {
                this.custom6 = [];
                for (let item of data["Custom6"])
                    this.custom6.push(item);
            }
            if (data["Custom7"] && data["Custom7"].constructor === Array) {
                this.custom7 = [];
                for (let item of data["Custom7"])
                    this.custom7.push(item);
            }
            if (data["Custom8"] && data["Custom8"].constructor === Array) {
                this.custom8 = [];
                for (let item of data["Custom8"])
                    this.custom8.push(item);
            }
            if (data["Custom9"] && data["Custom9"].constructor === Array) {
                this.custom9 = [];
                for (let item of data["Custom9"])
                    this.custom9.push(item);
            }
            if (data["Custom10"] && data["Custom10"].constructor === Array) {
                this.custom10 = [];
                for (let item of data["Custom10"])
                    this.custom10.push(item);
            }
        }
    }

    static fromJS(data: any): Plus {
        let result = new Plus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Version"] = this.version;
        if (this.licensee && this.licensee.constructor === Array) {
            data["Licensee"] = [];
            for (let item of this.licensee)
                data["Licensee"].push(item.toJSON());
        }
        data["LicenseeID"] = this.licenseeID;
        data["LicenseeName"] = this.licenseeName;
        if (this.endUser && this.endUser.constructor === Array) {
            data["EndUser"] = [];
            for (let item of this.endUser)
                data["EndUser"].push(item.toJSON());
        }
        data["EndUserID"] = this.endUserID;
        data["EndUserName"] = this.endUserName;
        if (this.licensor && this.licensor.constructor === Array) {
            data["Licensor"] = [];
            for (let item of this.licensor)
                data["Licensor"].push(item.toJSON());
        }
        if (this.licensorNotes) {
            data["LicensorNotes"] = {};
            for (let key in this.licensorNotes) {
                if (this.licensorNotes.hasOwnProperty(key))
                    data["LicensorNotes"][key] = this.licensorNotes[key];
            }
        }
        data["MediaSummaryCode"] = this.mediaSummaryCode;
        data["LicenseStartDate"] = this.licenseStartDate ? this.licenseStartDate.toISOString() : <any>undefined;
        data["LicenseEndDate"] = this.licenseEndDate ? this.licenseEndDate.toISOString() : <any>undefined;
        if (this.mediaConstraints) {
            data["MediaConstraints"] = {};
            for (let key in this.mediaConstraints) {
                if (this.mediaConstraints.hasOwnProperty(key))
                    data["MediaConstraints"][key] = this.mediaConstraints[key];
            }
        }
        if (this.regionConstraints) {
            data["RegionConstraints"] = {};
            for (let key in this.regionConstraints) {
                if (this.regionConstraints.hasOwnProperty(key))
                    data["RegionConstraints"][key] = this.regionConstraints[key];
            }
        }
        if (this.productOrServiceConstraints) {
            data["ProductOrServiceConstraints"] = {};
            for (let key in this.productOrServiceConstraints) {
                if (this.productOrServiceConstraints.hasOwnProperty(key))
                    data["ProductOrServiceConstraints"][key] = this.productOrServiceConstraints[key];
            }
        }
        if (this.imageFileConstraints && this.imageFileConstraints.constructor === Array) {
            data["ImageFileConstraints"] = [];
            for (let item of this.imageFileConstraints)
                data["ImageFileConstraints"].push(item);
        }
        if (this.imageAlterationConstraints && this.imageAlterationConstraints.constructor === Array) {
            data["ImageAlterationConstraints"] = [];
            for (let item of this.imageAlterationConstraints)
                data["ImageAlterationConstraints"].push(item);
        }
        data["ImageDuplicationConstraints"] = this.imageDuplicationConstraints;
        data["ModelReleaseStatus"] = this.modelReleaseStatus;
        if (this.modelReleaseID && this.modelReleaseID.constructor === Array) {
            data["ModelReleaseID"] = [];
            for (let item of this.modelReleaseID)
                data["ModelReleaseID"].push(item);
        }
        data["MinorModelAgeDisclosure"] = this.minorModelAgeDisclosure;
        data["PropertyReleaseStatus"] = this.propertyReleaseStatus;
        if (this.propertyReleaseID && this.propertyReleaseID.constructor === Array) {
            data["PropertyReleaseID"] = [];
            for (let item of this.propertyReleaseID)
                data["PropertyReleaseID"].push(item);
        }
        if (this.otherConstraints) {
            data["OtherConstraints"] = {};
            for (let key in this.otherConstraints) {
                if (this.otherConstraints.hasOwnProperty(key))
                    data["OtherConstraints"][key] = this.otherConstraints[key];
            }
        }
        data["CreditLineRequired"] = this.creditLineRequired;
        data["AdultContentWarning"] = this.adultContentWarning;
        if (this.otherLicenseRequirements) {
            data["OtherLicenseRequirements"] = {};
            for (let key in this.otherLicenseRequirements) {
                if (this.otherLicenseRequirements.hasOwnProperty(key))
                    data["OtherLicenseRequirements"][key] = this.otherLicenseRequirements[key];
            }
        }
        if (this.termsAndConditionsText) {
            data["TermsAndConditionsText"] = {};
            for (let key in this.termsAndConditionsText) {
                if (this.termsAndConditionsText.hasOwnProperty(key))
                    data["TermsAndConditionsText"][key] = this.termsAndConditionsText[key];
            }
        }
        data["TermsAndConditionsURL"] = this.termsAndConditionsURL;
        if (this.otherConditions) {
            data["OtherConditions"] = {};
            for (let key in this.otherConditions) {
                if (this.otherConditions.hasOwnProperty(key))
                    data["OtherConditions"][key] = this.otherConditions[key];
            }
        }
        data["ImageType"] = this.imageType;
        data["LicensorImageID"] = this.licensorImageID;
        data["FileNameAsDelivered"] = this.fileNameAsDelivered;
        data["ImageFileFormatAsDelivered"] = this.imageFileFormatAsDelivered;
        data["ImageFileSizeAsDelivered"] = this.imageFileSizeAsDelivered;
        data["CopyrightStatus"] = this.copyrightStatus;
        data["CopyrightRegistrationNumber"] = this.copyrightRegistrationNumber;
        data["FirstPublicationDate"] = this.firstPublicationDate ? this.firstPublicationDate.toISOString() : <any>undefined;
        if (this.copyrightOwner && this.copyrightOwner.constructor === Array) {
            data["CopyrightOwner"] = [];
            for (let item of this.copyrightOwner)
                data["CopyrightOwner"].push(item.toJSON());
        }
        data["CopyrightOwnerImageID"] = this.copyrightOwnerImageID;
        if (this.imageCreator && this.imageCreator.constructor === Array) {
            data["ImageCreator"] = [];
            for (let item of this.imageCreator)
                data["ImageCreator"].push(item.toJSON());
        }
        data["ImageCreatorImageID"] = this.imageCreatorImageID;
        if (this.imageSupplier && this.imageSupplier.constructor === Array) {
            data["ImageSupplier"] = [];
            for (let item of this.imageSupplier)
                data["ImageSupplier"].push(item.toJSON());
        }
        data["ImageSupplierImageID"] = this.imageSupplierImageID;
        data["LicenseeImageID"] = this.licenseeImageID;
        if (this.licenseeImageNotes) {
            data["LicenseeImageNotes"] = {};
            for (let key in this.licenseeImageNotes) {
                if (this.licenseeImageNotes.hasOwnProperty(key))
                    data["LicenseeImageNotes"][key] = this.licenseeImageNotes[key];
            }
        }
        if (this.otherImageInfo) {
            data["OtherImageInfo"] = {};
            for (let key in this.otherImageInfo) {
                if (this.otherImageInfo.hasOwnProperty(key))
                    data["OtherImageInfo"][key] = this.otherImageInfo[key];
            }
        }
        data["LicenseID"] = this.licenseID;
        if (this.licensorTransactionID && this.licensorTransactionID.constructor === Array) {
            data["LicensorTransactionID"] = [];
            for (let item of this.licensorTransactionID)
                data["LicensorTransactionID"].push(item);
        }
        if (this.licenseeTransactionID && this.licenseeTransactionID.constructor === Array) {
            data["LicenseeTransactionID"] = [];
            for (let item of this.licenseeTransactionID)
                data["LicenseeTransactionID"].push(item);
        }
        if (this.licenseeProjectReference && this.licenseeProjectReference.constructor === Array) {
            data["LicenseeProjectReference"] = [];
            for (let item of this.licenseeProjectReference)
                data["LicenseeProjectReference"].push(item);
        }
        data["LicenseTransactionDate"] = this.licenseTransactionDate ? this.licenseTransactionDate.toISOString() : <any>undefined;
        data["Reuse"] = this.reuse;
        if (this.otherLicenseDocuments && this.otherLicenseDocuments.constructor === Array) {
            data["OtherLicenseDocuments"] = [];
            for (let item of this.otherLicenseDocuments)
                data["OtherLicenseDocuments"].push(item);
        }
        if (this.otherLicenseInfo) {
            data["OtherLicenseInfo"] = {};
            for (let key in this.otherLicenseInfo) {
                if (this.otherLicenseInfo.hasOwnProperty(key))
                    data["OtherLicenseInfo"][key] = this.otherLicenseInfo[key];
            }
        }
        if (this.custom1 && this.custom1.constructor === Array) {
            data["Custom1"] = [];
            for (let item of this.custom1)
                data["Custom1"].push(item);
        }
        if (this.custom2 && this.custom2.constructor === Array) {
            data["Custom2"] = [];
            for (let item of this.custom2)
                data["Custom2"].push(item);
        }
        if (this.custom3 && this.custom3.constructor === Array) {
            data["Custom3"] = [];
            for (let item of this.custom3)
                data["Custom3"].push(item);
        }
        if (this.custom4 && this.custom4.constructor === Array) {
            data["Custom4"] = [];
            for (let item of this.custom4)
                data["Custom4"].push(item);
        }
        if (this.custom5 && this.custom5.constructor === Array) {
            data["Custom5"] = [];
            for (let item of this.custom5)
                data["Custom5"].push(item);
        }
        if (this.custom6 && this.custom6.constructor === Array) {
            data["Custom6"] = [];
            for (let item of this.custom6)
                data["Custom6"].push(item);
        }
        if (this.custom7 && this.custom7.constructor === Array) {
            data["Custom7"] = [];
            for (let item of this.custom7)
                data["Custom7"].push(item);
        }
        if (this.custom8 && this.custom8.constructor === Array) {
            data["Custom8"] = [];
            for (let item of this.custom8)
                data["Custom8"].push(item);
        }
        if (this.custom9 && this.custom9.constructor === Array) {
            data["Custom9"] = [];
            for (let item of this.custom9)
                data["Custom9"].push(item);
        }
        if (this.custom10 && this.custom10.constructor === Array) {
            data["Custom10"] = [];
            for (let item of this.custom10)
                data["Custom10"].push(item);
        }
        return data; 
    }
}

export interface IPlus {
    version?: string | undefined;
    licensee?: LicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: EndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: LicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: CopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: ImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: ImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;
}

export class LicenseeInfo implements ILicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;

    constructor(data?: ILicenseeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.licenseeName = data["LicenseeName"];
            this.licenseeID = data["LicenseeID"];
        }
    }

    static fromJS(data: any): LicenseeInfo {
        let result = new LicenseeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LicenseeName"] = this.licenseeName;
        data["LicenseeID"] = this.licenseeID;
        return data; 
    }
}

export interface ILicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;
}

export class EndUserInfo implements IEndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;

    constructor(data?: IEndUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.endUserName = data["EndUserName"];
            this.endUserID = data["EndUserID"];
        }
    }

    static fromJS(data: any): EndUserInfo {
        let result = new EndUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EndUserName"] = this.endUserName;
        data["EndUserID"] = this.endUserID;
        return data; 
    }
}

export interface IEndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;
}

export class LicensorInfo implements ILicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;

    constructor(data?: ILicensorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.licensorName = data["LicensorName"];
            this.licensorID = data["LicensorID"];
            this.licensorStreetAddress = data["LicensorStreetAddress"];
            this.licensorExtendedAddress = data["LicensorExtendedAddress"];
            this.licensorCity = data["LicensorCity"];
            this.licensorRegion = data["LicensorRegion"];
            this.licensorPostalCode = data["LicensorPostalCode"];
            this.licensorCountry = data["LicensorCountry"];
            this.licensorTelephoneType1 = data["LicensorTelephoneType1"];
            this.licensorTelephone1 = data["LicensorTelephone1"];
            this.licensorTelephoneType2 = data["LicensorTelephoneType2"];
            this.licensorTelephone2 = data["LicensorTelephone2"];
            this.licensorEmail = data["LicensorEmail"];
            this.licensorURL = data["LicensorURL"];
        }
    }

    static fromJS(data: any): LicensorInfo {
        let result = new LicensorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LicensorName"] = this.licensorName;
        data["LicensorID"] = this.licensorID;
        data["LicensorStreetAddress"] = this.licensorStreetAddress;
        data["LicensorExtendedAddress"] = this.licensorExtendedAddress;
        data["LicensorCity"] = this.licensorCity;
        data["LicensorRegion"] = this.licensorRegion;
        data["LicensorPostalCode"] = this.licensorPostalCode;
        data["LicensorCountry"] = this.licensorCountry;
        data["LicensorTelephoneType1"] = this.licensorTelephoneType1;
        data["LicensorTelephone1"] = this.licensorTelephone1;
        data["LicensorTelephoneType2"] = this.licensorTelephoneType2;
        data["LicensorTelephone2"] = this.licensorTelephone2;
        data["LicensorEmail"] = this.licensorEmail;
        data["LicensorURL"] = this.licensorURL;
        return data; 
    }
}

export interface ILicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;
}

export class CopyrightOwnerInfo implements ICopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;

    constructor(data?: ICopyrightOwnerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.copyrightOwnerName = data["CopyrightOwnerName"];
            this.copyrightOwnerID = data["CopyrightOwnerID"];
        }
    }

    static fromJS(data: any): CopyrightOwnerInfo {
        let result = new CopyrightOwnerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CopyrightOwnerName"] = this.copyrightOwnerName;
        data["CopyrightOwnerID"] = this.copyrightOwnerID;
        return data; 
    }
}

export interface ICopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;
}

export class ImageCreatorInfo implements IImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;

    constructor(data?: IImageCreatorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageCreatorName = data["ImageCreatorName"];
            this.imageCreatorID = data["ImageCreatorID"];
        }
    }

    static fromJS(data: any): ImageCreatorInfo {
        let result = new ImageCreatorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ImageCreatorName"] = this.imageCreatorName;
        data["ImageCreatorID"] = this.imageCreatorID;
        return data; 
    }
}

export interface IImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;
}

export class ImageSupplierInfo implements IImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;

    constructor(data?: IImageSupplierInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageSupplierName = data["ImageSupplierName"];
            this.imageSupplierID = data["ImageSupplierID"];
        }
    }

    static fromJS(data: any): ImageSupplierInfo {
        let result = new ImageSupplierInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ImageSupplierName"] = this.imageSupplierName;
        data["ImageSupplierID"] = this.imageSupplierID;
        return data; 
    }
}

export interface IImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;
}

export class Tiff implements ITiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;

    constructor(data?: ITiff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.artist = data["Artist"];
            if (data["BitsPerSample"] && data["BitsPerSample"].constructor === Array) {
                this.bitsPerSample = [];
                for (let item of data["BitsPerSample"])
                    this.bitsPerSample.push(item);
            }
            this.compression = data["Compression"];
            if (data["Copyright"]) {
                this.copyright = {};
                for (let key in data["Copyright"]) {
                    if (data["Copyright"].hasOwnProperty(key))
                        this.copyright[key] = data["Copyright"][key];
                }
            }
            this.dateTime = data["DateTime"] ? new Date(data["DateTime"].toString()) : <any>undefined;
            if (data["ImageDescription"]) {
                this.imageDescription = {};
                for (let key in data["ImageDescription"]) {
                    if (data["ImageDescription"].hasOwnProperty(key))
                        this.imageDescription[key] = data["ImageDescription"][key];
                }
            }
            this.imageLength = data["ImageLength"];
            this.imageWidth = data["ImageWidth"];
            this.make = data["Make"];
            this.model = data["Model"];
            this.orientation = data["Orientation"];
            this.photometricInterpretation = data["PhotometricInterpretation"];
            this.planarConfiguration = data["PlanarConfiguration"];
            if (data["PrimaryChromaticities"] && data["PrimaryChromaticities"].constructor === Array) {
                this.primaryChromaticities = [];
                for (let item of data["PrimaryChromaticities"])
                    this.primaryChromaticities.push(item);
            }
            if (data["ReferenceBlackWhite"] && data["ReferenceBlackWhite"].constructor === Array) {
                this.referenceBlackWhite = [];
                for (let item of data["ReferenceBlackWhite"])
                    this.referenceBlackWhite.push(item);
            }
            this.resolutionUnit = data["ResolutionUnit"];
            this.samplesPerPixel = data["SamplesPerPixel"];
            this.software = data["Software"];
            if (data["TransferFunction"] && data["TransferFunction"].constructor === Array) {
                this.transferFunction = [];
                for (let item of data["TransferFunction"])
                    this.transferFunction.push(item);
            }
            if (data["WhitePoint"] && data["WhitePoint"].constructor === Array) {
                this.whitePoint = [];
                for (let item of data["WhitePoint"])
                    this.whitePoint.push(item);
            }
            this.xResolution = data["XResolution"];
            this.yResolution = data["YResolution"];
            if (data["YCbCrCoefficients"] && data["YCbCrCoefficients"].constructor === Array) {
                this.yCbCrCoefficients = [];
                for (let item of data["YCbCrCoefficients"])
                    this.yCbCrCoefficients.push(item);
            }
            this.yCbCrPositioning = data["YCbCrPositioning"];
            this.yCbCrSubSampling = data["YCbCrSubSampling"];
            this.nativeDigest = data["NativeDigest"];
        }
    }

    static fromJS(data: any): Tiff {
        let result = new Tiff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Artist"] = this.artist;
        if (this.bitsPerSample && this.bitsPerSample.constructor === Array) {
            data["BitsPerSample"] = [];
            for (let item of this.bitsPerSample)
                data["BitsPerSample"].push(item);
        }
        data["Compression"] = this.compression;
        if (this.copyright) {
            data["Copyright"] = {};
            for (let key in this.copyright) {
                if (this.copyright.hasOwnProperty(key))
                    data["Copyright"][key] = this.copyright[key];
            }
        }
        data["DateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        if (this.imageDescription) {
            data["ImageDescription"] = {};
            for (let key in this.imageDescription) {
                if (this.imageDescription.hasOwnProperty(key))
                    data["ImageDescription"][key] = this.imageDescription[key];
            }
        }
        data["ImageLength"] = this.imageLength;
        data["ImageWidth"] = this.imageWidth;
        data["Make"] = this.make;
        data["Model"] = this.model;
        data["Orientation"] = this.orientation;
        data["PhotometricInterpretation"] = this.photometricInterpretation;
        data["PlanarConfiguration"] = this.planarConfiguration;
        if (this.primaryChromaticities && this.primaryChromaticities.constructor === Array) {
            data["PrimaryChromaticities"] = [];
            for (let item of this.primaryChromaticities)
                data["PrimaryChromaticities"].push(item);
        }
        if (this.referenceBlackWhite && this.referenceBlackWhite.constructor === Array) {
            data["ReferenceBlackWhite"] = [];
            for (let item of this.referenceBlackWhite)
                data["ReferenceBlackWhite"].push(item);
        }
        data["ResolutionUnit"] = this.resolutionUnit;
        data["SamplesPerPixel"] = this.samplesPerPixel;
        data["Software"] = this.software;
        if (this.transferFunction && this.transferFunction.constructor === Array) {
            data["TransferFunction"] = [];
            for (let item of this.transferFunction)
                data["TransferFunction"].push(item);
        }
        if (this.whitePoint && this.whitePoint.constructor === Array) {
            data["WhitePoint"] = [];
            for (let item of this.whitePoint)
                data["WhitePoint"].push(item);
        }
        data["XResolution"] = this.xResolution;
        data["YResolution"] = this.yResolution;
        if (this.yCbCrCoefficients && this.yCbCrCoefficients.constructor === Array) {
            data["YCbCrCoefficients"] = [];
            for (let item of this.yCbCrCoefficients)
                data["YCbCrCoefficients"].push(item);
        }
        data["YCbCrPositioning"] = this.yCbCrPositioning;
        data["YCbCrSubSampling"] = this.yCbCrSubSampling;
        data["NativeDigest"] = this.nativeDigest;
        return data; 
    }
}

export interface ITiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;
}

/** Corresponds to tiff.CompressionChoice */
export enum Compression {
    Uncompressed = <any>"Uncompressed", 
    CCITT = <any>"CCITT", 
    T4 = <any>"T4", 
    T6 = <any>"T6", 
    LZW = <any>"LZW", 
    OJPEG = <any>"OJPEG", 
    JPEG = <any>"JPEG", 
    Deflate = <any>"Deflate", 
    T82 = <any>"T82", 
    T43 = <any>"T43", 
    NeXT = <any>"NeXT", 
    ARW = <any>"ARW", 
    RAW = <any>"RAW", 
    SRW = <any>"SRW", 
    Group3_1D = <any>"Group3_1D", 
    PackBits = <any>"PackBits", 
    ThunderScan = <any>"ThunderScan", 
    KDC = <any>"KDC", 
    RasterPadding = <any>"RasterPadding", 
    LineWork = <any>"LineWork", 
    HighContinuous = <any>"HighContinuous", 
    BinaryLineWork = <any>"BinaryLineWork", 
    PixarFilm = <any>"PixarFilm", 
    PixarLog = <any>"PixarLog", 
    DCS = <any>"DCS", 
    JBIG = <any>"JBIG", 
    JPEG2000 = <any>"JPEG2000", 
    NEF = <any>"NEF", 
    JBIG2 = <any>"JBIG2", 
    DCR = <any>"DCR", 
    PEF = <any>"PEF", 
}

/** Corresponds to tiff.OrientationChoice */
export enum Orientation {
    None = <any>"None", 
    TopRowLeftColumn = <any>"TopRowLeftColumn", 
    TopRowRightColumn = <any>"TopRowRightColumn", 
    BottomRowLeftColumn = <any>"BottomRowLeftColumn", 
    BottomRowRightColumn = <any>"BottomRowRightColumn", 
    LeftRowTopColumn = <any>"LeftRowTopColumn", 
    RightRowTopColumn = <any>"RightRowTopColumn", 
    RightRowBottomColumn = <any>"RightRowBottomColumn", 
    LeftRowBottomColumn = <any>"LeftRowBottomColumn", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to tiff.PhotometricInterpretationChoice */
export enum PhotometricInterpretation {
    WhiteIsZero = <any>"WhiteIsZero", 
    BlackIsZero = <any>"BlackIsZero", 
    RGB = <any>"RGB", 
    Palette = <any>"Palette", 
    TransparencyMask = <any>"TransparencyMask", 
    CMYK = <any>"CMYK", 
    YCbCr = <any>"YCbCr", 
    CIELab = <any>"CIELab", 
    ICCLab = <any>"ICCLab", 
    ITULab = <any>"ITULab", 
    ColorFilterArray = <any>"ColorFilterArray", 
    LogL = <any>"LogL", 
    LogLUV = <any>"LogLUV", 
    LinearRaw = <any>"LinearRaw", 
}

/** Corresponds to tiff.PlanarConfigurationChoice */
export enum PlanarConfiguration {
    Chunky = <any>"Chunky", 
    Planar = <any>"Planar", 
    Line = <any>"Line", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum ResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Centimeter = <any>"Centimeter", 
}

/** Corresponds to tiff.YCbCrPositioningChoice */
export enum YCbCrPositioning {
    Centered = <any>"Centered", 
    Cosited = <any>"Cosited", 
}

/** Corresponds to tiff.YCbCrSubSamplingChoice */
export enum YCbCrSubSampling {
    YCbCr111 = <any>"YCbCr111", 
    YCbCr422 = <any>"YCbCr422", 
    YCbCr420 = <any>"YCbCr420", 
}

export class Xmp implements IXmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: XmpGImg[] | undefined;
    pageInfo?: XmpGImg[] | undefined;

    constructor(data?: IXmp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseURL = data["BaseURL"];
            this.createDate = data["CreateDate"] ? new Date(data["CreateDate"].toString()) : <any>undefined;
            this.creatorTool = data["CreatorTool"];
            if (data["Identifier"] && data["Identifier"].constructor === Array) {
                this.identifier = [];
                for (let item of data["Identifier"])
                    this.identifier.push(item);
            }
            this.label = data["Label"];
            this.metadataDate = data["MetadataDate"] ? new Date(data["MetadataDate"].toString()) : <any>undefined;
            this.modifyDate = data["ModifyDate"] ? new Date(data["ModifyDate"].toString()) : <any>undefined;
            this.nickname = data["Nickname"];
            this.rating = data["Rating"];
            if (data["Thumbnails"] && data["Thumbnails"].constructor === Array) {
                this.thumbnails = [];
                for (let item of data["Thumbnails"])
                    this.thumbnails.push(XmpGImg.fromJS(item));
            }
            if (data["PageInfo"] && data["PageInfo"].constructor === Array) {
                this.pageInfo = [];
                for (let item of data["PageInfo"])
                    this.pageInfo.push(XmpGImg.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Xmp {
        let result = new Xmp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BaseURL"] = this.baseURL;
        data["CreateDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["CreatorTool"] = this.creatorTool;
        if (this.identifier && this.identifier.constructor === Array) {
            data["Identifier"] = [];
            for (let item of this.identifier)
                data["Identifier"].push(item);
        }
        data["Label"] = this.label;
        data["MetadataDate"] = this.metadataDate ? this.metadataDate.toISOString() : <any>undefined;
        data["ModifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["Nickname"] = this.nickname;
        data["Rating"] = this.rating;
        if (this.thumbnails && this.thumbnails.constructor === Array) {
            data["Thumbnails"] = [];
            for (let item of this.thumbnails)
                data["Thumbnails"].push(item.toJSON());
        }
        if (this.pageInfo && this.pageInfo.constructor === Array) {
            data["PageInfo"] = [];
            for (let item of this.pageInfo)
                data["PageInfo"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: XmpGImg[] | undefined;
    pageInfo?: XmpGImg[] | undefined;
}

/** Corresponds to xmp.RatingChoice */
export enum Rating {
    Rejected = <any>"Rejected", 
    Unrated = <any>"Unrated", 
    One = <any>"One", 
    Two = <any>"Two", 
    Three = <any>"Three", 
    Four = <any>"Four", 
    Five = <any>"Five", 
}

export class XmpGImg implements IXmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;

    constructor(data?: IXmpGImg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.format = data["Format"];
            this.width = data["Width"];
            this.height = data["Height"];
            this.image = data["Image"];
        }
    }

    static fromJS(data: any): XmpGImg {
        let result = new XmpGImg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Format"] = this.format;
        data["Width"] = this.width;
        data["Height"] = this.height;
        data["Image"] = this.image;
        return data; 
    }
}

export interface IXmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;
}

/** Corresponds to xmpGImg.FormatChoice */
export enum ImgFormat {
    JPEG = <any>"JPEG", 
}

export class XmpBJ implements IXmpBJ {
    jobRef?: Job[] | undefined;

    constructor(data?: IXmpBJ) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["JobRef"] && data["JobRef"].constructor === Array) {
                this.jobRef = [];
                for (let item of data["JobRef"])
                    this.jobRef.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpBJ {
        let result = new XmpBJ();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.jobRef && this.jobRef.constructor === Array) {
            data["JobRef"] = [];
            for (let item of this.jobRef)
                data["JobRef"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmpBJ {
    jobRef?: Job[] | undefined;
}

export class Job implements IJob {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.url = data["Url"];
        }
    }

    static fromJS(data: any): Job {
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Url"] = this.url;
        return data; 
    }
}

export interface IJob {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class XmpDM implements IXmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: TimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: BeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: Media[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: Time | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: Time | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: Marker[] | undefined;
    outCue?: Time | undefined;
    projectName?: string | undefined;
    projectRef?: ProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: Time | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: ResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: TimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: TimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: Track[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: XmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: Dimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;

    constructor(data?: IXmpDM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.absPeakAudioFilePath = data["AbsPeakAudioFilePath"];
            this.artist = data["Artist"];
            this.album = data["Album"];
            this.altTapeName = data["AltTapeName"];
            this.altTimecode = data["AltTimecode"] ? TimeCode.fromJS(data["AltTimecode"]) : <any>undefined;
            this.audioChannelType = data["AudioChannelType"];
            this.audioCompressor = data["AudioCompressor"];
            this.audioSampleRate = data["AudioSampleRate"];
            this.audioSampleType = data["AudioSampleType"];
            this.beatSpliceParams = data["BeatSpliceParams"] ? BeatSpliceStretch.fromJS(data["BeatSpliceParams"]) : <any>undefined;
            this.cameraAngle = data["CameraAngle"];
            this.cameraLabel = data["CameraLabel"];
            this.cameraModel = data["CameraModel"];
            this.cameraMove = data["CameraMove"];
            this.client = data["Client"];
            this.comment = data["Comment"];
            this.composer = data["Composer"];
            if (data["ContributedMedia"] && data["ContributedMedia"].constructor === Array) {
                this.contributedMedia = [];
                for (let item of data["ContributedMedia"])
                    this.contributedMedia.push(Media.fromJS(item));
            }
            this.director = data["Director"];
            this.directorPhotography = data["DirectorPhotography"];
            this.duration = data["Duration"] ? Time.fromJS(data["Duration"]) : <any>undefined;
            this.engineer = data["Engineer"];
            this.fileDataRate = data["FileDataRate"];
            this.genre = data["Genre"];
            this.good = data["Good"];
            this.instrument = data["Instrument"];
            this.introTime = data["IntroTime"] ? Time.fromJS(data["IntroTime"]) : <any>undefined;
            this.key = data["Key"];
            this.logComment = data["LogComment"];
            this.loop = data["Loop"];
            this.numberOfBeats = data["NumberOfBeats"];
            if (data["Markers"] && data["Markers"].constructor === Array) {
                this.markers = [];
                for (let item of data["Markers"])
                    this.markers.push(Marker.fromJS(item));
            }
            this.outCue = data["OutCue"] ? Time.fromJS(data["OutCue"]) : <any>undefined;
            this.projectName = data["ProjectName"];
            this.projectRef = data["ProjectRef"] ? ProjectLink.fromJS(data["ProjectRef"]) : <any>undefined;
            this.pullDown = data["PullDown"];
            this.relativePeakAudioFilePath = data["RelativePeakAudioFilePath"];
            this.relativeTimestamp = data["RelativeTimestamp"] ? Time.fromJS(data["RelativeTimestamp"]) : <any>undefined;
            this.releaseDate = data["ReleaseDate"] ? new Date(data["ReleaseDate"].toString()) : <any>undefined;
            this.resampleParams = data["ResampleParams"] ? ResampleStretch.fromJS(data["ResampleParams"]) : <any>undefined;
            this.scaleType = data["ScaleType"];
            this.scene = data["Scene"];
            this.shotDate = data["ShotDate"] ? new Date(data["ShotDate"].toString()) : <any>undefined;
            this.shotDay = data["ShotDay"];
            this.shotLocation = data["ShotLocation"];
            this.shotName = data["ShotName"];
            this.shotNumber = data["ShotNumber"];
            this.shotSize = data["ShotSize"];
            this.speakerPlacement = data["SpeakerPlacement"];
            this.startTimecode = data["StartTimecode"] ? TimeCode.fromJS(data["StartTimecode"]) : <any>undefined;
            this.stretchMode = data["StretchMode"];
            this.takeNumber = data["TakeNumber"];
            this.tapeName = data["TapeName"];
            this.tempo = data["Tempo"];
            this.timeScaleParams = data["TimeScaleParams"] ? TimeScaleStretch.fromJS(data["TimeScaleParams"]) : <any>undefined;
            this.timeSignature = data["TimeSignature"];
            this.trackNumber = data["TrackNumber"];
            if (data["Tracks"] && data["Tracks"].constructor === Array) {
                this.tracks = [];
                for (let item of data["Tracks"])
                    this.tracks.push(Track.fromJS(item));
            }
            this.videoAlphaMode = data["VideoAlphaMode"];
            this.videoAlphaPremultipleColor = data["VideoAlphaPremultipleColor"] ? XmpG.fromJS(data["VideoAlphaPremultipleColor"]) : <any>undefined;
            this.videoAlphaUnityIsTransparent = data["VideoAlphaUnityIsTransparent"];
            this.videoColorSpace = data["VideoColorSpace"];
            this.videoCompressor = data["VideoCompressor"];
            this.videoFieldOrder = data["VideoFieldOrder"];
            this.videoFrameRate = data["VideoFrameRate"];
            this.videoFrameSize = data["VideoFrameSize"] ? Dimension.fromJS(data["VideoFrameSize"]) : <any>undefined;
            this.videoPixelDepth = data["VideoPixelDepth"];
            this.videoPixelAspectRatio = data["VideoPixelAspectRatio"];
        }
    }

    static fromJS(data: any): XmpDM {
        let result = new XmpDM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AbsPeakAudioFilePath"] = this.absPeakAudioFilePath;
        data["Artist"] = this.artist;
        data["Album"] = this.album;
        data["AltTapeName"] = this.altTapeName;
        data["AltTimecode"] = this.altTimecode ? this.altTimecode.toJSON() : <any>undefined;
        data["AudioChannelType"] = this.audioChannelType;
        data["AudioCompressor"] = this.audioCompressor;
        data["AudioSampleRate"] = this.audioSampleRate;
        data["AudioSampleType"] = this.audioSampleType;
        data["BeatSpliceParams"] = this.beatSpliceParams ? this.beatSpliceParams.toJSON() : <any>undefined;
        data["CameraAngle"] = this.cameraAngle;
        data["CameraLabel"] = this.cameraLabel;
        data["CameraModel"] = this.cameraModel;
        data["CameraMove"] = this.cameraMove;
        data["Client"] = this.client;
        data["Comment"] = this.comment;
        data["Composer"] = this.composer;
        if (this.contributedMedia && this.contributedMedia.constructor === Array) {
            data["ContributedMedia"] = [];
            for (let item of this.contributedMedia)
                data["ContributedMedia"].push(item.toJSON());
        }
        data["Director"] = this.director;
        data["DirectorPhotography"] = this.directorPhotography;
        data["Duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["Engineer"] = this.engineer;
        data["FileDataRate"] = this.fileDataRate;
        data["Genre"] = this.genre;
        data["Good"] = this.good;
        data["Instrument"] = this.instrument;
        data["IntroTime"] = this.introTime ? this.introTime.toJSON() : <any>undefined;
        data["Key"] = this.key;
        data["LogComment"] = this.logComment;
        data["Loop"] = this.loop;
        data["NumberOfBeats"] = this.numberOfBeats;
        if (this.markers && this.markers.constructor === Array) {
            data["Markers"] = [];
            for (let item of this.markers)
                data["Markers"].push(item.toJSON());
        }
        data["OutCue"] = this.outCue ? this.outCue.toJSON() : <any>undefined;
        data["ProjectName"] = this.projectName;
        data["ProjectRef"] = this.projectRef ? this.projectRef.toJSON() : <any>undefined;
        data["PullDown"] = this.pullDown;
        data["RelativePeakAudioFilePath"] = this.relativePeakAudioFilePath;
        data["RelativeTimestamp"] = this.relativeTimestamp ? this.relativeTimestamp.toJSON() : <any>undefined;
        data["ReleaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["ResampleParams"] = this.resampleParams ? this.resampleParams.toJSON() : <any>undefined;
        data["ScaleType"] = this.scaleType;
        data["Scene"] = this.scene;
        data["ShotDate"] = this.shotDate ? this.shotDate.toISOString() : <any>undefined;
        data["ShotDay"] = this.shotDay;
        data["ShotLocation"] = this.shotLocation;
        data["ShotName"] = this.shotName;
        data["ShotNumber"] = this.shotNumber;
        data["ShotSize"] = this.shotSize;
        data["SpeakerPlacement"] = this.speakerPlacement;
        data["StartTimecode"] = this.startTimecode ? this.startTimecode.toJSON() : <any>undefined;
        data["StretchMode"] = this.stretchMode;
        data["TakeNumber"] = this.takeNumber;
        data["TapeName"] = this.tapeName;
        data["Tempo"] = this.tempo;
        data["TimeScaleParams"] = this.timeScaleParams ? this.timeScaleParams.toJSON() : <any>undefined;
        data["TimeSignature"] = this.timeSignature;
        data["TrackNumber"] = this.trackNumber;
        if (this.tracks && this.tracks.constructor === Array) {
            data["Tracks"] = [];
            for (let item of this.tracks)
                data["Tracks"].push(item.toJSON());
        }
        data["VideoAlphaMode"] = this.videoAlphaMode;
        data["VideoAlphaPremultipleColor"] = this.videoAlphaPremultipleColor ? this.videoAlphaPremultipleColor.toJSON() : <any>undefined;
        data["VideoAlphaUnityIsTransparent"] = this.videoAlphaUnityIsTransparent;
        data["VideoColorSpace"] = this.videoColorSpace;
        data["VideoCompressor"] = this.videoCompressor;
        data["VideoFieldOrder"] = this.videoFieldOrder;
        data["VideoFrameRate"] = this.videoFrameRate;
        data["VideoFrameSize"] = this.videoFrameSize ? this.videoFrameSize.toJSON() : <any>undefined;
        data["VideoPixelDepth"] = this.videoPixelDepth;
        data["VideoPixelAspectRatio"] = this.videoPixelAspectRatio;
        return data; 
    }
}

export interface IXmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: TimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: BeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: Media[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: Time | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: Time | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: Marker[] | undefined;
    outCue?: Time | undefined;
    projectName?: string | undefined;
    projectRef?: ProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: Time | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: ResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: TimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: TimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: Track[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: XmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: Dimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;
}

export class TimeCode implements ITimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;

    constructor(data?: ITimeCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeFormat = data["TimeFormat"];
            this.timeValue = data["TimeValue"];
        }
    }

    static fromJS(data: any): TimeCode {
        let result = new TimeCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TimeFormat"] = this.timeFormat;
        data["TimeValue"] = this.timeValue;
        return data; 
    }
}

export interface ITimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;
}

/** Corresponds to Timecode.TimeFormatChoice */
export enum TimeFormat {
    Timecode24 = <any>"Timecode24", 
    Timecode25 = <any>"Timecode25", 
    Timecode2997Drop = <any>"Timecode2997Drop", 
    Timecode2997NonDrop = <any>"Timecode2997NonDrop", 
    Timecode30 = <any>"Timecode30", 
    Timecode50 = <any>"Timecode50", 
    Timecode5994Drop = <any>"Timecode5994Drop", 
    Timecode5994NonDrop = <any>"Timecode5994NonDrop", 
    Timecode60 = <any>"Timecode60", 
    Timecode23976 = <any>"Timecode23976", 
}

/** Corresponds to xmpDM.AudioChannelTypeChoice */
export enum AudioChannelType {
    CHANNEL_MONO = <any>"CHANNEL_MONO", 
    CHANNEL_STEREO = <any>"CHANNEL_STEREO", 
    CHANNEL_5_1 = <any>"CHANNEL_5_1", 
    CHANNEL_7_1 = <any>"CHANNEL_7_1", 
    CHANNEL_16 = <any>"CHANNEL_16", 
    CHANNEL_OTHER = <any>"CHANNEL_OTHER", 
}

/** Corresponds to xmpDM.AudioSampleTypeChoice */
export enum AudioSampleType {
    SAMPLE_8_INT = <any>"SAMPLE_8_INT", 
    SAMPLE_16_INT = <any>"SAMPLE_16_INT", 
    SAMPLE_24_INT = <any>"SAMPLE_24_INT", 
    SAMPLE_32_INT = <any>"SAMPLE_32_INT", 
    SAMPLE_32_FLOAT = <any>"SAMPLE_32_FLOAT", 
    SAMPLE_COMPRESSED = <any>"SAMPLE_COMPRESSED", 
    SAMPLE_PACKED = <any>"SAMPLE_PACKED", 
    SAMPLE_OTHER = <any>"SAMPLE_OTHER", 
}

export class BeatSpliceStretch implements IBeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: Time | undefined;
    useFileBeatsMarker?: boolean | undefined;

    constructor(data?: IBeatSpliceStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.riseInDecibel = data["RiseInDecibel"];
            this.riseInTimeDuration = data["RiseInTimeDuration"] ? Time.fromJS(data["RiseInTimeDuration"]) : <any>undefined;
            this.useFileBeatsMarker = data["UseFileBeatsMarker"];
        }
    }

    static fromJS(data: any): BeatSpliceStretch {
        let result = new BeatSpliceStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RiseInDecibel"] = this.riseInDecibel;
        data["RiseInTimeDuration"] = this.riseInTimeDuration ? this.riseInTimeDuration.toJSON() : <any>undefined;
        data["UseFileBeatsMarker"] = this.useFileBeatsMarker;
        return data; 
    }
}

export interface IBeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: Time | undefined;
    useFileBeatsMarker?: boolean | undefined;
}

export class Time implements ITime {
    scale?: string | undefined;
    value?: number | undefined;

    constructor(data?: ITime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scale = data["Scale"];
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): Time {
        let result = new Time();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Scale"] = this.scale;
        data["Value"] = this.value;
        return data; 
    }
}

export interface ITime {
    scale?: string | undefined;
    value?: number | undefined;
}

/** Corresponds to xmpDM.CameraAngleChoice */
export enum CameraAngle {
    ANGLE_LOW = <any>"ANGLE_LOW", 
    ANGLE_EYE_LEVEL = <any>"ANGLE_EYE_LEVEL", 
    ANGLE_HIGH = <any>"ANGLE_HIGH", 
    ANGLE_OVERHEAD_SHOT = <any>"ANGLE_OVERHEAD_SHOT", 
    ANGLE_BIRDS_EYE_SHOT = <any>"ANGLE_BIRDS_EYE_SHOT", 
    ANGLE_DUTCH = <any>"ANGLE_DUTCH", 
    ANGLE_POV = <any>"ANGLE_POV", 
    ANGLE_OVER_THE_SHOULDER = <any>"ANGLE_OVER_THE_SHOULDER", 
    ANGLE_REACTION_SHOT = <any>"ANGLE_REACTION_SHOT", 
}

/** Corresponds to xmpDM.CameraMoveChoice */
export enum CameraMove {
    MOVE_AERIAL = <any>"MOVE_AERIAL", 
    MOVE_BOOM_UP = <any>"MOVE_BOOM_UP", 
    MOVE_BOOM_DOWN = <any>"MOVE_BOOM_DOWN", 
    MOVE_CRANE_UP = <any>"MOVE_CRANE_UP", 
    MOVE_CRANE_DOWN = <any>"MOVE_CRANE_DOWN", 
    MOVE_DOLLY_IN = <any>"MOVE_DOLLY_IN", 
    MOVE_DOLLY_OUT = <any>"MOVE_DOLLY_OUT", 
    MOVE_PAN_LEFT = <any>"MOVE_PAN_LEFT", 
    MOVE_PAN_RIGHT = <any>"MOVE_PAN_RIGHT", 
    MOVE_PEDESTAL_UP = <any>"MOVE_PEDESTAL_UP", 
    MOVE_PEDESTAL_DOWN = <any>"MOVE_PEDESTAL_DOWN", 
    MOVE_TILT_UP = <any>"MOVE_TILT_UP", 
    MOVE_TILT_DOWN = <any>"MOVE_TILT_DOWN", 
    MOVE_TRACKING = <any>"MOVE_TRACKING", 
    MOVE_TRUCK_LEFT = <any>"MOVE_TRUCK_LEFT", 
    MOVE_TRUCK_RIGHT = <any>"MOVE_TRUCK_RIGHT", 
    MOVE_ZOOM_IN = <any>"MOVE_ZOOM_IN", 
    MOVE_ZOOM_OUT = <any>"MOVE_ZOOM_OUT", 
}

export class Media implements IMedia {
    duration?: Time | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: Time | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.duration = data["Duration"] ? Time.fromJS(data["Duration"]) : <any>undefined;
            this.managed = data["Managed"];
            this.path = data["Path"];
            this.startTime = data["StartTime"] ? Time.fromJS(data["StartTime"]) : <any>undefined;
            this.track = data["Track"];
            this.webStatement = data["WebStatement"];
        }
    }

    static fromJS(data: any): Media {
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["Managed"] = this.managed;
        data["Path"] = this.path;
        data["StartTime"] = this.startTime ? this.startTime.toJSON() : <any>undefined;
        data["Track"] = this.track;
        data["WebStatement"] = this.webStatement;
        return data; 
    }
}

export interface IMedia {
    duration?: Time | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: Time | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;
}

/** Corresponds to xmpDM.AudioMusicalKeyChoice */
export enum AudioMusicalKey {
    KEY_C = <any>"KEY_C", 
    KEY_C_SHARP = <any>"KEY_C_SHARP", 
    KEY_D = <any>"KEY_D", 
    KEY_D_SHARP = <any>"KEY_D_SHARP", 
    KEY_E = <any>"KEY_E", 
    KEY_F = <any>"KEY_F", 
    KEY_F_SHARP = <any>"KEY_F_SHARP", 
    KEY_G = <any>"KEY_G", 
    KEY_G_SHARP = <any>"KEY_G_SHARP", 
    KEY_A = <any>"KEY_A", 
    KEY_A_SHARP = <any>"KEY_A_SHARP", 
    KEY_B = <any>"KEY_B", 
}

export class Marker implements IMarker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;

    constructor(data?: IMarker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["Comment"];
            if (data["CuePointParams"]) {
                this.cuePointParams = {};
                for (let key in data["CuePointParams"]) {
                    if (data["CuePointParams"].hasOwnProperty(key))
                        this.cuePointParams[key] = data["CuePointParams"][key];
                }
            }
            this.cuePointType = data["CuePointType"];
            this.duration = data["Duration"];
            this.location = data["Location"];
            this.name = data["Name"];
            this.probability = data["Probability"];
            this.speaker = data["Speaker"];
            this.startTime = data["StartTime"];
            this.target = data["Target"];
            this.type = data["Type"];
        }
    }

    static fromJS(data: any): Marker {
        let result = new Marker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Comment"] = this.comment;
        if (this.cuePointParams) {
            data["CuePointParams"] = {};
            for (let key in this.cuePointParams) {
                if (this.cuePointParams.hasOwnProperty(key))
                    data["CuePointParams"][key] = this.cuePointParams[key];
            }
        }
        data["CuePointType"] = this.cuePointType;
        data["Duration"] = this.duration;
        data["Location"] = this.location;
        data["Name"] = this.name;
        data["Probability"] = this.probability;
        data["Speaker"] = this.speaker;
        data["StartTime"] = this.startTime;
        data["Target"] = this.target;
        data["Type"] = this.type;
        return data; 
    }
}

export interface IMarker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;
}

/** Corresponds to Xmp.Media.Marker.TypeChoice */
export enum MarkerType {
    Chapter = <any>"Chapter", 
    Cue = <any>"Cue", 
    Index = <any>"Index", 
    Speech = <any>"Speech", 
    Track = <any>"Track", 
}

export class ProjectLink implements IProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.path = data["Path"];
            this.type = data["Type"];
        }
    }

    static fromJS(data: any): ProjectLink {
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Path"] = this.path;
        data["Type"] = this.type;
        return data; 
    }
}

export interface IProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;
}

/** Corresponds to Xmp.Media.ProjectLink.TypeChoice */
export enum ProjectLinkType {
    Movie = <any>"Movie", 
    Still = <any>"Still", 
    Audio = <any>"Audio", 
    Custom = <any>"Custom", 
}

/** Corresponds to xmpDM.VideoPullDownChoice */
export enum VideoPullDown {
    PULLDOWN_WSSWW = <any>"PULLDOWN_WSSWW", 
    PULLDOWN_SSWWW = <any>"PULLDOWN_SSWWW", 
    PULLDOWN_SWWWS = <any>"PULLDOWN_SWWWS", 
    PULLDOWN_WWWSS = <any>"PULLDOWN_WWWSS", 
    PULLDOWN_WWSSW = <any>"PULLDOWN_WWSSW", 
    PULLDOWN_WWWSW = <any>"PULLDOWN_WWWSW", 
    PULLDOWN_WWSWW = <any>"PULLDOWN_WWSWW", 
    PULLDOWN_WSWWW = <any>"PULLDOWN_WSWWW", 
    PULLDOWN_SWWWW = <any>"PULLDOWN_SWWWW", 
    PULLDOWN_WWWWS = <any>"PULLDOWN_WWWWS", 
}

export class ResampleStretch implements IResampleStretch {
    quality?: Quality | undefined;

    constructor(data?: IResampleStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quality = data["Quality"];
        }
    }

    static fromJS(data: any): ResampleStretch {
        let result = new ResampleStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Quality"] = this.quality;
        return data; 
    }
}

export interface IResampleStretch {
    quality?: Quality | undefined;
}

/** Corresponds to Xmp.Media.resampleStretch.QualityChoice and Xmp.Media.timeScaleStretch.QualityChoice */
export enum Quality {
    High = <any>"High", 
    Medium = <any>"Medium", 
    Low = <any>"Low", 
}

/** Corresponds to xmpDM.AudioMusicalScaleTypeChoice */
export enum AudioMusicalScaleType {
    SCALE_MAJOR = <any>"SCALE_MAJOR", 
    SCALE_MINOR = <any>"SCALE_MINOR", 
    SCALE_BOTH = <any>"SCALE_BOTH", 
    SCALE_NEITHER = <any>"SCALE_NEITHER", 
}

/** Corresponds to xmpDM.ShotSizeChoice */
export enum ShotSize {
    SHOT_ECU = <any>"SHOT_ECU", 
    SHOT_MCU = <any>"SHOT_MCU", 
    SHOT_CU = <any>"SHOT_CU", 
    SHOT_MS = <any>"SHOT_MS", 
    SHOT_WS = <any>"SHOT_WS", 
    SHOT_MWS = <any>"SHOT_MWS", 
    SHOT_EWS = <any>"SHOT_EWS", 
}

/** Corresponds to xmpDM.AudioStretchModeChoice */
export enum AudioStretchMode {
    STRETCH_FIXED_LENGTH = <any>"STRETCH_FIXED_LENGTH", 
    STRETCH_TIME_SCALE = <any>"STRETCH_TIME_SCALE", 
    STRETCH_RESAMPLE = <any>"STRETCH_RESAMPLE", 
    STRETCH_BEAT_SPLICE = <any>"STRETCH_BEAT_SPLICE", 
    STRETCH_HYBRID = <any>"STRETCH_HYBRID", 
}

export class TimeScaleStretch implements ITimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;

    constructor(data?: ITimeScaleStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameOverlappingPercentage = data["FrameOverlappingPercentage"];
            this.frameSize = data["FrameSize"];
            this.quality = data["Quality"];
        }
    }

    static fromJS(data: any): TimeScaleStretch {
        let result = new TimeScaleStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FrameOverlappingPercentage"] = this.frameOverlappingPercentage;
        data["FrameSize"] = this.frameSize;
        data["Quality"] = this.quality;
        return data; 
    }
}

export interface ITimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;
}

/** Corresponds to xmpDM.TimeSignatureChoice */
export enum TimeSignature {
    TIME_2_4 = <any>"TIME_2_4", 
    TIME_3_4 = <any>"TIME_3_4", 
    TIME_4_4 = <any>"TIME_4_4", 
    TIME_5_4 = <any>"TIME_5_4", 
    TIME_7_4 = <any>"TIME_7_4", 
    TIME_6_8 = <any>"TIME_6_8", 
    TIME_9_8 = <any>"TIME_9_8", 
    TIME_12_8 = <any>"TIME_12_8", 
    TIME_OTHER = <any>"TIME_OTHER", 
}

export class Track implements ITrack {
    frameRate?: string | undefined;
    markers?: Marker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;

    constructor(data?: ITrack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameRate = data["FrameRate"];
            if (data["Markers"] && data["Markers"].constructor === Array) {
                this.markers = [];
                for (let item of data["Markers"])
                    this.markers.push(Marker.fromJS(item));
            }
            this.trackName = data["TrackName"];
            this.trackType = data["TrackType"];
        }
    }

    static fromJS(data: any): Track {
        let result = new Track();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FrameRate"] = this.frameRate;
        if (this.markers && this.markers.constructor === Array) {
            data["Markers"] = [];
            for (let item of this.markers)
                data["Markers"].push(item.toJSON());
        }
        data["TrackName"] = this.trackName;
        data["TrackType"] = this.trackType;
        return data; 
    }
}

export interface ITrack {
    frameRate?: string | undefined;
    markers?: Marker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;
}

/** Corresponds to xmpDM.VideoAlphaModeChoice */
export enum VideoAlphaMode {
    ALPHA_MODE_STRAIGHT = <any>"ALPHA_MODE_STRAIGHT", 
    ALPHA_MODE_PREMULTIPLIED = <any>"ALPHA_MODE_PREMULTIPLIED", 
    ALPHA_MODE_NONE = <any>"ALPHA_MODE_NONE", 
}

export class XmpG implements IXmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;

    constructor(data?: IXmpG) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.a = data["A"];
            this.b = data["B"];
            this.l = data["L"];
            this.black = data["Black"];
            this.cyan = data["Cyan"];
            this.magenta = data["Magenta"];
            this.yellow = data["Yellow"];
            this.blue = data["Blue"];
            this.green = data["Green"];
            this.red = data["Red"];
            this.mode = data["Mode"];
            this.swatchName = data["SwatchName"];
            this.type = data["Type"];
        }
    }

    static fromJS(data: any): XmpG {
        let result = new XmpG();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["A"] = this.a;
        data["B"] = this.b;
        data["L"] = this.l;
        data["Black"] = this.black;
        data["Cyan"] = this.cyan;
        data["Magenta"] = this.magenta;
        data["Yellow"] = this.yellow;
        data["Blue"] = this.blue;
        data["Green"] = this.green;
        data["Red"] = this.red;
        data["Mode"] = this.mode;
        data["SwatchName"] = this.swatchName;
        data["Type"] = this.type;
        return data; 
    }
}

export interface IXmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;
}

/** Corresponds to xmpG.ModeChoice */
export enum ColorantMode {
    CMYK = <any>"CMYK", 
    RGB = <any>"RGB", 
    LAB = <any>"LAB", 
}

/** Corresponds to xmpG.TypeChoice */
export enum ColorantType {
    Process = <any>"Process", 
    Spot = <any>"Spot", 
}

/** Corresponds to xmpDM.VideoColorSpaceChoice */
export enum VideoColorSpace {
    COLOR_SPACE_SRGB = <any>"COLOR_SPACE_SRGB", 
    COLOR_SPACE_CCIR_601 = <any>"COLOR_SPACE_CCIR_601", 
    COLOR_SPACE_CCIR_709 = <any>"COLOR_SPACE_CCIR_709", 
}

/** Corresponds to xmpDM.VideoFieldOrderChoice */
export enum VideoFieldOrder {
    FIELD_ORDER_UPPER = <any>"FIELD_ORDER_UPPER", 
    FIELD_ORDER_LOWER = <any>"FIELD_ORDER_LOWER", 
    FIELD_ORDER_PROGRESSIVE = <any>"FIELD_ORDER_PROGRESSIVE", 
}

/** Corresponds to xmpDM.VideoFrameRateChoice */
export enum VideoFrameRate {
    FRAME_RATE_24 = <any>"FRAME_RATE_24", 
    FRAME_RATE_NTSC = <any>"FRAME_RATE_NTSC", 
    FRAME_RATE_PAL = <any>"FRAME_RATE_PAL", 
}

export class Dimension implements IDimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;

    constructor(data?: IDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.height = data["Height"];
            this.width = data["Width"];
            this.unit = data["Unit"];
        }
    }

    static fromJS(data: any): Dimension {
        let result = new Dimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Height"] = this.height;
        data["Width"] = this.width;
        data["Unit"] = this.unit;
        return data; 
    }
}

export interface IDimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;
}

/** Corresponds to stDim.UnitChoice */
export enum Unit {
    Inch = <any>"Inch", 
    Millimeter = <any>"Millimeter", 
    Centimeter = <any>"Centimeter", 
    Pixel = <any>"Pixel", 
    Pica = <any>"Pica", 
    Point = <any>"Point", 
}

/** Corresponds to xmpDM.VideoPixelDepthChoice */
export enum VideoPixelDepth {
    PIXEL_DEPTH_8_INT = <any>"PIXEL_DEPTH_8_INT", 
    PIXEL_DEPTH_16_INT = <any>"PIXEL_DEPTH_16_INT", 
    PIXEL_DEPTH_24_INT = <any>"PIXEL_DEPTH_24_INT", 
    PIXEL_DEPTH_32_INT = <any>"PIXEL_DEPTH_32_INT", 
    PIXEL_DEPTH_32_FLOAT = <any>"PIXEL_DEPTH_32_FLOAT", 
    PIXEL_DEPTH_OTHER = <any>"PIXEL_DEPTH_OTHER", 
}

export class Xmpidq implements IXmpidq {
    scheme?: string | undefined;

    constructor(data?: IXmpidq) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheme = data["Scheme"];
        }
    }

    static fromJS(data: any): Xmpidq {
        let result = new Xmpidq();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Scheme"] = this.scheme;
        return data; 
    }
}

export interface IXmpidq {
    scheme?: string | undefined;
}

export class XmpMM implements IXmpMM {
    derivedFrom?: Reference | undefined;
    documentID?: string | undefined;
    history?: Event[] | undefined;
    ingredients?: Reference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: Reference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: VersionInfo[] | undefined;

    constructor(data?: IXmpMM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.derivedFrom = data["DerivedFrom"] ? Reference.fromJS(data["DerivedFrom"]) : <any>undefined;
            this.documentID = data["DocumentID"];
            if (data["History"] && data["History"].constructor === Array) {
                this.history = [];
                for (let item of data["History"])
                    this.history.push(Event.fromJS(item));
            }
            if (data["Ingredients"] && data["Ingredients"].constructor === Array) {
                this.ingredients = [];
                for (let item of data["Ingredients"])
                    this.ingredients.push(Reference.fromJS(item));
            }
            this.instanceID = data["InstanceID"];
            this.managedFrom = data["ManagedFrom"] ? Reference.fromJS(data["ManagedFrom"]) : <any>undefined;
            this.manager = data["Manager"];
            this.manageTo = data["ManageTo"];
            this.manageUI = data["ManageUI"];
            this.managerVariant = data["ManagerVariant"];
            this.originalDocumentID = data["OriginalDocumentID"];
            this.renditionClass = data["RenditionClass"];
            this.renditionParams = data["RenditionParams"];
            this.versionID = data["VersionID"];
            if (data["Versions"] && data["Versions"].constructor === Array) {
                this.versions = [];
                for (let item of data["Versions"])
                    this.versions.push(VersionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMM {
        let result = new XmpMM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DerivedFrom"] = this.derivedFrom ? this.derivedFrom.toJSON() : <any>undefined;
        data["DocumentID"] = this.documentID;
        if (this.history && this.history.constructor === Array) {
            data["History"] = [];
            for (let item of this.history)
                data["History"].push(item.toJSON());
        }
        if (this.ingredients && this.ingredients.constructor === Array) {
            data["Ingredients"] = [];
            for (let item of this.ingredients)
                data["Ingredients"].push(item.toJSON());
        }
        data["InstanceID"] = this.instanceID;
        data["ManagedFrom"] = this.managedFrom ? this.managedFrom.toJSON() : <any>undefined;
        data["Manager"] = this.manager;
        data["ManageTo"] = this.manageTo;
        data["ManageUI"] = this.manageUI;
        data["ManagerVariant"] = this.managerVariant;
        data["OriginalDocumentID"] = this.originalDocumentID;
        data["RenditionClass"] = this.renditionClass;
        data["RenditionParams"] = this.renditionParams;
        data["VersionID"] = this.versionID;
        if (this.versions && this.versions.constructor === Array) {
            data["Versions"] = [];
            for (let item of this.versions)
                data["Versions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmpMM {
    derivedFrom?: Reference | undefined;
    documentID?: string | undefined;
    history?: Event[] | undefined;
    ingredients?: Reference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: Reference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: VersionInfo[] | undefined;
}

export class Reference implements IReference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["AlternatePaths"] && data["AlternatePaths"].constructor === Array) {
                this.alternatePaths = [];
                for (let item of data["AlternatePaths"])
                    this.alternatePaths.push(item);
            }
            this.documentID = data["DocumentID"];
            this.filePath = data["FilePath"];
            this.fromPart = data["FromPart"];
            this.instanceID = data["InstanceID"];
            this.lastModifyDate = data["LastModifyDate"] ? new Date(data["LastModifyDate"].toString()) : <any>undefined;
            this.manager = data["Manager"];
            this.managerVariant = data["ManagerVariant"];
            this.manageTo = data["ManageTo"];
            this.manageUI = data["ManageUI"];
            this.maskMarkers = data["MaskMarkers"];
            this.originalDocumentID = data["OriginalDocumentID"];
            this.partMapping = data["PartMapping"];
            this.renditionClass = data["RenditionClass"];
            this.renditionParams = data["RenditionParams"];
            this.toPart = data["ToPart"];
            this.versionID = data["VersionID"];
        }
    }

    static fromJS(data: any): Reference {
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.alternatePaths && this.alternatePaths.constructor === Array) {
            data["AlternatePaths"] = [];
            for (let item of this.alternatePaths)
                data["AlternatePaths"].push(item);
        }
        data["DocumentID"] = this.documentID;
        data["FilePath"] = this.filePath;
        data["FromPart"] = this.fromPart;
        data["InstanceID"] = this.instanceID;
        data["LastModifyDate"] = this.lastModifyDate ? this.lastModifyDate.toISOString() : <any>undefined;
        data["Manager"] = this.manager;
        data["ManagerVariant"] = this.managerVariant;
        data["ManageTo"] = this.manageTo;
        data["ManageUI"] = this.manageUI;
        data["MaskMarkers"] = this.maskMarkers;
        data["OriginalDocumentID"] = this.originalDocumentID;
        data["PartMapping"] = this.partMapping;
        data["RenditionClass"] = this.renditionClass;
        data["RenditionParams"] = this.renditionParams;
        data["ToPart"] = this.toPart;
        data["VersionID"] = this.versionID;
        return data; 
    }
}

export interface IReference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;
}

/** Corresponds to stRef.MaskMarkersChoice */
export enum MaskMarkers {
    All = <any>"All", 
    None = <any>"None", 
}

export class Event implements IEvent {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["Action"];
            this.changed = data["Changed"];
            this.instanceID = data["InstanceID"];
            this.parameters = data["Parameters"];
            this.softwareAgent = data["SoftwareAgent"];
            this.when = data["When"] ? new Date(data["When"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Event {
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Action"] = this.action;
        data["Changed"] = this.changed;
        data["InstanceID"] = this.instanceID;
        data["Parameters"] = this.parameters;
        data["SoftwareAgent"] = this.softwareAgent;
        data["When"] = this.when ? this.when.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEvent {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;
}

/** Corresponds to stEvt.ActionChoice */
export enum EventAction {
    Converted = <any>"Converted", 
    Copied = <any>"Copied", 
    Created = <any>"Created", 
    Cropped = <any>"Cropped", 
    Edited = <any>"Edited", 
    Filtered = <any>"Filtered", 
    Formatted = <any>"Formatted", 
    VersionUpdated = <any>"VersionUpdated", 
    Printed = <any>"Printed", 
    Published = <any>"Published", 
    Managed = <any>"Managed", 
    Produced = <any>"Produced", 
    Resized = <any>"Resized", 
    Saved = <any>"Saved", 
    Derived = <any>"Derived", 
}

export class VersionInfo implements IVersionInfo {
    comments?: string | undefined;
    event?: Event | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;

    constructor(data?: IVersionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["Comments"];
            this.event = data["Event"] ? Event.fromJS(data["Event"]) : <any>undefined;
            this.modifier = data["Modifier"];
            this.modifyDate = data["ModifyDate"] ? new Date(data["ModifyDate"].toString()) : <any>undefined;
            this.version = data["Version"];
        }
    }

    static fromJS(data: any): VersionInfo {
        let result = new VersionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Comments"] = this.comments;
        data["Event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["Modifier"] = this.modifier;
        data["ModifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["Version"] = this.version;
        return data; 
    }
}

export interface IVersionInfo {
    comments?: string | undefined;
    event?: Event | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;
}

export class XmpNote implements IXmpNote {
    hasExtendedXMP?: string | undefined;

    constructor(data?: IXmpNote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasExtendedXMP = data["HasExtendedXMP"];
        }
    }

    static fromJS(data: any): XmpNote {
        let result = new XmpNote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasExtendedXMP"] = this.hasExtendedXMP;
        return data; 
    }
}

export interface IXmpNote {
    hasExtendedXMP?: string | undefined;
}

export class XmpRights implements IXmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;

    constructor(data?: IXmpRights) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.certificate = data["Certificate"];
            this.marked = data["Marked"];
            if (data["Owner"] && data["Owner"].constructor === Array) {
                this.owner = [];
                for (let item of data["Owner"])
                    this.owner.push(item);
            }
            if (data["UsageTerms"]) {
                this.usageTerms = {};
                for (let key in data["UsageTerms"]) {
                    if (data["UsageTerms"].hasOwnProperty(key))
                        this.usageTerms[key] = data["UsageTerms"][key];
                }
            }
            this.webStatement = data["WebStatement"];
        }
    }

    static fromJS(data: any): XmpRights {
        let result = new XmpRights();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Certificate"] = this.certificate;
        data["Marked"] = this.marked;
        if (this.owner && this.owner.constructor === Array) {
            data["Owner"] = [];
            for (let item of this.owner)
                data["Owner"].push(item);
        }
        if (this.usageTerms) {
            data["UsageTerms"] = {};
            for (let key in this.usageTerms) {
                if (this.usageTerms.hasOwnProperty(key))
                    data["UsageTerms"][key] = this.usageTerms[key];
            }
        }
        data["WebStatement"] = this.webStatement;
        return data; 
    }
}

export interface IXmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;
}

export class XmpTPg implements IXmpTPg {
    colorants?: XmpG[] | undefined;
    fonts?: Font[] | undefined;
    maxPageSize?: Dimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;

    constructor(data?: IXmpTPg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Colorants"] && data["Colorants"].constructor === Array) {
                this.colorants = [];
                for (let item of data["Colorants"])
                    this.colorants.push(XmpG.fromJS(item));
            }
            if (data["Fonts"] && data["Fonts"].constructor === Array) {
                this.fonts = [];
                for (let item of data["Fonts"])
                    this.fonts.push(Font.fromJS(item));
            }
            this.maxPageSize = data["MaxPageSize"] ? Dimension.fromJS(data["MaxPageSize"]) : <any>undefined;
            this.nPages = data["NPages"];
            if (data["PlateNames"] && data["PlateNames"].constructor === Array) {
                this.plateNames = [];
                for (let item of data["PlateNames"])
                    this.plateNames.push(item);
            }
        }
    }

    static fromJS(data: any): XmpTPg {
        let result = new XmpTPg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.colorants && this.colorants.constructor === Array) {
            data["Colorants"] = [];
            for (let item of this.colorants)
                data["Colorants"].push(item.toJSON());
        }
        if (this.fonts && this.fonts.constructor === Array) {
            data["Fonts"] = [];
            for (let item of this.fonts)
                data["Fonts"].push(item.toJSON());
        }
        data["MaxPageSize"] = this.maxPageSize ? this.maxPageSize.toJSON() : <any>undefined;
        data["NPages"] = this.nPages;
        if (this.plateNames && this.plateNames.constructor === Array) {
            data["PlateNames"] = [];
            for (let item of this.plateNames)
                data["PlateNames"].push(item);
        }
        return data; 
    }
}

export interface IXmpTPg {
    colorants?: XmpG[] | undefined;
    fonts?: Font[] | undefined;
    maxPageSize?: Dimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;
}

export class Font implements IFont {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;

    constructor(data?: IFont) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ChildFontFiles"] && data["ChildFontFiles"].constructor === Array) {
                this.childFontFiles = [];
                for (let item of data["ChildFontFiles"])
                    this.childFontFiles.push(item);
            }
            this.composite = data["Composite"];
            this.fontFace = data["FontFace"];
            this.fontFamily = data["FontFamily"];
            this.fontFileName = data["FontFileName"];
            this.fontName = data["FontName"];
            this.fontType = data["FontType"];
            this.versionString = data["VersionString"];
        }
    }

    static fromJS(data: any): Font {
        let result = new Font();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.childFontFiles && this.childFontFiles.constructor === Array) {
            data["ChildFontFiles"] = [];
            for (let item of this.childFontFiles)
                data["ChildFontFiles"].push(item);
        }
        data["Composite"] = this.composite;
        data["FontFace"] = this.fontFace;
        data["FontFamily"] = this.fontFamily;
        data["FontFileName"] = this.fontFileName;
        data["FontName"] = this.fontName;
        data["FontType"] = this.fontType;
        data["VersionString"] = this.versionString;
        return data; 
    }
}

export interface IFont {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;
}

/** Corresponds to stFnt.FontTypeChoice */
export enum FontType {
    TrueType = <any>"TrueType", 
    Type1 = <any>"Type1", 
    OpenType = <any>"OpenType", 
    OpenTypeCFF = <any>"OpenTypeCFF", 
}

export class ExifMetadata implements IExifMetadata {
    exif?: Exif | undefined;
    exifAux?: ExifAux | undefined;

    constructor(data?: IExifMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exif = data["Exif"] ? Exif.fromJS(data["Exif"]) : <any>undefined;
            this.exifAux = data["ExifAux"] ? ExifAux.fromJS(data["ExifAux"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExifMetadata {
        let result = new ExifMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Exif"] = this.exif ? this.exif.toJSON() : <any>undefined;
        data["ExifAux"] = this.exifAux ? this.exifAux.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IExifMetadata {
    exif?: Exif | undefined;
    exifAux?: ExifAux | undefined;
}

export class Exif implements IExif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cFAPattern?: CFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: DeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: Flash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gPSAltitude?: string | undefined;
    gPSAltitudeRef?: GPSAltitudeRef | undefined;
    gPSAreaInformation?: string | undefined;
    gPSDestBearing?: string | undefined;
    gPSDestBearingRef?: GPSDestBearingRef | undefined;
    gPSDestDistance?: string | undefined;
    gPSDestDistanceRef?: GPSDestDistanceRef | undefined;
    gPSDestLatitude?: string | undefined;
    gPSDestLongitude?: string | undefined;
    gPSDifferential?: GPSDifferential | undefined;
    gPSDOP?: string | undefined;
    gPSImgDirection?: string | undefined;
    gPSImgDirectionRef?: GPSImgDirectionRef | undefined;
    gPSCoordinate?: GPSCoordinate | undefined;
    gPSLatitude?: string | undefined;
    gPSLongitude?: string | undefined;
    gPSMapDatum?: string | undefined;
    gPSMeasureMode?: string | undefined;
    gPSProcessingMethod?: string | undefined;
    gPSSatellites?: string | undefined;
    gPSSpeed?: string | undefined;
    gPSSpeedRef?: GPSSpeedRef | undefined;
    gPSStatus?: GPSStatus | undefined;
    gPSTimeStamp?: Date | undefined;
    gPSTrack?: string | undefined;
    gPSTrackRef?: string | undefined;
    gPSVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    iSOSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oECF?: OECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: SFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;

    constructor(data?: IExif) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apertureValue = data["ApertureValue"];
            this.brightnessValue = data["BrightnessValue"];
            this.cFAPattern = data["CFAPattern"] ? CFAPattern.fromJS(data["CFAPattern"]) : <any>undefined;
            this.colorSpace = data["ColorSpace"];
            if (data["ComponentsConfiguration"] && data["ComponentsConfiguration"].constructor === Array) {
                this.componentsConfiguration = [];
                for (let item of data["ComponentsConfiguration"])
                    this.componentsConfiguration.push(item);
            }
            this.compressedBitsPerPixel = data["CompressedBitsPerPixel"];
            this.contrast = data["Contrast"];
            this.customRendered = data["CustomRendered"];
            this.dateTimeOriginal = data["DateTimeOriginal"] ? new Date(data["DateTimeOriginal"].toString()) : <any>undefined;
            this.dateTimeDigitized = data["DateTimeDigitized"] ? new Date(data["DateTimeDigitized"].toString()) : <any>undefined;
            this.deviceSettingDescription = data["DeviceSettingDescription"] ? DeviceSettings.fromJS(data["DeviceSettingDescription"]) : <any>undefined;
            this.digitalZoomRatio = data["DigitalZoomRatio"];
            this.exifVersion = data["ExifVersion"];
            this.exposureBiasValue = data["ExposureBiasValue"];
            this.exposureIndex = data["ExposureIndex"];
            this.exposureMode = data["ExposureMode"];
            this.exposureProgram = data["ExposureProgram"];
            this.exposureTime = data["ExposureTime"];
            this.fileSource = data["FileSource"];
            this.flash = data["Flash"] ? Flash.fromJS(data["Flash"]) : <any>undefined;
            this.flashEnergy = data["FlashEnergy"];
            this.flashpixVersion = data["FlashpixVersion"];
            this.fNumber = data["FNumber"];
            this.focalLength = data["FocalLength"];
            this.focalLengthIn35mmFilm = data["FocalLengthIn35mmFilm"];
            this.focalPlaneResolutionUnit = data["FocalPlaneResolutionUnit"];
            this.focalPlaneXResolution = data["FocalPlaneXResolution"];
            this.focalPlaneYResolution = data["FocalPlaneYResolution"];
            this.gainControl = data["GainControl"];
            this.gPSAltitude = data["GPSAltitude"];
            this.gPSAltitudeRef = data["GPSAltitudeRef"];
            this.gPSAreaInformation = data["GPSAreaInformation"];
            this.gPSDestBearing = data["GPSDestBearing"];
            this.gPSDestBearingRef = data["GPSDestBearingRef"];
            this.gPSDestDistance = data["GPSDestDistance"];
            this.gPSDestDistanceRef = data["GPSDestDistanceRef"];
            this.gPSDestLatitude = data["GPSDestLatitude"];
            this.gPSDestLongitude = data["GPSDestLongitude"];
            this.gPSDifferential = data["GPSDifferential"];
            this.gPSDOP = data["GPSDOP"];
            this.gPSImgDirection = data["GPSImgDirection"];
            this.gPSImgDirectionRef = data["GPSImgDirectionRef"];
            this.gPSCoordinate = data["GPSCoordinate"] ? GPSCoordinate.fromJS(data["GPSCoordinate"]) : <any>undefined;
            this.gPSLatitude = data["GPSLatitude"];
            this.gPSLongitude = data["GPSLongitude"];
            this.gPSMapDatum = data["GPSMapDatum"];
            this.gPSMeasureMode = data["GPSMeasureMode"];
            this.gPSProcessingMethod = data["GPSProcessingMethod"];
            this.gPSSatellites = data["GPSSatellites"];
            this.gPSSpeed = data["GPSSpeed"];
            this.gPSSpeedRef = data["GPSSpeedRef"];
            this.gPSStatus = data["GPSStatus"];
            this.gPSTimeStamp = data["GPSTimeStamp"] ? new Date(data["GPSTimeStamp"].toString()) : <any>undefined;
            this.gPSTrack = data["GPSTrack"];
            this.gPSTrackRef = data["GPSTrackRef"];
            this.gPSVersionID = data["GPSVersionID"];
            this.imageUniqueID = data["ImageUniqueID"];
            if (data["ISOSpeedRatings"] && data["ISOSpeedRatings"].constructor === Array) {
                this.iSOSpeedRatings = [];
                for (let item of data["ISOSpeedRatings"])
                    this.iSOSpeedRatings.push(item);
            }
            this.lightSource = data["LightSource"];
            this.maxApertureValue = data["MaxApertureValue"];
            this.meteringMode = data["MeteringMode"];
            this.oECF = data["OECF"] ? OECF.fromJS(data["OECF"]) : <any>undefined;
            this.pixelXDimension = data["PixelXDimension"];
            this.pixelYDimension = data["PixelYDimension"];
            this.relatedSoundFile = data["RelatedSoundFile"];
            this.saturation = data["Saturation"];
            this.sceneCaptureType = data["SceneCaptureType"];
            this.sceneType = data["SceneType"];
            this.sensingMethod = data["SensingMethod"];
            this.sharpness = data["Sharpness"];
            this.shutterSpeedValue = data["ShutterSpeedValue"];
            this.spatialFrequencyResponse = data["SpatialFrequencyResponse"] ? SFR.fromJS(data["SpatialFrequencyResponse"]) : <any>undefined;
            this.spectralSensitivity = data["SpectralSensitivity"];
            if (data["SubjectArea"] && data["SubjectArea"].constructor === Array) {
                this.subjectArea = [];
                for (let item of data["SubjectArea"])
                    this.subjectArea.push(item);
            }
            this.subjectDistance = data["SubjectDistance"];
            this.subjectDistanceRange = data["SubjectDistanceRange"];
            if (data["SubjectLocation"] && data["SubjectLocation"].constructor === Array) {
                this.subjectLocation = [];
                for (let item of data["SubjectLocation"])
                    this.subjectLocation.push(item);
            }
            if (data["UserComment"]) {
                this.userComment = {};
                for (let key in data["UserComment"]) {
                    if (data["UserComment"].hasOwnProperty(key))
                        this.userComment[key] = data["UserComment"][key];
                }
            }
            this.whiteBalance = data["WhiteBalance"];
            this.nativeDigest = data["NativeDigest"];
        }
    }

    static fromJS(data: any): Exif {
        let result = new Exif();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApertureValue"] = this.apertureValue;
        data["BrightnessValue"] = this.brightnessValue;
        data["CFAPattern"] = this.cFAPattern ? this.cFAPattern.toJSON() : <any>undefined;
        data["ColorSpace"] = this.colorSpace;
        if (this.componentsConfiguration && this.componentsConfiguration.constructor === Array) {
            data["ComponentsConfiguration"] = [];
            for (let item of this.componentsConfiguration)
                data["ComponentsConfiguration"].push(item);
        }
        data["CompressedBitsPerPixel"] = this.compressedBitsPerPixel;
        data["Contrast"] = this.contrast;
        data["CustomRendered"] = this.customRendered;
        data["DateTimeOriginal"] = this.dateTimeOriginal ? this.dateTimeOriginal.toISOString() : <any>undefined;
        data["DateTimeDigitized"] = this.dateTimeDigitized ? this.dateTimeDigitized.toISOString() : <any>undefined;
        data["DeviceSettingDescription"] = this.deviceSettingDescription ? this.deviceSettingDescription.toJSON() : <any>undefined;
        data["DigitalZoomRatio"] = this.digitalZoomRatio;
        data["ExifVersion"] = this.exifVersion;
        data["ExposureBiasValue"] = this.exposureBiasValue;
        data["ExposureIndex"] = this.exposureIndex;
        data["ExposureMode"] = this.exposureMode;
        data["ExposureProgram"] = this.exposureProgram;
        data["ExposureTime"] = this.exposureTime;
        data["FileSource"] = this.fileSource;
        data["Flash"] = this.flash ? this.flash.toJSON() : <any>undefined;
        data["FlashEnergy"] = this.flashEnergy;
        data["FlashpixVersion"] = this.flashpixVersion;
        data["FNumber"] = this.fNumber;
        data["FocalLength"] = this.focalLength;
        data["FocalLengthIn35mmFilm"] = this.focalLengthIn35mmFilm;
        data["FocalPlaneResolutionUnit"] = this.focalPlaneResolutionUnit;
        data["FocalPlaneXResolution"] = this.focalPlaneXResolution;
        data["FocalPlaneYResolution"] = this.focalPlaneYResolution;
        data["GainControl"] = this.gainControl;
        data["GPSAltitude"] = this.gPSAltitude;
        data["GPSAltitudeRef"] = this.gPSAltitudeRef;
        data["GPSAreaInformation"] = this.gPSAreaInformation;
        data["GPSDestBearing"] = this.gPSDestBearing;
        data["GPSDestBearingRef"] = this.gPSDestBearingRef;
        data["GPSDestDistance"] = this.gPSDestDistance;
        data["GPSDestDistanceRef"] = this.gPSDestDistanceRef;
        data["GPSDestLatitude"] = this.gPSDestLatitude;
        data["GPSDestLongitude"] = this.gPSDestLongitude;
        data["GPSDifferential"] = this.gPSDifferential;
        data["GPSDOP"] = this.gPSDOP;
        data["GPSImgDirection"] = this.gPSImgDirection;
        data["GPSImgDirectionRef"] = this.gPSImgDirectionRef;
        data["GPSCoordinate"] = this.gPSCoordinate ? this.gPSCoordinate.toJSON() : <any>undefined;
        data["GPSLatitude"] = this.gPSLatitude;
        data["GPSLongitude"] = this.gPSLongitude;
        data["GPSMapDatum"] = this.gPSMapDatum;
        data["GPSMeasureMode"] = this.gPSMeasureMode;
        data["GPSProcessingMethod"] = this.gPSProcessingMethod;
        data["GPSSatellites"] = this.gPSSatellites;
        data["GPSSpeed"] = this.gPSSpeed;
        data["GPSSpeedRef"] = this.gPSSpeedRef;
        data["GPSStatus"] = this.gPSStatus;
        data["GPSTimeStamp"] = this.gPSTimeStamp ? this.gPSTimeStamp.toISOString() : <any>undefined;
        data["GPSTrack"] = this.gPSTrack;
        data["GPSTrackRef"] = this.gPSTrackRef;
        data["GPSVersionID"] = this.gPSVersionID;
        data["ImageUniqueID"] = this.imageUniqueID;
        if (this.iSOSpeedRatings && this.iSOSpeedRatings.constructor === Array) {
            data["ISOSpeedRatings"] = [];
            for (let item of this.iSOSpeedRatings)
                data["ISOSpeedRatings"].push(item);
        }
        data["LightSource"] = this.lightSource;
        data["MaxApertureValue"] = this.maxApertureValue;
        data["MeteringMode"] = this.meteringMode;
        data["OECF"] = this.oECF ? this.oECF.toJSON() : <any>undefined;
        data["PixelXDimension"] = this.pixelXDimension;
        data["PixelYDimension"] = this.pixelYDimension;
        data["RelatedSoundFile"] = this.relatedSoundFile;
        data["Saturation"] = this.saturation;
        data["SceneCaptureType"] = this.sceneCaptureType;
        data["SceneType"] = this.sceneType;
        data["SensingMethod"] = this.sensingMethod;
        data["Sharpness"] = this.sharpness;
        data["ShutterSpeedValue"] = this.shutterSpeedValue;
        data["SpatialFrequencyResponse"] = this.spatialFrequencyResponse ? this.spatialFrequencyResponse.toJSON() : <any>undefined;
        data["SpectralSensitivity"] = this.spectralSensitivity;
        if (this.subjectArea && this.subjectArea.constructor === Array) {
            data["SubjectArea"] = [];
            for (let item of this.subjectArea)
                data["SubjectArea"].push(item);
        }
        data["SubjectDistance"] = this.subjectDistance;
        data["SubjectDistanceRange"] = this.subjectDistanceRange;
        if (this.subjectLocation && this.subjectLocation.constructor === Array) {
            data["SubjectLocation"] = [];
            for (let item of this.subjectLocation)
                data["SubjectLocation"].push(item);
        }
        if (this.userComment) {
            data["UserComment"] = {};
            for (let key in this.userComment) {
                if (this.userComment.hasOwnProperty(key))
                    data["UserComment"][key] = this.userComment[key];
            }
        }
        data["WhiteBalance"] = this.whiteBalance;
        data["NativeDigest"] = this.nativeDigest;
        return data; 
    }
}

export interface IExif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cFAPattern?: CFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: DeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: Flash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gPSAltitude?: string | undefined;
    gPSAltitudeRef?: GPSAltitudeRef | undefined;
    gPSAreaInformation?: string | undefined;
    gPSDestBearing?: string | undefined;
    gPSDestBearingRef?: GPSDestBearingRef | undefined;
    gPSDestDistance?: string | undefined;
    gPSDestDistanceRef?: GPSDestDistanceRef | undefined;
    gPSDestLatitude?: string | undefined;
    gPSDestLongitude?: string | undefined;
    gPSDifferential?: GPSDifferential | undefined;
    gPSDOP?: string | undefined;
    gPSImgDirection?: string | undefined;
    gPSImgDirectionRef?: GPSImgDirectionRef | undefined;
    gPSCoordinate?: GPSCoordinate | undefined;
    gPSLatitude?: string | undefined;
    gPSLongitude?: string | undefined;
    gPSMapDatum?: string | undefined;
    gPSMeasureMode?: string | undefined;
    gPSProcessingMethod?: string | undefined;
    gPSSatellites?: string | undefined;
    gPSSpeed?: string | undefined;
    gPSSpeedRef?: GPSSpeedRef | undefined;
    gPSStatus?: GPSStatus | undefined;
    gPSTimeStamp?: Date | undefined;
    gPSTrack?: string | undefined;
    gPSTrackRef?: string | undefined;
    gPSVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    iSOSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oECF?: OECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: SFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;
}

export class CFAPattern implements ICFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;

    constructor(data?: ICFAPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["Columns"];
            this.rows = data["Rows"];
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [];
                for (let item of data["Values"])
                    this.values.push(item);
            }
        }
    }

    static fromJS(data: any): CFAPattern {
        let result = new CFAPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Columns"] = this.columns;
        data["Rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        return data; 
    }
}

export interface ICFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;
}

/** Corresponds to exif.ColorSpaceChoice */
export enum ColorSpace {
    None = <any>"None", 
    SRGB = <any>"sRGB", 
    AdobeRGB = <any>"AdobeRGB", 
    Uncalibrated = <any>"Uncalibrated", 
}

/** Corresponds to exif.ContrastChoice */
export enum Contrast {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.CustomRenderedChoice */
export enum CustomRendered {
    NormalProcess = <any>"NormalProcess", 
    CustomProcess = <any>"CustomProcess", 
}

export class DeviceSettings implements IDeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;

    constructor(data?: IDeviceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["Columns"];
            this.rows = data["Rows"];
            if (data["Settings"] && data["Settings"].constructor === Array) {
                this.settings = [];
                for (let item of data["Settings"])
                    this.settings.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceSettings {
        let result = new DeviceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Columns"] = this.columns;
        data["Rows"] = this.rows;
        if (this.settings && this.settings.constructor === Array) {
            data["Settings"] = [];
            for (let item of this.settings)
                data["Settings"].push(item);
        }
        return data; 
    }
}

export interface IDeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;
}

/** Corresponds to exif.ExifVersionChoice */
export enum ExifVersion {
    V210 = <any>"V210", 
    V220 = <any>"V220", 
    V221 = <any>"V221", 
    V222 = <any>"V222", 
    V230 = <any>"V230", 
}

/** Corresponds to exif.ExposureModeChoice */
export enum ExposureMode {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    AutoBracket = <any>"AutoBracket", 
}

/** Corresponds to exif.ExposureProgramChoice */
export enum ExposureProgram {
    Undefined = <any>"Undefined", 
    Manual = <any>"Manual", 
    NormalProgram = <any>"NormalProgram", 
    AperturePriority = <any>"AperturePriority", 
    ShutterPriority = <any>"ShutterPriority", 
    CreativeProgram = <any>"CreativeProgram", 
    ActionProgram = <any>"ActionProgram", 
    PortraitMode = <any>"PortraitMode", 
    LandscapeMode = <any>"LandscapeMode", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.FileSourceChoice */
export enum FileSource {
    Other = <any>"Other", 
    TransparentScanner = <any>"TransparentScanner", 
    ReflexScanner = <any>"ReflexScanner", 
    DSC = <any>"DSC", 
}

export class Flash implements IFlash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;

    constructor(data?: IFlash) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fired = data["Fired"];
            this.return = data["Return"];
            this.mode = data["Mode"];
            this.function = data["Function"];
            this.redEyeMode = data["RedEyeMode"];
        }
    }

    static fromJS(data: any): Flash {
        let result = new Flash();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Fired"] = this.fired;
        data["Return"] = this.return;
        data["Mode"] = this.mode;
        data["Function"] = this.function;
        data["RedEyeMode"] = this.redEyeMode;
        return data; 
    }
}

export interface IFlash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;
}

/** Corresponds to Xmp.Structure.Flash.ReturnChoice */
export enum FlashReturn {
    NoStrobeReturnDetection = <any>"NoStrobeReturnDetection", 
    StrobeReturnLightNotDetected = <any>"StrobeReturnLightNotDetected", 
    StrobeReturnLightDetected = <any>"StrobeReturnLightDetected", 
}

/** Corresponds to Xmp.Structure.Flash.ModeChoice */
export enum FlashMode {
    Unknown = <any>"Unknown", 
    CompulsoryFlashFiring = <any>"CompulsoryFlashFiring", 
    CompulsoryFlashSuppression = <any>"CompulsoryFlashSuppression", 
    AutoMode = <any>"AutoMode", 
}

/** Corresponds to exif.FlashpixVersionChoice */
export enum FlashpixVersion {
    V100 = <any>"V100", 
    V101 = <any>"V101", 
    V110 = <any>"V110", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum FocalPlaneResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Meter = <any>"Meter", 
    Centimeter = <any>"Centimeter", 
    Millimeter = <any>"Millimeter", 
    Micrometer = <any>"Micrometer", 
}

/** Corresponds to exif.GainControlChoice */
export enum GainControl {
    None = <any>"None", 
    LowGainUp = <any>"LowGainUp", 
    HighGainUp = <any>"HighGainUp", 
    LowGainDown = <any>"LowGainDown", 
    HighGainDown = <any>"HighGainDown", 
}

/** Corresponds to exif.GPSAltitudeRefChoice */
export enum GPSAltitudeRef {
    AboveSeaLevel = <any>"AboveSeaLevel", 
    BelowSeaLevel = <any>"BelowSeaLevel", 
}

/** Corresponds to exif.GPSDestBearingRefChoice */
export enum GPSDestBearingRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

/** Corresponds to exif.GPSDestDistanceRefChoice */
export enum GPSDestDistanceRef {
    Kilometers = <any>"Kilometers", 
    Miles = <any>"Miles", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSDifferentialChoice */
export enum GPSDifferential {
    WithoutCorrection = <any>"WithoutCorrection", 
    WithCorrection = <any>"WithCorrection", 
}

/** Corresponds to exif.GPSImgDirectionRefChoice */
export enum GPSImgDirectionRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

export class GPSCoordinate implements IGPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;

    constructor(data?: IGPSCoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lon = data["lon"];
            this.lat = data["lat"];
        }
    }

    static fromJS(data: any): GPSCoordinate {
        let result = new GPSCoordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lon"] = this.lon;
        data["lat"] = this.lat;
        return data; 
    }
}

export interface IGPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;
}

/** Corresponds to exif.GPSSpeedRefChoice */
export enum GPSSpeedRef {
    KilometersPerHour = <any>"KilometersPerHour", 
    MilesPerHour = <any>"MilesPerHour", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSStatusChoice */
export enum GPSStatus {
    MeasurementInProgress = <any>"MeasurementInProgress", 
    MeasurementIsInteroperability = <any>"MeasurementIsInteroperability", 
}

/** Corresponds to exif.LightSourceChoice */
export enum LightSource {
    Unidentified = <any>"Unidentified", 
    Daylight = <any>"Daylight", 
    Fluorescent = <any>"Fluorescent", 
    Tungsten = <any>"Tungsten", 
    Flash = <any>"Flash", 
    FineWeather = <any>"FineWeather", 
    CloudyWeather = <any>"CloudyWeather", 
    Shade = <any>"Shade", 
    DaylightFluorescent = <any>"DaylightFluorescent", 
    DayWhiteFluorescent = <any>"DayWhiteFluorescent", 
    CoolWhiteFluorescent = <any>"CoolWhiteFluorescent", 
    WhiteFluorescent = <any>"WhiteFluorescent", 
    StandardIlluminantA = <any>"StandardIlluminantA", 
    StandardIlluminantB = <any>"StandardIlluminantB", 
    StandardIlluminantC = <any>"StandardIlluminantC", 
    D55Illuminant = <any>"D55Illuminant", 
    D65Illuminant = <any>"D65Illuminant", 
    D75Illuminant = <any>"D75Illuminant", 
    D50Illuminant = <any>"D50Illuminant", 
    ISOStudioTungsten = <any>"ISOStudioTungsten", 
    Other = <any>"Other", 
}

/** Corresponds to exif.MeteringModeChoice */
export enum MeteringMode {
    Unidentified = <any>"Unidentified", 
    Average = <any>"Average", 
    CenterWeightedAverage = <any>"CenterWeightedAverage", 
    Spot = <any>"Spot", 
    MultiSpot = <any>"MultiSpot", 
    Pattern = <any>"Pattern", 
    Partial = <any>"Partial", 
    Reserved = <any>"Reserved", 
    Other = <any>"Other", 
}

export class OECF implements IOECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;

    constructor(data?: IOECF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["Columns"];
            this.rows = data["Rows"];
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [];
                for (let item of data["Values"])
                    this.values.push(item);
            }
            if (data["Names"] && data["Names"].constructor === Array) {
                this.names = [];
                for (let item of data["Names"])
                    this.names.push(item);
            }
        }
    }

    static fromJS(data: any): OECF {
        let result = new OECF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Columns"] = this.columns;
        data["Rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        if (this.names && this.names.constructor === Array) {
            data["Names"] = [];
            for (let item of this.names)
                data["Names"].push(item);
        }
        return data; 
    }
}

export interface IOECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SaturationChoice */
export enum Saturation {
    Normal = <any>"Normal", 
    Low = <any>"Low", 
    High = <any>"High", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.SceneCaptureTypeChoice */
export enum SceneCaptureType {
    Standard = <any>"Standard", 
    Landscape = <any>"Landscape", 
    Portrait = <any>"Portrait", 
    NightScene = <any>"NightScene", 
}

/** Corresponds to exif.SceneTypeChoice */
export enum SceneType {
    DirectlyPhotographedImage = <any>"DirectlyPhotographedImage", 
}

/** Corresponds to exif.SensingMethodChoice */
export enum SensingMethod {
    Undefined = <any>"Undefined", 
    MonochromeArea = <any>"MonochromeArea", 
    OneChipColourAreaSensor = <any>"OneChipColourAreaSensor", 
    TwoChipColourAreaSensor = <any>"TwoChipColourAreaSensor", 
    ThreeChipColourAreaSensor = <any>"ThreeChipColourAreaSensor", 
    ColourSequentialAreaSensor = <any>"ColourSequentialAreaSensor", 
    MonochromeLinearArea = <any>"MonochromeLinearArea", 
    TrilinearSensor = <any>"TrilinearSensor", 
    ColourSequentialLinearSensor = <any>"ColourSequentialLinearSensor", 
}

/** Corresponds to exif.SharpnessChoice */
export enum Sharpness {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

export class SFR implements ISFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;

    constructor(data?: ISFR) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["Columns"];
            this.rows = data["Rows"];
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [];
                for (let item of data["Values"])
                    this.values.push(item);
            }
            if (data["Names"] && data["Names"].constructor === Array) {
                this.names = [];
                for (let item of data["Names"])
                    this.names.push(item);
            }
        }
    }

    static fromJS(data: any): SFR {
        let result = new SFR();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Columns"] = this.columns;
        data["Rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        if (this.names && this.names.constructor === Array) {
            data["Names"] = [];
            for (let item of this.names)
                data["Names"].push(item);
        }
        return data; 
    }
}

export interface ISFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SubjectDistanceRangeChoice */
export enum SubjectDistanceRange {
    Unknown = <any>"Unknown", 
    Macro = <any>"Macro", 
    CloseView = <any>"CloseView", 
    DistantView = <any>"DistantView", 
}

/** Corresponds to exif.WhiteBalanceChoice */
export enum WhiteBalanceExif {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    Unknown = <any>"Unknown", 
}

export class ExifAux implements IExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;

    constructor(data?: IExifAux) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lens = data["Lens"];
            this.serialNumber = data["SerialNumber"];
        }
    }

    static fromJS(data: any): ExifAux {
        let result = new ExifAux();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Lens"] = this.lens;
        data["SerialNumber"] = this.serialNumber;
        return data; 
    }
}

export interface IExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;
}

export class AudioMetadata extends FileMetadata implements IAudioMetadata {
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IAudioMetadata) {
        super(data);
        this._discriminator = "AudioMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["AudioStreams"] && data["AudioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["AudioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AudioMetadata {
        let result = new AudioMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["AudioStreams"] = [];
            for (let item of this.audioStreams)
                data["AudioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAudioMetadata extends IFileMetadata {
    audioStreams?: AudioStream[] | undefined;
}

export class AudioStream implements IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;

    constructor(data?: IAudioStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["BitRate"];
            this.bitRateMode = data["BitRateMode"];
            this.channels = data["Channels"];
            this.channelPositions = data["ChannelPositions"];
            this.codec = data["Codec"];
            this.durationInSeconds = data["DurationInSeconds"];
            this.format = data["Format"];
            this.language = data["Language"];
            this.resolution = data["Resolution"];
            this.samplingRate = data["SamplingRate"];
            this.streamSize = data["StreamSize"];
        }
    }

    static fromJS(data: any): AudioStream {
        let result = new AudioStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BitRate"] = this.bitRate;
        data["BitRateMode"] = this.bitRateMode;
        data["Channels"] = this.channels;
        data["ChannelPositions"] = this.channelPositions;
        data["Codec"] = this.codec;
        data["DurationInSeconds"] = this.durationInSeconds;
        data["Format"] = this.format;
        data["Language"] = this.language;
        data["Resolution"] = this.resolution;
        data["SamplingRate"] = this.samplingRate;
        data["StreamSize"] = this.streamSize;
        return data; 
    }
}

export interface IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export class DocumentMetadata extends FileMetadata implements IDocumentMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;

    constructor(data?: IDocumentMetadata) {
        super(data);
        this._discriminator = "DocumentMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.applicationName = data["ApplicationName"];
            this.applicationVersion = data["ApplicationVersion"];
            this.author = data["Author"];
            this.creator = data["Creator"];
            this.publisher = data["Publisher"];
            this.company = data["Company"];
            this.documentTitle = data["DocumentTitle"];
            this.characterCount = data["CharacterCount"];
            this.characterCountWithSpaces = data["CharacterCountWithSpaces"];
            this.lineCount = data["LineCount"];
            this.pageCount = data["PageCount"];
            this.slideCount = data["SlideCount"];
            this.paragraphCount = data["ParagraphCount"];
            this.revisionNumber = data["RevisionNumber"];
            if (data["Titles"] && data["Titles"].constructor === Array) {
                this.titles = [];
                for (let item of data["Titles"])
                    this.titles.push(item);
            }
            if (data["ImageTitles"] && data["ImageTitles"].constructor === Array) {
                this.imageTitles = [];
                for (let item of data["ImageTitles"])
                    this.imageTitles.push(item);
            }
            this.epsInfo = data["EpsInfo"] ? EpsMetadata.fromJS(data["EpsInfo"]) : <any>undefined;
            if (data["EmbeddedFiles"] && data["EmbeddedFiles"].constructor === Array) {
                this.embeddedFiles = [];
                for (let item of data["EmbeddedFiles"])
                    this.embeddedFiles.push(FileMetadata.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentMetadata {
        let result = new DocumentMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationName"] = this.applicationName;
        data["ApplicationVersion"] = this.applicationVersion;
        data["Author"] = this.author;
        data["Creator"] = this.creator;
        data["Publisher"] = this.publisher;
        data["Company"] = this.company;
        data["DocumentTitle"] = this.documentTitle;
        data["CharacterCount"] = this.characterCount;
        data["CharacterCountWithSpaces"] = this.characterCountWithSpaces;
        data["LineCount"] = this.lineCount;
        data["PageCount"] = this.pageCount;
        data["SlideCount"] = this.slideCount;
        data["ParagraphCount"] = this.paragraphCount;
        data["RevisionNumber"] = this.revisionNumber;
        if (this.titles && this.titles.constructor === Array) {
            data["Titles"] = [];
            for (let item of this.titles)
                data["Titles"].push(item);
        }
        if (this.imageTitles && this.imageTitles.constructor === Array) {
            data["ImageTitles"] = [];
            for (let item of this.imageTitles)
                data["ImageTitles"].push(item);
        }
        data["EpsInfo"] = this.epsInfo ? this.epsInfo.toJSON() : <any>undefined;
        if (this.embeddedFiles && this.embeddedFiles.constructor === Array) {
            data["EmbeddedFiles"] = [];
            for (let item of this.embeddedFiles)
                data["EmbeddedFiles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentMetadata extends IFileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;
}

export class EpsMetadata implements IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;

    constructor(data?: IEpsMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isRasterized = data["IsRasterized"];
            this.widthInPoints = data["WidthInPoints"];
            this.heightInPoints = data["HeightInPoints"];
        }
    }

    static fromJS(data: any): EpsMetadata {
        let result = new EpsMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsRasterized"] = this.isRasterized;
        data["WidthInPoints"] = this.widthInPoints;
        data["HeightInPoints"] = this.heightInPoints;
        return data; 
    }
}

export interface IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export class ImageMetadata extends FileMetadata implements IImageMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;

    constructor(data?: IImageMetadata) {
        super(data);
        this._discriminator = "ImageMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["Width"];
            this.height = data["Height"];
            this.widthInInch = data["WidthInInch"];
            this.heightInInch = data["HeightInInch"];
            this.widthInCm = data["WidthInCm"];
            this.heightInCm = data["HeightInCm"];
            this.colorSpace = data["ColorSpace"];
            this.colorProfile = data["ColorProfile"];
            this.bitsPerPixel = data["BitsPerPixel"];
            this.bitsPerChannel = data["BitsPerChannel"];
            this.channels = data["Channels"];
            this.pixelFormat = data["PixelFormat"];
            this.hasAlpha = data["HasAlpha"];
            this.isIndexed = data["IsIndexed"];
            this.isExtended = data["IsExtended"];
            this.horizontalResolution = data["HorizontalResolution"];
            this.verticalResolution = data["VerticalResolution"];
            this.totalFrames = data["TotalFrames"];
            this.totalUnspecifiedTiffExtraChannels = data["TotalUnspecifiedTiffExtraChannels"];
            this.hasExifData = data["HasExifData"];
            this.hasIptcData = data["HasIptcData"];
            this.hasAdobeResourceData = data["HasAdobeResourceData"];
            this.hasXmpData = data["HasXmpData"];
            this.uncompressedSizeInBytes = data["UncompressedSizeInBytes"];
        }
    }

    static fromJS(data: any): ImageMetadata {
        let result = new ImageMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Width"] = this.width;
        data["Height"] = this.height;
        data["WidthInInch"] = this.widthInInch;
        data["HeightInInch"] = this.heightInInch;
        data["WidthInCm"] = this.widthInCm;
        data["HeightInCm"] = this.heightInCm;
        data["ColorSpace"] = this.colorSpace;
        data["ColorProfile"] = this.colorProfile;
        data["BitsPerPixel"] = this.bitsPerPixel;
        data["BitsPerChannel"] = this.bitsPerChannel;
        data["Channels"] = this.channels;
        data["PixelFormat"] = this.pixelFormat;
        data["HasAlpha"] = this.hasAlpha;
        data["IsIndexed"] = this.isIndexed;
        data["IsExtended"] = this.isExtended;
        data["HorizontalResolution"] = this.horizontalResolution;
        data["VerticalResolution"] = this.verticalResolution;
        data["TotalFrames"] = this.totalFrames;
        data["TotalUnspecifiedTiffExtraChannels"] = this.totalUnspecifiedTiffExtraChannels;
        data["HasExifData"] = this.hasExifData;
        data["HasIptcData"] = this.hasIptcData;
        data["HasAdobeResourceData"] = this.hasAdobeResourceData;
        data["HasXmpData"] = this.hasXmpData;
        data["UncompressedSizeInBytes"] = this.uncompressedSizeInBytes;
        super.toJSON(data);
        return data; 
    }
}

export interface IImageMetadata extends IFileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export class VideoMetadata extends FileMetadata implements IVideoMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IVideoMetadata) {
        super(data);
        this._discriminator = "VideoMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["Width"];
            this.height = data["Height"];
            this.durationInSeconds = data["DurationInSeconds"];
            this.format = data["Format"];
            this.codec = data["Codec"];
            this.overallBitrate = data["OverallBitrate"];
            if (data["VideoStreams"] && data["VideoStreams"].constructor === Array) {
                this.videoStreams = [];
                for (let item of data["VideoStreams"])
                    this.videoStreams.push(VideoStream.fromJS(item));
            }
            if (data["AudioStreams"] && data["AudioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["AudioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoMetadata {
        let result = new VideoMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Width"] = this.width;
        data["Height"] = this.height;
        data["DurationInSeconds"] = this.durationInSeconds;
        data["Format"] = this.format;
        data["Codec"] = this.codec;
        data["OverallBitrate"] = this.overallBitrate;
        if (this.videoStreams && this.videoStreams.constructor === Array) {
            data["VideoStreams"] = [];
            for (let item of this.videoStreams)
                data["VideoStreams"].push(item.toJSON());
        }
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["AudioStreams"] = [];
            for (let item of this.audioStreams)
                data["AudioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IVideoMetadata extends IFileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;
}

export class VideoStream implements IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;

    constructor(data?: IVideoStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["BitRate"];
            this.codec = data["Codec"];
            this.displayAspectRatio = data["DisplayAspectRatio"];
            this.durationInSeconds = data["DurationInSeconds"];
            this.format = data["Format"];
            this.frameCount = data["FrameCount"];
            this.frameRate = data["FrameRate"];
            this.height = data["Height"];
            this.language = data["Language"];
            this.pixelAspectRatio = data["PixelAspectRatio"];
            this.resolution = data["Resolution"];
            this.streamSize = data["StreamSize"];
            this.width = data["Width"];
            this.rotation = data["Rotation"];
        }
    }

    static fromJS(data: any): VideoStream {
        let result = new VideoStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BitRate"] = this.bitRate;
        data["Codec"] = this.codec;
        data["DisplayAspectRatio"] = this.displayAspectRatio;
        data["DurationInSeconds"] = this.durationInSeconds;
        data["Format"] = this.format;
        data["FrameCount"] = this.frameCount;
        data["FrameRate"] = this.frameRate;
        data["Height"] = this.height;
        data["Language"] = this.language;
        data["PixelAspectRatio"] = this.pixelAspectRatio;
        data["Resolution"] = this.resolution;
        data["StreamSize"] = this.streamSize;
        data["Width"] = this.width;
        data["Rotation"] = this.rotation;
        return data; 
    }
}

export interface IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export class DriveMetadata implements IDriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: DriveMetadataAudit | undefined;
    description?: string | undefined;

    constructor(data?: IDriveMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["Location"];
            this.fileType = data["FileType"];
            this.audit = data["Audit"] ? DriveMetadataAudit.fromJS(data["Audit"]) : <any>undefined;
            this.description = data["Description"];
        }
    }

    static fromJS(data: any): DriveMetadata {
        let result = new DriveMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Location"] = this.location;
        data["FileType"] = this.fileType;
        data["Audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["Description"] = this.description;
        return data; 
    }
}

export interface IDriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: DriveMetadataAudit | undefined;
    description?: string | undefined;
}

export class DriveMetadataAudit implements IDriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;

    constructor(data?: IDriveMetadataAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.owner = data["Owner"];
            this.modified = data["Modified"];
            this.opened = data["Opened"];
            this.created = data["Created"];
        }
    }

    static fromJS(data: any): DriveMetadataAudit {
        let result = new DriveMetadataAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Owner"] = this.owner;
        data["Modified"] = this.modified;
        data["Opened"] = this.opened;
        data["Created"] = this.created;
        return data; 
    }
}

export interface IDriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;
}

export class OutputItem implements IOutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;

    constructor(data?: IOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.filePath = data["FilePath"];
            this.outputSource = data["OutputSource"];
        }
    }

    static fromJS(data: any): OutputItem {
        let result = new OutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["FilePath"] = this.filePath;
        data["OutputSource"] = this.outputSource;
        return data; 
    }
}

export interface IOutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered", 
    Embedded = <any>"Embedded", 
}

export class FileTransfer2ContentCreateRequest implements IFileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransfer2ContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["TransferId"];
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["Metadata"] ? DataDictionary.fromJS(data["Metadata"]) : <any>undefined;
            if (data["ContentPermissionSetIds"] && data["ContentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["ContentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransfer2ContentCreateRequest {
        let result = new FileTransfer2ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TransferId"] = this.transferId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["ContentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["ContentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class FileTransferPartial2ContentCreateRequest implements IFileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: FileTransferCreateItem[] | undefined;

    constructor(data?: IFileTransferPartial2ContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["TransferId"];
            if (data["Items"] && data["Items"].constructor === Array) {
                this.items = [];
                for (let item of data["Items"])
                    this.items.push(FileTransferCreateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FileTransferPartial2ContentCreateRequest {
        let result = new FileTransferPartial2ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TransferId"] = this.transferId;
        if (this.items && this.items.constructor === Array) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: FileTransferCreateItem[] | undefined;
}

export class FileTransferCreateItem implements IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransferCreateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileId = data["FileId"];
            if (data["LayerSchemaIds"] && data["LayerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["LayerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["Metadata"] ? DataDictionary.fromJS(data["Metadata"]) : <any>undefined;
            if (data["ContentPermissionSetIds"] && data["ContentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["ContentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferCreateItem {
        let result = new FileTransferCreateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileId"] = this.fileId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["LayerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["LayerSchemaIds"].push(item);
        }
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["ContentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["ContentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class TransferSearchRequest implements ITransferSearchRequest {
    channel?: string | undefined;
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: ITransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.channel = data["Channel"];
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["Start"];
            this.limit = data["Limit"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransferSearchRequest {
        let result = new TransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Channel"] = this.channel;
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Start"] = this.start;
        data["Limit"] = this.limit;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITransferSearchRequest {
    channel?: string | undefined;
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfTransferViewItem implements IBaseResultOfTransferViewItem {
    totalResults: number;
    results?: TransferViewItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfTransferViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(TransferViewItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfTransferViewItem {
        let result = new BaseResultOfTransferViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfTransferViewItem {
    totalResults: number;
    results?: TransferViewItem[] | undefined;
    pageToken?: string | undefined;
}

export class TransferSearchResult extends BaseResultOfTransferViewItem implements ITransferSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: ITransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["ElapsedMilliseconds"];
        }
    }

    static fromJS(data: any): TransferSearchResult {
        let result = new TransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ElapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferSearchResult extends IBaseResultOfTransferViewItem {
    elapsedMilliseconds: number;
}

export class FileTransferSearchRequest implements IFileTransferSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: IFileTransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["SearchString"];
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["Start"];
            this.limit = data["Limit"];
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileTransferSearchRequest {
        let result = new FileTransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SearchString"] = this.searchString;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        data["Start"] = this.start;
        data["Limit"] = this.limit;
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFileTransferSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfFileTransferViewItem implements IBaseResultOfFileTransferViewItem {
    totalResults: number;
    results?: FileTransferViewItem[] | undefined;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfFileTransferViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["TotalResults"];
            if (data["Results"] && data["Results"].constructor === Array) {
                this.results = [];
                for (let item of data["Results"])
                    this.results.push(FileTransferViewItem.fromJS(item));
            }
            this.pageToken = data["PageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfFileTransferViewItem {
        let result = new BaseResultOfFileTransferViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["PageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfFileTransferViewItem {
    totalResults: number;
    results?: FileTransferViewItem[] | undefined;
    pageToken?: string | undefined;
}

export class FileTransferSearchResult extends BaseResultOfFileTransferViewItem implements IFileTransferSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IFileTransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["ElapsedMilliseconds"];
        }
    }

    static fromJS(data: any): FileTransferSearchResult {
        let result = new FileTransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ElapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IFileTransferSearchResult extends IBaseResultOfFileTransferViewItem {
    elapsedMilliseconds: number;
}

export class FileTransferViewItem implements IFileTransferViewItem {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    contentId?: string | undefined;

    constructor(data?: IFileTransferViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.identifier = data["Identifier"];
            this.transferId = data["TransferId"];
            this.state = data["State"];
            this.entityType = data["EntityType"];
            this.contentId = data["ContentId"];
        }
    }

    static fromJS(data: any): FileTransferViewItem {
        let result = new FileTransferViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Identifier"] = this.identifier;
        data["TransferId"] = this.transferId;
        data["State"] = this.state;
        data["EntityType"] = this.entityType;
        data["ContentId"] = this.contentId;
        return data; 
    }
}

export interface IFileTransferViewItem {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    contentId?: string | undefined;
}

export class ChannelViewItem implements IChannelViewItem {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    entityType: EntityType;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;

    constructor(data?: IChannelViewItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.sortOrder = data["SortOrder"];
            this.searchIndexId = data["SearchIndexId"];
            this.entityType = data["EntityType"];
            if (data["SchemaIds"] && data["SchemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["SchemaIds"])
                    this.schemaIds.push(item);
            }
            this.filter = data["Filter"] ? FilterBase.fromJS(data["Filter"]) : <any>undefined;
            this.names = data["Names"] ? TranslatedStringDictionary.fromJS(data["Names"]) : <any>undefined;
            if (data["Sort"] && data["Sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["Sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["Aggregations"] && data["Aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["Aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            if (data["ExtendedSimpleSearchFields"] && data["ExtendedSimpleSearchFields"].constructor === Array) {
                this.extendedSimpleSearchFields = [];
                for (let item of data["ExtendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields.push(item);
            }
        }
    }

    static fromJS(data: any): ChannelViewItem {
        let result = new ChannelViewItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["SortOrder"] = this.sortOrder;
        data["SearchIndexId"] = this.searchIndexId;
        data["EntityType"] = this.entityType;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["SchemaIds"] = [];
            for (let item of this.schemaIds)
                data["SchemaIds"].push(item);
        }
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["Names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.sort && this.sort.constructor === Array) {
            data["Sort"] = [];
            for (let item of this.sort)
                data["Sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["Aggregations"] = [];
            for (let item of this.aggregations)
                data["Aggregations"].push(item.toJSON());
        }
        if (this.extendedSimpleSearchFields && this.extendedSimpleSearchFields.constructor === Array) {
            data["ExtendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["ExtendedSimpleSearchFields"].push(item);
        }
        return data; 
    }
}

export interface IChannelViewItem {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    entityType: EntityType;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, null));
}

function blobToText(blob: Blob): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}
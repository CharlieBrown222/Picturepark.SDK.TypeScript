/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { PictureparkServiceBase } from './base.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const PICTUREPARK_API_URL = new InjectionToken<string>('PICTUREPARK_API_URL');

export abstract class DTOBase {
    // tslint:disable-next-line: variable-name
    private _fields: {
        type: 'object' | 'array' | 'dictionary';
        dataType: string;
        propertyName: string;
        supportsConstructorConversion: boolean;
        builder?: (item: any) => any;
    }[] = [];

    constructor(data?: any) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property)) {
                    (this)[property] = (data)[property];
                }
            }
        }
    }

    init(data?: any) {
        this._fields.forEach(field => {
            switch(field.type) {
                case "array":
                    if (Array.isArray(data[field.propertyName])) {
                        this[field.propertyName] = [] as any;
                        for (let item of data[field.propertyName]) {
                            if(field.supportsConstructorConversion === true) {
                                this[field.propertyName].push(field.builder!(item));
                            } else {
                                this[field.propertyName].push(item);
                            }
                        }
                    }
                    break;
                case "object":
                        if(field.supportsConstructorConversion === true) {
                            this[field.propertyName] = data[field.propertyName] ? field.builder!(data[field.propertyName]) : <any>undefined;
                        } else {
                            this[field.propertyName] = data[field.propertyName];
                        }
                    break;
                case "dictionary":
                    if (data[field.propertyName]) {
                        this[field.propertyName] = {} as any;
                        for (let key in data[field.propertyName]) {
                            if (data[field.propertyName].hasOwnProperty(key))
                                this[field.propertyName][key] = data[field.propertyName][key];
                        }
                    }
                    break;
            }
        });
    }

    construct(data?: any): void {
        this._fields.forEach(field => {
            if (!field.supportsConstructorConversion) {
                return;
            }

            switch (field.type) {
                case 'array':
                    this.constructArray(data, field.propertyName, field.builder);
                    break;
                case 'dictionary':
                    this.constructDict(data, field.propertyName, field.builder);
                    break;
                case 'object':
                    this.constructObject(data, field.propertyName, field.builder);
                    break;
            }
        });
    }

    setProp(
        type: 'object' | 'array' | 'dictionary',
        dataType: string,
        propertyName: string,
        supportsConstructorConversion: boolean,
        builder?: (item: any) => any
    ): void {
        this._fields.push({type, dataType, supportsConstructorConversion, propertyName, builder});
    }

    constructArray<T>(data: any, propertyName: string, builder?: (item: any) => T): void {
        if (data[propertyName]) {
            this[propertyName] = [];
            for (let i = 0; i < data[propertyName].length; i++) {
                const item = data[propertyName][i];
                this[propertyName][i] = item && !(item as any).toJSON  && builder ? builder(item) : item as T;
            }
        }
    }

    constructDict<T>(data: any, propertyName: string, builder?: (item: any) => T): void {
        if (data[propertyName]) {
            this[propertyName] = {};
            for (const key in data[propertyName]) {
                if (data[propertyName].hasOwnProperty(key)) {
                    const item = data[propertyName][key];
                    this[propertyName][key] = item && !(item as any).toJSON && builder ? builder(item) : item as T;
                }
            }
        }
    }

    constructObject<T>(data: any, propertyName: string, builder?: (item: any) => T): void {
        this[propertyName] = data[propertyName] && !(data[propertyName] as any).toJSON && builder
            ? builder(data[propertyName]) : this[propertyName] as T;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this["_kind"];
        this._fields.forEach(field => {
            switch (field.type) {
                case 'array':
                    if (this[field.propertyName]) {
                        data[field.propertyName] = [];
                        for (let i = 0; i < this[field.propertyName].length; i++) {
                            const item = this[field.propertyName][i];
                            data[field.propertyName][i] = item && (item as any).toJSON  ? (item as any).toJSON() : item as any;
                        }
                    }
                    break;
                case 'dictionary':
                    if (this[field.propertyName]) {
                        data[field.propertyName] = {};
                        for (const key in this[field.propertyName]) {
                            if (this[field.propertyName].hasOwnProperty(key)) {
                                const item = this[field.propertyName][key];
                                data[field.propertyName][key] = item && (item as any).toJSON ? (item as any).toJSON() : item as any;
                            }
                        }
                    }
                    break;
                case 'object':
                    data[field.propertyName] = this[field.propertyName] && (this[field.propertyName] as any).toJSON ?(this[field.propertyName] as any).toJSON : this[field.propertyName] as any;
                    break;
            }
        });
        return data;
    }
}

export abstract class AuthService {
    private _pictureparkApiUrl: string;

    constructor(pictureparkApiUrl: string) {
        this._pictureparkApiUrl = pictureparkApiUrl;
    }

    get apiServer() {
        return this._pictureparkApiUrl;
    }

    abstract get isAuthenticated(): boolean;
    abstract transformHttpRequestOptions(options: any): Promise<any>;
}

@Injectable({
    providedIn: 'root'
})
export class BusinessProcessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param businessProcessSearchRequest The business process request.
     * @return BusinessProcessSearchResult
     */
    search(businessProcessSearchRequest: BusinessProcessSearchRequest): Observable<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<BusinessProcessSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessSearchResult>(<any>null);
    }

    /**
     * Wait for life cycles
     * @param processId The business process id.
     * @param lifeCycleIds (optional) Business process life cycles to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitForLifeCycleResult
     */
    waitForLifeCycles(processId: string, lifeCycleIds: BusinessProcessLifeCycle[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitLifeCycles?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (lifeCycleIds !== undefined)
            lifeCycleIds && lifeCycleIds.forEach(item => { url_ += "lifeCycleIds=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForLifeCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForLifeCycles(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForLifeCycles(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForLifeCycleResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Wait for states
     * @param processId The business process id.
     * @param states (optional) Business process states to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForStateResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitStates?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForStates(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForStateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForStateResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForStates(response: HttpResponseBase): Observable<BusinessProcessWaitForStateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForStateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForStateResult>(<any>null);
    }

    /**
     * Wait for completion
     * @param processId The business process id.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(processId: string, timeout: string | null | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitCompletion?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForCompletion(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForCompletion(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForLifeCycleResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Get details
     * @param processId The business process id.
     * @return BusinessProcessDetails
     */
    getDetails(processId: string): Observable<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/details";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessDetails>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<BusinessProcessDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessDetails>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BusinessRuleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get the current business rule configuration
     * @return BusinessRuleConfiguration
     */
    getConfiguration(): Observable<BusinessRuleConfiguration> {
        let url_ = this.baseUrl + "/v1/businessrules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<BusinessRuleConfiguration>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessRuleConfiguration>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<BusinessRuleConfiguration> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessRuleConfiguration.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessRuleConfiguration>(<any>null);
    }

    /**
     * Updates the business rule configuration.
     * @param disableRuleEngine (optional) Disables the rule engine completely.
     * @param rules (optional) Rules
     * @return Business process
     */
    updateConfiguration(disableRuleEngine: boolean | undefined, rules: BusinessRule[] | null | undefined): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/businessrules/configuration?";
        if (disableRuleEngine === null)
            throw new Error("The parameter 'disableRuleEngine' cannot be null.");
        else if (disableRuleEngine !== undefined)
            url_ += "DisableRuleEngine=" + encodeURIComponent("" + disableRuleEngine) + "&"; 
        if (rules !== undefined)
            rules && rules.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Rules[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfiguration(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChannelService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get all channels
     * @return List of channel
     */
    getAll(): Observable<Channel[]> {
        let url_ = this.baseUrl + "/v1/channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Channel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Channel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Channel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel[]>(<any>null);
    }

    /**
     * Create channel
     * @param request The request containing information needed to create new channel.
     * @return Channel
     */
    create(request: ChannelCreateRequest): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/channels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Channel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel>(<any>null);
    }

    /**
     * Get channel
     * @param id The channel ID.
     * @return Channel
     */
    get(id: string): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Channel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel>(<any>null);
    }

    /**
     * Update channel
     * @param id ID of channel to update
     * @param request The request containing information needed to update the channel.
     * @return Updated channel
     */
    update(id: string, request: ChannelUpdateRequest): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Channel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel>(<any>null);
    }

    /**
     * Delete channel
     * @param id ID of the channel that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get content
     * @param contentId The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return Content detail
     */
    get(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Delete content
     * @param contentId The ID of the content to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Ok
     */
    delete(contentId: string, forceReferenceRemoval: boolean | null | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get multiple contents
     * @param ids List of content IDs
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return List of Content detail
     */
    getMany(ids: string[] | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail[]>(<any>null);
    }

    /**
     * Create content
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param contentCreateRequest Content create request.
     * @return The content details
     */
    create(resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, contentCreateRequest: ContentCreateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Search contents
     * @param contentSearchRequest Content search request.
     * @return Content search result
     */
    search(contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ContentSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentSearchResult>(<any>null);
    }

    /**
     * Aggregate contents
     * @param contentAggregationRequest Content aggregation request.
     * @return Object aggregation result
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Aggregate contents on channel
     * @param contentAggregationOnChannelRequest Content aggregation on channel request.
     * @return Object aggregation result
     */
    aggregateOnChannel(contentAggregationOnChannelRequest: ContentAggregationOnChannelRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregateOnChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationOnChannelRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregateOnChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregateOnChannel(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregateOnChannel(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Get content references
     * @param contentId The content ID whose references to retrieve.
     * @param contentReferencesRequest Content references request.
     * @return ContentReferencesResult
     */
    getReferences(contentId: string, contentReferencesRequest: ContentReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/references/search";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferences(<any>response_);
                } catch (e) {
                    return <Observable<ContentReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferences(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentReferencesResult>(<any>null);
    }

    /**
     * Get many content references
     * @param contentManyReferencesRequest Content many references request.
     * @return Content references result
     */
    getReferencesMany(contentManyReferencesRequest: ContentManyReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentManyReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesMany(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentReferencesResult>(<any>null);
    }

    /**
     * Create download link
     * @param request Content download link request
     * @return Download link
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDownloadLink(<any>response_);
                } catch (e) {
                    return <Observable<DownloadLink>><any>_observableThrow(e);
                }
            } else
                return <Observable<DownloadLink>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DownloadLink>(<any>null);
    }

    /**
     * Download content
     * @param contentId The content ID.
     * @param outputFormatId The output format ID.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000).
     * @return Http response message
     */
    download(contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download thumbnail
     * @param contentId The content ID.
     * @param size Thumbnail size. Either small, medium or large.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     * @return Http response message
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, width: number | null | undefined, height: number | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/thumbnails/{contentId}/{size}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadThumbnail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadThumbnail(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadThumbnail(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Create multiple contents
     * @param contentCreateManyRequest Content create many request.
     * @return Business process
     */
    createMany(contentCreateManyRequest: ContentCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple contents
     * @param deleteManyRequest Delete many request.
     * @return Business process
     */
    deleteMany(deleteManyRequest: ContentDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple contents - by filter
     * @param deleteManyFilterRequest Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(deleteManyFilterRequest: ContentDeleteManyFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyFilterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteManyByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteManyByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Restore content
     * @param contentId The content ID.
     * @param allowMissingDependencies (optional) Allows restoring contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Ok
     */
    restore(contentId: string, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/restore?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore multiple contents
     * @param restoreManyRequest Content restore many request.
     * @return Business process
     */
    restoreMany(restoreManyRequest: ContentRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update content file
     * @param contentId The ID of the content to replace.
     * @param updateRequest Content file update request
     * @return Business process
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/file";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFile(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFile(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update content metadata
     * @param contentId The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows storing references to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param updateRequest Content metadata update request.
     * @return Content detail
     */
    updateMetadata(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, updateRequest: ContentMetadataUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/metadata?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadata(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMetadata(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Update content permissions
     * @param contentId The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param updateRequest Content permissions update request.
     * @return Content detail
     */
    updatePermissions(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined, timeout: string | null | undefined, updateRequest: ContentPermissionsUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Update multiple content metadata
     * @param updateRequest Content metadata update many request.
     * @return Business process
     */
    updateMetadataMany(updateRequest: ContentMetadataUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadataMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadataMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMetadataMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple contents permissions
     * @param updateManyRequest Content permissions update many request.
     * @return Business process
     */
    updatePermissionsMany(updateManyRequest: ContentPermissionsUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissionsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Transfer content ownership
     * @param contentId The content ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param updateRequest Content ownership transfer request.
     * @return Ok
     */
    transferOwnership(contentId: string, timeout: string | null | undefined, updateRequest: ContentOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/ownership?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Transfer multiple contents ownerships
     * @param contentOwnershipTransferManyRequest Content ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(contentOwnershipTransferManyRequest: ContentOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentOwnershipTransferManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update content fields - by IDs
     * @param updateRequest Content fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(updateRequest: ContentFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest Content fields batch update filter request. It contains the changes that need to be applied to the contents and the filter request to identify the contents.
     * @return Business process
     */
    batchUpdateFieldsByFilter(updateRequest: ContentFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get content permission set
     * @param permissionSetId The content permission set ID.
     * @return Content permission set detail
     */
    get(permissionSetId: string): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Create content permission set
     * @param request The request containing information needed to create new permission set.
     * @return Content permission set detail
     */
    create(request: ContentPermissionSetCreateRequest): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Get multiple permission sets
     * @param ids (optional) Permission set IDs to get information about
     * @return Content permission set details
     */
    getMany(ids: string[] | undefined): Observable<ContentPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentPermissionSetDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentPermissionSetDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail[]>(<any>null);
    }

    /**
     * Update content permission set
     * @param id ID of permission set to update
     * @param request The request containing information needed to update the permission set.
     * @return Content permission set detail
     */
    update(id: string, request: ContentPermissionSetUpdateRequest): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Delete content permission set
     * @param id ID of the permission set that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Transfer ownership of content permission set
     * @param id ID of the permission set to transfer
     * @param request The request containing user who should be the new owner.
     * @return OK
     */
    transferOwnership(id: string, request: PermissionSetOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for the permission set
     * @param id ID of the permission set to view permissions of.
     * @return List of permissions
     */
    getPermissions(id: string): Observable<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetRight[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetRight[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionSetRight[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetRight[]>(<any>null);
    }

    /**
     * Create multiple content permission sets
     * @param request The request containing information needed to create new permission sets.
     * @return Bulk response with information about created permission sets
     */
    createMany(request: ContentPermissionSetCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple content permission sets
     * @param request The request containing information needed to update the permission set.
     * @return Bulk response with information about updated permission sets
     */
    updateMany(request: ContentPermissionSetUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple content permission sets
     * @param request The request with permission set IDs to delete.
     * @return Bulk response with information about success or failure
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Transfer ownership of multiple content permission sets
     * @param request The request containing information on which permission set to transfer to which user.
     * @return OK
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for multiple permission sets
     * @param ids (optional) IDs of the permission sets to view permissions of.
     * @return List of permissions
     */
    getPermissionsMany(ids: string[] | undefined): Observable<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many/permissions?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsMany(response: HttpResponseBase): Observable<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionSetUserPermissionRights.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetUserPermissionRights[]>(<any>null);
    }

    /**
     * Search content permission sets
     * @param request The permission set search request.
     * @return Permission set search result
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSetSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param documentHistorySearchRequest The document history search request.
     * @return Document history search result.
     */
    search(documentHistorySearchRequest: DocumentHistorySearchRequest): Observable<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistorySearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistorySearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<DocumentHistorySearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistorySearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistorySearchResult>(<any>null);
    }

    /**
     * Get current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @return Document history item
     */
    getCurrent(documentType: string, documentId: string): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrent(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrent(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistory>(<any>null);
    }

    /**
     * Get version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document.
     * @return Document history item
     */
    getVersion(documentType: string, documentId: string, documentVersion: number): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistory>(<any>null);
    }

    /**
     * Compare with current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference.
     */
    compareWithCurrent(documentType: string, documentId: string, version: number | undefined): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCompareWithCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareWithCurrent(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>_observableThrow(response_);
        }));
    }

    protected processCompareWithCurrent(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistoryDifference.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Compare with version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document to use for the comparison.
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference
     */
    compareWithVersion(documentType: string, documentId: string, documentVersion: number, version: number | undefined): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion)); 
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCompareWithVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareWithVersion(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>_observableThrow(response_);
        }));
    }

    protected processCompareWithVersion(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistoryDifference.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistoryDifference>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class InfoService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get info
     * @return CustomerInfo
     */
    getInfo(): Observable<CustomerInfo> {
        let url_ = this.baseUrl + "/v1/info/customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(<any>response_);
                } catch (e) {
                    return <Observable<CustomerInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfo(response: HttpResponseBase): Observable<CustomerInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerInfo>(<any>null);
    }

    /**
     * Get version
     * @return VersionInfo
     */
    getVersion(): Observable<VersionInfo> {
        let url_ = this.baseUrl + "/v1/info/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<VersionInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<VersionInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<VersionInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VersionInfo>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class JsonSchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get json schema
     * @param schemaId The ID of the schema whose json schema to retrieve.
     * @return Json schema view item: almost a 1:1 representation of the Newtonsoft json schema.
     */
    get(schemaId: string): Observable<any> {
        let url_ = this.baseUrl + "/v1/jsonSchemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ListItemService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get list item
     * @param listItemId The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @return List item detail
     */
    get(listItemId: string, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Update list item
     * @param listItemId The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param updateRequest The list item update request.
     * @return List item detail
     */
    update(listItemId: string, resolveBehaviors: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, updateRequest: ListItemUpdateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Delete list item
     * @param listItemId The ID of the list item to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the list item should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Ok
     */
    delete(listItemId: string, forceReferenceRemoval: boolean | null | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get multiple list items
     * @param ids List of list item IDs.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list items are resolved and returned.
     * @return List of list item details
     */
    getMany(ids: string[] | null, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail[]> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ListItemDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListItemDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail[]>(<any>null);
    }

    /**
     * Create list item
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param listItemCreateRequest List item create request.
     * @return List item detail
     */
    create(resolveBehaviors: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, listItemCreateRequest: ListItemCreateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Search list items
     * @param listItemSearchRequest The list item search request.
     * @return List item search result
     */
    search(listItemSearchRequest: ListItemSearchRequest): Observable<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/listItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListItemSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListItemSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemSearchResult>(<any>null);
    }

    /**
     * Aggregate list items
     * @param listItemAggregationRequest The list item aggregation request.
     * @return Object aggregation result
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/listItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create multiple list items
     * @param listItemCreateManyRequest List item create many request.
     * @return Business process
     */
    createMany(listItemCreateManyRequest: ListItemCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple list items
     * @param listItemUpdateManyRequest List item update many request.
     * @return Business process
     */
    updateMany(listItemUpdateManyRequest: ListItemUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemUpdateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple list items
     * @param deleteManyRequest List item delete many request.
     * @return Business process
     */
    deleteMany(deleteManyRequest: ListItemDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple list items - by filter
     * @param deleteManyFilterRequest Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(deleteManyFilterRequest: ListItemDeleteManyFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyFilterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteManyByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteManyByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Restore list item
     * @param listItemId The list item ID.
     * @param allowMissingDependencies (optional) Allows restoring list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Ok
     */
    restore(listItemId: string, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/restore?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore multiple list items
     * @param restoreManyRequest List item restore many request.
     * @return Business process
     */
    restoreMany(restoreManyRequest: ListItemRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by IDs
     * @param updateRequest List item fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(updateRequest: ListItemFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest List item fields batch update by filter request.
     * @return Business process
     */
    batchUpdateFieldsByFilter(updateRequest: ListItemFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Get list item references
     * @param listItemId The ID of the list item.
     * @param listItemReferencesRequest Request options to specify how many references to fetch.
     * @return List item references
     */
    getReferencesToListItem(listItemId: string, listItemReferencesRequest: ListItemReferencesRequest): Observable<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/references/search";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesToListItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesToListItem(<any>response_);
                } catch (e) {
                    return <Observable<ListItemReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesToListItem(response: HttpResponseBase): Observable<ListItemReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemReferencesResult>(<any>null);
    }

    /**
     * Get multiple list items references
     * @param listItemManyReferencesRequest ListItemManyReferencesRequest
     * @return A list of references per list item.
     */
    getReferencesToListItems(listItemManyReferencesRequest: ListItemManyReferencesRequest): Observable<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/listItems/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemManyReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesToListItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesToListItems(<any>response_);
                } catch (e) {
                    return <Observable<ListItemReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesToListItems(response: HttpResponseBase): Observable<ListItemReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemReferencesResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LiveStreamService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * This endpoint cannot be used. It is kept to generate LiveStream message contracts.
     * @return OK
     * @deprecated
     */
    getMessage(): Observable<LiveStreamMessage> {
        let url_ = this.baseUrl + "/v1/liveStream/message";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessage(<any>response_);
                } catch (e) {
                    return <Observable<LiveStreamMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiveStreamMessage>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessage(response: HttpResponseBase): Observable<LiveStreamMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiveStreamMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiveStreamMessage>(<any>null);
    }

    /**
     * Search
     * @param request Parameters for the search
     * @return Resulting live stream events
     */
    search(request: LiveStreamSearchRequest): Observable<LiveStreamSearchResult> {
        let url_ = this.baseUrl + "/v1/liveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<LiveStreamSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiveStreamSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<LiveStreamSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiveStreamSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiveStreamSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search output documents
     * @param outputSearchRequest The output search request.
     * @return Output result set.
     */
    search(outputSearchRequest: OutputSearchRequest): Observable<OutputSearchResult> {
        let url_ = this.baseUrl + "/v1/outputs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(outputSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<OutputSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<OutputSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputSearchResult>(<any>null);
    }

    /**
     * Get - single
     * @param outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Observable<OutputDetail> {
        let url_ = this.baseUrl + "/v1/outputs/{outputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{outputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OutputDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkBusinessException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputDetail>(<any>null);
    }

    /**
     * Resets retry attempts counter on failed (optionally also completed) outputs and they will be subsequently picked up for re-rendering.
     * @param request Request containing options to filter which outputs should be reset.
     * @return Business process tracking the resetting
     */
    resetRetryAttempts(request: OutputResetRetryAttemptsRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputs/resetRetryAttempts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processResetRetryAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetRetryAttempts(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processResetRetryAttempts(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputFormatService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get output format
     * @param id The output format ID.
     * @return Output format
     */
    get(id: string): Observable<OutputFormat> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OutputFormat>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputFormat>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputFormat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputFormat.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputFormat>(<any>null);
    }

    /**
     * Update output format
     * @param id ID of output format to update
     * @param request The request containing information needed to update the output format.
     * @return Updated output format
     */
    update(id: string, request: OutputFormatEditable): Observable<OutputFormat> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OutputFormat>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputFormat>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OutputFormat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputFormat.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputFormat>(<any>null);
    }

    /**
     * Delete output format
     * @param id ID of the output format that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create output format
     * @param request The request containing information needed to create new output format.
     * @return Output format
     */
    create(request: OutputFormat): Observable<OutputFormat> {
        let url_ = this.baseUrl + "/v1/outputFormats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OutputFormat>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputFormat>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OutputFormat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputFormat.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputFormat>(<any>null);
    }

    /**
     * Get multiple output formats
     * @param ids (optional) Output format IDs to get information about. If this is omitted, all output formats in the system will be returned.
     * @return Output formats
     */
    getMany(ids: string[] | null | undefined): Observable<OutputFormat[]> {
        let url_ = this.baseUrl + "/v1/outputFormats?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<OutputFormat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputFormat[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<OutputFormat[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutputFormat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputFormat[]>(<any>null);
    }

    /**
     * Create multiple output formats
     * @param request The request containing information needed to create new output formats.
     * @return Bulk response with information about created output formats
     */
    createMany(request: OutputFormatCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/outputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple output formats
     * @param request The request containing information needed to update the output format.
     * @return Bulk response with information about updated output formats
     */
    updateMany(request: OutputFormatUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/outputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple output formats
     * @param request The request with output formats IDs to delete.
     * @return Bulk response with information about success or failure
     */
    deleteMany(request: OutputFormatDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/outputFormats/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProfileService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return User profile
     */
    get(): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfile>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfile>(<any>null);
    }

    /**
     * Update
     * @return Updated user profile
     */
    update(updateRequest: UserProfileUpdateRequest): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfile>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfile>(<any>null);
    }

    /**
     * Request deletion
     * @return OK
     */
    requestDeletion(): Observable<void> {
        let url_ = this.baseUrl + "/v1/profile/requestDeletion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRequestDeletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestDeletion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequestDeletion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get schema
     * @param schemaId The schema ID.
     * @return Schema detail
     */
    get(schemaId: string): Observable<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail>(<any>null);
    }

    /**
     * Update schema
     * @param schemaId The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param schema The schema update request.
     * @return Schema update result, containing the updated schema
     */
    update(schemaId: string, timeout: string | null | undefined, schema: SchemaUpdateRequest): Observable<SchemaUpdateResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaUpdateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaUpdateResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaUpdateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaUpdateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaUpdateResult>(<any>null);
    }

    /**
     * Delete schema
     * @param schemaId The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Schema delete result
     */
    delete(schemaId: string, timeout: string | null | undefined): Observable<SchemaDeleteResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDeleteResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDeleteResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SchemaDeleteResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaDeleteResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDeleteResult>(<any>null);
    }

    /**
     * Get multiple schemas
     * @param ids (optional) Comma separated list of schema IDs.
     * @return List of schema details
     */
    getMany(ids: string[] | null | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Create schema
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param schema The schema create request.
     * @return Schema create result, containing the created schema
     */
    create(timeout: string | null | undefined, schema: SchemaCreateRequest): Observable<SchemaCreateResult> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaCreateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaCreateResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaCreateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaCreateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaCreateResult>(<any>null);
    }

    /**
     * Search schemas
     * @param schemaSearchRequest The schema search request.
     * @return Schema search result
     */
    search(schemaSearchRequest: SchemaSearchRequest): Observable<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SchemaSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SchemaSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaSearchResult>(<any>null);
    }

    /**
     * Search index fields
     * @param request The search request.
     * @return Indexed fields
     */
    getIndexFields(request: IndexFieldsSearchBySchemaIdsRequest): Observable<IndexField[]> {
        let url_ = this.baseUrl + "/v1/schemas/indexFields/searchBySchemaIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetIndexFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndexFields(<any>response_);
                } catch (e) {
                    return <Observable<IndexField[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndexField[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndexFields(response: HttpResponseBase): Observable<IndexField[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexField.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndexField[]>(<any>null);
    }

    /**
     * Exists schema
     * @param schemaId The schema ID.
     * @return Schema Exists response
     */
    exists(schemaId: string): Observable<SchemaExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/exists";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(<any>response_);
                } catch (e) {
                    return <Observable<SchemaExistsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaExistsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<SchemaExistsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaExistsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaExistsResponse>(<any>null);
    }

    /**
     * Exists field in schema
     * @param schemaId The schema ID.
     * @param fieldId The field ID.
     * @return Field Exists response
     */
    fieldExists(schemaId: string, fieldId: string): Observable<FieldExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/{fieldId}/exists";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processFieldExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFieldExists(<any>response_);
                } catch (e) {
                    return <Observable<FieldExistsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FieldExistsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFieldExists(response: HttpResponseBase): Observable<FieldExistsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldExistsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FieldExistsResponse>(<any>null);
    }

    /**
     * Gets all schemas referenced by the schema specified in
     * @param schemaId The schema ID.
     * @return Referenced schema details
     */
    getReferenced(schemaId: string): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/referenced";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferenced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenced(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenced(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Transfer ownership
     * @param schemaId The schema ID.
     * @param request Request detailing which user to transfer to.
     * @return OK
     */
    transferOwnership(schemaId: string, request: SchemaOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/ownership";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Gets all schemas referenced by the schemas specified in
     * @param ids (optional) The schema IDs.
     * @return Referenced schema details
     */
    getManyReferenced(ids: string[] | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas/many/referenced?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetManyReferenced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyReferenced(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyReferenced(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Create multiple schemas
     * @param schemas The schema create many request.
     * @return BusinessProcess which can be awaited.
     */
    createMany(schemas: SchemaCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemas);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Transfer ownership of multiple schemas
     * @param request Schema ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(request: SchemaOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get schema permission set
     * @param permissionSetId The schema permission set ID.
     * @return Schema permission set detail
     */
    get(permissionSetId: string): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Create schema permission set
     * @param request The request containing information needed to create new permission set.
     * @return Schema permission set detail
     */
    create(request: SchemaPermissionSetCreateRequest): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Get multiple permission sets
     * @param ids (optional) Permission set IDs to get information about
     * @return Schema permission set details
     */
    getMany(ids: string[] | undefined): Observable<SchemaPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaPermissionSetDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaPermissionSetDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail[]>(<any>null);
    }

    /**
     * Update schema permission set
     * @param id ID of permission set to update
     * @param request The request containing information needed to update the permission set.
     * @return Schema permission set detail
     */
    update(id: string, request: SchemaPermissionSetUpdateRequest): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Delete schema permission set
     * @param id ID of the permission set that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Transfer ownership of schema permission set
     * @param id ID of the permission set to transfer
     * @param request The request containing user who should be the new owner.
     * @return OK
     */
    transferOwnership(id: string, request: PermissionSetOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for the permission set
     * @param id ID of the permission set to view permissions of.
     * @return List of permissions
     */
    getPermissions(id: string): Observable<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetRight[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetRight[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionSetRight[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetRight[]>(<any>null);
    }

    /**
     * Create multiple schema permission sets
     * @param request The request containing information needed to create new permission sets.
     * @return Bulk response with information about created permission sets
     */
    createMany(request: SchemaPermissionSetCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple schema permission sets
     * @param request The request containing information needed to update the permission set.
     * @return Bulk response with information about updated permission sets
     */
    updateMany(request: SchemaPermissionSetUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple schema permission sets
     * @param request The request with permission set IDs to delete.
     * @return Bulk response with information about success or failure
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Transfer ownership of multiple schema permission sets
     * @param request The request containing information on which permission set to transfer to which user.
     * @return OK
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for multiple permission sets
     * @param ids (optional) IDs of the permission sets to view permissions of.
     * @return List of permissions
     */
    getPermissionsMany(ids: string[] | undefined): Observable<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many/permissions?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsMany(response: HttpResponseBase): Observable<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionSetUserPermissionRights.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetUserPermissionRights[]>(<any>null);
    }

    /**
     * Search schema permission sets
     * @param request The permission set search request.
     * @return Permission set search result
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSetSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaTransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Import schemas
     * @param schemaImportRequest The schema import request.
     * @return Transfer
     */
    import(schemaImportRequest: SchemaImportRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/schematransfers/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaImportRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkBusinessException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ShareService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @param id Share Id (not token, use [GetShareJson](#operation/Share_GetShareJson) to get share by token)
     * @return Share detail
     */
    get(id: string): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }

    /**
     * Update
     * @param id The share id.
     * @param updateRequest The share update request.
     * @return Share detail
     */
    update(id: string, updateRequest: ShareBaseUpdateRequest): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }

    /**
     * Search
     * @param request Search request
     * @return Share search result
     */
    search(request: ShareSearchRequest): Observable<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ShareSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ShareSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param request Aggregation request
     * @return Share aggregation result
     */
    aggregate(request: ShareAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create
     * @param request Polymorphic create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest): Observable<CreateShareResult> {
        let url_ = this.baseUrl + "/v1/shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateShareResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateShareResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateShareResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PermissionValidationException.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateShareResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateShareResult>(<any>null);
    }

    /**
     * Delete multiple shares
     * @param deleteManyRequest A delete many request containing the ids of the shares to delete.
     * @return BusinessProcess
     */
    deleteMany(deleteManyRequest: ShareDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/shares/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Get share json
     * @param token Share token
     * @return ShareDetail
     */
    getShareJson(token: string): Observable<any> {
        let url_ = this.baseUrl + "/v1/shares/json/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShareJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShareJson(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetShareJson(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(token: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shares/d/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param contentId The content id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithContentId(token: string, contentId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shares/d/{token}/{contentId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithContentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithContentId(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWithContentId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param contentId The content id
     * @param outputFormatId The output format id+
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithOutputFormatId(token: string, contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shares/d/{token}/{contentId}/{outputFormatId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithOutputFormatId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithOutputFormatId(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWithOutputFormatId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get transfer details
     * @param transferId ID of transfer.
     * @return TransferDetail
     */
    get(transferId: string): Observable<TransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TransferDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferDetail>(<any>null);
    }

    /**
     * Delete transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    delete(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Search
     * @param request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest): Observable<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<TransferSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<TransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferSearchResult>(<any>null);
    }

    /**
     * Cancel transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    cancelTransfer(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelTransfer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelTransfer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create transfer
     * @param request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Get file
     * @param fileTransferId ID of filetransfer.
     * @return FileTransferDetail
     */
    getFile(fileTransferId: string): Observable<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/files/{fileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{fileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileTransferDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileTransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileTransferDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileTransferDetail>(<any>null);
    }

    /**
     * Search for files
     * @param request The filetransfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest): Observable<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFiles(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileTransferSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchFiles(response: HttpResponseBase): Observable<FileTransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileTransferSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileTransferSearchResult>(<any>null);
    }

    /**
     * Get blacklist
     * @return Blacklist
     */
    getBlacklist(): Observable<Blacklist> {
        let url_ = this.baseUrl + "/v1/transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBlacklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlacklist(<any>response_);
                } catch (e) {
                    return <Observable<Blacklist>><any>_observableThrow(e);
                }
            } else
                return <Observable<Blacklist>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlacklist(response: HttpResponseBase): Observable<Blacklist> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Blacklist.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Blacklist>(<any>null);
    }

    /**
     * Delete files
     * @param request The filetransfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFiles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Import transfer
     * @param transferId ID of transfer.
     * @param request The ImportTransfer request.
     * @return Transfer
     */
    importTransfer(transferId: string, request: ImportTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImportTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTransfer(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processImportTransfer(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Import transfer partially
     * @param transferId ID of transfer.
     * @param request The ImportTransferPartial request.
     * @return Transfer
     */
    partialImport(transferId: string, request: ImportTransferPartialRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/partialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPartialImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartialImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processPartialImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Upload file
     * @param formFile (optional) Gets or sets the form file.
     * @param relativePath Relative path of the uploading file.
     * @param chunkNumber Current chunk number. Starts at 1.
     * @param currentChunkSize Size in bytes of the current chunk.
     * @param totalSize Total size in bytes of the uploading file.
     * @param totalChunks Total chunks of the uploading file.
     * @param transferId ID of transfer.
     * @param requestId Identifier of file.
     * @return OK
     */
    uploadFile(formFile: FileParameter | null | undefined, relativePath: string | null, chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string, requestId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/files/{requestId}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId)); 
        if (relativePath === undefined)
            throw new Error("The parameter 'relativePath' must be defined.");
        else
            url_ += "relativePath=" + encodeURIComponent("" + relativePath) + "&"; 
        if (chunkNumber === undefined || chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
        else
            url_ += "chunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === undefined || currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
        else
            url_ += "currentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === undefined || totalSize === null)
            throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
        else
            url_ += "totalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === undefined || totalChunks === null)
            throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
        else
            url_ += "totalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create user
     * @param request Requested user information.
     * @return Newly created user
     */
    create(request: UserCreateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Get user
     * @param userId User ID to search for.
     * @return Requested user details
     */
    get(userId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Update user
     * @param userId User ID to action on.
     * @param request New user information.
     * @return User details after the update of the user
     */
    update(userId: string, request: UserUpdateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Search users
     * @param searchRequest User search request.
     * @return Result of the user search
     */
    search(searchRequest: UserSearchRequest): Observable<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSearchResult>(<any>null);
    }

    /**
     * Get user by owner token
     * @param tokenId ID of the owner token.
     * @return User details of the user referenced by the owner token
     */
    getByOwnerToken(tokenId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByOwnerToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOwnerToken(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetByOwnerToken(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Get multiple users
     * @param ids User IDs.
     * @return Details of all the users who were found
     */
    getMany(ids: string[] | null): Observable<UserDetail[]> {
        let url_ = this.baseUrl + "/v1/users/many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail[]>(<any>null);
    }

    /**
     * Aggregate users
     * @param request User aggregation request.
     * @return Aggregation based on the request
     */
    aggregate(request: UserAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/users/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Lock / unlock user
     * @param userId User ID to action on.
     * @param request Request detailing if the user should be locked or unlocked.
     * @return OK
     */
    lock(userId: string, request: UserLockRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/lock";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Change user's review state
     * @param userId User ID to action on.
     * @param request Request detailing if the user should be set as _reviewed_ or _to be reviewed_.
     * @return OK
     */
    review(userId: string, request: UserReviewRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/review";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReview(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Invite user
     * @param userId User ID to action on.
     * @return OK
     */
    invite(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/invite";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvite(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Reinvite user
     * @param userId User ID to action on.
     * @return OK
     */
    reinvite(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/reinvite";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReinvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvite(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReinvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Delete user
     * @param userId User ID to action on.
     * @param request Request with details regarding the deletion.
     * @return OK
     */
    delete(userId: string, request: UserDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/delete";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Cancels a user triggered deletion request and returns user to _Reviewed_ state.
     * @param userId User ID to action on.
     * @return OK
     */
    cancelDeletionRequest(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/cancelDeletionRequest";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelDeletionRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelDeletionRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelDeletionRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore user
     * @param userId User ID to action on.
     * @return OK
     */
    restore(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/restore";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get multiple user roles
     * @param ids User role IDs to get information about.
     * @return List of user roles
     */
    getMany(ids: string[] | null): Observable<UserRole[]> {
        let url_ = this.baseUrl + "/v1/userRoles?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<UserRole[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRole.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole[]>(<any>null);
    }

    /**
     * Create user role
     * @param request User role creation request.
     * @return Newly created user role
     */
    create(request: UserRoleCreateRequest): Observable<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole>(<any>null);
    }

    /**
     * Get user role
     * @param userRoleId The user role ID
     * @return User role or null if not found
     */
    get(userRoleId: string): Observable<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles/{userRoleId}";
        if (userRoleId === undefined || userRoleId === null)
            throw new Error("The parameter 'userRoleId' must be defined.");
        url_ = url_.replace("{userRoleId}", encodeURIComponent("" + userRoleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole>(<any>null);
    }

    /**
     * Search user roles
     * @param searchRequest User role search request.
     * @return Result of the user role search
     */
    search(searchRequest: UserRoleSearchRequest): Observable<UserRoleSearchResult> {
        let url_ = this.baseUrl + "/v1/userRoles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserRoleSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleSearchResult>(<any>null);
    }

    /**
     * Update user roles
     * @param id ID of the user role to update.
     * @param request User role update request.
     * @return Updated user role
     */
    update(id: string, request: UserRoleEditable): Observable<UserRole> {
        let url_ = this.baseUrl + "/v1/userRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRole>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRole>(<any>null);
    }

    /**
     * Delete user role
     * @param id ID of user role to delete
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/userRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create multiple user roles
     * @param request Multiple user role creation request.
     * @return Bulk response
     */
    createMany(request: UserRoleCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple user roles
     * @param request Multiple user role update request.
     * @return Bulk response
     */
    updateMany(request: UserRoleUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple user roles
     * @param request Multiple user role deletion request.
     * @return Bulk request
     */
    deleteMany(request: UserRoleDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }
}

export class BaseResultOfBusinessProcess extends DTOBase {
    totalResults!: number;
    results!: BusinessProcess[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfBusinessProcess) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "BusinessProcess[]", "results", true, (item: any) => BusinessProcess.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfBusinessProcess {
        return BaseResultOfBusinessProcess.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfBusinessProcess {
    totalResults: number;
    results: BusinessProcess[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess implements ISearchBehaviorBaseResultOfBusinessProcess {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfBusinessProcess) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfBusinessProcess {
        return SearchBehaviorBaseResultOfBusinessProcess.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfBusinessProcess extends IBaseResultOfBusinessProcess {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Search result from a search for business processes */
export class BusinessProcessSearchResult extends SearchBehaviorBaseResultOfBusinessProcess implements IBusinessProcessSearchResult {

    constructor(data?: IBusinessProcessSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessSearchResult {
        return BusinessProcessSearchResult.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchResult();
        result.init(data);
        return result;
    }

}

/** Search result from a search for business processes */
export interface IBusinessProcessSearchResult extends ISearchBehaviorBaseResultOfBusinessProcess {
}

export class QueryDebugInformation extends DTOBase {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;

    constructor(data?: IQueryDebugInformation) {
        super(data);
        this.setProp("object", "string", "general", false);
        this.setProp("object", "string", "auditTrail", false);
        this.setProp("object", "any", "request", false);
        this.setProp("object", "any", "response", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): QueryDebugInformation {
        return QueryDebugInformation.fromJS(data);
     }

    static fromJS(data: any): QueryDebugInformation {
        data = typeof data === 'object' ? data : {};
        let result = new QueryDebugInformation();
        result.init(data);
        return result;
    }

}

export interface IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;
}

/** Business process */
export class BusinessProcess extends DTOBase {
    /** ID of the business process. */
    id!: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId!: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation!: boolean;
    /** Scope of the business process. */
    businessProcessScope!: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle!: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate!: Date;
    /** When the business process finished. */
    endDate!: Date;
    /** Is the business process finished. */
    finished!: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: BusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;

    protected _kind: string;

    constructor(data?: IBusinessProcess) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "processDefinitionId", false);
        this.setProp("object", "string", "referenceId", false);
        this.setProp("object", "string", "referenceDocType", false);
        this.setProp("object", "boolean", "supportsCancellation", false);
        this.setProp("object", "BusinessProcessScope", "businessProcessScope", false);
        this.setProp("object", "BusinessProcessLifeCycle", "lifeCycle", false);
        this.setProp("object", "Date", "startDate", false);
        this.setProp("object", "Date", "endDate", false);
        this.setProp("object", "boolean", "finished", false);
        this.setProp("array", "BusinessProcessState[]", "stateHistory", true, (item: any) => BusinessProcessState.fromJS(item));
        this.setProp("object", "string", "currentState", false);
        this.setProp("object", "Date", "lastReportedProgress", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "BusinessProcess";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcess {
        return BusinessProcess.fromJS(data);
     }

    static fromJS(data: any): BusinessProcess {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessDetails") {
            let result = new BusinessProcessDetails();
            result.init(data);
            return result;
        }
        let result = new BusinessProcess();
        result.init(data);
        return result;
    }

}

/** Business process */
export interface IBusinessProcess {
    /** ID of the business process. */
    id: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation: boolean;
    /** Scope of the business process. */
    businessProcessScope: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate: Date;
    /** When the business process finished. */
    endDate: Date;
    /** Is the business process finished. */
    finished: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: IBusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;
}

/** Scope of the business process */
export enum BusinessProcessScope {
    System = "System",
    User = "User",
}

/** Life cycle of the business process */
export enum BusinessProcessLifeCycle {
    Draft = "Draft",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    Cancelled = "Cancelled",
    CancellationInProgress = "CancellationInProgress",
    Failed = "Failed",
    SucceededWithErrors = "SucceededWithErrors",
}

/** State transition information of a business process */
export class BusinessProcessState extends DTOBase {
    /** State of the business process */
    state!: string;
    /** Date and time of when the state transition was performed. */
    timestamp!: Date;
    /** Eventual error associated to the state transition. */
    error?: ErrorResponse | undefined;

    constructor(data?: IBusinessProcessState) {
        super(data);
        this.setProp("object", "string", "state", false);
        this.setProp("object", "Date", "timestamp", false);
        this.setProp("object", "ErrorResponse", "error", true, (item: any) => ErrorResponse.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessState {
        return BusinessProcessState.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessState {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessState();
        result.init(data);
        return result;
    }

}

/** State transition information of a business process */
export interface IBusinessProcessState {
    /** State of the business process */
    state: string;
    /** Date and time of when the state transition was performed. */
    timestamp: Date;
    /** Eventual error associated to the state transition. */
    error?: IErrorResponse | undefined;
}

/** Error information with serialized exception */
export class ErrorResponse extends DTOBase {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;

    constructor(data?: IErrorResponse) {
        super(data);
        this.setProp("object", "string", "exception", false);
        this.setProp("object", "string", "traceId", false);
        this.setProp("object", "string", "traceJobId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ErrorResponse {
        return ErrorResponse.fromJS(data);
     }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

}

/** Error information with serialized exception */
export interface IErrorResponse {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;
}

export class Exception extends DTOBase {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        super(data);
        this.setProp("object", "string", "message", false);
        this.setProp("object", "Exception", "innerException", true, (item: any) => Exception.fromJS(item));
        this.setProp("object", "string", "stackTrace", false);
        this.setProp("object", "string", "source", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Exception {
        return Exception.fromJS(data);
     }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

}

export interface IException {
    message?: string | undefined;
    innerException?: IException | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel!: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode!: number;
    exceptionMessage?: string | undefined;

    protected _kind: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this.setProp("object", "TraceLevel", "traceLevel", false);
        this.setProp("object", "string", "traceId", false);
        this.setProp("object", "string", "traceJobId", false);
        this.setProp("object", "number", "httpStatusCode", false);
        this.setProp("object", "string", "exceptionMessage", false);

        this._kind = "PictureparkException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkException {
        return PictureparkException.fromJS(data);
     }

    static fromJS(data: any): PictureparkException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnauthorizedException") {
            let result = new UnauthorizedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ElasticVersionUpdateException") {
            let result = new ElasticVersionUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidVersionException") {
            let result = new InvalidVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotDeactivatedException") {
            let result = new EnvironmentNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotFoundException") {
            let result = new EnvironmentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentDeactivationException") {
            let result = new EnvironmentDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatResizingNotSupportedException") {
            let result = new OutputFormatResizingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RetryException") {
            let result = new RetryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerViolationException") {
            let result = new CustomerViolationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasNotFoundException") {
            let result = new CustomerAliasNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotDeactivatedException") {
            let result = new CustomerNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerDeactivationException") {
            let result = new CustomerDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotActiveException") {
            let result = new CustomerNotActiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConfigurationIndexNotFoundException") {
            let result = new ConfigurationIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAliasException") {
            let result = new DuplicateAliasException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RedisDatabaseExceededException") {
            let result = new RedisDatabaseExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumTransferSizeException") {
            let result = new MaximumTransferSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeMissingException") {
            let result = new RelationTypeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferenceUpdateException") {
            let result = new ReferenceUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferencesUpdateException") {
            let result = new ReferencesUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentBackupFailedException") {
            let result = new ContentBackupFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotSkippedException") {
            let result = new SnapshotSkippedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotAvailableException") {
            let result = new EnvironmentNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotAvailableException") {
            let result = new CustomerNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidExecutionScopeException") {
            let result = new BusinessRuleActionInvalidExecutionScopeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleLayerIdInvalidException") {
            let result = new BusinessRuleLayerIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkException extends IException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;
    exceptionMessage?: string | undefined;
}

export enum TraceLevel {
    Critical = "Critical",
    Error = "Error",
    Warning = "Warning",
    Information = "Information",
    Verbose = "Verbose",
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this.setProp("object", "string", "customerId", false);
        this.setProp("object", "string", "customerAlias", false);
        this.setProp("object", "string", "userId", false);

        this._kind = "PictureparkBusinessException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkBusinessException {
        return PictureparkBusinessException.fromJS(data);
     }

    static fromJS(data: any): PictureparkBusinessException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnauthorizedException") {
            let result = new UnauthorizedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatResizingNotSupportedException") {
            let result = new OutputFormatResizingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RetryException") {
            let result = new RetryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeMissingException") {
            let result = new RelationTypeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferenceUpdateException") {
            let result = new ReferenceUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferencesUpdateException") {
            let result = new ReferencesUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentBackupFailedException") {
            let result = new ContentBackupFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotSkippedException") {
            let result = new SnapshotSkippedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidExecutionScopeException") {
            let result = new BusinessRuleActionInvalidExecutionScopeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleLayerIdInvalidException") {
            let result = new BusinessRuleLayerIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export class PictureparkValidationException extends PictureparkBusinessException implements IPictureparkValidationException {

    constructor(data?: IPictureparkValidationException) {
        super(data);

        this._kind = "PictureparkValidationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkValidationException {
        return PictureparkValidationException.fromJS(data);
     }

    static fromJS(data: any): PictureparkValidationException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatResizingNotSupportedException") {
            let result = new OutputFormatResizingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidExecutionScopeException") {
            let result = new BusinessRuleActionInvalidExecutionScopeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleLayerIdInvalidException") {
            let result = new BusinessRuleLayerIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        let result = new PictureparkValidationException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkValidationException extends IPictureparkBusinessException {
}

export class PictureparkConflictException extends PictureparkBusinessException implements IPictureparkConflictException {
    reference?: string | undefined;

    constructor(data?: IPictureparkConflictException) {
        super(data);
        this.setProp("object", "string", "reference", false);

        this._kind = "PictureparkConflictException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkConflictException {
        return PictureparkConflictException.fromJS(data);
     }

    static fromJS(data: any): PictureparkConflictException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        let result = new PictureparkConflictException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkConflictException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class PictureparkTimeoutException extends PictureparkValidationException implements IPictureparkTimeoutException {

    constructor(data?: IPictureparkTimeoutException) {
        super(data);

        this._kind = "PictureparkTimeoutException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkTimeoutException {
        return PictureparkTimeoutException.fromJS(data);
     }

    static fromJS(data: any): PictureparkTimeoutException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkTimeoutException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkTimeoutException extends IPictureparkValidationException {
}

export class PictureparkForbiddenException extends PictureparkBusinessException implements IPictureparkForbiddenException {

    constructor(data?: IPictureparkForbiddenException) {
        super(data);

        this._kind = "PictureparkForbiddenException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkForbiddenException {
        return PictureparkForbiddenException.fromJS(data);
     }

    static fromJS(data: any): PictureparkForbiddenException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        let result = new PictureparkForbiddenException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkForbiddenException extends IPictureparkBusinessException {
}

export class UserEmailAlreadyExistsException extends PictureparkValidationException implements IUserEmailAlreadyExistsException {
    email?: string | undefined;

    constructor(data?: IUserEmailAlreadyExistsException) {
        super(data);
        this.setProp("object", "string", "email", false);

        this._kind = "UserEmailAlreadyExistsException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserEmailAlreadyExistsException {
        return UserEmailAlreadyExistsException.fromJS(data);
     }

    static fromJS(data: any): UserEmailAlreadyExistsException {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailAlreadyExistsException();
        result.init(data);
        return result;
    }

}

export interface IUserEmailAlreadyExistsException extends IPictureparkValidationException {
    email?: string | undefined;
}

export class UserRoleAssignedException extends PictureparkValidationException implements IUserRoleAssignedException {
    userRoleId?: string | undefined;

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);

        this._kind = "UserRoleAssignedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleAssignedException {
        return UserRoleAssignedException.fromJS(data);
     }

    static fromJS(data: any): UserRoleAssignedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

}

export interface IUserRoleAssignedException extends IPictureparkValidationException {
    userRoleId?: string | undefined;
}

export class UserNotFoundException extends PictureparkBusinessException implements IUserNotFoundException {
    missingUserId?: string | undefined;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this.setProp("object", "string", "missingUserId", false);

        this._kind = "UserNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserNotFoundException {
        return UserNotFoundException.fromJS(data);
     }

    static fromJS(data: any): UserNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IUserNotFoundException extends IPictureparkBusinessException {
    missingUserId?: string | undefined;
}

export class UserInactiveOrDeletedException extends PictureparkForbiddenException implements IUserInactiveOrDeletedException {

    constructor(data?: IUserInactiveOrDeletedException) {
        super(data);

        this._kind = "UserInactiveOrDeletedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserInactiveOrDeletedException {
        return UserInactiveOrDeletedException.fromJS(data);
     }

    static fromJS(data: any): UserInactiveOrDeletedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserInactiveOrDeletedException();
        result.init(data);
        return result;
    }

}

export interface IUserInactiveOrDeletedException extends IPictureparkForbiddenException {
}

export class TermsOfServiceNotNewestException extends PictureparkBusinessException implements ITermsOfServiceNotNewestException {

    constructor(data?: ITermsOfServiceNotNewestException) {
        super(data);

        this._kind = "TermsOfServiceNotNewestException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermsOfServiceNotNewestException {
        return TermsOfServiceNotNewestException.fromJS(data);
     }

    static fromJS(data: any): TermsOfServiceNotNewestException {
        data = typeof data === 'object' ? data : {};
        let result = new TermsOfServiceNotNewestException();
        result.init(data);
        return result;
    }

}

export interface ITermsOfServiceNotNewestException extends IPictureparkBusinessException {
}

export class IllegalAuthorizationStateTransitionException extends PictureparkValidationException implements IIllegalAuthorizationStateTransitionException {

    constructor(data?: IIllegalAuthorizationStateTransitionException) {
        super(data);

        this._kind = "IllegalAuthorizationStateTransitionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IllegalAuthorizationStateTransitionException {
        return IllegalAuthorizationStateTransitionException.fromJS(data);
     }

    static fromJS(data: any): IllegalAuthorizationStateTransitionException {
        data = typeof data === 'object' ? data : {};
        let result = new IllegalAuthorizationStateTransitionException();
        result.init(data);
        return result;
    }

}

export interface IIllegalAuthorizationStateTransitionException extends IPictureparkValidationException {
}

export class TermsOfServiceConsentRequiredException extends PictureparkForbiddenException implements ITermsOfServiceConsentRequiredException {

    constructor(data?: ITermsOfServiceConsentRequiredException) {
        super(data);

        this._kind = "TermsOfServiceConsentRequiredException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermsOfServiceConsentRequiredException {
        return TermsOfServiceConsentRequiredException.fromJS(data);
     }

    static fromJS(data: any): TermsOfServiceConsentRequiredException {
        data = typeof data === 'object' ? data : {};
        let result = new TermsOfServiceConsentRequiredException();
        result.init(data);
        return result;
    }

}

export interface ITermsOfServiceConsentRequiredException extends IPictureparkForbiddenException {
}

export class PictureparkNotFoundException extends PictureparkBusinessException implements IPictureparkNotFoundException {
    reference?: string | undefined;

    constructor(data?: IPictureparkNotFoundException) {
        super(data);
        this.setProp("object", "string", "reference", false);

        this._kind = "PictureparkNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkNotFoundException {
        return PictureparkNotFoundException.fromJS(data);
     }

    static fromJS(data: any): PictureparkNotFoundException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        let result = new PictureparkNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkNotFoundException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class UserRolesNotFoundException extends PictureparkNotFoundException implements IUserRolesNotFoundException {
    userRoleIds?: string[] | undefined;

    constructor(data?: IUserRolesNotFoundException) {
        super(data);
        this.setProp("array", "string[]", "userRoleIds", false);

        this._kind = "UserRolesNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRolesNotFoundException {
        return UserRolesNotFoundException.fromJS(data);
     }

    static fromJS(data: any): UserRolesNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolesNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IUserRolesNotFoundException extends IPictureparkNotFoundException {
    userRoleIds?: string[] | undefined;
}

export class UnauthorizedException extends PictureparkBusinessException implements IUnauthorizedException {

    constructor(data?: IUnauthorizedException) {
        super(data);

        this._kind = "UnauthorizedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UnauthorizedException {
        return UnauthorizedException.fromJS(data);
     }

    static fromJS(data: any): UnauthorizedException {
        data = typeof data === 'object' ? data : {};
        let result = new UnauthorizedException();
        result.init(data);
        return result;
    }

}

export interface IUnauthorizedException extends IPictureparkBusinessException {
}

export class UserUnlockDisallowedException extends PictureparkValidationException implements IUserUnlockDisallowedException {

    constructor(data?: IUserUnlockDisallowedException) {
        super(data);

        this._kind = "UserUnlockDisallowedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserUnlockDisallowedException {
        return UserUnlockDisallowedException.fromJS(data);
     }

    static fromJS(data: any): UserUnlockDisallowedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserUnlockDisallowedException();
        result.init(data);
        return result;
    }

}

export interface IUserUnlockDisallowedException extends IPictureparkValidationException {
}

export class RenderingException extends PictureparkBusinessException implements IRenderingException {

    constructor(data?: IRenderingException) {
        super(data);

        this._kind = "RenderingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RenderingException {
        return RenderingException.fromJS(data);
     }

    static fromJS(data: any): RenderingException {
        data = typeof data === 'object' ? data : {};
        let result = new RenderingException();
        result.init(data);
        return result;
    }

}

export interface IRenderingException extends IPictureparkBusinessException {
}

export class ServiceProviderDeleteException extends PictureparkException implements IServiceProviderDeleteException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderDeleteException) {
        super(data);
        this.setProp("object", "string", "serviceProviderId", false);
        this.setProp("object", "string", "detailedErrorMessage", false);

        this._kind = "ServiceProviderDeleteException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ServiceProviderDeleteException {
        return ServiceProviderDeleteException.fromJS(data);
     }

    static fromJS(data: any): ServiceProviderDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderDeleteException();
        result.init(data);
        return result;
    }

}

export interface IServiceProviderDeleteException extends IPictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export class ServiceProviderCreateException extends PictureparkException implements IServiceProviderCreateException {
    externalId?: string | undefined;
    detailErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderCreateException) {
        super(data);
        this.setProp("object", "string", "externalId", false);
        this.setProp("object", "string", "detailErrorMessage", false);

        this._kind = "ServiceProviderCreateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ServiceProviderCreateException {
        return ServiceProviderCreateException.fromJS(data);
     }

    static fromJS(data: any): ServiceProviderCreateException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderCreateException();
        result.init(data);
        return result;
    }

}

export interface IServiceProviderCreateException extends IPictureparkException {
    externalId?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export class ServiceProviderNotFoundException extends PictureparkException implements IServiceProviderNotFoundException {
    missingServiceProviderId?: string | undefined;

    constructor(data?: IServiceProviderNotFoundException) {
        super(data);
        this.setProp("object", "string", "missingServiceProviderId", false);

        this._kind = "ServiceProviderNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ServiceProviderNotFoundException {
        return ServiceProviderNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ServiceProviderNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IServiceProviderNotFoundException extends IPictureparkException {
    missingServiceProviderId?: string | undefined;
}

export class DocumentVersionNotFoundException extends PictureparkNotFoundException implements IDocumentVersionNotFoundException {
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentVersion?: string | undefined;

    constructor(data?: IDocumentVersionNotFoundException) {
        super(data);
        this.setProp("object", "string", "documentType", false);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "string", "documentVersion", false);

        this._kind = "DocumentVersionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentVersionNotFoundException {
        return DocumentVersionNotFoundException.fromJS(data);
     }

    static fromJS(data: any): DocumentVersionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersionNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IDocumentVersionNotFoundException extends IPictureparkNotFoundException {
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export class DefaultChannelDeleteException extends PictureparkValidationException implements IDefaultChannelDeleteException {

    constructor(data?: IDefaultChannelDeleteException) {
        super(data);

        this._kind = "DefaultChannelDeleteException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DefaultChannelDeleteException {
        return DefaultChannelDeleteException.fromJS(data);
     }

    static fromJS(data: any): DefaultChannelDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultChannelDeleteException();
        result.init(data);
        return result;
    }

}

export interface IDefaultChannelDeleteException extends IPictureparkValidationException {
}

export class ChannelsNotFoundException extends PictureparkNotFoundException implements IChannelsNotFoundException {

    constructor(data?: IChannelsNotFoundException) {
        super(data);

        this._kind = "ChannelsNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ChannelsNotFoundException {
        return ChannelsNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ChannelsNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelsNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IChannelsNotFoundException extends IPictureparkNotFoundException {
}

export class SuperAdminRolesNotAssignableToChannelException extends PictureparkValidationException implements ISuperAdminRolesNotAssignableToChannelException {

    constructor(data?: ISuperAdminRolesNotAssignableToChannelException) {
        super(data);

        this._kind = "SuperAdminRolesNotAssignableToChannelException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SuperAdminRolesNotAssignableToChannelException {
        return SuperAdminRolesNotAssignableToChannelException.fromJS(data);
     }

    static fromJS(data: any): SuperAdminRolesNotAssignableToChannelException {
        data = typeof data === 'object' ? data : {};
        let result = new SuperAdminRolesNotAssignableToChannelException();
        result.init(data);
        return result;
    }

}

export interface ISuperAdminRolesNotAssignableToChannelException extends IPictureparkValidationException {
}

export class ElasticVersionUpdateException extends PictureparkException implements IElasticVersionUpdateException {
    expectedVersion?: string | undefined;
    actualVersion?: string | undefined;

    constructor(data?: IElasticVersionUpdateException) {
        super(data);
        this.setProp("object", "string", "expectedVersion", false);
        this.setProp("object", "string", "actualVersion", false);

        this._kind = "ElasticVersionUpdateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ElasticVersionUpdateException {
        return ElasticVersionUpdateException.fromJS(data);
     }

    static fromJS(data: any): ElasticVersionUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ElasticVersionUpdateException();
        result.init(data);
        return result;
    }

}

export interface IElasticVersionUpdateException extends IPictureparkException {
    expectedVersion?: string | undefined;
    actualVersion?: string | undefined;
}

export class InvalidVersionException extends PictureparkException implements IInvalidVersionException {
    component?: string | undefined;
    version?: string | undefined;
    expectedVersion?: string | undefined;

    constructor(data?: IInvalidVersionException) {
        super(data);
        this.setProp("object", "string", "component", false);
        this.setProp("object", "string", "version", false);
        this.setProp("object", "string", "expectedVersion", false);

        this._kind = "InvalidVersionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidVersionException {
        return InvalidVersionException.fromJS(data);
     }

    static fromJS(data: any): InvalidVersionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidVersionException();
        result.init(data);
        return result;
    }

}

export interface IInvalidVersionException extends IPictureparkException {
    component?: string | undefined;
    version?: string | undefined;
    expectedVersion?: string | undefined;
}

export class EnvironmentNotDeactivatedException extends PictureparkException implements IEnvironmentNotDeactivatedException {

    constructor(data?: IEnvironmentNotDeactivatedException) {
        super(data);

        this._kind = "EnvironmentNotDeactivatedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentNotDeactivatedException {
        return EnvironmentNotDeactivatedException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotDeactivatedException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentNotDeactivatedException extends IPictureparkException {
}

export class EnvironmentNotFoundException extends PictureparkException implements IEnvironmentNotFoundException {

    constructor(data?: IEnvironmentNotFoundException) {
        super(data);

        this._kind = "EnvironmentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentNotFoundException {
        return EnvironmentNotFoundException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentNotFoundException extends IPictureparkException {
}

export class EnvironmentDeactivationException extends PictureparkException implements IEnvironmentDeactivationException {
    deactivationMessage?: string | undefined;

    constructor(data?: IEnvironmentDeactivationException) {
        super(data);
        this.setProp("object", "string", "deactivationMessage", false);

        this._kind = "EnvironmentDeactivationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentDeactivationException {
        return EnvironmentDeactivationException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentDeactivationException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentDeactivationException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentDeactivationException extends IPictureparkException {
    deactivationMessage?: string | undefined;
}

export class ShareNotFoundException extends PictureparkNotFoundException implements IShareNotFoundException {
    shareId?: string | undefined;

    constructor(data?: IShareNotFoundException) {
        super(data);
        this.setProp("object", "string", "shareId", false);

        this._kind = "ShareNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareNotFoundException {
        return ShareNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ShareNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IShareNotFoundException extends IPictureparkNotFoundException {
    shareId?: string | undefined;
}

export class ShareByTokenNotFoundException extends PictureparkNotFoundException implements IShareByTokenNotFoundException {
    token?: string | undefined;

    constructor(data?: IShareByTokenNotFoundException) {
        super(data);
        this.setProp("object", "string", "token", false);

        this._kind = "ShareByTokenNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareByTokenNotFoundException {
        return ShareByTokenNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ShareByTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareByTokenNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IShareByTokenNotFoundException extends IPictureparkNotFoundException {
    token?: string | undefined;
}

export class TokenGenerationException extends PictureparkBusinessException implements ITokenGenerationException {
    retries!: number;

    constructor(data?: ITokenGenerationException) {
        super(data);
        this.setProp("object", "number", "retries", false);

        this._kind = "TokenGenerationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TokenGenerationException {
        return TokenGenerationException.fromJS(data);
     }

    static fromJS(data: any): TokenGenerationException {
        data = typeof data === 'object' ? data : {};
        let result = new TokenGenerationException();
        result.init(data);
        return result;
    }

}

export interface ITokenGenerationException extends IPictureparkBusinessException {
    retries: number;
}

export class ShareExpiredException extends PictureparkBusinessException implements IShareExpiredException {
    token?: string | undefined;

    constructor(data?: IShareExpiredException) {
        super(data);
        this.setProp("object", "string", "token", false);

        this._kind = "ShareExpiredException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareExpiredException {
        return ShareExpiredException.fromJS(data);
     }

    static fromJS(data: any): ShareExpiredException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareExpiredException();
        result.init(data);
        return result;
    }

}

export interface IShareExpiredException extends IPictureparkBusinessException {
    token?: string | undefined;
}

export class OutputIdNotFoundException extends PictureparkNotFoundException implements IOutputIdNotFoundException {
    outputId?: string | undefined;

    constructor(data?: IOutputIdNotFoundException) {
        super(data);
        this.setProp("object", "string", "outputId", false);

        this._kind = "OutputIdNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputIdNotFoundException {
        return OutputIdNotFoundException.fromJS(data);
     }

    static fromJS(data: any): OutputIdNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputIdNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IOutputIdNotFoundException extends IPictureparkNotFoundException {
    outputId?: string | undefined;
}

export class OutputNotFoundException extends PictureparkBusinessException implements IOutputNotFoundException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputNotFoundException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);

        this._kind = "OutputNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputNotFoundException {
        return OutputNotFoundException.fromJS(data);
     }

    static fromJS(data: any): OutputNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IOutputNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class UnableToCreateOrModifyStaticOutputFormatException extends PictureparkValidationException implements IUnableToCreateOrModifyStaticOutputFormatException {

    constructor(data?: IUnableToCreateOrModifyStaticOutputFormatException) {
        super(data);

        this._kind = "UnableToCreateOrModifyStaticOutputFormatException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UnableToCreateOrModifyStaticOutputFormatException {
        return UnableToCreateOrModifyStaticOutputFormatException.fromJS(data);
     }

    static fromJS(data: any): UnableToCreateOrModifyStaticOutputFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToCreateOrModifyStaticOutputFormatException();
        result.init(data);
        return result;
    }

}

export interface IUnableToCreateOrModifyStaticOutputFormatException extends IPictureparkValidationException {
}

export class NotSupportedFileMappingException extends PictureparkValidationException implements INotSupportedFileMappingException {

    constructor(data?: INotSupportedFileMappingException) {
        super(data);

        this._kind = "NotSupportedFileMappingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NotSupportedFileMappingException {
        return NotSupportedFileMappingException.fromJS(data);
     }

    static fromJS(data: any): NotSupportedFileMappingException {
        data = typeof data === 'object' ? data : {};
        let result = new NotSupportedFileMappingException();
        result.init(data);
        return result;
    }

}

export interface INotSupportedFileMappingException extends IPictureparkValidationException {
}

export class NotSupportedFileExtensionException extends PictureparkValidationException implements INotSupportedFileExtensionException {

    constructor(data?: INotSupportedFileExtensionException) {
        super(data);

        this._kind = "NotSupportedFileExtensionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NotSupportedFileExtensionException {
        return NotSupportedFileExtensionException.fromJS(data);
     }

    static fromJS(data: any): NotSupportedFileExtensionException {
        data = typeof data === 'object' ? data : {};
        let result = new NotSupportedFileExtensionException();
        result.init(data);
        return result;
    }

}

export interface INotSupportedFileExtensionException extends IPictureparkValidationException {
}

export class DuplicateOutputFormatIdException extends PictureparkValidationException implements IDuplicateOutputFormatIdException {

    constructor(data?: IDuplicateOutputFormatIdException) {
        super(data);

        this._kind = "DuplicateOutputFormatIdException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateOutputFormatIdException {
        return DuplicateOutputFormatIdException.fromJS(data);
     }

    static fromJS(data: any): DuplicateOutputFormatIdException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateOutputFormatIdException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateOutputFormatIdException extends IPictureparkValidationException {
}

export class OutputFormatResizingNotSupportedException extends PictureparkValidationException implements IOutputFormatResizingNotSupportedException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputFormatResizingNotSupportedException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);

        this._kind = "OutputFormatResizingNotSupportedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatResizingNotSupportedException {
        return OutputFormatResizingNotSupportedException.fromJS(data);
     }

    static fromJS(data: any): OutputFormatResizingNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatResizingNotSupportedException();
        result.init(data);
        return result;
    }

}

export interface IOutputFormatResizingNotSupportedException extends IPictureparkValidationException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class LeaseNotAcquiredException extends PictureparkBusinessException implements ILeaseNotAcquiredException {
    resourceId?: string | undefined;

    constructor(data?: ILeaseNotAcquiredException) {
        super(data);
        this.setProp("object", "string", "resourceId", false);

        this._kind = "LeaseNotAcquiredException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LeaseNotAcquiredException {
        return LeaseNotAcquiredException.fromJS(data);
     }

    static fromJS(data: any): LeaseNotAcquiredException {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseNotAcquiredException();
        result.init(data);
        return result;
    }

}

export interface ILeaseNotAcquiredException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class OperationInProgressException extends PictureparkBusinessException implements IOperationInProgressException {
    leaseResourceType!: LeaseResourceType;

    constructor(data?: IOperationInProgressException) {
        super(data);
        this.setProp("object", "LeaseResourceType", "leaseResourceType", false);

        this._kind = "OperationInProgressException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OperationInProgressException {
        return OperationInProgressException.fromJS(data);
     }

    static fromJS(data: any): OperationInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new OperationInProgressException();
        result.init(data);
        return result;
    }

}

export interface IOperationInProgressException extends IPictureparkBusinessException {
    leaseResourceType: LeaseResourceType;
}

export enum LeaseResourceType {
    SchemaEditing = "SchemaEditing",
}

export class RetryException extends PictureparkBusinessException implements IRetryException {
    retries!: number;
    innerExceptionDetail?: string | undefined;

    constructor(data?: IRetryException) {
        super(data);
        this.setProp("object", "number", "retries", false);
        this.setProp("object", "string", "innerExceptionDetail", false);

        this._kind = "RetryException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RetryException {
        return RetryException.fromJS(data);
     }

    static fromJS(data: any): RetryException {
        data = typeof data === 'object' ? data : {};
        let result = new RetryException();
        result.init(data);
        return result;
    }

}

export interface IRetryException extends IPictureparkBusinessException {
    retries: number;
    innerExceptionDetail?: string | undefined;
}

export class OwnerTokenNotFoundException extends PictureparkNotFoundException implements IOwnerTokenNotFoundException {
    ownerTokenUserIds?: string[] | undefined;

    constructor(data?: IOwnerTokenNotFoundException) {
        super(data);
        this.setProp("array", "string[]", "ownerTokenUserIds", false);

        this._kind = "OwnerTokenNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OwnerTokenNotFoundException {
        return OwnerTokenNotFoundException.fromJS(data);
     }

    static fromJS(data: any): OwnerTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTokenNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IOwnerTokenNotFoundException extends IPictureparkNotFoundException {
    ownerTokenUserIds?: string[] | undefined;
}

export class InvalidStateException extends PictureparkValidationException implements IInvalidStateException {
    resourceId?: string | undefined;
    state?: string | undefined;

    constructor(data?: IInvalidStateException) {
        super(data);
        this.setProp("object", "string", "resourceId", false);
        this.setProp("object", "string", "state", false);

        this._kind = "InvalidStateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidStateException {
        return InvalidStateException.fromJS(data);
     }

    static fromJS(data: any): InvalidStateException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        let result = new InvalidStateException();
        result.init(data);
        return result;
    }

}

export interface IInvalidStateException extends IPictureparkValidationException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export class PictureparkArgumentNullException extends PictureparkValidationException implements IPictureparkArgumentNullException {
    argumentName?: string | undefined;

    constructor(data?: IPictureparkArgumentNullException) {
        super(data);
        this.setProp("object", "string", "argumentName", false);

        this._kind = "PictureparkArgumentNullException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkArgumentNullException {
        return PictureparkArgumentNullException.fromJS(data);
     }

    static fromJS(data: any): PictureparkArgumentNullException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkArgumentNullException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkArgumentNullException extends IPictureparkValidationException {
    argumentName?: string | undefined;
}

export class ObjectTypeMismatchException extends PictureparkBusinessException implements IObjectTypeMismatchException {
    type?: string | undefined;

    constructor(data?: IObjectTypeMismatchException) {
        super(data);
        this.setProp("object", "string", "type", false);

        this._kind = "ObjectTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ObjectTypeMismatchException {
        return ObjectTypeMismatchException.fromJS(data);
     }

    static fromJS(data: any): ObjectTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectTypeMismatchException();
        result.init(data);
        return result;
    }

}

export interface IObjectTypeMismatchException extends IPictureparkBusinessException {
    type?: string | undefined;
}

export class InvalidStateTransitionException extends InvalidStateException implements IInvalidStateTransitionException {
    transition?: string | undefined;

    constructor(data?: IInvalidStateTransitionException) {
        super(data);
        this.setProp("object", "string", "transition", false);

        this._kind = "InvalidStateTransitionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidStateTransitionException {
        return InvalidStateTransitionException.fromJS(data);
     }

    static fromJS(data: any): InvalidStateTransitionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidStateTransitionException();
        result.init(data);
        return result;
    }

}

export interface IInvalidStateTransitionException extends IInvalidStateException {
    transition?: string | undefined;
}

export class FailedToLockException extends PictureparkBusinessException implements IFailedToLockException {
    resourceId?: string | undefined;

    constructor(data?: IFailedToLockException) {
        super(data);
        this.setProp("object", "string", "resourceId", false);

        this._kind = "FailedToLockException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FailedToLockException {
        return FailedToLockException.fromJS(data);
     }

    static fromJS(data: any): FailedToLockException {
        data = typeof data === 'object' ? data : {};
        let result = new FailedToLockException();
        result.init(data);
        return result;
    }

}

export interface IFailedToLockException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class PictureparkOperationCanceledException extends PictureparkBusinessException implements IPictureparkOperationCanceledException {

    constructor(data?: IPictureparkOperationCanceledException) {
        super(data);

        this._kind = "PictureparkOperationCanceledException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkOperationCanceledException {
        return PictureparkOperationCanceledException.fromJS(data);
     }

    static fromJS(data: any): PictureparkOperationCanceledException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkOperationCanceledException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkOperationCanceledException extends IPictureparkBusinessException {
}

export class PictureparkApplicationException extends PictureparkBusinessException implements IPictureparkApplicationException {

    constructor(data?: IPictureparkApplicationException) {
        super(data);

        this._kind = "PictureparkApplicationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PictureparkApplicationException {
        return PictureparkApplicationException.fromJS(data);
     }

    static fromJS(data: any): PictureparkApplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkApplicationException();
        result.init(data);
        return result;
    }

}

export interface IPictureparkApplicationException extends IPictureparkBusinessException {
}

export class MissingCustomerDefaultLanguageException extends PictureparkValidationException implements IMissingCustomerDefaultLanguageException {
    customerDefaultLanguage?: string | undefined;

    constructor(data?: IMissingCustomerDefaultLanguageException) {
        super(data);
        this.setProp("object", "string", "customerDefaultLanguage", false);

        this._kind = "MissingCustomerDefaultLanguageException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MissingCustomerDefaultLanguageException {
        return MissingCustomerDefaultLanguageException.fromJS(data);
     }

    static fromJS(data: any): MissingCustomerDefaultLanguageException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingCustomerDefaultLanguageException();
        result.init(data);
        return result;
    }

}

export interface IMissingCustomerDefaultLanguageException extends IPictureparkValidationException {
    customerDefaultLanguage?: string | undefined;
}

export class PartialOperationNotSupportedException extends PictureparkValidationException implements IPartialOperationNotSupportedException {

    constructor(data?: IPartialOperationNotSupportedException) {
        super(data);

        this._kind = "PartialOperationNotSupportedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PartialOperationNotSupportedException {
        return PartialOperationNotSupportedException.fromJS(data);
     }

    static fromJS(data: any): PartialOperationNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new PartialOperationNotSupportedException();
        result.init(data);
        return result;
    }

}

export interface IPartialOperationNotSupportedException extends IPictureparkValidationException {
}

export class ContractMismatchException extends PictureparkValidationException implements IContractMismatchException {

    constructor(data?: IContractMismatchException) {
        super(data);

        this._kind = "ContractMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContractMismatchException {
        return ContractMismatchException.fromJS(data);
     }

    static fromJS(data: any): ContractMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ContractMismatchException();
        result.init(data);
        return result;
    }

}

export interface IContractMismatchException extends IPictureparkValidationException {
}

export class InvalidArgumentException extends PictureparkValidationException implements IInvalidArgumentException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;

    constructor(data?: IInvalidArgumentException) {
        super(data);
        this.setProp("object", "string", "argumentName", false);
        this.setProp("object", "string", "argumentValue", false);

        this._kind = "InvalidArgumentException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidArgumentException {
        return InvalidArgumentException.fromJS(data);
     }

    static fromJS(data: any): InvalidArgumentException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidArgumentException();
        result.init(data);
        return result;
    }

}

export interface IInvalidArgumentException extends IPictureparkValidationException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export class UnknownException extends PictureparkBusinessException implements IUnknownException {

    constructor(data?: IUnknownException) {
        super(data);

        this._kind = "UnknownException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UnknownException {
        return UnknownException.fromJS(data);
     }

    static fromJS(data: any): UnknownException {
        data = typeof data === 'object' ? data : {};
        let result = new UnknownException();
        result.init(data);
        return result;
    }

}

export interface IUnknownException extends IPictureparkBusinessException {
}

export class OwnerTokenInUseException extends PictureparkValidationException implements IOwnerTokenInUseException {
    ownerTokenUserId?: string | undefined;

    constructor(data?: IOwnerTokenInUseException) {
        super(data);
        this.setProp("object", "string", "ownerTokenUserId", false);

        this._kind = "OwnerTokenInUseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OwnerTokenInUseException {
        return OwnerTokenInUseException.fromJS(data);
     }

    static fromJS(data: any): OwnerTokenInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTokenInUseException();
        result.init(data);
        return result;
    }

}

export interface IOwnerTokenInUseException extends IPictureparkValidationException {
    ownerTokenUserId?: string | undefined;
}

export class InvalidValueFormatException extends PictureparkValidationException implements IInvalidValueFormatException {

    constructor(data?: IInvalidValueFormatException) {
        super(data);

        this._kind = "InvalidValueFormatException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidValueFormatException {
        return InvalidValueFormatException.fromJS(data);
     }

    static fromJS(data: any): InvalidValueFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidValueFormatException();
        result.init(data);
        return result;
    }

}

export interface IInvalidValueFormatException extends IPictureparkValidationException {
}

export class ItemIdDuplicatedException extends PictureparkValidationException implements IItemIdDuplicatedException {
    id?: string | undefined;

    constructor(data?: IItemIdDuplicatedException) {
        super(data);
        this.setProp("object", "string", "id", false);

        this._kind = "ItemIdDuplicatedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ItemIdDuplicatedException {
        return ItemIdDuplicatedException.fromJS(data);
     }

    static fromJS(data: any): ItemIdDuplicatedException {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdDuplicatedException();
        result.init(data);
        return result;
    }

}

export interface IItemIdDuplicatedException extends IPictureparkValidationException {
    id?: string | undefined;
}

export class CustomerViolationException extends PictureparkException implements ICustomerViolationException {
    expectedCustomerId?: string | undefined;
    currentCustomerId?: string | undefined;

    constructor(data?: ICustomerViolationException) {
        super(data);
        this.setProp("object", "string", "expectedCustomerId", false);
        this.setProp("object", "string", "currentCustomerId", false);

        this._kind = "CustomerViolationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerViolationException {
        return CustomerViolationException.fromJS(data);
     }

    static fromJS(data: any): CustomerViolationException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerViolationException();
        result.init(data);
        return result;
    }

}

export interface ICustomerViolationException extends IPictureparkException {
    expectedCustomerId?: string | undefined;
    currentCustomerId?: string | undefined;
}

export class CustomerAliasNotFoundException extends PictureparkException implements ICustomerAliasNotFoundException {
    customerAlias?: string | undefined;

    constructor(data?: ICustomerAliasNotFoundException) {
        super(data);
        this.setProp("object", "string", "customerAlias", false);

        this._kind = "CustomerAliasNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerAliasNotFoundException {
        return CustomerAliasNotFoundException.fromJS(data);
     }

    static fromJS(data: any): CustomerAliasNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ICustomerAliasNotFoundException extends IPictureparkException {
    customerAlias?: string | undefined;
}

export class CustomerAliasInUseException extends PictureparkBusinessException implements ICustomerAliasInUseException {
    existingCustomerId?: string | undefined;
    alias?: string | undefined;

    constructor(data?: ICustomerAliasInUseException) {
        super(data);
        this.setProp("object", "string", "existingCustomerId", false);
        this.setProp("object", "string", "alias", false);

        this._kind = "CustomerAliasInUseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerAliasInUseException {
        return CustomerAliasInUseException.fromJS(data);
     }

    static fromJS(data: any): CustomerAliasInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasInUseException();
        result.init(data);
        return result;
    }

}

export interface ICustomerAliasInUseException extends IPictureparkBusinessException {
    existingCustomerId?: string | undefined;
    alias?: string | undefined;
}

export class CustomerNotDeactivatedException extends PictureparkException implements ICustomerNotDeactivatedException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotDeactivatedException) {
        super(data);
        this.setProp("object", "string", "customerId", false);

        this._kind = "CustomerNotDeactivatedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerNotDeactivatedException {
        return CustomerNotDeactivatedException.fromJS(data);
     }

    static fromJS(data: any): CustomerNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotDeactivatedException();
        result.init(data);
        return result;
    }

}

export interface ICustomerNotDeactivatedException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerDeactivationException extends PictureparkException implements ICustomerDeactivationException {
    customerId?: string | undefined;
    deactivationMessage?: string | undefined;

    constructor(data?: ICustomerDeactivationException) {
        super(data);
        this.setProp("object", "string", "customerId", false);
        this.setProp("object", "string", "deactivationMessage", false);

        this._kind = "CustomerDeactivationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerDeactivationException {
        return CustomerDeactivationException.fromJS(data);
     }

    static fromJS(data: any): CustomerDeactivationException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDeactivationException();
        result.init(data);
        return result;
    }

}

export interface ICustomerDeactivationException extends IPictureparkException {
    customerId?: string | undefined;
    deactivationMessage?: string | undefined;
}

export class CustomerHostNotFoundException extends PictureparkException implements ICustomerHostNotFoundException {
    hostName?: string | undefined;

    constructor(data?: ICustomerHostNotFoundException) {
        super(data);
        this.setProp("object", "string", "hostName", false);

        this._kind = "CustomerHostNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerHostNotFoundException {
        return CustomerHostNotFoundException.fromJS(data);
     }

    static fromJS(data: any): CustomerHostNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerHostNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ICustomerHostNotFoundException extends IPictureparkException {
    hostName?: string | undefined;
}

export class CustomerNotFoundException extends PictureparkException implements ICustomerNotFoundException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotFoundException) {
        super(data);
        this.setProp("object", "string", "customerId", false);

        this._kind = "CustomerNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerNotFoundException {
        return CustomerNotFoundException.fromJS(data);
     }

    static fromJS(data: any): CustomerNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ICustomerNotFoundException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerNotActiveException extends PictureparkException implements ICustomerNotActiveException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotActiveException) {
        super(data);
        this.setProp("object", "string", "customerId", false);

        this._kind = "CustomerNotActiveException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerNotActiveException {
        return CustomerNotActiveException.fromJS(data);
     }

    static fromJS(data: any): CustomerNotActiveException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotActiveException();
        result.init(data);
        return result;
    }

}

export interface ICustomerNotActiveException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerBoostValuesInvalidException extends PictureparkValidationException implements ICustomerBoostValuesInvalidException {

    constructor(data?: ICustomerBoostValuesInvalidException) {
        super(data);

        this._kind = "CustomerBoostValuesInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerBoostValuesInvalidException {
        return CustomerBoostValuesInvalidException.fromJS(data);
     }

    static fromJS(data: any): CustomerBoostValuesInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBoostValuesInvalidException();
        result.init(data);
        return result;
    }

}

export interface ICustomerBoostValuesInvalidException extends IPictureparkValidationException {
}

export class ConfigurationIndexNotFoundException extends PictureparkException implements IConfigurationIndexNotFoundException {
    configurationIndex?: string | undefined;

    constructor(data?: IConfigurationIndexNotFoundException) {
        super(data);
        this.setProp("object", "string", "configurationIndex", false);

        this._kind = "ConfigurationIndexNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ConfigurationIndexNotFoundException {
        return ConfigurationIndexNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ConfigurationIndexNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIndexNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IConfigurationIndexNotFoundException extends IPictureparkException {
    configurationIndex?: string | undefined;
}

export class DuplicateSearchIndexDocException extends PictureparkBusinessException implements IDuplicateSearchIndexDocException {
    searchIndexDocId?: string | undefined;

    constructor(data?: IDuplicateSearchIndexDocException) {
        super(data);
        this.setProp("object", "string", "searchIndexDocId", false);

        this._kind = "DuplicateSearchIndexDocException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateSearchIndexDocException {
        return DuplicateSearchIndexDocException.fromJS(data);
     }

    static fromJS(data: any): DuplicateSearchIndexDocException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSearchIndexDocException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateSearchIndexDocException extends IPictureparkBusinessException {
    searchIndexDocId?: string | undefined;
}

export class SearchIndexDocNotFoundException extends PictureparkBusinessException implements ISearchIndexDocNotFoundException {
    searchIndexDocId?: string | undefined;

    constructor(data?: ISearchIndexDocNotFoundException) {
        super(data);
        this.setProp("object", "string", "searchIndexDocId", false);

        this._kind = "SearchIndexDocNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchIndexDocNotFoundException {
        return SearchIndexDocNotFoundException.fromJS(data);
     }

    static fromJS(data: any): SearchIndexDocNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexDocNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ISearchIndexDocNotFoundException extends IPictureparkBusinessException {
    searchIndexDocId?: string | undefined;
}

export class IndexDocumentNotFoundException extends PictureparkBusinessException implements IIndexDocumentNotFoundException {
    indexId?: string | undefined;

    constructor(data?: IIndexDocumentNotFoundException) {
        super(data);
        this.setProp("object", "string", "indexId", false);

        this._kind = "IndexDocumentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IndexDocumentNotFoundException {
        return IndexDocumentNotFoundException.fromJS(data);
     }

    static fromJS(data: any): IndexDocumentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocumentNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IIndexDocumentNotFoundException extends IPictureparkBusinessException {
    indexId?: string | undefined;
}

export class DuplicateAliasException extends PictureparkException implements IDuplicateAliasException {
    indexAlias?: string | undefined;

    constructor(data?: IDuplicateAliasException) {
        super(data);
        this.setProp("object", "string", "indexAlias", false);

        this._kind = "DuplicateAliasException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateAliasException {
        return DuplicateAliasException.fromJS(data);
     }

    static fromJS(data: any): DuplicateAliasException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateAliasException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateAliasException extends IPictureparkException {
    indexAlias?: string | undefined;
}

export class SearchIndexNotFoundException extends PictureparkBusinessException implements ISearchIndexNotFoundException {
    searchIndexId?: string | undefined;

    constructor(data?: ISearchIndexNotFoundException) {
        super(data);
        this.setProp("object", "string", "searchIndexId", false);

        this._kind = "SearchIndexNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchIndexNotFoundException {
        return SearchIndexNotFoundException.fromJS(data);
     }

    static fromJS(data: any): SearchIndexNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ISearchIndexNotFoundException extends IPictureparkBusinessException {
    searchIndexId?: string | undefined;
}

export class DefaultSearchIndexDeleteException extends PictureparkBusinessException implements IDefaultSearchIndexDeleteException {

    constructor(data?: IDefaultSearchIndexDeleteException) {
        super(data);

        this._kind = "DefaultSearchIndexDeleteException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DefaultSearchIndexDeleteException {
        return DefaultSearchIndexDeleteException.fromJS(data);
     }

    static fromJS(data: any): DefaultSearchIndexDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultSearchIndexDeleteException();
        result.init(data);
        return result;
    }

}

export interface IDefaultSearchIndexDeleteException extends IPictureparkBusinessException {
}

export class SearchIndexInUseException extends PictureparkBusinessException implements ISearchIndexInUseException {
    searchIndex?: string | undefined;

    constructor(data?: ISearchIndexInUseException) {
        super(data);
        this.setProp("object", "string", "searchIndex", false);

        this._kind = "SearchIndexInUseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchIndexInUseException {
        return SearchIndexInUseException.fromJS(data);
     }

    static fromJS(data: any): SearchIndexInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexInUseException();
        result.init(data);
        return result;
    }

}

export interface ISearchIndexInUseException extends IPictureparkBusinessException {
    searchIndex?: string | undefined;
}

export class IndexException extends PictureparkBusinessException implements IIndexException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexException) {
        super(data);
        this.setProp("object", "string", "indexName", false);
        this.setProp("object", "string", "debugInformation", false);

        this._kind = "IndexException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IndexException {
        return IndexException.fromJS(data);
     }

    static fromJS(data: any): IndexException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexException();
        result.init(data);
        return result;
    }

}

export interface IIndexException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class IndexMappingException extends PictureparkBusinessException implements IIndexMappingException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexMappingException) {
        super(data);
        this.setProp("object", "string", "indexName", false);
        this.setProp("object", "string", "debugInformation", false);

        this._kind = "IndexMappingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IndexMappingException {
        return IndexMappingException.fromJS(data);
     }

    static fromJS(data: any): IndexMappingException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexMappingException();
        result.init(data);
        return result;
    }

}

export interface IIndexMappingException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class DuplicatedSearchBehaviorException extends PictureparkValidationException implements IDuplicatedSearchBehaviorException {
    duplicatedSearchBehaviors?: string | undefined;

    constructor(data?: IDuplicatedSearchBehaviorException) {
        super(data);
        this.setProp("object", "string", "duplicatedSearchBehaviors", false);

        this._kind = "DuplicatedSearchBehaviorException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicatedSearchBehaviorException {
        return DuplicatedSearchBehaviorException.fromJS(data);
     }

    static fromJS(data: any): DuplicatedSearchBehaviorException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicatedSearchBehaviorException();
        result.init(data);
        return result;
    }

}

export interface IDuplicatedSearchBehaviorException extends IPictureparkValidationException {
    duplicatedSearchBehaviors?: string | undefined;
}

export class SearchStringLeadingWildcardException extends PictureparkValidationException implements ISearchStringLeadingWildcardException {

    constructor(data?: ISearchStringLeadingWildcardException) {
        super(data);

        this._kind = "SearchStringLeadingWildcardException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchStringLeadingWildcardException {
        return SearchStringLeadingWildcardException.fromJS(data);
     }

    static fromJS(data: any): SearchStringLeadingWildcardException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStringLeadingWildcardException();
        result.init(data);
        return result;
    }

}

export interface ISearchStringLeadingWildcardException extends IPictureparkValidationException {
}

export class DuplicateAggregatorException extends PictureparkValidationException implements IDuplicateAggregatorException {
    aggregatorName?: string | undefined;

    constructor(data?: IDuplicateAggregatorException) {
        super(data);
        this.setProp("object", "string", "aggregatorName", false);

        this._kind = "DuplicateAggregatorException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateAggregatorException {
        return DuplicateAggregatorException.fromJS(data);
     }

    static fromJS(data: any): DuplicateAggregatorException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateAggregatorException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateAggregatorException extends IPictureparkValidationException {
    aggregatorName?: string | undefined;
}

export class InvalidDateTimeFormatException extends PictureparkValidationException implements IInvalidDateTimeFormatException {
    value?: string | undefined;
    expectedFormat?: string | undefined;

    constructor(data?: IInvalidDateTimeFormatException) {
        super(data);
        this.setProp("object", "string", "value", false);
        this.setProp("object", "string", "expectedFormat", false);

        this._kind = "InvalidDateTimeFormatException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidDateTimeFormatException {
        return InvalidDateTimeFormatException.fromJS(data);
     }

    static fromJS(data: any): InvalidDateTimeFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidDateTimeFormatException();
        result.init(data);
        return result;
    }

}

export interface IInvalidDateTimeFormatException extends IPictureparkValidationException {
    value?: string | undefined;
    expectedFormat?: string | undefined;
}

export class InvalidSortFieldException extends PictureparkValidationException implements IInvalidSortFieldException {
    fieldName?: string | undefined;

    constructor(data?: IInvalidSortFieldException) {
        super(data);
        this.setProp("object", "string", "fieldName", false);

        this._kind = "InvalidSortFieldException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidSortFieldException {
        return InvalidSortFieldException.fromJS(data);
     }

    static fromJS(data: any): InvalidSortFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidSortFieldException();
        result.init(data);
        return result;
    }

}

export interface IInvalidSortFieldException extends IPictureparkValidationException {
    fieldName?: string | undefined;
}

export class DocumentVersionConflictException extends PictureparkConflictException implements IDocumentVersionConflictException {
    documentId?: string | undefined;
    documentType?: string | undefined;
    documentVersion!: number;

    constructor(data?: IDocumentVersionConflictException) {
        super(data);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "string", "documentType", false);
        this.setProp("object", "number", "documentVersion", false);

        this._kind = "DocumentVersionConflictException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentVersionConflictException {
        return DocumentVersionConflictException.fromJS(data);
     }

    static fromJS(data: any): DocumentVersionConflictException {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersionConflictException();
        result.init(data);
        return result;
    }

}

export interface IDocumentVersionConflictException extends IPictureparkConflictException {
    documentId?: string | undefined;
    documentType?: string | undefined;
    documentVersion: number;
}

export class RedisDatabaseExceededException extends PictureparkException implements IRedisDatabaseExceededException {
    customerId?: string | undefined;
    customerCount!: number;
    maxCount!: number;
    startIndex!: number;
    redisDatabaseCount!: number;

    constructor(data?: IRedisDatabaseExceededException) {
        super(data);
        this.setProp("object", "string", "customerId", false);
        this.setProp("object", "number", "customerCount", false);
        this.setProp("object", "number", "maxCount", false);
        this.setProp("object", "number", "startIndex", false);
        this.setProp("object", "number", "redisDatabaseCount", false);

        this._kind = "RedisDatabaseExceededException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RedisDatabaseExceededException {
        return RedisDatabaseExceededException.fromJS(data);
     }

    static fromJS(data: any): RedisDatabaseExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new RedisDatabaseExceededException();
        result.init(data);
        return result;
    }

}

export interface IRedisDatabaseExceededException extends IPictureparkException {
    customerId?: string | undefined;
    customerCount: number;
    maxCount: number;
    startIndex: number;
    redisDatabaseCount: number;
}

export class DuplicateDocumentException extends PictureparkValidationException implements IDuplicateDocumentException {
    documentId?: string | undefined;
    documentType?: string | undefined;

    constructor(data?: IDuplicateDocumentException) {
        super(data);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "string", "documentType", false);

        this._kind = "DuplicateDocumentException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateDocumentException {
        return DuplicateDocumentException.fromJS(data);
     }

    static fromJS(data: any): DuplicateDocumentException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateDocumentException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateDocumentException extends IPictureparkValidationException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export class ObjectStoreResponseException extends PictureparkBusinessException implements IObjectStoreResponseException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreResponseException) {
        super(data);
        this.setProp("object", "string", "rowErrorMessages", false);
        this.setProp("object", "string", "message", false);

        this._kind = "ObjectStoreResponseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ObjectStoreResponseException {
        return ObjectStoreResponseException.fromJS(data);
     }

    static fromJS(data: any): ObjectStoreResponseException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStoreResponseException();
        result.init(data);
        return result;
    }

}

export interface IObjectStoreResponseException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export class ObjectStoreException extends PictureparkBusinessException implements IObjectStoreException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IObjectStoreException) {
        super(data);
        this.setProp("object", "string", "rowErrorMessages", false);
        this.setProp("object", "string", "errorMessage", false);

        this._kind = "ObjectStoreException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ObjectStoreException {
        return ObjectStoreException.fromJS(data);
     }

    static fromJS(data: any): ObjectStoreException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStoreException();
        result.init(data);
        return result;
    }

}

export interface IObjectStoreException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
}

export class QueryException extends PictureparkBusinessException implements IQueryException {
    debugInformation?: string | undefined;
    serverError?: StorageServerError | undefined;

    constructor(data?: IQueryException) {
        super(data);
        this.setProp("object", "string", "debugInformation", false);
        this.setProp("object", "StorageServerError", "serverError", true, (item: any) => StorageServerError.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "QueryException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): QueryException {
        return QueryException.fromJS(data);
     }

    static fromJS(data: any): QueryException {
        data = typeof data === 'object' ? data : {};
        let result = new QueryException();
        result.init(data);
        return result;
    }

}

export interface IQueryException extends IPictureparkBusinessException {
    debugInformation?: string | undefined;
    serverError?: IStorageServerError | undefined;
}

export class StorageServerError extends DTOBase {
    error?: StorageError | undefined;
    status!: number;

    constructor(data?: IStorageServerError) {
        super(data);
        this.setProp("object", "StorageError", "error", true, (item: any) => StorageError.fromJS(item));
        this.setProp("object", "number", "status", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): StorageServerError {
        return StorageServerError.fromJS(data);
     }

    static fromJS(data: any): StorageServerError {
        data = typeof data === 'object' ? data : {};
        let result = new StorageServerError();
        result.init(data);
        return result;
    }

}

export interface IStorageServerError {
    error?: IStorageError | undefined;
    status: number;
}

export class StorageError extends DTOBase {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
    rootCause?: StorageRootCause[] | undefined;
    causedBy?: StorageCausedBy | undefined;

    constructor(data?: IStorageError) {
        super(data);
        this.setProp("object", "string", "index", false);
        this.setProp("object", "string", "reason", false);
        this.setProp("object", "string", "resourceId", false);
        this.setProp("object", "string", "resourceType", false);
        this.setProp("object", "string", "type", false);
        this.setProp("array", "StorageRootCause[]", "rootCause", true, (item: any) => StorageRootCause.fromJS(item));
        this.setProp("object", "StorageCausedBy", "causedBy", true, (item: any) => StorageCausedBy.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): StorageError {
        return StorageError.fromJS(data);
     }

    static fromJS(data: any): StorageError {
        data = typeof data === 'object' ? data : {};
        let result = new StorageError();
        result.init(data);
        return result;
    }

}

export interface IStorageError {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
    rootCause?: IStorageRootCause[] | undefined;
    causedBy?: IStorageCausedBy | undefined;
}

export class StorageRootCause extends DTOBase {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;

    constructor(data?: IStorageRootCause) {
        super(data);
        this.setProp("object", "string", "index", false);
        this.setProp("object", "string", "reason", false);
        this.setProp("object", "string", "resourceId", false);
        this.setProp("object", "string", "resourceType", false);
        this.setProp("object", "string", "type", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): StorageRootCause {
        return StorageRootCause.fromJS(data);
     }

    static fromJS(data: any): StorageRootCause {
        data = typeof data === 'object' ? data : {};
        let result = new StorageRootCause();
        result.init(data);
        return result;
    }

}

export interface IStorageRootCause {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
}

export class StorageCausedBy extends DTOBase {
    reason?: string | undefined;
    type?: string | undefined;
    innerCausedBy?: StorageCausedBy | undefined;

    constructor(data?: IStorageCausedBy) {
        super(data);
        this.setProp("object", "string", "reason", false);
        this.setProp("object", "string", "type", false);
        this.setProp("object", "StorageCausedBy", "innerCausedBy", true, (item: any) => StorageCausedBy.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): StorageCausedBy {
        return StorageCausedBy.fromJS(data);
     }

    static fromJS(data: any): StorageCausedBy {
        data = typeof data === 'object' ? data : {};
        let result = new StorageCausedBy();
        result.init(data);
        return result;
    }

}

export interface IStorageCausedBy {
    reason?: string | undefined;
    type?: string | undefined;
    innerCausedBy?: IStorageCausedBy | undefined;
}

export class PermissionOwnershipTransferException extends PictureparkValidationException implements IPermissionOwnershipTransferException {
    transferUserId?: string | undefined;
    missingUserRight!: UserRight;

    constructor(data?: IPermissionOwnershipTransferException) {
        super(data);
        this.setProp("object", "string", "transferUserId", false);
        this.setProp("object", "UserRight", "missingUserRight", false);

        this._kind = "PermissionOwnershipTransferException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionOwnershipTransferException {
        return PermissionOwnershipTransferException.fromJS(data);
     }

    static fromJS(data: any): PermissionOwnershipTransferException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOwnershipTransferException();
        result.init(data);
        return result;
    }

}

export interface IPermissionOwnershipTransferException extends IPictureparkValidationException {
    transferUserId?: string | undefined;
    missingUserRight: UserRight;
}

export enum UserRight {
    ManageContent = "ManageContent",
    ManageSharings = "ManageSharings",
    ManageTransfer = "ManageTransfer",
    ManageChannels = "ManageChannels",
    ManageSchemas = "ManageSchemas",
    ManageUsers = "ManageUsers",
    ManageUserRoles = "ManageUserRoles",
    ManagePermissions = "ManagePermissions",
    ManageSearchIndexes = "ManageSearchIndexes",
    ManageCollections = "ManageCollections",
    ManageListItems = "ManageListItems",
    ManageServiceProviders = "ManageServiceProviders",
    ManageEmbeds = "ManageEmbeds",
    ManageTemplates = "ManageTemplates",
    ManageTermsOfService = "ManageTermsOfService",
    ManageLiveStream = "ManageLiveStream",
    ManageDocumentHistory = "ManageDocumentHistory",
    ManageAllShares = "ManageAllShares",
    ManageOutputFormats = "ManageOutputFormats",
}

export class PermissionSetNotFoundException extends PictureparkNotFoundException implements IPermissionSetNotFoundException {
    permissionSetIds?: string[] | undefined;

    constructor(data?: IPermissionSetNotFoundException) {
        super(data);
        this.setProp("array", "string[]", "permissionSetIds", false);

        this._kind = "PermissionSetNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetNotFoundException {
        return PermissionSetNotFoundException.fromJS(data);
     }

    static fromJS(data: any): PermissionSetNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetNotFoundException extends IPictureparkNotFoundException {
    permissionSetIds?: string[] | undefined;
}

export class PermissionSetAggregateException extends PictureparkValidationException implements IPermissionSetAggregateException {
    exceptions?: PictureparkException[] | undefined;

    constructor(data?: IPermissionSetAggregateException) {
        super(data);
        this.setProp("array", "PictureparkException[]", "exceptions", true, (item: any) => PictureparkException.fromJS(item));

        this._kind = "PermissionSetAggregateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetAggregateException {
        return PermissionSetAggregateException.fromJS(data);
     }

    static fromJS(data: any): PermissionSetAggregateException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetAggregateException();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetAggregateException extends IPictureparkValidationException {
    exceptions?: PictureparkException[] | undefined;
}

export class DuplicateRightException extends PictureparkValidationException implements IDuplicateRightException {
    permissionSetId?: string | undefined;

    constructor(data?: IDuplicateRightException) {
        super(data);
        this.setProp("object", "string", "permissionSetId", false);

        this._kind = "DuplicateRightException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateRightException {
        return DuplicateRightException.fromJS(data);
     }

    static fromJS(data: any): DuplicateRightException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateRightException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateRightException extends IPictureparkValidationException {
    permissionSetId?: string | undefined;
}

export class PermissionValidationException extends PictureparkValidationException implements IPermissionValidationException {
    permission?: string | undefined;
    operation?: string | undefined;

    constructor(data?: IPermissionValidationException) {
        super(data);
        this.setProp("object", "string", "permission", false);
        this.setProp("object", "string", "operation", false);

        this._kind = "PermissionValidationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionValidationException {
        return PermissionValidationException.fromJS(data);
     }

    static fromJS(data: any): PermissionValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionValidationException();
        result.init(data);
        return result;
    }

}

export interface IPermissionValidationException extends IPictureparkValidationException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export class PermissionSetInUseException extends PictureparkValidationException implements IPermissionSetInUseException {
    reference?: string | undefined;
    referenceCount!: number;

    constructor(data?: IPermissionSetInUseException) {
        super(data);
        this.setProp("object", "string", "reference", false);
        this.setProp("object", "number", "referenceCount", false);

        this._kind = "PermissionSetInUseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetInUseException {
        return PermissionSetInUseException.fromJS(data);
     }

    static fromJS(data: any): PermissionSetInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetInUseException();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetInUseException extends IPictureparkValidationException {
    reference?: string | undefined;
    referenceCount: number;
}

export class ContentPermissionException extends PictureparkValidationException implements IContentPermissionException {
    contentId?: string | undefined;
    contentRights?: ContentRight[] | undefined;

    constructor(data?: IContentPermissionException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("array", "ContentRight[]", "contentRights", false);

        this._kind = "ContentPermissionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionException {
        return ContentPermissionException.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionException();
        result.init(data);
        return result;
    }

}

export interface IContentPermissionException extends IPictureparkValidationException {
    contentId?: string | undefined;
    contentRights?: ContentRight[] | undefined;
}

/** Content rights */
export enum ContentRight {
    View = "View",
    AccessOriginal = "AccessOriginal",
    EditMetadata = "EditMetadata",
    EditContent = "EditContent",
    ManagePermissions = "ManagePermissions",
    Delete = "Delete",
}

export class ListItemPermissionException extends PictureparkValidationException implements IListItemPermissionException {
    listItemId?: string | undefined;
    metadataRight!: MetadataRight;

    constructor(data?: IListItemPermissionException) {
        super(data);
        this.setProp("object", "string", "listItemId", false);
        this.setProp("object", "MetadataRight", "metadataRight", false);

        this._kind = "ListItemPermissionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemPermissionException {
        return ListItemPermissionException.fromJS(data);
     }

    static fromJS(data: any): ListItemPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemPermissionException();
        result.init(data);
        return result;
    }

}

export interface IListItemPermissionException extends IPictureparkValidationException {
    listItemId?: string | undefined;
    metadataRight: MetadataRight;
}

/** Metadata rights */
export enum MetadataRight {
    View = "View",
    ManageItems = "ManageItems",
    ManageSchema = "ManageSchema",
}

export class SchemaPermissionException extends PictureparkValidationException implements ISchemaPermissionException {
    schemaId?: string | undefined;
    metadataRight!: MetadataRight;

    constructor(data?: ISchemaPermissionException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "MetadataRight", "metadataRight", false);

        this._kind = "SchemaPermissionException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionException {
        return SchemaPermissionException.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionException();
        result.init(data);
        return result;
    }

}

export interface ISchemaPermissionException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    metadataRight: MetadataRight;
}

/** This exception is an abstract base for permission set validation. */
export class PermissionSetValidationException extends PictureparkValidationException implements IPermissionSetValidationException {

    constructor(data?: IPermissionSetValidationException) {
        super(data);

        this._kind = "PermissionSetValidationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetValidationException {
        return PermissionSetValidationException.fromJS(data);
     }

    static fromJS(data: any): PermissionSetValidationException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        let result = new PermissionSetValidationException();
        result.init(data);
        return result;
    }

}

/** This exception is an abstract base for permission set validation. */
export interface IPermissionSetValidationException extends IPictureparkValidationException {
}

export class PermissionSetInvalidRightCombinationException extends PermissionSetValidationException implements IPermissionSetInvalidRightCombinationException {

    constructor(data?: IPermissionSetInvalidRightCombinationException) {
        super(data);

        this._kind = "PermissionSetInvalidRightCombinationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetInvalidRightCombinationException {
        return PermissionSetInvalidRightCombinationException.fromJS(data);
     }

    static fromJS(data: any): PermissionSetInvalidRightCombinationException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetInvalidRightCombinationException();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetInvalidRightCombinationException extends IPermissionSetValidationException {
}

export class AmbiguousUserRoleRightsException extends PermissionSetValidationException implements IAmbiguousUserRoleRightsException {

    constructor(data?: IAmbiguousUserRoleRightsException) {
        super(data);

        this._kind = "AmbiguousUserRoleRightsException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AmbiguousUserRoleRightsException {
        return AmbiguousUserRoleRightsException.fromJS(data);
     }

    static fromJS(data: any): AmbiguousUserRoleRightsException {
        data = typeof data === 'object' ? data : {};
        let result = new AmbiguousUserRoleRightsException();
        result.init(data);
        return result;
    }

}

export interface IAmbiguousUserRoleRightsException extends IPermissionSetValidationException {
}

export class UnsupportedListItemChangeCommandException extends PictureparkValidationException implements IUnsupportedListItemChangeCommandException {
    commandType?: string | undefined;

    constructor(data?: IUnsupportedListItemChangeCommandException) {
        super(data);
        this.setProp("object", "string", "commandType", false);

        this._kind = "UnsupportedListItemChangeCommandException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UnsupportedListItemChangeCommandException {
        return UnsupportedListItemChangeCommandException.fromJS(data);
     }

    static fromJS(data: any): UnsupportedListItemChangeCommandException {
        data = typeof data === 'object' ? data : {};
        let result = new UnsupportedListItemChangeCommandException();
        result.init(data);
        return result;
    }

}

export interface IUnsupportedListItemChangeCommandException extends IPictureparkValidationException {
    commandType?: string | undefined;
}

export class ListItemLayerException extends PictureparkValidationException implements IListItemLayerException {
    listItemId?: string | undefined;

    constructor(data?: IListItemLayerException) {
        super(data);
        this.setProp("object", "string", "listItemId", false);

        this._kind = "ListItemLayerException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemLayerException {
        return ListItemLayerException.fromJS(data);
     }

    static fromJS(data: any): ListItemLayerException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemLayerException();
        result.init(data);
        return result;
    }

}

export interface IListItemLayerException extends IPictureparkValidationException {
    listItemId?: string | undefined;
}

export class ListItemNotFoundException extends PictureparkNotFoundException implements IListItemNotFoundException {
    listItemIds?: string[] | undefined;

    constructor(data?: IListItemNotFoundException) {
        super(data);
        this.setProp("array", "string[]", "listItemIds", false);

        this._kind = "ListItemNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemNotFoundException {
        return ListItemNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ListItemNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IListItemNotFoundException extends IPictureparkNotFoundException {
    listItemIds?: string[] | undefined;
}

export class ListItemCyclicDependencyException extends PictureparkBusinessException implements IListItemCyclicDependencyException {
    listItemIds?: string[] | undefined;

    constructor(data?: IListItemCyclicDependencyException) {
        super(data);
        this.setProp("array", "string[]", "listItemIds", false);

        this._kind = "ListItemCyclicDependencyException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemCyclicDependencyException {
        return ListItemCyclicDependencyException.fromJS(data);
     }

    static fromJS(data: any): ListItemCyclicDependencyException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCyclicDependencyException();
        result.init(data);
        return result;
    }

}

export interface IListItemCyclicDependencyException extends IPictureparkBusinessException {
    listItemIds?: string[] | undefined;
}

export class DeleteListItemsWithReferencesException extends PictureparkValidationException implements IDeleteListItemsWithReferencesException {
    numberOfReferences!: number;

    constructor(data?: IDeleteListItemsWithReferencesException) {
        super(data);
        this.setProp("object", "number", "numberOfReferences", false);

        this._kind = "DeleteListItemsWithReferencesException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DeleteListItemsWithReferencesException {
        return DeleteListItemsWithReferencesException.fromJS(data);
     }

    static fromJS(data: any): DeleteListItemsWithReferencesException {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteListItemsWithReferencesException();
        result.init(data);
        return result;
    }

}

export interface IDeleteListItemsWithReferencesException extends IPictureparkValidationException {
    numberOfReferences: number;
}

export class ListItemUpdateManyException extends PictureparkBusinessException implements IListItemUpdateManyException {
    failedItemsCount!: number;
    totalItemsCount!: number;

    constructor(data?: IListItemUpdateManyException) {
        super(data);
        this.setProp("object", "number", "failedItemsCount", false);
        this.setProp("object", "number", "totalItemsCount", false);

        this._kind = "ListItemUpdateManyException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemUpdateManyException {
        return ListItemUpdateManyException.fromJS(data);
     }

    static fromJS(data: any): ListItemUpdateManyException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateManyException();
        result.init(data);
        return result;
    }

}

export interface IListItemUpdateManyException extends IPictureparkBusinessException {
    failedItemsCount: number;
    totalItemsCount: number;
}

export class ListItemSchemaMismatchException extends PictureparkValidationException implements IListItemSchemaMismatchException {
    listItemId?: string | undefined;
    listItemSchemaId?: string | undefined;
    fieldSchemaId?: string | undefined;

    constructor(data?: IListItemSchemaMismatchException) {
        super(data);
        this.setProp("object", "string", "listItemId", false);
        this.setProp("object", "string", "listItemSchemaId", false);
        this.setProp("object", "string", "fieldSchemaId", false);

        this._kind = "ListItemSchemaMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemSchemaMismatchException {
        return ListItemSchemaMismatchException.fromJS(data);
     }

    static fromJS(data: any): ListItemSchemaMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSchemaMismatchException();
        result.init(data);
        return result;
    }

}

export interface IListItemSchemaMismatchException extends IPictureparkValidationException {
    listItemId?: string | undefined;
    listItemSchemaId?: string | undefined;
    fieldSchemaId?: string | undefined;
}

export class TransferInfoNotFoundException extends PictureparkNotFoundException implements ITransferInfoNotFoundException {
    transferInfoId?: string | undefined;

    constructor(data?: ITransferInfoNotFoundException) {
        super(data);
        this.setProp("object", "string", "transferInfoId", false);

        this._kind = "TransferInfoNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferInfoNotFoundException {
        return TransferInfoNotFoundException.fromJS(data);
     }

    static fromJS(data: any): TransferInfoNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TransferInfoNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ITransferInfoNotFoundException extends IPictureparkNotFoundException {
    transferInfoId?: string | undefined;
}

export class FileTransferNotFoundException extends PictureparkNotFoundException implements IFileTransferNotFoundException {
    fileTransferId?: string | undefined;

    constructor(data?: IFileTransferNotFoundException) {
        super(data);
        this.setProp("object", "string", "fileTransferId", false);

        this._kind = "FileTransferNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferNotFoundException {
        return FileTransferNotFoundException.fromJS(data);
     }

    static fromJS(data: any): FileTransferNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IFileTransferNotFoundException extends IPictureparkNotFoundException {
    fileTransferId?: string | undefined;
}

export class InvalidTransferTypeException extends PictureparkBusinessException implements IInvalidTransferTypeException {
    transferType!: TransferType;

    constructor(data?: IInvalidTransferTypeException) {
        super(data);
        this.setProp("object", "TransferType", "transferType", false);

        this._kind = "InvalidTransferTypeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidTransferTypeException {
        return InvalidTransferTypeException.fromJS(data);
     }

    static fromJS(data: any): InvalidTransferTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidTransferTypeException();
        result.init(data);
        return result;
    }

}

export interface IInvalidTransferTypeException extends IPictureparkBusinessException {
    transferType: TransferType;
}

/** Type of the transfer */
export enum TransferType {
    FileUpload = "FileUpload",
    FileUploadAutoImport = "FileUploadAutoImport",
    WebDownload = "WebDownload",
    SchemaImport = "SchemaImport",
}

export class TransferNotFoundException extends PictureparkNotFoundException implements ITransferNotFoundException {
    transferId?: string | undefined;

    constructor(data?: ITransferNotFoundException) {
        super(data);
        this.setProp("object", "string", "transferId", false);

        this._kind = "TransferNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferNotFoundException {
        return TransferNotFoundException.fromJS(data);
     }

    static fromJS(data: any): TransferNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TransferNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ITransferNotFoundException extends IPictureparkNotFoundException {
    transferId?: string | undefined;
}

export class WrongChunkSizeException extends PictureparkValidationException implements IWrongChunkSizeException {
    actual!: number;
    expected!: number;

    constructor(data?: IWrongChunkSizeException) {
        super(data);
        this.setProp("object", "number", "actual", false);
        this.setProp("object", "number", "expected", false);

        this._kind = "WrongChunkSizeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): WrongChunkSizeException {
        return WrongChunkSizeException.fromJS(data);
     }

    static fromJS(data: any): WrongChunkSizeException {
        data = typeof data === 'object' ? data : {};
        let result = new WrongChunkSizeException();
        result.init(data);
        return result;
    }

}

export interface IWrongChunkSizeException extends IPictureparkValidationException {
    actual: number;
    expected: number;
}

export class ChunkSizeOutOfRangeException extends PictureparkValidationException implements IChunkSizeOutOfRangeException {
    actual!: number;
    minimum!: number;
    maximum!: number;

    constructor(data?: IChunkSizeOutOfRangeException) {
        super(data);
        this.setProp("object", "number", "actual", false);
        this.setProp("object", "number", "minimum", false);
        this.setProp("object", "number", "maximum", false);

        this._kind = "ChunkSizeOutOfRangeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ChunkSizeOutOfRangeException {
        return ChunkSizeOutOfRangeException.fromJS(data);
     }

    static fromJS(data: any): ChunkSizeOutOfRangeException {
        data = typeof data === 'object' ? data : {};
        let result = new ChunkSizeOutOfRangeException();
        result.init(data);
        return result;
    }

}

export interface IChunkSizeOutOfRangeException extends IPictureparkValidationException {
    actual: number;
    minimum: number;
    maximum: number;
}

export class MaximumTransferSizeException extends PictureparkException implements IMaximumTransferSizeException {
    transferSize!: number;
    maximumTransferSize!: number;
    transferId?: string | undefined;

    constructor(data?: IMaximumTransferSizeException) {
        super(data);
        this.setProp("object", "number", "transferSize", false);
        this.setProp("object", "number", "maximumTransferSize", false);
        this.setProp("object", "string", "transferId", false);

        this._kind = "MaximumTransferSizeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MaximumTransferSizeException {
        return MaximumTransferSizeException.fromJS(data);
     }

    static fromJS(data: any): MaximumTransferSizeException {
        data = typeof data === 'object' ? data : {};
        let result = new MaximumTransferSizeException();
        result.init(data);
        return result;
    }

}

export interface IMaximumTransferSizeException extends IPictureparkException {
    transferSize: number;
    maximumTransferSize: number;
    transferId?: string | undefined;
}

export class MissingDependenciesException extends PictureparkValidationException implements IMissingDependenciesException {
    itemIds?: string | undefined;

    constructor(data?: IMissingDependenciesException) {
        super(data);
        this.setProp("object", "string", "itemIds", false);

        this._kind = "MissingDependenciesException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MissingDependenciesException {
        return MissingDependenciesException.fromJS(data);
     }

    static fromJS(data: any): MissingDependenciesException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingDependenciesException();
        result.init(data);
        return result;
    }

}

export interface IMissingDependenciesException extends IPictureparkValidationException {
    itemIds?: string | undefined;
}

export class RelationSelfReferencingException extends PictureparkValidationException implements IRelationSelfReferencingException {
    itemId?: string | undefined;
    itemType?: string | undefined;

    constructor(data?: IRelationSelfReferencingException) {
        super(data);
        this.setProp("object", "string", "itemId", false);
        this.setProp("object", "string", "itemType", false);

        this._kind = "RelationSelfReferencingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RelationSelfReferencingException {
        return RelationSelfReferencingException.fromJS(data);
     }

    static fromJS(data: any): RelationSelfReferencingException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationSelfReferencingException();
        result.init(data);
        return result;
    }

}

export interface IRelationSelfReferencingException extends IPictureparkValidationException {
    itemId?: string | undefined;
    itemType?: string | undefined;
}

export class InvalidChangeCommandFieldTypeInvalidException extends PictureparkValidationException implements IInvalidChangeCommandFieldTypeInvalidException {
    commandType?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldActualType?: string | undefined;
    fieldExpectedType?: string | undefined;

    constructor(data?: IInvalidChangeCommandFieldTypeInvalidException) {
        super(data);
        this.setProp("object", "string", "commandType", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldActualType", false);
        this.setProp("object", "string", "fieldExpectedType", false);

        this._kind = "InvalidChangeCommandFieldTypeInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidChangeCommandFieldTypeInvalidException {
        return InvalidChangeCommandFieldTypeInvalidException.fromJS(data);
     }

    static fromJS(data: any): InvalidChangeCommandFieldTypeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandFieldTypeInvalidException();
        result.init(data);
        return result;
    }

}

export interface IInvalidChangeCommandFieldTypeInvalidException extends IPictureparkValidationException {
    commandType?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldActualType?: string | undefined;
    fieldExpectedType?: string | undefined;
}

export class InvalidChangeCommandFieldNotFoundException extends PictureparkValidationException implements IInvalidChangeCommandFieldNotFoundException {
    commandTypeName?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IInvalidChangeCommandFieldNotFoundException) {
        super(data);
        this.setProp("object", "string", "commandTypeName", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "InvalidChangeCommandFieldNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidChangeCommandFieldNotFoundException {
        return InvalidChangeCommandFieldNotFoundException.fromJS(data);
     }

    static fromJS(data: any): InvalidChangeCommandFieldNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandFieldNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IInvalidChangeCommandFieldNotFoundException extends IPictureparkValidationException {
    commandTypeName?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidChangeCommandSchemaChangeInvalidException extends PictureparkValidationException implements IInvalidChangeCommandSchemaChangeInvalidException {
    commandTypeName?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IInvalidChangeCommandSchemaChangeInvalidException) {
        super(data);
        this.setProp("object", "string", "commandTypeName", false);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "InvalidChangeCommandSchemaChangeInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidChangeCommandSchemaChangeInvalidException {
        return InvalidChangeCommandSchemaChangeInvalidException.fromJS(data);
     }

    static fromJS(data: any): InvalidChangeCommandSchemaChangeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandSchemaChangeInvalidException();
        result.init(data);
        return result;
    }

}

export interface IInvalidChangeCommandSchemaChangeInvalidException extends IPictureparkValidationException {
    commandTypeName?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidMetadataException extends PictureparkValidationException implements IInvalidMetadataException {
    metadataErrors?: MetadataError[] | undefined;
    validationErrors?: PictureparkBusinessException[] | undefined;

    constructor(data?: IInvalidMetadataException) {
        super(data);
        this.setProp("array", "MetadataError[]", "metadataErrors", true, (item: any) => MetadataError.fromJS(item));
        this.setProp("array", "PictureparkBusinessException[]", "validationErrors", true, (item: any) => PictureparkBusinessException.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "InvalidMetadataException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InvalidMetadataException {
        return InvalidMetadataException.fromJS(data);
     }

    static fromJS(data: any): InvalidMetadataException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidMetadataException();
        result.init(data);
        return result;
    }

}

export interface IInvalidMetadataException extends IPictureparkValidationException {
    metadataErrors?: IMetadataError[] | undefined;
    validationErrors?: PictureparkBusinessException[] | undefined;
}

export class MetadataError extends DTOBase {
    errorType?: string | undefined;
    lineNumber!: number;
    linePosition!: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IMetadataError) {
        super(data);
        this.setProp("object", "string", "errorType", false);
        this.setProp("object", "number", "lineNumber", false);
        this.setProp("object", "number", "linePosition", false);
        this.setProp("object", "string", "path", false);
        this.setProp("object", "string", "message", false);
        this.setProp("object", "string", "schemaId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataError {
        return MetadataError.fromJS(data);
     }

    static fromJS(data: any): MetadataError {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataError();
        result.init(data);
        return result;
    }

}

export interface IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export class RelationNotFoundException extends PictureparkBusinessException implements IRelationNotFoundException {
    relationId?: string | undefined;

    constructor(data?: IRelationNotFoundException) {
        super(data);
        this.setProp("object", "string", "relationId", false);

        this._kind = "RelationNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RelationNotFoundException {
        return RelationNotFoundException.fromJS(data);
     }

    static fromJS(data: any): RelationNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IRelationNotFoundException extends IPictureparkBusinessException {
    relationId?: string | undefined;
}

export class RelationTypeNotFoundException extends PictureparkBusinessException implements IRelationTypeNotFoundException {
    relationType?: string | undefined;

    constructor(data?: IRelationTypeNotFoundException) {
        super(data);
        this.setProp("object", "string", "relationType", false);

        this._kind = "RelationTypeNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RelationTypeNotFoundException {
        return RelationTypeNotFoundException.fromJS(data);
     }

    static fromJS(data: any): RelationTypeNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IRelationTypeNotFoundException extends IPictureparkBusinessException {
    relationType?: string | undefined;
}

export class RelationTypeTargetDocTypeMismatchException extends PictureparkBusinessException implements IRelationTypeTargetDocTypeMismatchException {
    relationType?: string | undefined;
    targetDocType?: string | undefined;
    expectedTargetDocType?: string | undefined;

    constructor(data?: IRelationTypeTargetDocTypeMismatchException) {
        super(data);
        this.setProp("object", "string", "relationType", false);
        this.setProp("object", "string", "targetDocType", false);
        this.setProp("object", "string", "expectedTargetDocType", false);

        this._kind = "RelationTypeTargetDocTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RelationTypeTargetDocTypeMismatchException {
        return RelationTypeTargetDocTypeMismatchException.fromJS(data);
     }

    static fromJS(data: any): RelationTypeTargetDocTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeTargetDocTypeMismatchException();
        result.init(data);
        return result;
    }

}

export interface IRelationTypeTargetDocTypeMismatchException extends IPictureparkBusinessException {
    relationType?: string | undefined;
    targetDocType?: string | undefined;
    expectedTargetDocType?: string | undefined;
}

export class AggregationNameInvalidException extends PictureparkValidationException implements IAggregationNameInvalidException {
    aggregationName?: string | undefined;
    aggregationPrefix?: string | undefined;

    constructor(data?: IAggregationNameInvalidException) {
        super(data);
        this.setProp("object", "string", "aggregationName", false);
        this.setProp("object", "string", "aggregationPrefix", false);

        this._kind = "AggregationNameInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregationNameInvalidException {
        return AggregationNameInvalidException.fromJS(data);
     }

    static fromJS(data: any): AggregationNameInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationNameInvalidException();
        result.init(data);
        return result;
    }

}

export interface IAggregationNameInvalidException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
    aggregationPrefix?: string | undefined;
}

/** Size of the aggregation is invalid. */
export class AggregationSizeInvalidException extends PictureparkValidationException implements IAggregationSizeInvalidException {
    /** The name identifying the aggregation. */
    aggregationName?: string | undefined;
    /** The invalid size of the aggregation: size must be equal or greater than 1. */
    aggregationSize!: number;

    constructor(data?: IAggregationSizeInvalidException) {
        super(data);
        this.setProp("object", "string", "aggregationName", false);
        this.setProp("object", "number", "aggregationSize", false);

        this._kind = "AggregationSizeInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregationSizeInvalidException {
        return AggregationSizeInvalidException.fromJS(data);
     }

    static fromJS(data: any): AggregationSizeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationSizeInvalidException();
        result.init(data);
        return result;
    }

}

/** Size of the aggregation is invalid. */
export interface IAggregationSizeInvalidException extends IPictureparkValidationException {
    /** The name identifying the aggregation. */
    aggregationName?: string | undefined;
    /** The invalid size of the aggregation: size must be equal or greater than 1. */
    aggregationSize: number;
}

export class AggregationFilterNotSupportedException extends PictureparkValidationException implements IAggregationFilterNotSupportedException {
    aggregationName?: string | undefined;
    notSupportedFilterType?: string | undefined;
    supportedFilterTypes?: string[] | undefined;

    constructor(data?: IAggregationFilterNotSupportedException) {
        super(data);
        this.setProp("object", "string", "aggregationName", false);
        this.setProp("object", "string", "notSupportedFilterType", false);
        this.setProp("array", "string[]", "supportedFilterTypes", false);

        this._kind = "AggregationFilterNotSupportedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregationFilterNotSupportedException {
        return AggregationFilterNotSupportedException.fromJS(data);
     }

    static fromJS(data: any): AggregationFilterNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationFilterNotSupportedException();
        result.init(data);
        return result;
    }

}

export interface IAggregationFilterNotSupportedException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
    notSupportedFilterType?: string | undefined;
    supportedFilterTypes?: string[] | undefined;
}

export class RelationTypeMissingException extends PictureparkBusinessException implements IRelationTypeMissingException {

    constructor(data?: IRelationTypeMissingException) {
        super(data);

        this._kind = "RelationTypeMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RelationTypeMissingException {
        return RelationTypeMissingException.fromJS(data);
     }

    static fromJS(data: any): RelationTypeMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeMissingException();
        result.init(data);
        return result;
    }

}

export interface IRelationTypeMissingException extends IPictureparkBusinessException {
}

export class ReferencesUpdateException extends PictureparkBusinessException implements IReferencesUpdateException {
    exceptions?: ReferenceUpdateException[] | undefined;

    constructor(data?: IReferencesUpdateException) {
        super(data);
        this.setProp("array", "ReferenceUpdateException[]", "exceptions", true, (item: any) => ReferenceUpdateException.fromJS(item));

        this._kind = "ReferencesUpdateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ReferencesUpdateException {
        return ReferencesUpdateException.fromJS(data);
     }

    static fromJS(data: any): ReferencesUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ReferencesUpdateException();
        result.init(data);
        return result;
    }

}

export interface IReferencesUpdateException extends IPictureparkBusinessException {
    exceptions?: ReferenceUpdateException[] | undefined;
}

export class ReferenceUpdateException extends PictureparkBusinessException implements IReferenceUpdateException {
    /** This is the source of the reference. */
    referenceItemId?: string | undefined;
    /** This is the DocType of the source of the reference. */
    referenceType?: string | undefined;
    /** These exceptions describe why the source metadata item could not be updated. */
    exceptions?: PictureparkException[] | undefined;

    constructor(data?: IReferenceUpdateException) {
        super(data);
        this.setProp("object", "string", "referenceItemId", false);
        this.setProp("object", "string", "referenceType", false);
        this.setProp("array", "PictureparkException[]", "exceptions", true, (item: any) => PictureparkException.fromJS(item));

        this._kind = "ReferenceUpdateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ReferenceUpdateException {
        return ReferenceUpdateException.fromJS(data);
     }

    static fromJS(data: any): ReferenceUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceUpdateException();
        result.init(data);
        return result;
    }

}

export interface IReferenceUpdateException extends IPictureparkBusinessException {
    /** This is the source of the reference. */
    referenceItemId?: string | undefined;
    /** This is the DocType of the source of the reference. */
    referenceType?: string | undefined;
    /** These exceptions describe why the source metadata item could not be updated. */
    exceptions?: PictureparkException[] | undefined;
}

export class DuplicatedItemAssignedException extends PictureparkValidationException implements IDuplicatedItemAssignedException {
    itemId?: string | undefined;
    itemPath?: string | undefined;

    constructor(data?: IDuplicatedItemAssignedException) {
        super(data);
        this.setProp("object", "string", "itemId", false);
        this.setProp("object", "string", "itemPath", false);

        this._kind = "DuplicatedItemAssignedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicatedItemAssignedException {
        return DuplicatedItemAssignedException.fromJS(data);
     }

    static fromJS(data: any): DuplicatedItemAssignedException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicatedItemAssignedException();
        result.init(data);
        return result;
    }

}

export interface IDuplicatedItemAssignedException extends IPictureparkValidationException {
    itemId?: string | undefined;
    itemPath?: string | undefined;
}

export class SchemaFieldOverwriteTypeMismatchException extends PictureparkValidationException implements ISchemaFieldOverwriteTypeMismatchException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    fieldOverwriteType?: string | undefined;
    fieldType?: string | undefined;

    constructor(data?: ISchemaFieldOverwriteTypeMismatchException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "fieldOverwriteType", false);
        this.setProp("object", "string", "fieldType", false);

        this._kind = "SchemaFieldOverwriteTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldOverwriteTypeMismatchException {
        return SchemaFieldOverwriteTypeMismatchException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldOverwriteTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldOverwriteTypeMismatchException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldOverwriteTypeMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    fieldOverwriteType?: string | undefined;
    fieldType?: string | undefined;
}

export class SchemaFieldOverwriteIdException extends PictureparkValidationException implements ISchemaFieldOverwriteIdException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldOverwriteIdException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaFieldOverwriteIdException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldOverwriteIdException {
        return SchemaFieldOverwriteIdException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldOverwriteIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldOverwriteIdException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldOverwriteIdException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldIdDuplicatedException extends PictureparkValidationException implements ISchemaFieldIdDuplicatedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIdDuplicatedException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaFieldIdDuplicatedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldIdDuplicatedException {
        return SchemaFieldIdDuplicatedException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldIdDuplicatedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdDuplicatedException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldIdDuplicatedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldIdPreviouslyUsedException extends PictureparkValidationException implements ISchemaFieldIdPreviouslyUsedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    usedInSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldIdPreviouslyUsedException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "usedInSchemaId", false);

        this._kind = "SchemaFieldIdPreviouslyUsedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldIdPreviouslyUsedException {
        return SchemaFieldIdPreviouslyUsedException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldIdPreviouslyUsedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdPreviouslyUsedException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldIdPreviouslyUsedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    usedInSchemaId?: string | undefined;
}

export class SchemaFieldIdAlreadyExistsInSchemaHierarchyException extends PictureparkValidationException implements ISchemaFieldIdAlreadyExistsInSchemaHierarchyException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    existingInSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldIdAlreadyExistsInSchemaHierarchyException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "existingInSchemaId", false);

        this._kind = "SchemaFieldIdAlreadyExistsInSchemaHierarchyException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldIdAlreadyExistsInSchemaHierarchyException {
        return SchemaFieldIdAlreadyExistsInSchemaHierarchyException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldIdAlreadyExistsInSchemaHierarchyException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldIdAlreadyExistsInSchemaHierarchyException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    existingInSchemaId?: string | undefined;
}

export class SchemaFieldSchemaIndexInfoSimpleSearchNestingException extends PictureparkValidationException implements ISchemaFieldSchemaIndexInfoSimpleSearchNestingException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;

    constructor(data?: ISchemaFieldSchemaIndexInfoSimpleSearchNestingException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "relatedFieldId", false);
        this.setProp("object", "string", "relatedOuterFieldId", false);

        this._kind = "SchemaFieldSchemaIndexInfoSimpleSearchNestingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldSchemaIndexInfoSimpleSearchNestingException {
        return SchemaFieldSchemaIndexInfoSimpleSearchNestingException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldSchemaIndexInfoSimpleSearchNestingException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldSchemaIndexInfoSimpleSearchNestingException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;
}

export class SchemaFieldSchemaIndexInfoNestingException extends PictureparkValidationException implements ISchemaFieldSchemaIndexInfoNestingException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;

    constructor(data?: ISchemaFieldSchemaIndexInfoNestingException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "relatedFieldId", false);
        this.setProp("object", "string", "relatedOuterFieldId", false);

        this._kind = "SchemaFieldSchemaIndexInfoNestingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldSchemaIndexInfoNestingException {
        return SchemaFieldSchemaIndexInfoNestingException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldSchemaIndexInfoNestingException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSchemaIndexInfoNestingException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldSchemaIndexInfoNestingException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;
}

export class SchemaFieldIdUppercaseException extends PictureparkValidationException implements ISchemaFieldIdUppercaseException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIdUppercaseException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaFieldIdUppercaseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldIdUppercaseException {
        return SchemaFieldIdUppercaseException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldIdUppercaseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdUppercaseException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldIdUppercaseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaIdLowercaseException extends PictureparkValidationException implements ISchemaIdLowercaseException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaIdLowercaseException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaIdLowercaseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaIdLowercaseException {
        return SchemaIdLowercaseException.fromJS(data);
     }

    static fromJS(data: any): SchemaIdLowercaseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIdLowercaseException();
        result.init(data);
        return result;
    }

}

export interface ISchemaIdLowercaseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaInfoNotFoundException extends PictureparkNotFoundException implements ISchemaInfoNotFoundException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaInfoNotFoundException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaInfoNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInfoNotFoundException {
        return SchemaInfoNotFoundException.fromJS(data);
     }

    static fromJS(data: any): SchemaInfoNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInfoNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInfoNotFoundException extends IPictureparkNotFoundException {
    schemaId?: string | undefined;
}

export class IndexedFieldThresholdExceededException extends PictureparkValidationException implements IIndexedFieldThresholdExceededException {
    schemaIds?: string[] | undefined;
    indexedFieldCount!: number;
    indexedFieldThreshold!: number;

    constructor(data?: IIndexedFieldThresholdExceededException) {
        super(data);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("object", "number", "indexedFieldCount", false);
        this.setProp("object", "number", "indexedFieldThreshold", false);

        this._kind = "IndexedFieldThresholdExceededException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IndexedFieldThresholdExceededException {
        return IndexedFieldThresholdExceededException.fromJS(data);
     }

    static fromJS(data: any): IndexedFieldThresholdExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexedFieldThresholdExceededException();
        result.init(data);
        return result;
    }

}

export interface IIndexedFieldThresholdExceededException extends IPictureparkValidationException {
    schemaIds?: string[] | undefined;
    indexedFieldCount: number;
    indexedFieldThreshold: number;
}

export class SortableFieldThresholdExceededException extends PictureparkValidationException implements ISortableFieldThresholdExceededException {
    schemaIds?: string[] | undefined;
    sortableFieldCount!: number;
    sortableFieldThreshold!: number;

    constructor(data?: ISortableFieldThresholdExceededException) {
        super(data);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("object", "number", "sortableFieldCount", false);
        this.setProp("object", "number", "sortableFieldThreshold", false);

        this._kind = "SortableFieldThresholdExceededException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SortableFieldThresholdExceededException {
        return SortableFieldThresholdExceededException.fromJS(data);
     }

    static fromJS(data: any): SortableFieldThresholdExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new SortableFieldThresholdExceededException();
        result.init(data);
        return result;
    }

}

export interface ISortableFieldThresholdExceededException extends IPictureparkValidationException {
    schemaIds?: string[] | undefined;
    sortableFieldCount: number;
    sortableFieldThreshold: number;
}

export class DuplicateSchemaInfoException extends PictureparkBusinessException implements IDuplicateSchemaInfoException {
    schemaId?: string | undefined;

    constructor(data?: IDuplicateSchemaInfoException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "DuplicateSchemaInfoException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateSchemaInfoException {
        return DuplicateSchemaInfoException.fromJS(data);
     }

    static fromJS(data: any): DuplicateSchemaInfoException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSchemaInfoException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateSchemaInfoException extends IPictureparkBusinessException {
    schemaId?: string | undefined;
}

export class SchemaFieldNumberRangeException extends PictureparkValidationException implements ISchemaFieldNumberRangeException {
    fieldId?: string | undefined;
    propertyName?: string | undefined;
    minValue!: number;
    maxValue!: number;

    constructor(data?: ISchemaFieldNumberRangeException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "propertyName", false);
        this.setProp("object", "number", "minValue", false);
        this.setProp("object", "number", "maxValue", false);

        this._kind = "SchemaFieldNumberRangeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldNumberRangeException {
        return SchemaFieldNumberRangeException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldNumberRangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNumberRangeException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldNumberRangeException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    propertyName?: string | undefined;
    minValue: number;
    maxValue: number;
}

export class SchemaInUseContentSchemaException extends PictureparkValidationException implements ISchemaInUseContentSchemaException {
    schemaId?: string | undefined;
    contentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaInUseContentSchemaException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "string[]", "contentSchemaIds", false);

        this._kind = "SchemaInUseContentSchemaException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInUseContentSchemaException {
        return SchemaInUseContentSchemaException.fromJS(data);
     }

    static fromJS(data: any): SchemaInUseContentSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseContentSchemaException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInUseContentSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    contentSchemaIds?: string[] | undefined;
}

export class SchemaInUseListItemException extends PictureparkValidationException implements ISchemaInUseListItemException {
    schemaId?: string | undefined;
    listItemCount!: number;

    constructor(data?: ISchemaInUseListItemException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "number", "listItemCount", false);

        this._kind = "SchemaInUseListItemException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInUseListItemException {
        return SchemaInUseListItemException.fromJS(data);
     }

    static fromJS(data: any): SchemaInUseListItemException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseListItemException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInUseListItemException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    listItemCount: number;
}

export class SchemaInUseContentException extends PictureparkValidationException implements ISchemaInUseContentException {
    schemaId?: string | undefined;
    contentCount!: number;

    constructor(data?: ISchemaInUseContentException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "number", "contentCount", false);

        this._kind = "SchemaInUseContentException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInUseContentException {
        return SchemaInUseContentException.fromJS(data);
     }

    static fromJS(data: any): SchemaInUseContentException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseContentException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInUseContentException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    contentCount: number;
}

export class SchemaInUseFieldException extends PictureparkValidationException implements ISchemaInUseFieldException {
    schemaId?: string | undefined;
    fieldNamespaces?: string[] | undefined;

    constructor(data?: ISchemaInUseFieldException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "string[]", "fieldNamespaces", false);

        this._kind = "SchemaInUseFieldException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInUseFieldException {
        return SchemaInUseFieldException.fromJS(data);
     }

    static fromJS(data: any): SchemaInUseFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseFieldException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInUseFieldException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldNamespaces?: string[] | undefined;
}

export class DuplicateMetadataDisplayPatternException extends PictureparkValidationException implements IDuplicateMetadataDisplayPatternException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;

    constructor(data?: IDuplicateMetadataDisplayPatternException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "displayPatternId", false);

        this._kind = "DuplicateMetadataDisplayPatternException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateMetadataDisplayPatternException {
        return DuplicateMetadataDisplayPatternException.fromJS(data);
     }

    static fromJS(data: any): DuplicateMetadataDisplayPatternException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateMetadataDisplayPatternException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateMetadataDisplayPatternException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;
}

export class DuplicateSchemaException extends PictureparkValidationException implements IDuplicateSchemaException {
    schemaId?: string | undefined;

    constructor(data?: IDuplicateSchemaException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "DuplicateSchemaException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DuplicateSchemaException {
        return DuplicateSchemaException.fromJS(data);
     }

    static fromJS(data: any): DuplicateSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSchemaException();
        result.init(data);
        return result;
    }

}

export interface IDuplicateSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaImportEmptyException extends PictureparkValidationException implements ISchemaImportEmptyException {

    constructor(data?: ISchemaImportEmptyException) {
        super(data);

        this._kind = "SchemaImportEmptyException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaImportEmptyException {
        return SchemaImportEmptyException.fromJS(data);
     }

    static fromJS(data: any): SchemaImportEmptyException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportEmptyException();
        result.init(data);
        return result;
    }

}

export interface ISchemaImportEmptyException extends IPictureparkValidationException {
}

export class SchemaImportVersionMismatchException extends PictureparkValidationException implements ISchemaImportVersionMismatchException {
    providedVersion?: string | undefined;
    expectedVersion?: string | undefined;

    constructor(data?: ISchemaImportVersionMismatchException) {
        super(data);
        this.setProp("object", "string", "providedVersion", false);
        this.setProp("object", "string", "expectedVersion", false);

        this._kind = "SchemaImportVersionMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaImportVersionMismatchException {
        return SchemaImportVersionMismatchException.fromJS(data);
     }

    static fromJS(data: any): SchemaImportVersionMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportVersionMismatchException();
        result.init(data);
        return result;
    }

}

export interface ISchemaImportVersionMismatchException extends IPictureparkValidationException {
    providedVersion?: string | undefined;
    expectedVersion?: string | undefined;
}

export class SchemaInheritanceFieldIndexDeviationException extends PictureparkValidationException implements ISchemaInheritanceFieldIndexDeviationException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaInheritanceFieldIndexDeviationException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaInheritanceFieldIndexDeviationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInheritanceFieldIndexDeviationException {
        return SchemaInheritanceFieldIndexDeviationException.fromJS(data);
     }

    static fromJS(data: any): SchemaInheritanceFieldIndexDeviationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInheritanceFieldIndexDeviationException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInheritanceFieldIndexDeviationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaInheritanceTypeDeviationException extends PictureparkValidationException implements ISchemaInheritanceTypeDeviationException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaInheritanceTypeDeviationException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaInheritanceTypeDeviationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInheritanceTypeDeviationException {
        return SchemaInheritanceTypeDeviationException.fromJS(data);
     }

    static fromJS(data: any): SchemaInheritanceTypeDeviationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInheritanceTypeDeviationException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInheritanceTypeDeviationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaValidationException extends PictureparkValidationException implements ISchemaValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;

    constructor(data?: ISchemaValidationException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "PictureparkBusinessException[]", "exceptions", true, (item: any) => PictureparkBusinessException.fromJS(item));

        this._kind = "SchemaValidationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaValidationException {
        return SchemaValidationException.fromJS(data);
     }

    static fromJS(data: any): SchemaValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaValidationException();
        result.init(data);
        return result;
    }

}

export interface ISchemaValidationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export class SchemaSortFieldException extends PictureparkValidationException implements ISchemaSortFieldException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaSortFieldException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaSortFieldException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaSortFieldException {
        return SchemaSortFieldException.fromJS(data);
     }

    static fromJS(data: any): SchemaSortFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSortFieldException();
        result.init(data);
        return result;
    }

}

export interface ISchemaSortFieldException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldIdException extends PictureparkValidationException implements ISchemaFieldIdException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIdException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaFieldIdException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldIdException {
        return SchemaFieldIdException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldIdException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldTypeChangeException extends PictureparkValidationException implements ISchemaFieldTypeChangeException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldTypeName?: string | undefined;
    newTypeName?: string | undefined;

    constructor(data?: ISchemaFieldTypeChangeException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "oldTypeName", false);
        this.setProp("object", "string", "newTypeName", false);

        this._kind = "SchemaFieldTypeChangeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldTypeChangeException {
        return SchemaFieldTypeChangeException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldTypeChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldTypeChangeException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldTypeChangeException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldTypeName?: string | undefined;
    newTypeName?: string | undefined;
}

export class SchemaFieldIndexException extends PictureparkValidationException implements ISchemaFieldIndexException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIndexException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaFieldIndexException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldIndexException {
        return SchemaFieldIndexException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldIndexException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIndexException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldIndexException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldNotSortableException extends PictureparkValidationException implements ISchemaFieldNotSortableException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldNotSortableException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaFieldNotSortableException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldNotSortableException {
        return SchemaFieldNotSortableException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldNotSortableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSortableException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldNotSortableException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class SchemaFieldNotSearchableException extends PictureparkValidationException implements ISchemaFieldNotSearchableException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldNotSearchableException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaFieldNotSearchableException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldNotSearchableException {
        return SchemaFieldNotSearchableException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldNotSearchableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSearchableException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldNotSearchableException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class SchemaFieldInvalidBoostException extends PictureparkValidationException implements ISchemaFieldInvalidBoostException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    boost!: number;
    allowedBoostValues?: number[] | undefined;

    constructor(data?: ISchemaFieldInvalidBoostException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "number", "boost", false);
        this.setProp("array", "number[]", "allowedBoostValues", false);

        this._kind = "SchemaFieldInvalidBoostException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldInvalidBoostException {
        return SchemaFieldInvalidBoostException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldInvalidBoostException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldInvalidBoostException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldInvalidBoostException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    boost: number;
    allowedBoostValues?: number[] | undefined;
}

export class SchemaNoContentException extends PictureparkValidationException implements ISchemaNoContentException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNoContentException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaNoContentException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaNoContentException {
        return SchemaNoContentException.fromJS(data);
     }

    static fromJS(data: any): SchemaNoContentException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNoContentException();
        result.init(data);
        return result;
    }

}

export interface ISchemaNoContentException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaParentChangeException extends PictureparkValidationException implements ISchemaParentChangeException {
    schemaId?: string | undefined;
    oldSchemaParentId?: string | undefined;
    newSchemaParentId?: string | undefined;

    constructor(data?: ISchemaParentChangeException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "oldSchemaParentId", false);
        this.setProp("object", "string", "newSchemaParentId", false);

        this._kind = "SchemaParentChangeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaParentChangeException {
        return SchemaParentChangeException.fromJS(data);
     }

    static fromJS(data: any): SchemaParentChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaParentChangeException();
        result.init(data);
        return result;
    }

}

export interface ISchemaParentChangeException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    oldSchemaParentId?: string | undefined;
    newSchemaParentId?: string | undefined;
}

export class SchemaMissingTypeException extends PictureparkValidationException implements ISchemaMissingTypeException {
    schemaId?: string | undefined;
    expectedSchemaTypes?: SchemaType[] | undefined;

    constructor(data?: ISchemaMissingTypeException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "SchemaType[]", "expectedSchemaTypes", false);

        this._kind = "SchemaMissingTypeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaMissingTypeException {
        return SchemaMissingTypeException.fromJS(data);
     }

    static fromJS(data: any): SchemaMissingTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMissingTypeException();
        result.init(data);
        return result;
    }

}

export interface ISchemaMissingTypeException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    expectedSchemaTypes?: SchemaType[] | undefined;
}

/** Type of the schema */
export enum SchemaType {
    Content = "Content",
    Layer = "Layer",
    List = "List",
    Struct = "Struct",
}

export class SchemaPermissionConfigurationException extends PictureparkValidationException implements ISchemaPermissionConfigurationException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaPermissionConfigurationException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaPermissionConfigurationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionConfigurationException {
        return SchemaPermissionConfigurationException.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionConfigurationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionConfigurationException();
        result.init(data);
        return result;
    }

}

export interface ISchemaPermissionConfigurationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaNoLayerException extends PictureparkValidationException implements ISchemaNoLayerException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNoLayerException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaNoLayerException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaNoLayerException {
        return SchemaNoLayerException.fromJS(data);
     }

    static fromJS(data: any): SchemaNoLayerException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNoLayerException();
        result.init(data);
        return result;
    }

}

export interface ISchemaNoLayerException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaIdException extends PictureparkValidationException implements ISchemaIdException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaIdException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaIdException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaIdException {
        return SchemaIdException.fromJS(data);
     }

    static fromJS(data: any): SchemaIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIdException();
        result.init(data);
        return result;
    }

}

export interface ISchemaIdException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaInUseException extends PictureparkValidationException implements ISchemaInUseException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;

    constructor(data?: ISchemaInUseException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "PictureparkBusinessException[]", "exceptions", true, (item: any) => PictureparkBusinessException.fromJS(item));

        this._kind = "SchemaInUseException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaInUseException {
        return SchemaInUseException.fromJS(data);
     }

    static fromJS(data: any): SchemaInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseException();
        result.init(data);
        return result;
    }

}

export interface ISchemaInUseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export class SchemaNotFoundException extends PictureparkNotFoundException implements ISchemaNotFoundException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNotFoundException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaNotFoundException {
        return SchemaNotFoundException.fromJS(data);
     }

    static fromJS(data: any): SchemaNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNotFoundException();
        result.init(data);
        return result;
    }

}

export interface ISchemaNotFoundException extends IPictureparkNotFoundException {
    schemaId?: string | undefined;
}

export class SystemSchemaInvalidModificationException extends PictureparkValidationException implements ISystemSchemaInvalidModificationException {
    schemaId?: string | undefined;

    constructor(data?: ISystemSchemaInvalidModificationException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SystemSchemaInvalidModificationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SystemSchemaInvalidModificationException {
        return SystemSchemaInvalidModificationException.fromJS(data);
     }

    static fromJS(data: any): SystemSchemaInvalidModificationException {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSchemaInvalidModificationException();
        result.init(data);
        return result;
    }

}

export interface ISystemSchemaInvalidModificationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaFieldRelationSchemaSystemSchemaException extends PictureparkValidationException implements ISchemaFieldRelationSchemaSystemSchemaException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldRelationSchemaSystemSchemaException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "relationSchemaId", false);

        this._kind = "SchemaFieldRelationSchemaSystemSchemaException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldRelationSchemaSystemSchemaException {
        return SchemaFieldRelationSchemaSystemSchemaException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldRelationSchemaSystemSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationSchemaSystemSchemaException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldRelationSchemaSystemSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;
}

export class SchemaFieldRelationSchemaTypeUnsupportedException extends PictureparkValidationException implements ISchemaFieldRelationSchemaTypeUnsupportedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldRelationSchemaTypeUnsupportedException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "relationSchemaId", false);

        this._kind = "SchemaFieldRelationSchemaTypeUnsupportedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldRelationSchemaTypeUnsupportedException {
        return SchemaFieldRelationSchemaTypeUnsupportedException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldRelationSchemaTypeUnsupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldRelationSchemaTypeUnsupportedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;
}

export class SchemaMultipleTypesException extends PictureparkValidationException implements ISchemaMultipleTypesException {
    schemaId?: string | undefined;
    schemaTypes?: string[] | undefined;

    constructor(data?: ISchemaMultipleTypesException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "string[]", "schemaTypes", false);

        this._kind = "SchemaMultipleTypesException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaMultipleTypesException {
        return SchemaMultipleTypesException.fromJS(data);
     }

    static fromJS(data: any): SchemaMultipleTypesException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMultipleTypesException();
        result.init(data);
        return result;
    }

}

export interface ISchemaMultipleTypesException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    schemaTypes?: string[] | undefined;
}

export class MissingDisplayPatternForCustomerDefaultLanguageException extends PictureparkValidationException implements IMissingDisplayPatternForCustomerDefaultLanguageException {
    schemaId?: string | undefined;
    missingTypes?: DisplayPatternType[] | undefined;

    constructor(data?: IMissingDisplayPatternForCustomerDefaultLanguageException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "DisplayPatternType[]", "missingTypes", false);

        this._kind = "MissingDisplayPatternForCustomerDefaultLanguageException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MissingDisplayPatternForCustomerDefaultLanguageException {
        return MissingDisplayPatternForCustomerDefaultLanguageException.fromJS(data);
     }

    static fromJS(data: any): MissingDisplayPatternForCustomerDefaultLanguageException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
        result.init(data);
        return result;
    }

}

export interface IMissingDisplayPatternForCustomerDefaultLanguageException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    missingTypes?: DisplayPatternType[] | undefined;
}

/** The display pattern type */
export enum DisplayPatternType {
    Thumbnail = "Thumbnail",
    List = "List",
    Detail = "Detail",
    Name = "Name",
}

export class SchemaViewForAllException extends PictureparkValidationException implements ISchemaViewForAllException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaViewForAllException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SchemaViewForAllException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaViewForAllException {
        return SchemaViewForAllException.fromJS(data);
     }

    static fromJS(data: any): SchemaViewForAllException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaViewForAllException();
        result.init(data);
        return result;
    }

}

export interface ISchemaViewForAllException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SystemLayerReferenceInvalidModificationException extends PictureparkValidationException implements ISystemLayerReferenceInvalidModificationException {
    schemaId?: string | undefined;

    constructor(data?: ISystemLayerReferenceInvalidModificationException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "SystemLayerReferenceInvalidModificationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SystemLayerReferenceInvalidModificationException {
        return SystemLayerReferenceInvalidModificationException.fromJS(data);
     }

    static fromJS(data: any): SystemLayerReferenceInvalidModificationException {
        data = typeof data === 'object' ? data : {};
        let result = new SystemLayerReferenceInvalidModificationException();
        result.init(data);
        return result;
    }

}

export interface ISystemLayerReferenceInvalidModificationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaFieldAnalyzerInvalidException extends PictureparkValidationException implements ISchemaFieldAnalyzerInvalidException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    analyzers?: Analyzer[] | undefined;
    allowedAnalyzers?: Analyzer[] | undefined;

    constructor(data?: ISchemaFieldAnalyzerInvalidException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("array", "Analyzer[]", "analyzers", false);
        this.setProp("array", "Analyzer[]", "allowedAnalyzers", false);

        this._kind = "SchemaFieldAnalyzerInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldAnalyzerInvalidException {
        return SchemaFieldAnalyzerInvalidException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldAnalyzerInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldAnalyzerInvalidException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldAnalyzerInvalidException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    analyzers?: Analyzer[] | undefined;
    allowedAnalyzers?: Analyzer[] | undefined;
}

export enum Analyzer {
    None = "None",
    Simple = "Simple",
    Language = "Language",
    PathHierarchy = "PathHierarchy",
    EdgeNGram = "EdgeNGram",
    NGram = "NGram",
}

export class SchemaFieldRelationMultipleTypesException extends PictureparkValidationException implements ISchemaFieldRelationMultipleTypesException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldRelationMultipleTypesException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);

        this._kind = "SchemaFieldRelationMultipleTypesException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldRelationMultipleTypesException {
        return SchemaFieldRelationMultipleTypesException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldRelationMultipleTypesException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationMultipleTypesException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldRelationMultipleTypesException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class DeleteContentsWithReferencesException extends PictureparkValidationException implements IDeleteContentsWithReferencesException {
    numberOfReferences!: number;
    numberOfShares!: number;

    constructor(data?: IDeleteContentsWithReferencesException) {
        super(data);
        this.setProp("object", "number", "numberOfReferences", false);
        this.setProp("object", "number", "numberOfShares", false);

        this._kind = "DeleteContentsWithReferencesException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DeleteContentsWithReferencesException {
        return DeleteContentsWithReferencesException.fromJS(data);
     }

    static fromJS(data: any): DeleteContentsWithReferencesException {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContentsWithReferencesException();
        result.init(data);
        return result;
    }

}

export interface IDeleteContentsWithReferencesException extends IPictureparkValidationException {
    numberOfReferences: number;
    numberOfShares: number;
}

export class ContentMetadataUpdateManyException extends PictureparkBusinessException implements IContentMetadataUpdateManyException {
    failedItemsCount!: number;
    totalItemsCount!: number;

    constructor(data?: IContentMetadataUpdateManyException) {
        super(data);
        this.setProp("object", "number", "failedItemsCount", false);
        this.setProp("object", "number", "totalItemsCount", false);

        this._kind = "ContentMetadataUpdateManyException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentMetadataUpdateManyException {
        return ContentMetadataUpdateManyException.fromJS(data);
     }

    static fromJS(data: any): ContentMetadataUpdateManyException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateManyException();
        result.init(data);
        return result;
    }

}

export interface IContentMetadataUpdateManyException extends IPictureparkBusinessException {
    failedItemsCount: number;
    totalItemsCount: number;
}

export class ContentNotFoundException extends PictureparkNotFoundException implements IContentNotFoundException {
    contentIds?: string[] | undefined;

    constructor(data?: IContentNotFoundException) {
        super(data);
        this.setProp("array", "string[]", "contentIds", false);

        this._kind = "ContentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentNotFoundException {
        return ContentNotFoundException.fromJS(data);
     }

    static fromJS(data: any): ContentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IContentNotFoundException extends IPictureparkNotFoundException {
    contentIds?: string[] | undefined;
}

export class ContentLayerInvalidException extends PictureparkValidationException implements IContentLayerInvalidException {
    contentId?: string | undefined;
    layerIds?: string | undefined;

    constructor(data?: IContentLayerInvalidException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "layerIds", false);

        this._kind = "ContentLayerInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentLayerInvalidException {
        return ContentLayerInvalidException.fromJS(data);
     }

    static fromJS(data: any): ContentLayerInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentLayerInvalidException();
        result.init(data);
        return result;
    }

}

export interface IContentLayerInvalidException extends IPictureparkValidationException {
    contentId?: string | undefined;
    layerIds?: string | undefined;
}

export class ContentFileReplaceTypeMismatchException extends PictureparkValidationException implements IContentFileReplaceTypeMismatchException {
    contentId?: string | undefined;
    originalContentType!: ContentType;
    newContentType!: ContentType;

    constructor(data?: IContentFileReplaceTypeMismatchException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "ContentType", "originalContentType", false);
        this.setProp("object", "ContentType", "newContentType", false);

        this._kind = "ContentFileReplaceTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentFileReplaceTypeMismatchException {
        return ContentFileReplaceTypeMismatchException.fromJS(data);
     }

    static fromJS(data: any): ContentFileReplaceTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileReplaceTypeMismatchException();
        result.init(data);
        return result;
    }

}

export interface IContentFileReplaceTypeMismatchException extends IPictureparkValidationException {
    contentId?: string | undefined;
    originalContentType: ContentType;
    newContentType: ContentType;
}

/** Content types */
export enum ContentType {
    Unknown = "Unknown",
    Bitmap = "Bitmap",
    VectorGraphic = "VectorGraphic",
    RawImage = "RawImage",
    InterchangeDocument = "InterchangeDocument",
    WordProcessingDocument = "WordProcessingDocument",
    TextDocument = "TextDocument",
    DesktopPublishingDocument = "DesktopPublishingDocument",
    Presentation = "Presentation",
    Spreadsheet = "Spreadsheet",
    Archive = "Archive",
    Audio = "Audio",
    Video = "Video",
    Font = "Font",
    Multimedia = "Multimedia",
    Application = "Application",
    SourceCode = "SourceCode",
    Database = "Database",
    Cad = "Cad",
    Model3d = "Model3d",
    ContentItem = "ContentItem",
}

export class ContentBackupFailedException extends PictureparkBusinessException implements IContentBackupFailedException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    outputId?: string | undefined;

    constructor(data?: IContentBackupFailedException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);
        this.setProp("object", "string", "outputId", false);

        this._kind = "ContentBackupFailedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentBackupFailedException {
        return ContentBackupFailedException.fromJS(data);
     }

    static fromJS(data: any): ContentBackupFailedException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentBackupFailedException();
        result.init(data);
        return result;
    }

}

export interface IContentBackupFailedException extends IPictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    outputId?: string | undefined;
}

export class ContentLayerSameRootException extends PictureparkValidationException implements IContentLayerSameRootException {
    contentId?: string | undefined;
    layerIdsByRootSchema?: LayerIdsByRootSchema[] | undefined;

    constructor(data?: IContentLayerSameRootException) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("array", "LayerIdsByRootSchema[]", "layerIdsByRootSchema", true, (item: any) => LayerIdsByRootSchema.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "ContentLayerSameRootException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentLayerSameRootException {
        return ContentLayerSameRootException.fromJS(data);
     }

    static fromJS(data: any): ContentLayerSameRootException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentLayerSameRootException();
        result.init(data);
        return result;
    }

}

export interface IContentLayerSameRootException extends IPictureparkValidationException {
    contentId?: string | undefined;
    layerIdsByRootSchema?: ILayerIdsByRootSchema[] | undefined;
}

export class LayerIdsByRootSchema extends DTOBase {
    rootSchemaId?: string | undefined;
    layerSchemaIds?: string[] | undefined;

    constructor(data?: ILayerIdsByRootSchema) {
        super(data);
        this.setProp("object", "string", "rootSchemaId", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LayerIdsByRootSchema {
        return LayerIdsByRootSchema.fromJS(data);
     }

    static fromJS(data: any): LayerIdsByRootSchema {
        data = typeof data === 'object' ? data : {};
        let result = new LayerIdsByRootSchema();
        result.init(data);
        return result;
    }

}

export interface ILayerIdsByRootSchema {
    rootSchemaId?: string | undefined;
    layerSchemaIds?: string[] | undefined;
}

export class BusinessProcessEngineRequestException extends PictureparkBusinessException implements IBusinessProcessEngineRequestException {
    businessProcessId?: string | undefined;
    engineError?: string | undefined;

    constructor(data?: IBusinessProcessEngineRequestException) {
        super(data);
        this.setProp("object", "string", "businessProcessId", false);
        this.setProp("object", "string", "engineError", false);

        this._kind = "BusinessProcessEngineRequestException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessEngineRequestException {
        return BusinessProcessEngineRequestException.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessEngineRequestException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessEngineRequestException();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessEngineRequestException extends IPictureparkBusinessException {
    businessProcessId?: string | undefined;
    engineError?: string | undefined;
}

export class BusinessProcessNotFoundException extends PictureparkNotFoundException implements IBusinessProcessNotFoundException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessNotFoundException) {
        super(data);
        this.setProp("object", "string", "businessProcessId", false);

        this._kind = "BusinessProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessNotFoundException {
        return BusinessProcessNotFoundException.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessNotFoundException extends IPictureparkNotFoundException {
    businessProcessId?: string | undefined;
}

export class BusinessProcessDefinitionNotFoundException extends PictureparkNotFoundException implements IBusinessProcessDefinitionNotFoundException {
    processDefinitionId?: string | undefined;

    constructor(data?: IBusinessProcessDefinitionNotFoundException) {
        super(data);
        this.setProp("object", "string", "processDefinitionId", false);

        this._kind = "BusinessProcessDefinitionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        return BusinessProcessDefinitionNotFoundException.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDefinitionNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessDefinitionNotFoundException extends IPictureparkNotFoundException {
    processDefinitionId?: string | undefined;
}

export class BusinessProcessDefinitionCreateException extends PictureparkBusinessException implements IBusinessProcessDefinitionCreateException {
    processDefinitionIds?: string[] | undefined;

    constructor(data?: IBusinessProcessDefinitionCreateException) {
        super(data);
        this.setProp("array", "string[]", "processDefinitionIds", false);

        this._kind = "BusinessProcessDefinitionCreateException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDefinitionCreateException {
        return BusinessProcessDefinitionCreateException.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDefinitionCreateException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDefinitionCreateException();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessDefinitionCreateException extends IPictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export class SchemaFieldImportMismatchException extends PictureparkValidationException implements ISchemaFieldImportMismatchException {
    schemaId?: string | undefined;
    importingFieldIds?: string | undefined;
    existingFieldIds?: string | undefined;

    constructor(data?: ISchemaFieldImportMismatchException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "importingFieldIds", false);
        this.setProp("object", "string", "existingFieldIds", false);

        this._kind = "SchemaFieldImportMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldImportMismatchException {
        return SchemaFieldImportMismatchException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldImportMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportMismatchException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldImportMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    importingFieldIds?: string | undefined;
    existingFieldIds?: string | undefined;
}

export class SchemaFieldImportRelatedSchemaMismatchException extends PictureparkValidationException implements ISchemaFieldImportRelatedSchemaMismatchException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingRelatedSchemaId?: string | undefined;
    existingRelatedSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldImportRelatedSchemaMismatchException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "importingRelatedSchemaId", false);
        this.setProp("object", "string", "existingRelatedSchemaId", false);

        this._kind = "SchemaFieldImportRelatedSchemaMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldImportRelatedSchemaMismatchException {
        return SchemaFieldImportRelatedSchemaMismatchException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldImportRelatedSchemaMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportRelatedSchemaMismatchException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldImportRelatedSchemaMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingRelatedSchemaId?: string | undefined;
    existingRelatedSchemaId?: string | undefined;
}

export class SchemaFieldImportTypeMismatchException extends PictureparkValidationException implements ISchemaFieldImportTypeMismatchException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingFieldType?: string | undefined;
    existingFieldType?: string | undefined;

    constructor(data?: ISchemaFieldImportTypeMismatchException) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "importingFieldType", false);
        this.setProp("object", "string", "existingFieldType", false);

        this._kind = "SchemaFieldImportTypeMismatchException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldImportTypeMismatchException {
        return SchemaFieldImportTypeMismatchException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldImportTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportTypeMismatchException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldImportTypeMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingFieldType?: string | undefined;
    existingFieldType?: string | undefined;
}

export class SchemaFieldNotSupportedException extends PictureparkValidationException implements ISchemaFieldNotSupportedException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldType?: string | undefined;

    constructor(data?: ISchemaFieldNotSupportedException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "string", "fieldType", false);

        this._kind = "SchemaFieldNotSupportedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldNotSupportedException {
        return SchemaFieldNotSupportedException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSupportedException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldNotSupportedException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldType?: string | undefined;
}

export class SchemaFieldDisplayPatternTypeNotSupportedException extends PictureparkValidationException implements ISchemaFieldDisplayPatternTypeNotSupportedException {
    fieldId?: string | undefined;
    displayPatternType!: DisplayPatternType;
    supportedDisplayPatternTypes?: DisplayPatternType[] | undefined;

    constructor(data?: ISchemaFieldDisplayPatternTypeNotSupportedException) {
        super(data);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "DisplayPatternType", "displayPatternType", false);
        this.setProp("array", "DisplayPatternType[]", "supportedDisplayPatternTypes", false);

        this._kind = "SchemaFieldDisplayPatternTypeNotSupportedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaFieldDisplayPatternTypeNotSupportedException {
        return SchemaFieldDisplayPatternTypeNotSupportedException.fromJS(data);
     }

    static fromJS(data: any): SchemaFieldDisplayPatternTypeNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
        result.init(data);
        return result;
    }

}

export interface ISchemaFieldDisplayPatternTypeNotSupportedException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    displayPatternType: DisplayPatternType;
    supportedDisplayPatternTypes?: DisplayPatternType[] | undefined;
}

export class SnapshotTimeoutException extends PictureparkTimeoutException implements ISnapshotTimeoutException {

    constructor(data?: ISnapshotTimeoutException) {
        super(data);

        this._kind = "SnapshotTimeoutException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SnapshotTimeoutException {
        return SnapshotTimeoutException.fromJS(data);
     }

    static fromJS(data: any): SnapshotTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotTimeoutException();
        result.init(data);
        return result;
    }

}

export interface ISnapshotTimeoutException extends IPictureparkTimeoutException {
}

export class SnapshotFailedException extends PictureparkBusinessException implements ISnapshotFailedException {

    constructor(data?: ISnapshotFailedException) {
        super(data);

        this._kind = "SnapshotFailedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SnapshotFailedException {
        return SnapshotFailedException.fromJS(data);
     }

    static fromJS(data: any): SnapshotFailedException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotFailedException();
        result.init(data);
        return result;
    }

}

export interface ISnapshotFailedException extends IPictureparkBusinessException {
}

export class SnapshotSkippedException extends PictureparkBusinessException implements ISnapshotSkippedException {

    constructor(data?: ISnapshotSkippedException) {
        super(data);

        this._kind = "SnapshotSkippedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SnapshotSkippedException {
        return SnapshotSkippedException.fromJS(data);
     }

    static fromJS(data: any): SnapshotSkippedException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotSkippedException();
        result.init(data);
        return result;
    }

}

export interface ISnapshotSkippedException extends IPictureparkBusinessException {
}

export class AddMetadataLanguageTimeoutException extends PictureparkTimeoutException implements IAddMetadataLanguageTimeoutException {
    environmentProcessId?: string | undefined;

    constructor(data?: IAddMetadataLanguageTimeoutException) {
        super(data);
        this.setProp("object", "string", "environmentProcessId", false);

        this._kind = "AddMetadataLanguageTimeoutException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AddMetadataLanguageTimeoutException {
        return AddMetadataLanguageTimeoutException.fromJS(data);
     }

    static fromJS(data: any): AddMetadataLanguageTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new AddMetadataLanguageTimeoutException();
        result.init(data);
        return result;
    }

}

export interface IAddMetadataLanguageTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string | undefined;
}

export class EnvironmentProcessAlreadyRunningException extends PictureparkValidationException implements IEnvironmentProcessAlreadyRunningException {
    environmentProcessType!: EnvironmentProcessType;

    constructor(data?: IEnvironmentProcessAlreadyRunningException) {
        super(data);
        this.setProp("object", "EnvironmentProcessType", "environmentProcessType", false);

        this._kind = "EnvironmentProcessAlreadyRunningException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentProcessAlreadyRunningException {
        return EnvironmentProcessAlreadyRunningException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentProcessAlreadyRunningException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessAlreadyRunningException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentProcessAlreadyRunningException extends IPictureparkValidationException {
    environmentProcessType: EnvironmentProcessType;
}

export enum EnvironmentProcessType {
    AddMetadataLanguage = "AddMetadataLanguage",
    CustomerUpdate = "CustomerUpdate",
    EnvironmentUpdate = "EnvironmentUpdate",
    CustomerBoostValuesUpdate = "CustomerBoostValuesUpdate",
}

export class EnvironmentProcessNotFoundException extends PictureparkNotFoundException implements IEnvironmentProcessNotFoundException {
    environmentProcessId?: string | undefined;

    constructor(data?: IEnvironmentProcessNotFoundException) {
        super(data);
        this.setProp("object", "string", "environmentProcessId", false);

        this._kind = "EnvironmentProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentProcessNotFoundException {
        return EnvironmentProcessNotFoundException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentProcessNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessNotFoundException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentProcessNotFoundException extends IPictureparkNotFoundException {
    environmentProcessId?: string | undefined;
}

export class EnvironmentProcessWaitTimeoutException extends PictureparkTimeoutException implements IEnvironmentProcessWaitTimeoutException {
    environmentProcessId?: string | undefined;
    waitedLifecycles?: string | undefined;

    constructor(data?: IEnvironmentProcessWaitTimeoutException) {
        super(data);
        this.setProp("object", "string", "environmentProcessId", false);
        this.setProp("object", "string", "waitedLifecycles", false);

        this._kind = "EnvironmentProcessWaitTimeoutException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentProcessWaitTimeoutException {
        return EnvironmentProcessWaitTimeoutException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentProcessWaitTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessWaitTimeoutException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentProcessWaitTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string | undefined;
    waitedLifecycles?: string | undefined;
}

export class CustomerBoostValuesUpdateTimeoutException extends PictureparkTimeoutException implements ICustomerBoostValuesUpdateTimeoutException {
    environmentProcessId?: string | undefined;

    constructor(data?: ICustomerBoostValuesUpdateTimeoutException) {
        super(data);
        this.setProp("object", "string", "environmentProcessId", false);

        this._kind = "CustomerBoostValuesUpdateTimeoutException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerBoostValuesUpdateTimeoutException {
        return CustomerBoostValuesUpdateTimeoutException.fromJS(data);
     }

    static fromJS(data: any): CustomerBoostValuesUpdateTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBoostValuesUpdateTimeoutException();
        result.init(data);
        return result;
    }

}

export interface ICustomerBoostValuesUpdateTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string | undefined;
}

export class NoTermsOfServiceDefinedException extends PictureparkBusinessException implements INoTermsOfServiceDefinedException {

    constructor(data?: INoTermsOfServiceDefinedException) {
        super(data);

        this._kind = "NoTermsOfServiceDefinedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NoTermsOfServiceDefinedException {
        return NoTermsOfServiceDefinedException.fromJS(data);
     }

    static fromJS(data: any): NoTermsOfServiceDefinedException {
        data = typeof data === 'object' ? data : {};
        let result = new NoTermsOfServiceDefinedException();
        result.init(data);
        return result;
    }

}

export interface INoTermsOfServiceDefinedException extends IPictureparkBusinessException {
}

export class AtLeastOneActiveTermsOfServiceMustExistException extends PictureparkValidationException implements IAtLeastOneActiveTermsOfServiceMustExistException {

    constructor(data?: IAtLeastOneActiveTermsOfServiceMustExistException) {
        super(data);

        this._kind = "AtLeastOneActiveTermsOfServiceMustExistException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AtLeastOneActiveTermsOfServiceMustExistException {
        return AtLeastOneActiveTermsOfServiceMustExistException.fromJS(data);
     }

    static fromJS(data: any): AtLeastOneActiveTermsOfServiceMustExistException {
        data = typeof data === 'object' ? data : {};
        let result = new AtLeastOneActiveTermsOfServiceMustExistException();
        result.init(data);
        return result;
    }

}

export interface IAtLeastOneActiveTermsOfServiceMustExistException extends IPictureparkValidationException {
}

export class ForbiddenHtmlElementsUsedException extends PictureparkValidationException implements IForbiddenHtmlElementsUsedException {

    constructor(data?: IForbiddenHtmlElementsUsedException) {
        super(data);

        this._kind = "ForbiddenHtmlElementsUsedException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ForbiddenHtmlElementsUsedException {
        return ForbiddenHtmlElementsUsedException.fromJS(data);
     }

    static fromJS(data: any): ForbiddenHtmlElementsUsedException {
        data = typeof data === 'object' ? data : {};
        let result = new ForbiddenHtmlElementsUsedException();
        result.init(data);
        return result;
    }

}

export interface IForbiddenHtmlElementsUsedException extends IPictureparkValidationException {
}

export class BusinessProcessStateNotHitException extends PictureparkTimeoutException implements IBusinessProcessStateNotHitException {
    businessProcessId?: string | undefined;
    expected?: string[] | undefined;
    actual?: string | undefined;

    constructor(data?: IBusinessProcessStateNotHitException) {
        super(data);
        this.setProp("object", "string", "businessProcessId", false);
        this.setProp("array", "string[]", "expected", false);
        this.setProp("object", "string", "actual", false);

        this._kind = "BusinessProcessStateNotHitException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessStateNotHitException {
        return BusinessProcessStateNotHitException.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessStateNotHitException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessStateNotHitException();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessStateNotHitException extends IPictureparkTimeoutException {
    businessProcessId?: string | undefined;
    expected?: string[] | undefined;
    actual?: string | undefined;
}

export class BusinessProcessLifeCycleNotHitException extends PictureparkTimeoutException implements IBusinessProcessLifeCycleNotHitException {
    businessProcessId?: string | undefined;
    expected?: BusinessProcessLifeCycle[] | undefined;
    actual!: BusinessProcessLifeCycle;

    constructor(data?: IBusinessProcessLifeCycleNotHitException) {
        super(data);
        this.setProp("object", "string", "businessProcessId", false);
        this.setProp("array", "BusinessProcessLifeCycle[]", "expected", false);
        this.setProp("object", "BusinessProcessLifeCycle", "actual", false);

        this._kind = "BusinessProcessLifeCycleNotHitException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessLifeCycleNotHitException {
        return BusinessProcessLifeCycleNotHitException.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessLifeCycleNotHitException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessLifeCycleNotHitException();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessLifeCycleNotHitException extends IPictureparkTimeoutException {
    businessProcessId?: string | undefined;
    expected?: BusinessProcessLifeCycle[] | undefined;
    actual: BusinessProcessLifeCycle;
}

export class OnlyAccessibleToRecipientException extends PictureparkValidationException implements IOnlyAccessibleToRecipientException {

    constructor(data?: IOnlyAccessibleToRecipientException) {
        super(data);

        this._kind = "OnlyAccessibleToRecipientException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OnlyAccessibleToRecipientException {
        return OnlyAccessibleToRecipientException.fromJS(data);
     }

    static fromJS(data: any): OnlyAccessibleToRecipientException {
        data = typeof data === 'object' ? data : {};
        let result = new OnlyAccessibleToRecipientException();
        result.init(data);
        return result;
    }

}

export interface IOnlyAccessibleToRecipientException extends IPictureparkValidationException {
}

export class EnvironmentNotAvailableException extends PictureparkException implements IEnvironmentNotAvailableException {

    constructor(data?: IEnvironmentNotAvailableException) {
        super(data);

        this._kind = "EnvironmentNotAvailableException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EnvironmentNotAvailableException {
        return EnvironmentNotAvailableException.fromJS(data);
     }

    static fromJS(data: any): EnvironmentNotAvailableException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotAvailableException();
        result.init(data);
        return result;
    }

}

export interface IEnvironmentNotAvailableException extends IPictureparkException {
}

export class CustomerNotAvailableException extends PictureparkException implements ICustomerNotAvailableException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotAvailableException) {
        super(data);
        this.setProp("object", "string", "customerId", false);

        this._kind = "CustomerNotAvailableException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerNotAvailableException {
        return CustomerNotAvailableException.fromJS(data);
     }

    static fromJS(data: any): CustomerNotAvailableException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotAvailableException();
        result.init(data);
        return result;
    }

}

export interface ICustomerNotAvailableException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerAliasHeaderMissingException extends PictureparkValidationException implements ICustomerAliasHeaderMissingException {

    constructor(data?: ICustomerAliasHeaderMissingException) {
        super(data);

        this._kind = "CustomerAliasHeaderMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerAliasHeaderMissingException {
        return CustomerAliasHeaderMissingException.fromJS(data);
     }

    static fromJS(data: any): CustomerAliasHeaderMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasHeaderMissingException();
        result.init(data);
        return result;
    }

}

export interface ICustomerAliasHeaderMissingException extends IPictureparkValidationException {
}

export class BusinessRuleActionInvalidDocumentTypeException extends PictureparkValidationException implements IBusinessRuleActionInvalidDocumentTypeException {
    allowedDocumentTypes?: BusinessRuleTriggerDocType[] | undefined;

    constructor(data?: IBusinessRuleActionInvalidDocumentTypeException) {
        super(data);
        this.setProp("array", "BusinessRuleTriggerDocType[]", "allowedDocumentTypes", false);

        this._kind = "BusinessRuleActionInvalidDocumentTypeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleActionInvalidDocumentTypeException {
        return BusinessRuleActionInvalidDocumentTypeException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleActionInvalidDocumentTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleActionInvalidDocumentTypeException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleActionInvalidDocumentTypeException extends IPictureparkValidationException {
    allowedDocumentTypes?: BusinessRuleTriggerDocType[] | undefined;
}

export enum BusinessRuleTriggerDocType {
    Content = "Content",
}

export class BusinessRuleActionInvalidExecutionScopeException extends PictureparkValidationException implements IBusinessRuleActionInvalidExecutionScopeException {
    allowedScopes?: BusinessRuleExecutionScope[] | undefined;

    constructor(data?: IBusinessRuleActionInvalidExecutionScopeException) {
        super(data);
        this.setProp("array", "BusinessRuleExecutionScope[]", "allowedScopes", false);

        this._kind = "BusinessRuleActionInvalidExecutionScopeException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleActionInvalidExecutionScopeException {
        return BusinessRuleActionInvalidExecutionScopeException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleActionInvalidExecutionScopeException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleActionInvalidExecutionScopeException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleActionInvalidExecutionScopeException extends IPictureparkValidationException {
    allowedScopes?: BusinessRuleExecutionScope[] | undefined;
}

export enum BusinessRuleExecutionScope {
    MainDoc = "MainDoc",
    SearchDoc = "SearchDoc",
}

export class BusinessRuleActionsMissingException extends PictureparkValidationException implements IBusinessRuleActionsMissingException {

    constructor(data?: IBusinessRuleActionsMissingException) {
        super(data);

        this._kind = "BusinessRuleActionsMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleActionsMissingException {
        return BusinessRuleActionsMissingException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleActionsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleActionsMissingException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleActionsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleConditionMissingException extends PictureparkValidationException implements IBusinessRuleConditionMissingException {

    constructor(data?: IBusinessRuleConditionMissingException) {
        super(data);

        this._kind = "BusinessRuleConditionMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleConditionMissingException {
        return BusinessRuleConditionMissingException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleConditionMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConditionMissingException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleConditionMissingException extends IPictureparkValidationException {
}

export class BusinessRuleConditionsMissingException extends PictureparkValidationException implements IBusinessRuleConditionsMissingException {

    constructor(data?: IBusinessRuleConditionsMissingException) {
        super(data);

        this._kind = "BusinessRuleConditionsMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleConditionsMissingException {
        return BusinessRuleConditionsMissingException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleConditionsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConditionsMissingException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleConditionsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleConfigurationValidationException extends PictureparkValidationException implements IBusinessRuleConfigurationValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;

    constructor(data?: IBusinessRuleConfigurationValidationException) {
        super(data);
        this.setProp("array", "PictureparkValidationException[]", "innerExceptions", true, (item: any) => PictureparkValidationException.fromJS(item));

        this._kind = "BusinessRuleConfigurationValidationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleConfigurationValidationException {
        return BusinessRuleConfigurationValidationException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleConfigurationValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfigurationValidationException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleConfigurationValidationException extends IPictureparkValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export class BusinessRuleLayerIdInvalidException extends PictureparkValidationException implements IBusinessRuleLayerIdInvalidException {
    layerId?: string | undefined;

    constructor(data?: IBusinessRuleLayerIdInvalidException) {
        super(data);
        this.setProp("object", "string", "layerId", false);

        this._kind = "BusinessRuleLayerIdInvalidException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleLayerIdInvalidException {
        return BusinessRuleLayerIdInvalidException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleLayerIdInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleLayerIdInvalidException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleLayerIdInvalidException extends IPictureparkValidationException {
    layerId?: string | undefined;
}

export class BusinessRuleRuleIdDuplicationException extends PictureparkValidationException implements IBusinessRuleRuleIdDuplicationException {

    constructor(data?: IBusinessRuleRuleIdDuplicationException) {
        super(data);

        this._kind = "BusinessRuleRuleIdDuplicationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleRuleIdDuplicationException {
        return BusinessRuleRuleIdDuplicationException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleRuleIdDuplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleRuleIdDuplicationException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleRuleIdDuplicationException extends IPictureparkValidationException {
}

export class BusinessRuleRuleIdMissingException extends PictureparkValidationException implements IBusinessRuleRuleIdMissingException {

    constructor(data?: IBusinessRuleRuleIdMissingException) {
        super(data);

        this._kind = "BusinessRuleRuleIdMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleRuleIdMissingException {
        return BusinessRuleRuleIdMissingException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleRuleIdMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleRuleIdMissingException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleRuleIdMissingException extends IPictureparkValidationException {
}

export class BusinessRuleTriggerPointMissingException extends PictureparkValidationException implements IBusinessRuleTriggerPointMissingException {

    constructor(data?: IBusinessRuleTriggerPointMissingException) {
        super(data);

        this._kind = "BusinessRuleTriggerPointMissingException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleTriggerPointMissingException {
        return BusinessRuleTriggerPointMissingException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleTriggerPointMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTriggerPointMissingException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleTriggerPointMissingException extends IPictureparkValidationException {
}

export class BusinessRuleValidationException extends PictureparkValidationException implements IBusinessRuleValidationException {
    ruleId?: string | undefined;
    innerExceptions?: PictureparkValidationException[] | undefined;

    constructor(data?: IBusinessRuleValidationException) {
        super(data);
        this.setProp("object", "string", "ruleId", false);
        this.setProp("array", "PictureparkValidationException[]", "innerExceptions", true, (item: any) => PictureparkValidationException.fromJS(item));

        this._kind = "BusinessRuleValidationException";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleValidationException {
        return BusinessRuleValidationException.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleValidationException();
        result.init(data);
        return result;
    }

}

export interface IBusinessRuleValidationException extends IPictureparkValidationException {
    ruleId?: string | undefined;
    innerExceptions?: PictureparkValidationException[] | undefined;
}

/** Search request to search for business processes */
export class BusinessProcessSearchRequest extends DTOBase {
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: IBusinessProcessSearchRequest) {
        super(data);
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("object", "boolean", "debugMode", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessSearchRequest {
        return BusinessProcessSearchRequest.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchRequest();
        result.init(data);
        return result;
    }

}

/** Search request to search for business processes */
export interface IBusinessProcessSearchRequest {
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

/** The filters' base class */
export class FilterBase extends DTOBase {

    protected _kind: string;

    getDisplayName(locale: string): string | null {
        return null;
    }

    constructor(data?: IFilterBase) {
        super(data);

        this._kind = "FilterBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FilterBase {
        return FilterBase.fromJS(data);
     }

    static fromJS(data: any): FilterBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AndFilter") {
            let result = new AndFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrFilter") {
            let result = new OrFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFilter") {
            let result = new NotFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DateRangeFilter") {
            let result = new DateRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ExistsFilter") {
            let result = new ExistsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoBoundingBoxFilter") {
            let result = new GeoBoundingBoxFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceFilter") {
            let result = new GeoDistanceFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedFilter") {
            let result = new NestedFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeFilter") {
            let result = new NumericRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PrefixFilter") {
            let result = new PrefixFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermFilter") {
            let result = new TermFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsFilter") {
            let result = new TermsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilter") {
            let result = new AggregationFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChildFilter") {
            let result = new ChildFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ParentFilter") {
            let result = new ParentFilter();
            result.init(data);
            return result;
        }
        let result = new FilterBase();
        result.init(data);
        return result;
    }

}

/** The filters' base class */
export interface IFilterBase {
}

/** Used to put filters in "and" */
export class AndFilter extends FilterBase implements IAndFilter {
    /** The filters to put in "and". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IAndFilter) {
        super(data);
        this.setProp("array", "FilterBase[]", "filters", true, (item: any) => FilterBase.fromJS(item));

        this._kind = "AndFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AndFilter {
        return AndFilter.fromJS(data);
     }

    static fromJS(data: any): AndFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AndFilter();
        result.init(data);
        return result;
    }

}

/** Used to put filters in "and" */
export interface IAndFilter extends IFilterBase {
    /** The filters to put in "and". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;
}

/** Put filters in "or" */
export class OrFilter extends FilterBase implements IOrFilter {
    /** The filters to put in "or". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IOrFilter) {
        super(data);
        this.setProp("array", "FilterBase[]", "filters", true, (item: any) => FilterBase.fromJS(item));

        this._kind = "OrFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OrFilter {
        return OrFilter.fromJS(data);
     }

    static fromJS(data: any): OrFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OrFilter();
        result.init(data);
        return result;
    }

}

/** Put filters in "or" */
export interface IOrFilter extends IFilterBase {
    /** The filters to put in "or". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;
}

/** Negates the specified filter */
export class NotFilter extends FilterBase implements INotFilter {
    /** The filter to be negated. */
    filter!: FilterBase;

    constructor(data?: INotFilter) {
        super(data);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

        if (!data) {
            this.filter = new FilterBase();
        }
        this._kind = "NotFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NotFilter {
        return NotFilter.fromJS(data);
     }

    static fromJS(data: any): NotFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NotFilter();
        result.init(data);
        return result;
    }

}

/** Negates the specified filter */
export interface INotFilter extends IFilterBase {
    /** The filter to be negated. */
    filter: FilterBase;
}

/** Filters over a range of date time values */
export class DateRangeFilter extends FilterBase implements IDateRangeFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The date time range. */
    range!: DateRange;

    getDisplayName(locale: string) {
        return this.range && this.range.names ? this.range.names.translate(locale) : 'n/a';
    }

    constructor(data?: IDateRangeFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "DateRange", "range", true, (item: any) => DateRange.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.range = new DateRange();
        }
        this._kind = "DateRangeFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DateRangeFilter {
        return DateRangeFilter.fromJS(data);
     }

    static fromJS(data: any): DateRangeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeFilter();
        result.init(data);
        return result;
    }

}

/** Filters over a range of date time values */
export interface IDateRangeFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The date time range. */
    range: IDateRange;
}

/** The date time range class used in filters */
export class DateRange extends DTOBase {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRange) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "from", false);
        this.setProp("object", "string", "to", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DateRange {
        return DateRange.fromJS(data);
     }

    static fromJS(data: any): DateRange {
        data = typeof data === 'object' ? data : {};
        let result = new DateRange();
        result.init(data);
        return result;
    }

}

/** The date time range class used in filters */
export interface IDateRange {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** A custom dictionary type to distinguish language specific class properties. */
export class TranslatedStringDictionary extends DTOBase {

    [key: string]: string | any; 

    translate(locale: string) {
        const language = locale.split('-')[0];
        return this[language] ? this[language] : this[Object.keys(this)[0]];
    }

    constructor(data?: ITranslatedStringDictionary) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

     fromJS(data: any): TranslatedStringDictionary {
        return TranslatedStringDictionary.fromJS(data);
     }

    static fromJS(data: any): TranslatedStringDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new TranslatedStringDictionary();
        result.init(data);
        return result;
    }

}

/** A custom dictionary type to distinguish language specific class properties. */
export interface ITranslatedStringDictionary {

    [key: string]: string | any; 
}

/** Filters over the existence of a field's value */
export class ExistsFilter extends FilterBase implements IExistsFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;

    constructor(data?: IExistsFilter) {
        super(data);
        this.setProp("object", "string", "field", false);

        this._kind = "ExistsFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ExistsFilter {
        return ExistsFilter.fromJS(data);
     }

    static fromJS(data: any): ExistsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ExistsFilter();
        result.init(data);
        return result;
    }

}

/** Filters over the existence of a field's value */
export interface IExistsFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
}

/** Filters geo point values based on a bounding box */
export class GeoBoundingBoxFilter extends FilterBase implements IGeoBoundingBoxFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The top left corner of the bounding box's geo location (latitude and longitude). */
    topLeft!: GeoLocation;
    /** The bottom right corner of the bounding box's geo location (latitude and longitude). */
    bottomRight!: GeoLocation;

    constructor(data?: IGeoBoundingBoxFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "GeoLocation", "topLeft", true, (item: any) => GeoLocation.fromJS(item));
        this.setProp("object", "GeoLocation", "bottomRight", true, (item: any) => GeoLocation.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.topLeft = new GeoLocation();
            this.bottomRight = new GeoLocation();
        }
        this._kind = "GeoBoundingBoxFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): GeoBoundingBoxFilter {
        return GeoBoundingBoxFilter.fromJS(data);
     }

    static fromJS(data: any): GeoBoundingBoxFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoBoundingBoxFilter();
        result.init(data);
        return result;
    }

}

/** Filters geo point values based on a bounding box */
export interface IGeoBoundingBoxFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The top left corner of the bounding box's geo location (latitude and longitude). */
    topLeft: IGeoLocation;
    /** The bottom right corner of the bounding box's geo location (latitude and longitude). */
    bottomRight: IGeoLocation;
}

/** It stores geo location information (latitude and longitude) */
export class GeoLocation extends DTOBase {
    /** The latitude */
    lat!: number;
    /** The longitude */
    lon!: number;

    constructor(data?: IGeoLocation) {
        super(data);
        this.setProp("object", "number", "lat", false);
        this.setProp("object", "number", "lon", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): GeoLocation {
        return GeoLocation.fromJS(data);
     }

    static fromJS(data: any): GeoLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeoLocation();
        result.init(data);
        return result;
    }

}

/** It stores geo location information (latitude and longitude) */
export interface IGeoLocation {
    /** The latitude */
    lat: number;
    /** The longitude */
    lon: number;
}

/** Filters within the radius of the distance from a location */
export class GeoDistanceFilter extends FilterBase implements IGeoDistanceFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location!: GeoLocation;
    /** The distance in meters from the point of origin. */
    distance!: number;

    constructor(data?: IGeoDistanceFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "GeoLocation", "location", true, (item: any) => GeoLocation.fromJS(item));
        this.setProp("object", "number", "distance", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.location = new GeoLocation();
        }
        this._kind = "GeoDistanceFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): GeoDistanceFilter {
        return GeoDistanceFilter.fromJS(data);
     }

    static fromJS(data: any): GeoDistanceFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

}

/** Filters within the radius of the distance from a location */
export interface IGeoDistanceFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location: IGeoLocation;
    /** The distance in meters from the point of origin. */
    distance: number;
}

/** Filters on nested documents */
export class NestedFilter extends FilterBase implements INestedFilter {
    /** The path pointing to the nested document (i.e. personLayer.nestedAddress). */
    path!: string;
    /** The filter to be applied on the nested documents. */
    filter!: FilterBase;

    constructor(data?: INestedFilter) {
        super(data);
        this.setProp("object", "string", "path", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

        if (!data) {
            this.filter = new FilterBase();
        }
        this._kind = "NestedFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NestedFilter {
        return NestedFilter.fromJS(data);
     }

    static fromJS(data: any): NestedFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NestedFilter();
        result.init(data);
        return result;
    }

}

/** Filters on nested documents */
export interface INestedFilter extends IFilterBase {
    /** The path pointing to the nested document (i.e. personLayer.nestedAddress). */
    path: string;
    /** The filter to be applied on the nested documents. */
    filter: FilterBase;
}

/** Filters over a range of numeric values */
export class NumericRangeFilter extends FilterBase implements INumericRangeFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The numeric range on which filtering. */
    range!: NumericRange;

    constructor(data?: INumericRangeFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "NumericRange", "range", true, (item: any) => NumericRange.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.range = new NumericRange();
        }
        this._kind = "NumericRangeFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NumericRangeFilter {
        return NumericRangeFilter.fromJS(data);
     }

    static fromJS(data: any): NumericRangeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeFilter();
        result.init(data);
        return result;
    }

}

/** Filters over a range of numeric values */
export interface INumericRangeFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The numeric range on which filtering. */
    range: INumericRange;
}

/** The numeric range class */
export class NumericRange extends DTOBase {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRange) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "number", "from", false);
        this.setProp("object", "number", "to", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NumericRange {
        return NumericRange.fromJS(data);
     }

    static fromJS(data: any): NumericRange {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRange();
        result.init(data);
        return result;
    }

}

/** The numeric range class */
export interface INumericRange {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** Filters field's values based on a prefix */
export class PrefixFilter extends FilterBase implements IPrefixFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The value to be used as prefix. */
    prefix!: string;

    constructor(data?: IPrefixFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "string", "prefix", false);

        this._kind = "PrefixFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PrefixFilter {
        return PrefixFilter.fromJS(data);
     }

    static fromJS(data: any): PrefixFilter {
        data = typeof data === 'object' ? data : {};
        let result = new PrefixFilter();
        result.init(data);
        return result;
    }

}

/** Filters field's values based on a prefix */
export interface IPrefixFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The value to be used as prefix. */
    prefix: string;
}

/** Filters values exactly containing a term */
export class TermFilter extends FilterBase implements ITermFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The value to use to filter on. */
    term!: string;

    constructor(data?: ITermFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "string", "term", false);

        this._kind = "TermFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermFilter {
        return TermFilter.fromJS(data);
     }

    static fromJS(data: any): TermFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TermFilter();
        result.init(data);
        return result;
    }

}

/** Filters values exactly containing a term */
export interface ITermFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The value to use to filter on. */
    term: string;
}

/** Filters values containing at least one of the terms */
export class TermsFilter extends FilterBase implements ITermsFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The list of values to be filtered on. At least one must match to return results. */
    terms!: string[];

    constructor(data?: ITermsFilter) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("array", "string[]", "terms", false);

        if (!data) {
            this.terms = [];
        }
        this._kind = "TermsFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermsFilter {
        return TermsFilter.fromJS(data);
     }

    static fromJS(data: any): TermsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TermsFilter();
        result.init(data);
        return result;
    }

}

/** Filters values containing at least one of the terms */
export interface ITermsFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The list of values to be filtered on. At least one must match to return results. */
    terms: string[];
}

/** Filters aggregations */
export class AggregationFilter extends FilterBase implements IAggregationFilter {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The filter to be applied. */
    filter?: FilterBase | undefined;
    /** Autogenerated Guid at request time, for precise aggregation result mapping. */
    temporaryAggregatorRequestId?: string | undefined;

    constructor(data?: IAggregationFilter) {
        super(data);
        this.setProp("object", "string", "aggregationName", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "string", "temporaryAggregatorRequestId", false);

        this._kind = "AggregationFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregationFilter {
        return AggregationFilter.fromJS(data);
     }

    static fromJS(data: any): AggregationFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationFilter();
        result.init(data);
        return result;
    }

}

/** Filters aggregations */
export interface IAggregationFilter extends IFilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The filter to be applied. */
    filter?: FilterBase | undefined;
    /** Autogenerated Guid at request time, for precise aggregation result mapping. */
    temporaryAggregatorRequestId?: string | undefined;
}

/** Filters on child documents */
export class ChildFilter extends FilterBase implements IChildFilter {
    /** The type of the child document. */
    childType!: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter!: FilterBase;

    constructor(data?: IChildFilter) {
        super(data);
        this.setProp("object", "string", "childType", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

        if (!data) {
            this.filter = new FilterBase();
        }
        this._kind = "ChildFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ChildFilter {
        return ChildFilter.fromJS(data);
     }

    static fromJS(data: any): ChildFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ChildFilter();
        result.init(data);
        return result;
    }

}

/** Filters on child documents */
export interface IChildFilter extends IFilterBase {
    /** The type of the child document. */
    childType: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter: FilterBase;
}

/** Filters on parent documents */
export class ParentFilter extends FilterBase implements IParentFilter {
    /** The type of the parent document. */
    parentType!: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter!: FilterBase;

    constructor(data?: IParentFilter) {
        super(data);
        this.setProp("object", "string", "parentType", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

        if (!data) {
            this.filter = new FilterBase();
        }
        this._kind = "ParentFilter";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ParentFilter {
        return ParentFilter.fromJS(data);
     }

    static fromJS(data: any): ParentFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ParentFilter();
        result.init(data);
        return result;
    }

}

/** Filters on parent documents */
export interface IParentFilter extends IFilterBase {
    /** The type of the parent document. */
    parentType: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter: FilterBase;
}

/** Search behaviors */
export enum SearchBehavior {
    DropInvalidCharactersOnFailure = "DropInvalidCharactersOnFailure",
    WildcardOnSingleTerm = "WildcardOnSingleTerm",
    SimplifiedSearch = "SimplifiedSearch",
    WildcardOnEveryTerm = "WildcardOnEveryTerm",
    SimplifiedSearchOr = "SimplifiedSearchOr",
}

/** Result from waiting for life cycle(s) on a business process */
export class BusinessProcessWaitForLifeCycleResult extends DTOBase {
    /** The life cycle that was hit. */
    lifeCycleHit?: BusinessProcessLifeCycle | undefined;
    /** The business process. */
    businessProcess!: BusinessProcess;

    constructor(data?: IBusinessProcessWaitForLifeCycleResult) {
        super(data);
        this.setProp("object", "BusinessProcessLifeCycle", "lifeCycleHit", false);
        this.setProp("object", "BusinessProcess", "businessProcess", true, (item: any) => BusinessProcess.fromJS(item));

        if (!data) {
            this.businessProcess = new BusinessProcess();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessWaitForLifeCycleResult {
        return BusinessProcessWaitForLifeCycleResult.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessWaitForLifeCycleResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitForLifeCycleResult();
        result.init(data);
        return result;
    }

}

/** Result from waiting for life cycle(s) on a business process */
export interface IBusinessProcessWaitForLifeCycleResult {
    /** The life cycle that was hit. */
    lifeCycleHit?: BusinessProcessLifeCycle | undefined;
    /** The business process. */
    businessProcess: BusinessProcess;
}

/** Result from waiting for state(s) on a business process */
export class BusinessProcessWaitForStateResult extends DTOBase {
    /** The state that was hit. */
    stateHit?: string | undefined;
    /** The business process. */
    businessProcess!: BusinessProcess;

    constructor(data?: IBusinessProcessWaitForStateResult) {
        super(data);
        this.setProp("object", "string", "stateHit", false);
        this.setProp("object", "BusinessProcess", "businessProcess", true, (item: any) => BusinessProcess.fromJS(item));

        if (!data) {
            this.businessProcess = new BusinessProcess();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessWaitForStateResult {
        return BusinessProcessWaitForStateResult.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessWaitForStateResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitForStateResult();
        result.init(data);
        return result;
    }

}

/** Result from waiting for state(s) on a business process */
export interface IBusinessProcessWaitForStateResult {
    /** The state that was hit. */
    stateHit?: string | undefined;
    /** The business process. */
    businessProcess: BusinessProcess;
}

/** Detailed representation of a business process */
export class BusinessProcessDetails extends BusinessProcess implements IBusinessProcessDetails {
    /** Details for the business process. */
    details?: BusinessProcessDetailsDataBase | undefined;

    constructor(data?: IBusinessProcessDetails) {
        super(data);
        this.setProp("object", "BusinessProcessDetailsDataBase", "details", true, (item: any) => BusinessProcessDetailsDataBase.fromJS(item));

        this._kind = "BusinessProcessDetails";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDetails {
        return BusinessProcessDetails.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetails();
        result.init(data);
        return result;
    }

}

/** Detailed representation of a business process */
export interface IBusinessProcessDetails extends IBusinessProcess {
    /** Details for the business process. */
    details?: BusinessProcessDetailsDataBase | undefined;
}

/** Base class for the details of a business process */
export abstract class BusinessProcessDetailsDataBase extends DTOBase {

    protected _kind: string;

    constructor(data?: IBusinessProcessDetailsDataBase) {
        super(data);

        this._kind = "BusinessProcessDetailsDataBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDetailsDataBase {
        return BusinessProcessDetailsDataBase.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDetailsDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessDetailsDataBatchResponse") {
            let result = new BusinessProcessDetailsDataBatchResponse();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataSchemaImport") {
            let result = new BusinessProcessDetailsDataSchemaImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataCdnPurge") {
            let result = new BusinessProcessDetailsDataCdnPurge();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataContentImport") {
            let result = new BusinessProcessDetailsDataContentImport();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessProcessDetailsDataBase' cannot be instantiated.");
    }

}

/** Base class for the details of a business process */
export interface IBusinessProcessDetailsDataBase {
}

/** Business process detailed information regarding a batch operation */
export class BusinessProcessDetailsDataBatchResponse extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBatchResponse {
    /** The DocType on which the operation was performed. */
    docType!: string;
    /** The response of the batch operation. */
    response!: BatchResponse;

    constructor(data?: IBusinessProcessDetailsDataBatchResponse) {
        super(data);
        this.setProp("object", "string", "docType", false);
        this.setProp("object", "BatchResponse", "response", true, (item: any) => BatchResponse.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.response = new BatchResponse();
        }
        this._kind = "BusinessProcessDetailsDataBatchResponse";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDetailsDataBatchResponse {
        return BusinessProcessDetailsDataBatchResponse.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDetailsDataBatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataBatchResponse();
        result.init(data);
        return result;
    }

}

/** Business process detailed information regarding a batch operation */
export interface IBusinessProcessDetailsDataBatchResponse extends IBusinessProcessDetailsDataBase {
    /** The DocType on which the operation was performed. */
    docType: string;
    /** The response of the batch operation. */
    response: IBatchResponse;
}

/** Response from a batch operation */
export class BatchResponse extends DTOBase {
    /** Rows in the response. */
    rows!: BatchResponseRow[];

    constructor(data?: IBatchResponse) {
        super(data);
        this.setProp("array", "BatchResponseRow[]", "rows", true, (item: any) => BatchResponseRow.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.rows = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BatchResponse {
        return BatchResponse.fromJS(data);
     }

    static fromJS(data: any): BatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BatchResponse();
        result.init(data);
        return result;
    }

}

/** Response from a batch operation */
export interface IBatchResponse {
    /** Rows in the response. */
    rows: IBatchResponseRow[];
}

/** Row in a batch operation response */
export class BatchResponseRow extends DTOBase {
    /** Id of the item. */
    id!: string;
    /** Indicates if the operation succeeded. */
    succeeded!: boolean;
    /** Status code of the operation. */
    status!: number;
    /** New version of the item. */
    version!: number;
    /** If the operation did not succeeded, this contains error information. */
    error?: ErrorResponse | undefined;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;

    constructor(data?: IBatchResponseRow) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "boolean", "succeeded", false);
        this.setProp("object", "number", "status", false);
        this.setProp("object", "number", "version", false);
        this.setProp("object", "ErrorResponse", "error", true, (item: any) => ErrorResponse.fromJS(item));
        this.setProp("object", "string", "requestId", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BatchResponseRow {
        return BatchResponseRow.fromJS(data);
     }

    static fromJS(data: any): BatchResponseRow {
        data = typeof data === 'object' ? data : {};
        let result = new BatchResponseRow();
        result.init(data);
        return result;
    }

}

/** Row in a batch operation response */
export interface IBatchResponseRow {
    /** Id of the item. */
    id: string;
    /** Indicates if the operation succeeded. */
    succeeded: boolean;
    /** Status code of the operation. */
    status: number;
    /** New version of the item. */
    version: number;
    /** If the operation did not succeeded, this contains error information. */
    error?: IErrorResponse | undefined;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;
}

/** Business process detailed information regarding Schema / ListItems import operation */
export class BusinessProcessDetailsDataSchemaImport extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataSchemaImport {
    /** Result information of a schema import operation */
    schemaImportResult?: SchemaImportResult | undefined;
    /** Result information of a list item import operation */
    listItemImportResult?: ListItemImportResult | undefined;

    constructor(data?: IBusinessProcessDetailsDataSchemaImport) {
        super(data);
        this.setProp("object", "SchemaImportResult", "schemaImportResult", true, (item: any) => SchemaImportResult.fromJS(item));
        this.setProp("object", "ListItemImportResult", "listItemImportResult", true, (item: any) => ListItemImportResult.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "BusinessProcessDetailsDataSchemaImport";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDetailsDataSchemaImport {
        return BusinessProcessDetailsDataSchemaImport.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDetailsDataSchemaImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataSchemaImport();
        result.init(data);
        return result;
    }

}

/** Business process detailed information regarding Schema / ListItems import operation */
export interface IBusinessProcessDetailsDataSchemaImport extends IBusinessProcessDetailsDataBase {
    /** Result information of a schema import operation */
    schemaImportResult?: ISchemaImportResult | undefined;
    /** Result information of a list item import operation */
    listItemImportResult?: IListItemImportResult | undefined;
}

/** Result information of a schema import operation */
export class SchemaImportResult extends DTOBase {
    /** Number of schemas imported */
    importedSchemaCount!: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount!: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount!: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[] | undefined;
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaImportResult) {
        super(data);
        this.setProp("object", "number", "importedSchemaCount", false);
        this.setProp("object", "number", "skippedSchemaCount", false);
        this.setProp("object", "number", "totalSchemaCount", false);
        this.setProp("array", "string[]", "skippedSchemaIds", false);
        this.setProp("array", "string[]", "importedSchemaIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaImportResult {
        return SchemaImportResult.fromJS(data);
     }

    static fromJS(data: any): SchemaImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportResult();
        result.init(data);
        return result;
    }

}

/** Result information of a schema import operation */
export interface ISchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[] | undefined;
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[] | undefined;
}

/** Result information of a list item import operation */
export class ListItemImportResult extends DTOBase {
    /** Number of list items imported */
    importedListItemCount!: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount!: number;
    /** Total number of list items requested to be imported */
    totalListItemCount!: number;
    /** Ids of the list items that were not imported because already found in the system */
    skippedListItemIds?: string[] | undefined;
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[] | undefined;

    constructor(data?: IListItemImportResult) {
        super(data);
        this.setProp("object", "number", "importedListItemCount", false);
        this.setProp("object", "number", "skippedListItemCount", false);
        this.setProp("object", "number", "totalListItemCount", false);
        this.setProp("array", "string[]", "skippedListItemIds", false);
        this.setProp("array", "string[]", "importedListItemIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemImportResult {
        return ListItemImportResult.fromJS(data);
     }

    static fromJS(data: any): ListItemImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemImportResult();
        result.init(data);
        return result;
    }

}

/** Result information of a list item import operation */
export interface IListItemImportResult {
    /** Number of list items imported */
    importedListItemCount: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount: number;
    /** Total number of list items requested to be imported */
    totalListItemCount: number;
    /** Ids of the list items that were not imported because already found in the system */
    skippedListItemIds?: string[] | undefined;
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[] | undefined;
}

/** Business process detailed information regarding a CDN purge operation */
export class BusinessProcessDetailsDataCdnPurge extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataCdnPurge {
    /** Serialized CDN configuration. */
    serializedCdnConfiguration!: string;
    /** Jobs that were processed in the operation. */
    jobs!: CdnPurgeJobBase[];

    constructor(data?: IBusinessProcessDetailsDataCdnPurge) {
        super(data);
        this.setProp("object", "string", "serializedCdnConfiguration", false);
        this.setProp("array", "CdnPurgeJobBase[]", "jobs", true, (item: any) => CdnPurgeJobBase.fromJS(item));

        if (!data) {
            this.jobs = [];
        }
        this._kind = "BusinessProcessDetailsDataCdnPurge";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDetailsDataCdnPurge {
        return BusinessProcessDetailsDataCdnPurge.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDetailsDataCdnPurge {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataCdnPurge();
        result.init(data);
        return result;
    }

}

/** Business process detailed information regarding a CDN purge operation */
export interface IBusinessProcessDetailsDataCdnPurge extends IBusinessProcessDetailsDataBase {
    /** Serialized CDN configuration. */
    serializedCdnConfiguration: string;
    /** Jobs that were processed in the operation. */
    jobs: CdnPurgeJobBase[];
}

/** Base class for a CDN purge job */
export class CdnPurgeJobBase extends DTOBase {
    /** Indicates if the operation was performed successfully. */
    success!: boolean;
    /** Number of retries left until the operation is considered as failed. */
    retriesLeft!: number;

    protected _kind: string;

    constructor(data?: ICdnPurgeJobBase) {
        super(data);
        this.setProp("object", "boolean", "success", false);
        this.setProp("object", "number", "retriesLeft", false);

        this._kind = "CdnPurgeJobBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CdnPurgeJobBase {
        return CdnPurgeJobBase.fromJS(data);
     }

    static fromJS(data: any): CdnPurgeJobBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CdnPurgeJobByTag") {
            let result = new CdnPurgeJobByTag();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CdnPurgeJobByUri") {
            let result = new CdnPurgeJobByUri();
            result.init(data);
            return result;
        }
        let result = new CdnPurgeJobBase();
        result.init(data);
        return result;
    }

}

/** Base class for a CDN purge job */
export interface ICdnPurgeJobBase {
    /** Indicates if the operation was performed successfully. */
    success: boolean;
    /** Number of retries left until the operation is considered as failed. */
    retriesLeft: number;
}

/** Represents a CDN purge by tag (e.g. share ID) */
export class CdnPurgeJobByTag extends CdnPurgeJobBase implements ICdnPurgeJobByTag {
    /** The tag that should be purged. */
    tag!: string;

    constructor(data?: ICdnPurgeJobByTag) {
        super(data);
        this.setProp("object", "string", "tag", false);

        this._kind = "CdnPurgeJobByTag";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CdnPurgeJobByTag {
        return CdnPurgeJobByTag.fromJS(data);
     }

    static fromJS(data: any): CdnPurgeJobByTag {
        data = typeof data === 'object' ? data : {};
        let result = new CdnPurgeJobByTag();
        result.init(data);
        return result;
    }

}

/** Represents a CDN purge by tag (e.g. share ID) */
export interface ICdnPurgeJobByTag extends ICdnPurgeJobBase {
    /** The tag that should be purged. */
    tag: string;
}

export class CdnPurgeJobByUri extends CdnPurgeJobBase implements ICdnPurgeJobByUri {
    uri?: string | undefined;

    constructor(data?: ICdnPurgeJobByUri) {
        super(data);
        this.setProp("object", "string", "uri", false);

        this._kind = "CdnPurgeJobByUri";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CdnPurgeJobByUri {
        return CdnPurgeJobByUri.fromJS(data);
     }

    static fromJS(data: any): CdnPurgeJobByUri {
        data = typeof data === 'object' ? data : {};
        let result = new CdnPurgeJobByUri();
        result.init(data);
        return result;
    }

}

export interface ICdnPurgeJobByUri extends ICdnPurgeJobBase {
    uri?: string | undefined;
}

/** Business process detailed information regarding Content import */
export class BusinessProcessDetailsDataContentImport extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataContentImport {
    /** Items that were imported. */
    items?: ContentImportResult[] | undefined;

    constructor(data?: IBusinessProcessDetailsDataContentImport) {
        super(data);
        this.setProp("array", "ContentImportResult[]", "items", true, (item: any) => ContentImportResult.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "BusinessProcessDetailsDataContentImport";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessDetailsDataContentImport {
        return BusinessProcessDetailsDataContentImport.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessDetailsDataContentImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataContentImport();
        result.init(data);
        return result;
    }

}

/** Business process detailed information regarding Content import */
export interface IBusinessProcessDetailsDataContentImport extends IBusinessProcessDetailsDataBase {
    /** Items that were imported. */
    items?: IContentImportResult[] | undefined;
}

/** Represents an item imported during a content import */
export class ContentImportResult extends DTOBase {
    /** ID of the file transfer. */
    fileTransferId!: string;
    /** ID of the resulting content. */
    contentId?: string | undefined;
    /** State of the item. */
    state?: string | undefined;
    /** Indicates if the operation succeeded. */
    succeeded!: boolean;
    /** If the operation did not succeeded, this contains error related information. */
    error?: ErrorResponse | undefined;

    constructor(data?: IContentImportResult) {
        super(data);
        this.setProp("object", "string", "fileTransferId", false);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "state", false);
        this.setProp("object", "boolean", "succeeded", false);
        this.setProp("object", "ErrorResponse", "error", true, (item: any) => ErrorResponse.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentImportResult {
        return ContentImportResult.fromJS(data);
     }

    static fromJS(data: any): ContentImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentImportResult();
        result.init(data);
        return result;
    }

}

/** Represents an item imported during a content import */
export interface IContentImportResult {
    /** ID of the file transfer. */
    fileTransferId: string;
    /** ID of the resulting content. */
    contentId?: string | undefined;
    /** State of the item. */
    state?: string | undefined;
    /** Indicates if the operation succeeded. */
    succeeded: boolean;
    /** If the operation did not succeeded, this contains error related information. */
    error?: IErrorResponse | undefined;
}

/** Represents the business rule configuration. */
export class BusinessRuleConfiguration extends DTOBase {
    /** Disables the rule completely. */
    disableRuleEngine!: boolean;
    /** Rules */
    rules?: BusinessRule[] | undefined;

    constructor(data?: IBusinessRuleConfiguration) {
        super(data);
        this.setProp("object", "boolean", "disableRuleEngine", false);
        this.setProp("array", "BusinessRule[]", "rules", true, (item: any) => BusinessRule.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleConfiguration {
        return BusinessRuleConfiguration.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfiguration();
        result.init(data);
        return result;
    }

}

/** Represents the business rule configuration. */
export interface IBusinessRuleConfiguration {
    /** Disables the rule completely. */
    disableRuleEngine: boolean;
    /** Rules */
    rules?: BusinessRule[] | undefined;
}

/** A business rule */
export abstract class BusinessRule extends DTOBase {
    /** User defined ID of the rule. */
    id?: string | undefined;
    /** Trigger point. */
    triggerPoint?: BusinessRuleTriggerPoint | undefined;
    /** Enable. */
    isEnabled!: boolean;
    /** Language specific rule names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific rule description. */
    description?: TranslatedStringDictionary | undefined;

    protected _kind: string;

    constructor(data?: IBusinessRule) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "BusinessRuleTriggerPoint", "triggerPoint", true, (item: any) => BusinessRuleTriggerPoint.fromJS(item));
        this.setProp("object", "boolean", "isEnabled", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "description", true, (item: any) => TranslatedStringDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "BusinessRule";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRule {
        return BusinessRule.fromJS(data);
     }

    static fromJS(data: any): BusinessRule {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessRuleConfigurable") {
            let result = new BusinessRuleConfigurable();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScript") {
            let result = new BusinessRuleScript();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRule' cannot be instantiated.");
    }

}

/** A business rule */
export interface IBusinessRule {
    /** User defined ID of the rule. */
    id?: string | undefined;
    /** Trigger point. */
    triggerPoint?: IBusinessRuleTriggerPoint | undefined;
    /** Enable. */
    isEnabled: boolean;
    /** Language specific rule names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific rule description. */
    description?: ITranslatedStringDictionary | undefined;
}

/** Represents a trigger point for a business rule */
export class BusinessRuleTriggerPoint extends DTOBase {
    /** Execution scope. */
    executionScope!: BusinessRuleExecutionScope;
    /** Document type. */
    documentType!: BusinessRuleTriggerDocType;
    /** Action performed. */
    action!: BusinessRuleTriggerAction;

    constructor(data?: IBusinessRuleTriggerPoint) {
        super(data);
        this.setProp("object", "BusinessRuleExecutionScope", "executionScope", false);
        this.setProp("object", "BusinessRuleTriggerDocType", "documentType", false);
        this.setProp("object", "BusinessRuleTriggerAction", "action", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleTriggerPoint {
        return BusinessRuleTriggerPoint.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleTriggerPoint {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTriggerPoint();
        result.init(data);
        return result;
    }

}

/** Represents a trigger point for a business rule */
export interface IBusinessRuleTriggerPoint {
    /** Execution scope. */
    executionScope: BusinessRuleExecutionScope;
    /** Document type. */
    documentType: BusinessRuleTriggerDocType;
    /** Action performed. */
    action: BusinessRuleTriggerAction;
}

export enum BusinessRuleTriggerAction {
    Create = "Create",
    Update = "Update",
}

/** A business rule configurable by specific actions and conditions */
export class BusinessRuleConfigurable extends BusinessRule implements IBusinessRuleConfigurable {
    /** The condition that makes this rule trigger. */
    condition?: BusinessRuleCondition | undefined;
    /** The actions that are performed when this rule triggers. */
    actions?: BusinessRuleAction[] | undefined;

    constructor(data?: IBusinessRuleConfigurable) {
        super(data);
        this.setProp("object", "BusinessRuleCondition", "condition", true, (item: any) => BusinessRuleCondition.fromJS(item));
        this.setProp("array", "BusinessRuleAction[]", "actions", true, (item: any) => BusinessRuleAction.fromJS(item));

        this._kind = "BusinessRuleConfigurable";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleConfigurable {
        return BusinessRuleConfigurable.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleConfigurable {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfigurable();
        result.init(data);
        return result;
    }

}

/** A business rule configurable by specific actions and conditions */
export interface IBusinessRuleConfigurable extends IBusinessRule {
    /** The condition that makes this rule trigger. */
    condition?: BusinessRuleCondition | undefined;
    /** The actions that are performed when this rule triggers. */
    actions?: BusinessRuleAction[] | undefined;
}

/** Conditions on which a business rule is executed */
export abstract class BusinessRuleCondition extends DTOBase {

    protected _kind: string;

    constructor(data?: IBusinessRuleCondition) {
        super(data);

        this._kind = "BusinessRuleCondition";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleCondition {
        return BusinessRuleCondition.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleCondition {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BooleanCondition") {
            throw new Error("The abstract class 'BooleanCondition' cannot be instantiated.");
        }
        if (data["kind"] === "AndCondition") {
            let result = new AndCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrCondition") {
            let result = new OrCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignedCondition") {
            let result = new LayerAssignedCondition();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRuleCondition' cannot be instantiated.");
    }

}

/** Conditions on which a business rule is executed */
export interface IBusinessRuleCondition {
}

/** Links multiple conditions with a boolean operator */
export abstract class BooleanCondition extends BusinessRuleCondition implements IBooleanCondition {
    /** The conditions. */
    conditions?: BusinessRuleCondition[] | undefined;

    constructor(data?: IBooleanCondition) {
        super(data);
        this.setProp("array", "BusinessRuleCondition[]", "conditions", true, (item: any) => BusinessRuleCondition.fromJS(item));

        this._kind = "BooleanCondition";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BooleanCondition {
        return BooleanCondition.fromJS(data);
     }

    static fromJS(data: any): BooleanCondition {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AndCondition") {
            let result = new AndCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrCondition") {
            let result = new OrCondition();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BooleanCondition' cannot be instantiated.");
    }

}

/** Links multiple conditions with a boolean operator */
export interface IBooleanCondition extends IBusinessRuleCondition {
    /** The conditions. */
    conditions?: BusinessRuleCondition[] | undefined;
}

/** Links conditions with AND */
export class AndCondition extends BooleanCondition implements IAndCondition {

    constructor(data?: IAndCondition) {
        super(data);

        this._kind = "AndCondition";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AndCondition {
        return AndCondition.fromJS(data);
     }

    static fromJS(data: any): AndCondition {
        data = typeof data === 'object' ? data : {};
        let result = new AndCondition();
        result.init(data);
        return result;
    }

}

/** Links conditions with AND */
export interface IAndCondition extends IBooleanCondition {
}

/** Links conditions with OR */
export class OrCondition extends BooleanCondition implements IOrCondition {

    constructor(data?: IOrCondition) {
        super(data);

        this._kind = "OrCondition";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OrCondition {
        return OrCondition.fromJS(data);
     }

    static fromJS(data: any): OrCondition {
        data = typeof data === 'object' ? data : {};
        let result = new OrCondition();
        result.init(data);
        return result;
    }

}

/** Links conditions with OR */
export interface IOrCondition extends IBooleanCondition {
}

/** Matches when a layer was assigned */
export class LayerAssignedCondition extends BusinessRuleCondition implements ILayerAssignedCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;

    constructor(data?: ILayerAssignedCondition) {
        super(data);
        this.setProp("object", "string", "layerId", false);

        this._kind = "LayerAssignedCondition";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LayerAssignedCondition {
        return LayerAssignedCondition.fromJS(data);
     }

    static fromJS(data: any): LayerAssignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new LayerAssignedCondition();
        result.init(data);
        return result;
    }

}

/** Matches when a layer was assigned */
export interface ILayerAssignedCondition extends IBusinessRuleCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;
}

/** Action to be performed by a business rule */
export abstract class BusinessRuleAction extends DTOBase {

    protected _kind: string;

    constructor(data?: IBusinessRuleAction) {
        super(data);

        this._kind = "BusinessRuleAction";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleAction {
        return BusinessRuleAction.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleAction {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AssignLayerAction") {
            let result = new AssignLayerAction();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRuleAction' cannot be instantiated.");
    }

}

/** Action to be performed by a business rule */
export interface IBusinessRuleAction {
}

/** Assigns a layer, adding the default values to the data dictionary */
export class AssignLayerAction extends BusinessRuleAction implements IAssignLayerAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
    /** A dictionary containing default values (used for example to populate required fields). */
    defaultValues?: DataDictionary | undefined;

    constructor(data?: IAssignLayerAction) {
        super(data);
        this.setProp("object", "string", "layerId", false);
        this.setProp("object", "DataDictionary", "defaultValues", true, (item: any) => DataDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "AssignLayerAction";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AssignLayerAction {
        return AssignLayerAction.fromJS(data);
     }

    static fromJS(data: any): AssignLayerAction {
        data = typeof data === 'object' ? data : {};
        let result = new AssignLayerAction();
        result.init(data);
        return result;
    }

}

/** Assigns a layer, adding the default values to the data dictionary */
export interface IAssignLayerAction extends IBusinessRuleAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
    /** A dictionary containing default values (used for example to populate required fields). */
    defaultValues?: IDataDictionary | undefined;
}

export class DataDictionary extends DTOBase {

    [key: string]: any; 

    constructor(data?: IDataDictionary) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

     fromJS(data: any): DataDictionary {
        return DataDictionary.fromJS(data);
     }

    static fromJS(data: any): DataDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DataDictionary();
        result.init(data);
        return result;
    }

}

export interface IDataDictionary {

    [key: string]: any; 
}

/** A business rule expressed as a script */
export class BusinessRuleScript extends BusinessRule implements IBusinessRuleScript {
    /** Script */
    script?: string | undefined;

    constructor(data?: IBusinessRuleScript) {
        super(data);
        this.setProp("object", "string", "script", false);

        this._kind = "BusinessRuleScript";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessRuleScript {
        return BusinessRuleScript.fromJS(data);
     }

    static fromJS(data: any): BusinessRuleScript {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleScript();
        result.init(data);
        return result;
    }

}

/** A business rule expressed as a script */
export interface IBusinessRuleScript extends IBusinessRule {
    /** Script */
    script?: string | undefined;
}

export class Channel extends DTOBase {
    /** ID of channel. */
    id!: string;
    /** Numeric sort order of the channel. Channels are returned ordered by this field. */
    sortOrder!: number;
    /** The search index ID where the channel requests the content from. Only RootContentSearchIndex is supported. */
    searchIndexId!: string;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names!: TranslatedStringDictionary;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort!: SortInfo[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations!: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields!: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds!: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns!: TranslatedStringDictionary;
    /** Audit information. */
    audit!: UserAudit;
    /** Grants rights to all the users to view the channel. */
    viewForAll!: boolean;

    constructor(data?: IChannel) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "number", "sortOrder", false);
        this.setProp("object", "string", "searchIndexId", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregations", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("array", "string[]", "extendedSimpleSearchFields", false);
        this.setProp("array", "string[]", "grantedUserRoleIds", false);
        this.setProp("object", "TranslatedStringDictionary", "missingResultsDisplayPatterns", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "boolean", "viewForAll", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.sort = [];
            this.aggregations = [];
            this.extendedSimpleSearchFields = [];
            this.grantedUserRoleIds = [];
            this.missingResultsDisplayPatterns = new TranslatedStringDictionary();
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Channel {
        return Channel.fromJS(data);
     }

    static fromJS(data: any): Channel {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }

}

export interface IChannel {
    /** ID of channel. */
    id: string;
    /** Numeric sort order of the channel. Channels are returned ordered by this field. */
    sortOrder: number;
    /** The search index ID where the channel requests the content from. Only RootContentSearchIndex is supported. */
    searchIndexId: string;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names: ITranslatedStringDictionary;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort: ISortInfo[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns: ITranslatedStringDictionary;
    /** Audit information. */
    audit: IUserAudit;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

/** Sorting information */
export class SortInfo extends DTOBase {
    /** The field's ID to sort on. */
    field?: string | undefined;
    /** The sort direction (ascending/descending). */
    direction!: SortDirection;

    constructor(data?: ISortInfo) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "SortDirection", "direction", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SortInfo {
        return SortInfo.fromJS(data);
     }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

}

/** Sorting information */
export interface ISortInfo {
    /** The field's ID to sort on. */
    field?: string | undefined;
    /** The sort direction (ascending/descending). */
    direction: SortDirection;
}

/** The sort direction */
export enum SortDirection {
    Asc = "Asc",
    Desc = "Desc",
}

/** It is the base class for all aggregators. */
export abstract class AggregatorBase extends DTOBase {
    /** The slug name of the aggregation. It must be unique per aggregation request. */
    name!: string;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional filter to limit the data set the aggregation is operation on. */
    filter?: FilterBase | undefined;

    protected _kind: string;

    constructor(data?: IAggregatorBase) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregators", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "AggregatorBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregatorBase {
        return AggregatorBase.fromJS(data);
     }

    static fromJS(data: any): AggregatorBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DateRangeAggregator") {
            let result = new DateRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceAggregator") {
            let result = new GeoDistanceAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedAggregator") {
            let result = new NestedAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeAggregator") {
            let result = new NumericRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsAggregator") {
            let result = new TermsAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AggregatorBase' cannot be instantiated.");
    }

}

/** It is the base class for all aggregators. */
export interface IAggregatorBase {
    /** The slug name of the aggregation. It must be unique per aggregation request. */
    name: string;
    /** Language specific field names. */
    names?: ITranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional filter to limit the data set the aggregation is operation on. */
    filter?: FilterBase | undefined;
}

/** A multi-bucket range aggregator dedicated for date values. */
export class DateRangeAggregator extends AggregatorBase implements IDateRangeAggregator {
    /** The field's ID to execute the aggregation on. */
    field!: string;
    /** A list of date time ranges. */
    ranges!: DateRangeForAggregator[];

    constructor(data?: IDateRangeAggregator) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("array", "DateRangeForAggregator[]", "ranges", true, (item: any) => DateRangeForAggregator.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.ranges = [];
        }
        this._kind = "DateRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DateRangeAggregator {
        return DateRangeAggregator.fromJS(data);
     }

    static fromJS(data: any): DateRangeAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeAggregator();
        result.init(data);
        return result;
    }

}

/** A multi-bucket range aggregator dedicated for date values. */
export interface IDateRangeAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field: string;
    /** A list of date time ranges. */
    ranges: IDateRangeForAggregator[];
}

/** The date range class used in aggregators. */
export class DateRangeForAggregator extends DTOBase {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRangeForAggregator) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "from", false);
        this.setProp("object", "string", "to", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DateRangeForAggregator {
        return DateRangeForAggregator.fromJS(data);
     }

    static fromJS(data: any): DateRangeForAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeForAggregator();
        result.init(data);
        return result;
    }

}

/** The date range class used in aggregators. */
export interface IDateRangeForAggregator {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** A multi-bucket range aggregator that works on geo_point fields */
export class GeoDistanceAggregator extends AggregatorBase implements IGeoDistanceAggregator {
    /** The field's ID to execute the aggregation on. */
    field!: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location!: GeoLocation;
    /** A list of distance ranges. */
    ranges!: GeoDistance[];

    constructor(data?: IGeoDistanceAggregator) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "GeoLocation", "location", true, (item: any) => GeoLocation.fromJS(item));
        this.setProp("array", "GeoDistance[]", "ranges", true, (item: any) => GeoDistance.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.location = new GeoLocation();
            this.ranges = [];
        }
        this._kind = "GeoDistanceAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): GeoDistanceAggregator {
        return GeoDistanceAggregator.fromJS(data);
     }

    static fromJS(data: any): GeoDistanceAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceAggregator();
        result.init(data);
        return result;
    }

}

/** A multi-bucket range aggregator that works on geo_point fields */
export interface IGeoDistanceAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location: IGeoLocation;
    /** A list of distance ranges. */
    ranges: IGeoDistance[];
}

/** Stores geo distance information for gei distance aggregation */
export class GeoDistance extends DTOBase {
    /** Language specific geo distance names. */
    names?: TranslatedStringDictionary | undefined;
    /** The distance in meters. */
    distance!: number;

    constructor(data?: IGeoDistance) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "number", "distance", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): GeoDistance {
        return GeoDistance.fromJS(data);
     }

    static fromJS(data: any): GeoDistance {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistance();
        result.init(data);
        return result;
    }

}

/** Stores geo distance information for gei distance aggregation */
export interface IGeoDistance {
    /** Language specific geo distance names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The distance in meters. */
    distance: number;
}

/** A special single bucket aggregation that enables aggregating on nested documents */
export class NestedAggregator extends AggregatorBase implements INestedAggregator {
    /** The path pointing to the nested object. */
    path!: string;

    constructor(data?: INestedAggregator) {
        super(data);
        this.setProp("object", "string", "path", false);

        this._kind = "NestedAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NestedAggregator {
        return NestedAggregator.fromJS(data);
     }

    static fromJS(data: any): NestedAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NestedAggregator();
        result.init(data);
        return result;
    }

}

/** A special single bucket aggregation that enables aggregating on nested documents */
export interface INestedAggregator extends IAggregatorBase {
    /** The path pointing to the nested object. */
    path: string;
}

/** A multi-bucket range aggregator. */
export class NumericRangeAggregator extends AggregatorBase implements INumericRangeAggregator {
    /** The field's ID to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges on which aggregate. */
    ranges!: NumericRangeForAggregator[];

    constructor(data?: INumericRangeAggregator) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("array", "NumericRangeForAggregator[]", "ranges", true, (item: any) => NumericRangeForAggregator.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.ranges = [];
        }
        this._kind = "NumericRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NumericRangeAggregator {
        return NumericRangeAggregator.fromJS(data);
     }

    static fromJS(data: any): NumericRangeAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeAggregator();
        result.init(data);
        return result;
    }

}

/** A multi-bucket range aggregator. */
export interface INumericRangeAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges on which aggregate. */
    ranges: INumericRangeForAggregator[];
}

/** The numeric range for aggregator class */
export class NumericRangeForAggregator extends DTOBase {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRangeForAggregator) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "number", "from", false);
        this.setProp("object", "number", "to", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NumericRangeForAggregator {
        return NumericRangeForAggregator.fromJS(data);
     }

    static fromJS(data: any): NumericRangeForAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeForAggregator();
        result.init(data);
        return result;
    }

}

/** The numeric range for aggregator class */
export interface INumericRangeForAggregator {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** A multi-bucket value aggregator */
export class TermsAggregator extends AggregatorBase implements ITermsAggregator {
    /** The field's ID to execute the aggregation on. Only not analyzed fields are supported. */
    field!: string;
    /** It defines how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
    /** Limits the possible returned aggregation values by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used. */
    searchFields?: string[] | undefined;

    constructor(data?: ITermsAggregator) {
        super(data);
        this.setProp("object", "string", "field", false);
        this.setProp("object", "number", "size", false);
        this.setProp("array", "string[]", "includes", false);
        this.setProp("array", "string[]", "excludes", false);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "string[]", "searchFields", false);

        this._kind = "TermsAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermsAggregator {
        return TermsAggregator.fromJS(data);
     }

    static fromJS(data: any): TermsAggregator {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new TermsAggregator();
        result.init(data);
        return result;
    }

}

/** A multi-bucket value aggregator */
export interface ITermsAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. Only not analyzed fields are supported. */
    field: string;
    /** It defines how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
    /** Limits the possible returned aggregation values by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used. */
    searchFields?: string[] | undefined;
}

/** A multi-bucket value aggregator used for aggregations on relation item ids. */
export class TermsRelationAggregator extends TermsAggregator implements ITermsRelationAggregator {
    /** Type of the item target of the relation. It is used to resolve the target ID. */
    documentType!: TermsRelationAggregatorDocumentType;

    constructor(data?: ITermsRelationAggregator) {
        super(data);
        this.setProp("object", "TermsRelationAggregatorDocumentType", "documentType", false);

        this._kind = "TermsRelationAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermsRelationAggregator {
        return TermsRelationAggregator.fromJS(data);
     }

    static fromJS(data: any): TermsRelationAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new TermsRelationAggregator();
        result.init(data);
        return result;
    }

}

/** A multi-bucket value aggregator used for aggregations on relation item ids. */
export interface ITermsRelationAggregator extends ITermsAggregator {
    /** Type of the item target of the relation. It is used to resolve the target ID. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = "Content",
    ListItem = "ListItem",
    Schema = "Schema",
    User = "User",
    ContentPermissionSet = "ContentPermissionSet",
    Owner = "Owner",
}

/** A multi-bucket value aggregator used for aggregations on indexed enum values. */
export class TermsEnumAggregator extends TermsAggregator implements ITermsEnumAggregator {
    /** Type of the enum target of the relation. It is used to resolve the enum translation. */
    enumType!: string;

    constructor(data?: ITermsEnumAggregator) {
        super(data);
        this.setProp("object", "string", "enumType", false);

        this._kind = "TermsEnumAggregator";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TermsEnumAggregator {
        return TermsEnumAggregator.fromJS(data);
     }

    static fromJS(data: any): TermsEnumAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new TermsEnumAggregator();
        result.init(data);
        return result;
    }

}

/** A multi-bucket value aggregator used for aggregations on indexed enum values. */
export interface ITermsEnumAggregator extends ITermsAggregator {
    /** Type of the enum target of the relation. It is used to resolve the enum translation. */
    enumType: string;
}

/** Audit information */
export class UserAudit extends DTOBase {
    /** The date on which the document was created. */
    creationDate!: Date;
    /** The last date on which the document was modified. */
    modificationDate!: Date;
    /** ID of the user who created the document. */
    createdByUser?: string | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: string | undefined;

    constructor(data?: IUserAudit) {
        super(data);
        this.setProp("object", "Date", "creationDate", false);
        this.setProp("object", "Date", "modificationDate", false);
        this.setProp("object", "string", "createdByUser", false);
        this.setProp("object", "string", "modifiedByUser", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserAudit {
        return UserAudit.fromJS(data);
     }

    static fromJS(data: any): UserAudit {
        data = typeof data === 'object' ? data : {};
        let result = new UserAudit();
        result.init(data);
        return result;
    }

}

/** Audit information */
export interface IUserAudit {
    /** The date on which the document was created. */
    creationDate: Date;
    /** The last date on which the document was modified. */
    modificationDate: Date;
    /** ID of the user who created the document. */
    createdByUser?: string | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: string | undefined;
}

export class ChannelCreateRequest extends DTOBase {
    id?: string | undefined;
    sort?: SortInfo[] | undefined;
    sortOrder!: number;
    names?: TranslatedStringDictionary | undefined;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll!: boolean;

    constructor(data?: IChannelCreateRequest) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "sortOrder", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "searchIndexId", false);
        this.setProp("array", "string[]", "grantedUserRoleIds", false);
        this.setProp("array", "AggregatorBase[]", "aggregations", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("array", "string[]", "extendedSimpleSearchFields", false);
        this.setProp("object", "TranslatedStringDictionary", "missingResultsDisplayPatterns", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "boolean", "viewForAll", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ChannelCreateRequest {
        return ChannelCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ChannelCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelCreateRequest();
        result.init(data);
        return result;
    }

}

export interface IChannelCreateRequest {
    id?: string | undefined;
    sort?: ISortInfo[] | undefined;
    sortOrder: number;
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: ITranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

export class ChannelUpdateRequest extends DTOBase {
    sort?: SortInfo[] | undefined;
    sortOrder!: number;
    names?: TranslatedStringDictionary | undefined;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll!: boolean;

    constructor(data?: IChannelUpdateRequest) {
        super(data);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "sortOrder", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "searchIndexId", false);
        this.setProp("array", "string[]", "grantedUserRoleIds", false);
        this.setProp("array", "AggregatorBase[]", "aggregations", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("array", "string[]", "extendedSimpleSearchFields", false);
        this.setProp("object", "TranslatedStringDictionary", "missingResultsDisplayPatterns", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "boolean", "viewForAll", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ChannelUpdateRequest {
        return ChannelUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ChannelUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelUpdateRequest();
        result.init(data);
        return result;
    }

}

export interface IChannelUpdateRequest {
    sort?: ISortInfo[] | undefined;
    sortOrder: number;
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: ITranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

/** A content detail. */
export class ContentDetail extends DTOBase {
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit | undefined;
    /** The content data */
    content!: any;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the content schema */
    contentSchemaId!: string;
    /** The type of content */
    contentType!: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The content id. */
    id!: string;
    /** An optional list of layer schemas ids */
    layerSchemaIds!: string[];
    /** The metadata dictionary */
    metadata?: DataDictionary | undefined;
    /** A list of rendering outputs for underlying digital file. */
    outputs?: Output[] | undefined;
    /** The owner token ID. Defines the content owner. */
    ownerTokenId!: string;
    /** The resolved owner. */
    owner?: User | undefined;
    /** The lifecycle of the content. */
    lifeCycle!: LifeCycle;
    /** List of content rights the user has on this content */
    contentRights?: ContentRight[] | undefined;

    constructor(data?: IContentDetail) {
        super(data);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "any", "content", false);
        this.setProp("array", "string[]", "contentPermissionSetIds", false);
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("object", "ContentType", "contentType", false);
        this.setProp("object", "DisplayValueDictionary", "displayValues", true, (item: any) => DisplayValueDictionary.fromJS(item));
        this.setProp("object", "string", "id", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "DataDictionary", "metadata", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("array", "Output[]", "outputs", true, (item: any) => Output.fromJS(item));
        this.setProp("object", "string", "ownerTokenId", false);
        this.setProp("object", "User", "owner", true, (item: any) => User.fromJS(item));
        this.setProp("object", "LifeCycle", "lifeCycle", false);
        this.setProp("array", "ContentRight[]", "contentRights", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.layerSchemaIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDetail {
        return ContentDetail.fromJS(data);
     }

    static fromJS(data: any): ContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetail();
        result.init(data);
        return result;
    }

}

/** A content detail. */
export interface IContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: IUserAudit | undefined;
    /** The content data */
    content: any;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the content schema */
    contentSchemaId: string;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The content id. */
    id: string;
    /** An optional list of layer schemas ids */
    layerSchemaIds: string[];
    /** The metadata dictionary */
    metadata?: IDataDictionary | undefined;
    /** A list of rendering outputs for underlying digital file. */
    outputs?: Output[] | undefined;
    /** The owner token ID. Defines the content owner. */
    ownerTokenId: string;
    /** The resolved owner. */
    owner?: IUser | undefined;
    /** The lifecycle of the content. */
    lifeCycle: LifeCycle;
    /** List of content rights the user has on this content */
    contentRights?: ContentRight[] | undefined;
}

export class DisplayValueDictionary extends DTOBase {

    [key: string]: string | any; 

    constructor(data?: IDisplayValueDictionary) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

     fromJS(data: any): DisplayValueDictionary {
        return DisplayValueDictionary.fromJS(data);
     }

    static fromJS(data: any): DisplayValueDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayValueDictionary();
        result.init(data);
        return result;
    }

}

export interface IDisplayValueDictionary {

    [key: string]: string | any; 
}

/** Output */
export class Output extends DTOBase {
    /** The ID of the output. */
    id!: string;
    /** The ID of the output format this output represents. */
    outputFormatId!: string;
    /** The ID of the content for which this output has been created. */
    contentId!: string;
    /** The rendering state of the output file. */
    renderingState!: OutputRenderingState;
    /** Detail of the output that are format dependent. */
    detail?: OutputDataBase | undefined;
    /** Date and time of the backup of the output file. */
    backupTimestamp?: Date | undefined;
    /** Number of rendering retry attempts left. */
    attemptsLeft!: number;
    /** Version counter incremented every time this output is rendered (or in case of Original when new original is uploaded). */
    fileVersion!: number;

    protected _kind: string;

    constructor(data?: IOutput) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "outputFormatId", false);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "OutputRenderingState", "renderingState", false);
        this.setProp("object", "OutputDataBase", "detail", true, (item: any) => OutputDataBase.fromJS(item));
        this.setProp("object", "Date", "backupTimestamp", false);
        this.setProp("object", "number", "attemptsLeft", false);
        this.setProp("object", "number", "fileVersion", false);

        this._kind = "Output";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Output {
        return Output.fromJS(data);
     }

    static fromJS(data: any): Output {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputDetail") {
            let result = new OutputDetail();
            result.init(data);
            return result;
        }
        let result = new Output();
        result.init(data);
        return result;
    }

}

/** Output */
export interface IOutput {
    /** The ID of the output. */
    id: string;
    /** The ID of the output format this output represents. */
    outputFormatId: string;
    /** The ID of the content for which this output has been created. */
    contentId: string;
    /** The rendering state of the output file. */
    renderingState: OutputRenderingState;
    /** Detail of the output that are format dependent. */
    detail?: OutputDataBase | undefined;
    /** Date and time of the backup of the output file. */
    backupTimestamp?: Date | undefined;
    /** Number of rendering retry attempts left. */
    attemptsLeft: number;
    /** Version counter incremented every time this output is rendered (or in case of Original when new original is uploaded). */
    fileVersion: number;
}

export enum OutputRenderingState {
    InProgress = "InProgress",
    Completed = "Completed",
    Failed = "Failed",
    Skipped = "Skipped",
    NoLicense = "NoLicense",
    RerenderRequested = "RerenderRequested",
}

/** Base class for the output detail dependent on the file format. */
export abstract class OutputDataBase extends DTOBase {
    /** The extension of the file. */
    fileExtension?: string | undefined;
    /** The name of the file. */
    fileName?: string | undefined;
    /** The path where the file is stored. */
    filePath?: string | undefined;
    /** The size of the file in bytes. */
    fileSizeInBytes?: number | undefined;
    /** The SHA-1 hash of the file. */
    sha1Hash?: string | undefined;

    protected _kind: string;

    constructor(data?: IOutputDataBase) {
        super(data);
        this.setProp("object", "string", "fileExtension", false);
        this.setProp("object", "string", "fileName", false);
        this.setProp("object", "string", "filePath", false);
        this.setProp("object", "number", "fileSizeInBytes", false);
        this.setProp("object", "string", "sha1Hash", false);

        this._kind = "OutputDataBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDataBase {
        return OutputDataBase.fromJS(data);
     }

    static fromJS(data: any): OutputDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputDataImage") {
            let result = new OutputDataImage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataAudio") {
            let result = new OutputDataAudio();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataVideo") {
            let result = new OutputDataVideo();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDocument") {
            let result = new OutputDataDocument();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDefault") {
            let result = new OutputDataDefault();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'OutputDataBase' cannot be instantiated.");
    }

}

/** Base class for the output detail dependent on the file format. */
export interface IOutputDataBase {
    /** The extension of the file. */
    fileExtension?: string | undefined;
    /** The name of the file. */
    fileName?: string | undefined;
    /** The path where the file is stored. */
    filePath?: string | undefined;
    /** The size of the file in bytes. */
    fileSizeInBytes?: number | undefined;
    /** The SHA-1 hash of the file. */
    sha1Hash?: string | undefined;
}

/** Output information for an image file. */
export class OutputDataImage extends OutputDataBase implements IOutputDataImage {
    /** The width of the image. */
    width!: number;
    /** The height of the image. */
    height!: number;

    constructor(data?: IOutputDataImage) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);

        this._kind = "OutputDataImage";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDataImage {
        return OutputDataImage.fromJS(data);
     }

    static fromJS(data: any): OutputDataImage {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataImage();
        result.init(data);
        return result;
    }

}

/** Output information for an image file. */
export interface IOutputDataImage extends IOutputDataBase {
    /** The width of the image. */
    width: number;
    /** The height of the image. */
    height: number;
}

/** Output information for an audio file. */
export class OutputDataAudio extends OutputDataBase implements IOutputDataAudio {
    /** Duration of the audio stream in seconds. */
    durationInSeconds?: number | undefined;

    constructor(data?: IOutputDataAudio) {
        super(data);
        this.setProp("object", "number", "durationInSeconds", false);

        this._kind = "OutputDataAudio";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDataAudio {
        return OutputDataAudio.fromJS(data);
     }

    static fromJS(data: any): OutputDataAudio {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataAudio();
        result.init(data);
        return result;
    }

}

/** Output information for an audio file. */
export interface IOutputDataAudio extends IOutputDataBase {
    /** Duration of the audio stream in seconds. */
    durationInSeconds?: number | undefined;
}

/** Output information for a video file. */
export class OutputDataVideo extends OutputDataBase implements IOutputDataVideo {
    /** Duration of the video in seconds. */
    durationInSeconds!: number;
    /** With of the video. */
    width!: number;
    /** Height of the video. */
    height!: number;
    /** The sprites making up the key frames of the video. */
    sprites?: Sprite[] | undefined;

    constructor(data?: IOutputDataVideo) {
        super(data);
        this.setProp("object", "number", "durationInSeconds", false);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("array", "Sprite[]", "sprites", true, (item: any) => Sprite.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "OutputDataVideo";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDataVideo {
        return OutputDataVideo.fromJS(data);
     }

    static fromJS(data: any): OutputDataVideo {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataVideo();
        result.init(data);
        return result;
    }

}

/** Output information for a video file. */
export interface IOutputDataVideo extends IOutputDataBase {
    /** Duration of the video in seconds. */
    durationInSeconds: number;
    /** With of the video. */
    width: number;
    /** Height of the video. */
    height: number;
    /** The sprites making up the key frames of the video. */
    sprites?: ISprite[] | undefined;
}

/** The sprite of a video sprite */
export class Sprite extends DTOBase {
    /** The width of the sprite. */
    width!: number;
    /** The height of the sprite. */
    height!: number;
    /** Y coordinate of the sprite in the saved file. */
    y!: number;
    /** X coordinate of the sprite in the saved file. */
    x!: number;
    /** The starting point in time of the sprite in the video. */
    start!: string;
    /** The ending point in time of the sprite in the video. */
    end!: string;

    constructor(data?: ISprite) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "number", "y", false);
        this.setProp("object", "number", "x", false);
        this.setProp("object", "string", "start", false);
        this.setProp("object", "string", "end", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Sprite {
        return Sprite.fromJS(data);
     }

    static fromJS(data: any): Sprite {
        data = typeof data === 'object' ? data : {};
        let result = new Sprite();
        result.init(data);
        return result;
    }

}

/** The sprite of a video sprite */
export interface ISprite {
    /** The width of the sprite. */
    width: number;
    /** The height of the sprite. */
    height: number;
    /** Y coordinate of the sprite in the saved file. */
    y: number;
    /** X coordinate of the sprite in the saved file. */
    x: number;
    /** The starting point in time of the sprite in the video. */
    start: string;
    /** The ending point in time of the sprite in the video. */
    end: string;
}

/** Output information for a document file. */
export class OutputDataDocument extends OutputDataBase implements IOutputDataDocument {
    /** Number of document's pages. */
    pageCount!: number;

    constructor(data?: IOutputDataDocument) {
        super(data);
        this.setProp("object", "number", "pageCount", false);

        this._kind = "OutputDataDocument";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDataDocument {
        return OutputDataDocument.fromJS(data);
     }

    static fromJS(data: any): OutputDataDocument {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataDocument();
        result.init(data);
        return result;
    }

}

/** Output information for a document file. */
export interface IOutputDataDocument extends IOutputDataBase {
    /** Number of document's pages. */
    pageCount: number;
}

/** Default output information */
export class OutputDataDefault extends OutputDataBase implements IOutputDataDefault {

    constructor(data?: IOutputDataDefault) {
        super(data);

        this._kind = "OutputDataDefault";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDataDefault {
        return OutputDataDefault.fromJS(data);
     }

    static fromJS(data: any): OutputDataDefault {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataDefault();
        result.init(data);
        return result;
    }

}

/** Default output information */
export interface IOutputDataDefault extends IOutputDataBase {
}

/** Output detail */
export class OutputDetail extends Output implements IOutputDetail {

    constructor(data?: IOutputDetail) {
        super(data);

        this._kind = "OutputDetail";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputDetail {
        return OutputDetail.fromJS(data);
     }

    static fromJS(data: any): OutputDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDetail();
        result.init(data);
        return result;
    }

}

/** Output detail */
export interface IOutputDetail extends IOutput {
}

export class User extends DTOBase {
    /** User's Picturepark ID. */
    id?: string | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress!: string;

    constructor(data?: IUser) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "firstName", false);
        this.setProp("object", "string", "lastName", false);
        this.setProp("object", "string", "emailAddress", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): User {
        return User.fromJS(data);
     }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

}

export interface IUser {
    /** User's Picturepark ID. */
    id?: string | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
}

/** Lifecycle */
export enum LifeCycle {
    Draft = "Draft",
    Active = "Active",
    Inactive = "Inactive",
    Deleted = "Deleted",
}

export enum ContentResolveBehavior {
    Content = "Content",
    LinkedListItems = "LinkedListItems",
    Metadata = "Metadata",
    Outputs = "Outputs",
    InnerDisplayValueThumbnail = "InnerDisplayValueThumbnail",
    InnerDisplayValueList = "InnerDisplayValueList",
    InnerDisplayValueDetail = "InnerDisplayValueDetail",
    InnerDisplayValueName = "InnerDisplayValueName",
    Owner = "Owner",
    Permissions = "Permissions",
    OuterDisplayValueThumbnail = "OuterDisplayValueThumbnail",
    OuterDisplayValueList = "OuterDisplayValueList",
    OuterDisplayValueDetail = "OuterDisplayValueDetail",
    OuterDisplayValueName = "OuterDisplayValueName",
}

export class BaseResultOfContent extends DTOBase {
    totalResults!: number;
    results!: Content[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfContent) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "Content[]", "results", true, (item: any) => Content.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfContent {
        return BaseResultOfContent.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfContent();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfContent {
    totalResults: number;
    results: IContent[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfContent extends BaseResultOfContent implements ISearchBehaviorBaseResultOfContent {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfContent) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfContent {
        return SearchBehaviorBaseResultOfContent.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfContent();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfContent extends IBaseResultOfContent {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result for content search operation */
export class ContentSearchResult extends SearchBehaviorBaseResultOfContent implements IContentSearchResult {
    /** Result of rights aggregation count requested in rightsAggregations in the ContentSearchRequest. */
    rightsAggregationsCounts?: ContentRightAggregationCount[] | undefined;

    constructor(data?: IContentSearchResult) {
        super(data);
        this.setProp("array", "ContentRightAggregationCount[]", "rightsAggregationsCounts", true, (item: any) => ContentRightAggregationCount.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentSearchResult {
        return ContentSearchResult.fromJS(data);
     }

    static fromJS(data: any): ContentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSearchResult();
        result.init(data);
        return result;
    }

}

/** Result for content search operation */
export interface IContentSearchResult extends ISearchBehaviorBaseResultOfContent {
    /** Result of rights aggregation count requested in rightsAggregations in the ContentSearchRequest. */
    rightsAggregationsCounts?: IContentRightAggregationCount[] | undefined;
}

/** Combination of ContentRight and found document count */
export class ContentRightAggregationCount extends DTOBase {
    /** ContentRight. */
    contentRight!: ContentRight;
    /** Found document count. */
    count!: number;

    constructor(data?: IContentRightAggregationCount) {
        super(data);
        this.setProp("object", "ContentRight", "contentRight", false);
        this.setProp("object", "number", "count", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentRightAggregationCount {
        return ContentRightAggregationCount.fromJS(data);
     }

    static fromJS(data: any): ContentRightAggregationCount {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRightAggregationCount();
        result.init(data);
        return result;
    }

}

/** Combination of ContentRight and found document count */
export interface IContentRightAggregationCount {
    /** ContentRight. */
    contentRight: ContentRight;
    /** Found document count. */
    count: number;
}

export class Content extends DTOBase {
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId!: string;
    /** The content type of this content. All except ContentItem are binary files. */
    contentType!: ContentType;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues!: { [key: string] : string; };
    id!: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;

    constructor(data?: IContent) {
        super(data);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("object", "ContentType", "contentType", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("dictionary", "{ [key: string] : string; }", "displayValues", false);
        this.setProp("object", "string", "id", false);
        this.setProp("array", "string[]", "brokenReferenceIds", false);
        this.setProp("array", "string[]", "brokenIndirectReferenceIds", false);
        this.setProp("array", "string[]", "brokenRelationTargetIds", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.displayValues = {};
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Content {
        return Content.fromJS(data);
     }

    static fromJS(data: any): Content {
        data = typeof data === 'object' ? data : {};
        let result = new Content();
        result.init(data);
        return result;
    }

}

export interface IContent {
    /** Audit information. */
    audit?: IUserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId: string;
    /** The content type of this content. All except ContentItem are binary files. */
    contentType: ContentType;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues: { [key: string] : string; };
    id: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
}

/** Request to search contents */
export class ContentSearchRequest extends DTOBase {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search among the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the contents. */
    filter?: FilterBase | undefined;
    /** Limits the search to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;
    /** Limits the search to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Limits the contents to the ones the user has the specified ContentRights. */
    rightsFilter?: ContentRight[] | undefined;
    /** Returns the aggregated document counts to the ones the user has the specified ContentRights.
Produces the rightsAggregationCounts on the ContentSearchResult. View will be ignored as the totalResults already gives this information. */
    rightsAggregations?: ContentRight[] | undefined;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType!: ContentSearchType;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ContentSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: IContentSearchRequest) {
        super(data);
        this.setProp("object", "string", "channelId", false);
        this.setProp("array", "string[]", "displayPatternIds", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "string", "collectionId", false);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "LifeCycleFilter", "lifeCycleFilter", false);
        this.setProp("object", "BrokenDependenciesFilter", "brokenDependenciesFilter", false);
        this.setProp("array", "ContentRight[]", "rightsFilter", false);
        this.setProp("array", "ContentRight[]", "rightsAggregations", false);
        this.setProp("object", "ContentSearchType", "searchType", false);
        this.setProp("object", "boolean", "debugMode", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentSearchRequest {
        return ContentSearchRequest.fromJS(data);
     }

    static fromJS(data: any): ContentSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search contents */
export interface IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search among the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the contents. */
    filter?: FilterBase | undefined;
    /** Limits the search to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the search to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the contents to the ones the user has the specified ContentRights. */
    rightsFilter?: ContentRight[] | undefined;
    /** Returns the aggregated document counts to the ones the user has the specified ContentRights.
Produces the rightsAggregationCounts on the ContentSearchResult. View will be ignored as the totalResults already gives this information. */
    rightsAggregations?: ContentRight[] | undefined;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ContentSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

export enum LifeCycleFilter {
    ActiveOnly = "ActiveOnly",
    All = "All",
    InactiveOnly = "InactiveOnly",
    ActiveInactiveOnly = "ActiveInactiveOnly",
}

/** Filter items with broken or not broken dependencies */
export enum BrokenDependenciesFilter {
    All = "All",
    NotBrokenOnly = "NotBrokenOnly",
    BrokenOnly = "BrokenOnly",
}

export enum ContentSearchType {
    Metadata = "Metadata",
    FullText = "FullText",
    MetadataAndFullText = "MetadataAndFullText",
}

/** Result for an aggregation operation */
export class ObjectAggregationResult extends DTOBase {
    /** How long did the search and aggregation took. */
    elapsedMilliseconds!: number;
    /** Results of the aggregation. */
    aggregationResults!: AggregationResult[];
    /** Search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten!: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. */
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IObjectAggregationResult) {
        super(data);
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("array", "AggregationResult[]", "aggregationResults", true, (item: any) => AggregationResult.fromJS(item));
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.aggregationResults = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ObjectAggregationResult {
        return ObjectAggregationResult.fromJS(data);
     }

    static fromJS(data: any): ObjectAggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectAggregationResult();
        result.init(data);
        return result;
    }

}

/** Result for an aggregation operation */
export interface IObjectAggregationResult {
    /** How long did the search and aggregation took. */
    elapsedMilliseconds: number;
    /** Results of the aggregation. */
    aggregationResults: IAggregationResult[];
    /** Search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. */
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result of an aggregation */
export class AggregationResult extends DTOBase {
    /** Name of the aggregation. */
    name!: string;
    /** When there are lots of unique terms, Elastic Search only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response. */
    sumOtherDocCount?: number | undefined;
    /** Items returned for the aggregation. Each item consists of a bucket with the matched value and the number of matches.
Optionally inner aggregations for further drill down can be available. */
    aggregationResultItems?: AggregationResultItem[] | undefined;

    constructor(data?: IAggregationResult) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "number", "sumOtherDocCount", false);
        this.setProp("array", "AggregationResultItem[]", "aggregationResultItems", true, (item: any) => AggregationResultItem.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregationResult {
        return AggregationResult.fromJS(data);
     }

    static fromJS(data: any): AggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationResult();
        result.init(data);
        return result;
    }

}

/** Result of an aggregation */
export interface IAggregationResult {
    /** Name of the aggregation. */
    name: string;
    /** When there are lots of unique terms, Elastic Search only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response. */
    sumOtherDocCount?: number | undefined;
    /** Items returned for the aggregation. Each item consists of a bucket with the matched value and the number of matches.
Optionally inner aggregations for further drill down can be available. */
    aggregationResultItems?: IAggregationResultItem[] | undefined;
}

/** Aggregation result item */
export class AggregationResultItem extends DTOBase {
    /** Value matched. */
    name!: string;
    /** Number of items matched. */
    count!: number;
    /** Ready to use filter to filter the data based on the aggregation result values.
It can be passed as one of the aggregation filters of an aggregation query: it returns documents meeting the aggregation condition. */
    filter?: AggregationFilter | undefined;
    /** True if the current result item matches on of the aggregation filters sent in the query. */
    active!: boolean;
    /** Inner aggregation results, if inner aggregations were provided in the query. */
    aggregationResults?: AggregationResult[] | undefined;

    getDisplayName(locale: string) {
        let displayName;

        // remove guid and show only owner name. example: name: "534e5b3763f242629eca53e764d713bf/cp support"
        if (this.filter && this.filter.aggregationName === 'ownerTokenId') {
          displayName = this.name.split("/").pop() || null;
        } else {
          displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null;
        }
        
        return displayName ? displayName : this.name;
    }

    constructor(data?: IAggregationResultItem) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "number", "count", false);
        this.setProp("object", "AggregationFilter", "filter", true, (item: any) => AggregationFilter.fromJS(item));
        this.setProp("object", "boolean", "active", false);
        this.setProp("array", "AggregationResult[]", "aggregationResults", true, (item: any) => AggregationResult.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AggregationResultItem {
        return AggregationResultItem.fromJS(data);
     }

    static fromJS(data: any): AggregationResultItem {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationResultItem();
        result.init(data);
        return result;
    }

}

/** Aggregation result item */
export interface IAggregationResultItem {
    /** Value matched. */
    name: string;
    /** Number of items matched. */
    count: number;
    /** Ready to use filter to filter the data based on the aggregation result values.
It can be passed as one of the aggregation filters of an aggregation query: it returns documents meeting the aggregation condition. */
    filter?: AggregationFilter | undefined;
    /** True if the current result item matches on of the aggregation filters sent in the query. */
    active: boolean;
    /** Inner aggregation results, if inner aggregations were provided in the query. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Request to aggregate contents based on the aggregators defined on a channel */
export class ContentAggregationOnChannelRequest extends DTOBase {
    /** The string used to query the list items to aggregate. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional filter to limit the contents to aggregate on. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. Defaults to RootChannel.
For the ContentAggregationOnChannelRequest only, the existing aggregation saved on the channel are retrieved and used to perform the aggregation. */
    channelId?: string | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limit the search to the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** Limits the aggregation to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;
    /** Limits the aggregation to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType!: ContentSearchType;

    constructor(data?: IContentAggregationOnChannelRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("array", "AggregationFilter[]", "aggregationFilters", true, (item: any) => AggregationFilter.fromJS(item));
        this.setProp("object", "string", "channelId", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "string", "collectionId", false);
        this.setProp("object", "LifeCycleFilter", "lifeCycleFilter", false);
        this.setProp("object", "BrokenDependenciesFilter", "brokenDependenciesFilter", false);
        this.setProp("object", "ContentSearchType", "searchType", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentAggregationOnChannelRequest {
        return ContentAggregationOnChannelRequest.fromJS(data);
     }

    static fromJS(data: any): ContentAggregationOnChannelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAggregationOnChannelRequest();
        result.init(data);
        return result;
    }

}

/** Request to aggregate contents based on the aggregators defined on a channel */
export interface IContentAggregationOnChannelRequest {
    /** The string used to query the list items to aggregate. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional filter to limit the contents to aggregate on. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. Defaults to RootChannel.
For the ContentAggregationOnChannelRequest only, the existing aggregation saved on the channel are retrieved and used to perform the aggregation. */
    channelId?: string | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limit the search to the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** Limits the aggregation to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the aggregation to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType: ContentSearchType;
}

/** Request to aggregate contents based on the specified aggregators */
export class ContentAggregationRequest extends ContentAggregationOnChannelRequest implements IContentAggregationRequest {
    /** List of aggregators that defines how the contents should be aggregated. */
    aggregators!: AggregatorBase[];

    constructor(data?: IContentAggregationRequest) {
        super(data);
        this.setProp("array", "AggregatorBase[]", "aggregators", true, (item: any) => AggregatorBase.fromJS(item));

        if (!data) {
            this.aggregators = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentAggregationRequest {
        return ContentAggregationRequest.fromJS(data);
     }

    static fromJS(data: any): ContentAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAggregationRequest();
        result.init(data);
        return result;
    }

}

/** Request to aggregate contents based on the specified aggregators */
export interface IContentAggregationRequest extends IContentAggregationOnChannelRequest {
    /** List of aggregators that defines how the contents should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Result to a get content references operation */
export class ContentReferencesResult extends DTOBase {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: MetadataReferenceResult | undefined;
    /** List of share references */
    shareReferences?: ContentShareReferenceResult | undefined;

    constructor(data?: IContentReferencesResult) {
        super(data);
        this.setProp("object", "MetadataReferenceResult", "metadataReferences", true, (item: any) => MetadataReferenceResult.fromJS(item));
        this.setProp("object", "ContentShareReferenceResult", "shareReferences", true, (item: any) => ContentShareReferenceResult.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentReferencesResult {
        return ContentReferencesResult.fromJS(data);
     }

    static fromJS(data: any): ContentReferencesResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferencesResult();
        result.init(data);
        return result;
    }

}

/** Result to a get content references operation */
export interface IContentReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: IMetadataReferenceResult | undefined;
    /** List of share references */
    shareReferences?: IContentShareReferenceResult | undefined;
}

export class BaseResultOfMetadataReference extends DTOBase {
    totalResults!: number;
    results!: MetadataReference[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfMetadataReference) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "MetadataReference[]", "results", true, (item: any) => MetadataReference.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfMetadataReference {
        return BaseResultOfMetadataReference.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfMetadataReference {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfMetadataReference();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfMetadataReference {
    totalResults: number;
    results: IMetadataReference[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Result for getting references. */
export class MetadataReferenceResult extends BaseResultOfMetadataReference implements IMetadataReferenceResult {
    /** Indicates if any reference is originating from an item that the current user does not have access to. */
    isReferencedByRestrictedItem?: boolean | undefined;

    constructor(data?: IMetadataReferenceResult) {
        super(data);
        this.setProp("object", "boolean", "isReferencedByRestrictedItem", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataReferenceResult {
        return MetadataReferenceResult.fromJS(data);
     }

    static fromJS(data: any): MetadataReferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReferenceResult();
        result.init(data);
        return result;
    }

}

/** Result for getting references. */
export interface IMetadataReferenceResult extends IBaseResultOfMetadataReference {
    /** Indicates if any reference is originating from an item that the current user does not have access to. */
    isReferencedByRestrictedItem?: boolean | undefined;
}

/** Reference to a metadata item */
export class MetadataReference extends DTOBase {
    /** Target ID of reference. */
    targetMetadataItemId!: string;
    /** Indicates if the source of the reference is restricted because of permissions.
If this is true and the SourceMetadataItemId property is filled, the user does not have the
edit permission on the source metadata item. If the SourceMetadataItemId is null, the user also
does not have the view permission on that item. */
    isRestricted!: boolean;
    /** ID of the source of the reference. */
    sourceMetadataItemId?: string | undefined;
    /** DocType of the source of the reference. */
    sourceDocType?: string | undefined;

    constructor(data?: IMetadataReference) {
        super(data);
        this.setProp("object", "string", "targetMetadataItemId", false);
        this.setProp("object", "boolean", "isRestricted", false);
        this.setProp("object", "string", "sourceMetadataItemId", false);
        this.setProp("object", "string", "sourceDocType", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataReference {
        return MetadataReference.fromJS(data);
     }

    static fromJS(data: any): MetadataReference {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReference();
        result.init(data);
        return result;
    }

}

/** Reference to a metadata item */
export interface IMetadataReference {
    /** Target ID of reference. */
    targetMetadataItemId: string;
    /** Indicates if the source of the reference is restricted because of permissions.
If this is true and the SourceMetadataItemId property is filled, the user does not have the
edit permission on the source metadata item. If the SourceMetadataItemId is null, the user also
does not have the view permission on that item. */
    isRestricted: boolean;
    /** ID of the source of the reference. */
    sourceMetadataItemId?: string | undefined;
    /** DocType of the source of the reference. */
    sourceDocType?: string | undefined;
}

export class BaseResultOfContentShareReference extends DTOBase {
    totalResults!: number;
    results!: ContentShareReference[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfContentShareReference) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "ContentShareReference[]", "results", true, (item: any) => ContentShareReference.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfContentShareReference {
        return BaseResultOfContentShareReference.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfContentShareReference {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfContentShareReference();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfContentShareReference {
    totalResults: number;
    results: IContentShareReference[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Result class for share reference search */
export class ContentShareReferenceResult extends BaseResultOfContentShareReference implements IContentShareReferenceResult {

    constructor(data?: IContentShareReferenceResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentShareReferenceResult {
        return ContentShareReferenceResult.fromJS(data);
     }

    static fromJS(data: any): ContentShareReferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareReferenceResult();
        result.init(data);
        return result;
    }

}

/** Result class for share reference search */
export interface IContentShareReferenceResult extends IBaseResultOfContentShareReference {
}

/** Share information for a share referencing a content */
export class ContentShareReference extends DTOBase {
    /** ID of the share. */
    id?: string | undefined;
    /** Name of the share. */
    name?: string | undefined;
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** Type of the share. */
    shareType!: ShareType;
    /** The email address of the user who created the share. */
    emailAddress?: string | undefined;

    constructor(data?: IContentShareReference) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "ShareType", "shareType", false);
        this.setProp("object", "string", "emailAddress", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentShareReference {
        return ContentShareReference.fromJS(data);
     }

    static fromJS(data: any): ContentShareReference {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareReference();
        result.init(data);
        return result;
    }

}

/** Share information for a share referencing a content */
export interface IContentShareReference {
    /** ID of the share. */
    id?: string | undefined;
    /** Name of the share. */
    name?: string | undefined;
    /** Audit information. */
    audit?: IUserAudit | undefined;
    /** Type of the share. */
    shareType: ShareType;
    /** The email address of the user who created the share. */
    emailAddress?: string | undefined;
}

export enum ShareType {
    Basic = "Basic",
    Embed = "Embed",
}

/** Request to get the references to a content */
export class ContentReferencesRequest extends DTOBase {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: PagingRequest | undefined;

    constructor(data?: IContentReferencesRequest) {
        super(data);
        this.setProp("object", "MetadataReferencesPagingRequest", "references", true, (item: any) => MetadataReferencesPagingRequest.fromJS(item));
        this.setProp("object", "PagingRequest", "shares", true, (item: any) => PagingRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentReferencesRequest {
        return ContentReferencesRequest.fromJS(data);
     }

    static fromJS(data: any): ContentReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferencesRequest();
        result.init(data);
        return result;
    }

}

/** Request to get the references to a content */
export interface IContentReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: IPagingRequest | undefined;
}

/** Request to page data */
export class PagingRequest extends DTOBase {
    /** Limits the number of the returned schemas. Defaults to 0. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;

    constructor(data?: IPagingRequest) {
        super(data);
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PagingRequest {
        return PagingRequest.fromJS(data);
     }

    static fromJS(data: any): PagingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingRequest();
        result.init(data);
        return result;
    }

}

/** Request to page data */
export interface IPagingRequest {
    /** Limits the number of the returned schemas. Defaults to 0. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
}

/** Request to get paginated metadata references */
export class MetadataReferencesPagingRequest extends PagingRequest implements IMetadataReferencesPagingRequest {
    /** Set to true to check if any incoming references are originating from an item the current user does not have full access to. */
    fetchReferencedByRestrictedItem!: boolean;

    constructor(data?: IMetadataReferencesPagingRequest) {
        super(data);
        this.setProp("object", "boolean", "fetchReferencedByRestrictedItem", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataReferencesPagingRequest {
        return MetadataReferencesPagingRequest.fromJS(data);
     }

    static fromJS(data: any): MetadataReferencesPagingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReferencesPagingRequest();
        result.init(data);
        return result;
    }

}

/** Request to get paginated metadata references */
export interface IMetadataReferencesPagingRequest extends IPagingRequest {
    /** Set to true to check if any incoming references are originating from an item the current user does not have full access to. */
    fetchReferencedByRestrictedItem: boolean;
}

/** Request to get multiple contents' references */
export class ContentManyReferencesRequest extends DTOBase {
    /** The IDs of the contents whose references need to be retrieved. */
    contentIds!: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: PagingRequest | undefined;

    constructor(data?: IContentManyReferencesRequest) {
        super(data);
        this.setProp("array", "string[]", "contentIds", false);
        this.setProp("object", "MetadataReferencesPagingRequest", "references", true, (item: any) => MetadataReferencesPagingRequest.fromJS(item));
        this.setProp("object", "PagingRequest", "shares", true, (item: any) => PagingRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentManyReferencesRequest {
        return ContentManyReferencesRequest.fromJS(data);
     }

    static fromJS(data: any): ContentManyReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentManyReferencesRequest();
        result.init(data);
        return result;
    }

}

/** Request to get multiple contents' references */
export interface IContentManyReferencesRequest {
    /** The IDs of the contents whose references need to be retrieved. */
    contentIds: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: IPagingRequest | undefined;
}

/** Download link information */
export class DownloadLink extends DTOBase {
    /** Token of the download, used to generate the url. */
    downloadToken!: string;
    /** Url of the download link. */
    downloadUrl!: string;

    constructor(data?: IDownloadLink) {
        super(data);
        this.setProp("object", "string", "downloadToken", false);
        this.setProp("object", "string", "downloadUrl", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DownloadLink {
        return DownloadLink.fromJS(data);
     }

    static fromJS(data: any): DownloadLink {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadLink();
        result.init(data);
        return result;
    }

}

/** Download link information */
export interface IDownloadLink {
    /** Token of the download, used to generate the url. */
    downloadToken: string;
    /** Url of the download link. */
    downloadUrl: string;
}

/** Request to create a content download link */
export class ContentDownloadLinkCreateRequest extends DTOBase {
    /** List of content information to generate the download link */
    contents!: ContentDownloadRequestItem[];

    constructor(data?: IContentDownloadLinkCreateRequest) {
        super(data);
        this.setProp("array", "ContentDownloadRequestItem[]", "contents", true, (item: any) => ContentDownloadRequestItem.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.contents = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDownloadLinkCreateRequest {
        return ContentDownloadLinkCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentDownloadLinkCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadLinkCreateRequest();
        result.init(data);
        return result;
    }

}

/** Request to create a content download link */
export interface IContentDownloadLinkCreateRequest {
    /** List of content information to generate the download link */
    contents: IContentDownloadRequestItem[];
}

/** Information needed to generate a content download link */
export class ContentDownloadRequestItem extends DTOBase {
    /** ID of the content that is going to be downloaded. */
    contentId!: string;
    /** ID of the output format that is going to be downloaded. */
    outputFormatId!: string;

    constructor(data?: IContentDownloadRequestItem) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDownloadRequestItem {
        return ContentDownloadRequestItem.fromJS(data);
     }

    static fromJS(data: any): ContentDownloadRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadRequestItem();
        result.init(data);
        return result;
    }

}

/** Information needed to generate a content download link */
export interface IContentDownloadRequestItem {
    /** ID of the content that is going to be downloaded. */
    contentId: string;
    /** ID of the output format that is going to be downloaded. */
    outputFormatId: string;
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = "Small",
    Medium = "Medium",
    Large = "Large",
}

/** A request structure for creating a content document. */
export class ContentCreateRequest extends DTOBase {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IContentCreateRequest) {
        super(data);
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "any", "content", false);
        this.setProp("object", "DataDictionary", "metadata", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("array", "string[]", "contentPermissionSetIds", false);
        this.setProp("object", "string", "requestId", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentCreateRequest {
        return ContentCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCreateRequest();
        result.init(data);
        return result;
    }

}

/** A request structure for creating a content document. */
export interface IContentCreateRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: IDataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** A request structure for creating multiple content documents. */
export class ContentCreateManyRequest extends DTOBase {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies!: boolean;
    /** Create items */
    items?: ContentCreateRequest[] | undefined;

    constructor(data?: IContentCreateManyRequest) {
        super(data);
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("array", "ContentCreateRequest[]", "items", true, (item: any) => ContentCreateRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentCreateManyRequest {
        return ContentCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCreateManyRequest();
        result.init(data);
        return result;
    }

}

/** A request structure for creating multiple content documents. */
export interface IContentCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: IContentCreateRequest[] | undefined;
}

/** Request to delete multiple contents. */
export class ContentDeleteManyRequest extends DTOBase {
    /** IDs of the contents to delete. */
    contentIds!: string[];
    /** A value indicating whether references to the contents should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IContentDeleteManyRequest) {
        super(data);
        this.setProp("array", "string[]", "contentIds", false);
        this.setProp("object", "boolean", "forceReferenceRemoval", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (!data) {
            this.contentIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDeleteManyRequest {
        return ContentDeleteManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDeleteManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to delete multiple contents. */
export interface IContentDeleteManyRequest {
    /** IDs of the contents to delete. */
    contentIds: string[];
    /** A value indicating whether references to the contents should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to delete multiple contents based on a provided filter */
export class ContentDeleteManyFilterRequest extends DTOBase {
    /** Filters the contents that need to be deleted. */
    filterRequest!: ContentFilterRequest;
    /** A value indicating whether references to the content items should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IContentDeleteManyFilterRequest) {
        super(data);
        this.setProp("object", "ContentFilterRequest", "filterRequest", true, (item: any) => ContentFilterRequest.fromJS(item));
        this.setProp("object", "boolean", "forceReferenceRemoval", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.filterRequest = new ContentFilterRequest();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDeleteManyFilterRequest {
        return ContentDeleteManyFilterRequest.fromJS(data);
     }

    static fromJS(data: any): ContentDeleteManyFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDeleteManyFilterRequest();
        result.init(data);
        return result;
    }

}

/** Request to delete multiple contents based on a provided filter */
export interface IContentDeleteManyFilterRequest {
    /** Filters the contents that need to be deleted. */
    filterRequest: IContentFilterRequest;
    /** A value indicating whether references to the content items should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

export class ContentFilterRequest extends DTOBase {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType!: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;

    constructor(data?: IContentFilterRequest) {
        super(data);
        this.setProp("object", "string", "channelId", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "ContentSearchType", "searchType", false);
        this.setProp("object", "string", "collectionId", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "LifeCycleFilter", "lifeCycleFilter", false);
        this.setProp("object", "BrokenDependenciesFilter", "brokenDependenciesFilter", false);
        this.setProp("array", "ContentRight[]", "rightsFilter", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentFilterRequest {
        return ContentFilterRequest.fromJS(data);
     }

    static fromJS(data: any): ContentFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFilterRequest();
        result.init(data);
        return result;
    }

}

export interface IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
}

/** Request to restore multiple contents */
export class ContentRestoreManyRequest extends DTOBase {
    /** IDs of the contents to restore. */
    contentIds!: string[];
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;

    constructor(data?: IContentRestoreManyRequest) {
        super(data);
        this.setProp("array", "string[]", "contentIds", false);
        this.setProp("object", "boolean", "allowMissingDependencies", false);

        if (!data) {
            this.contentIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentRestoreManyRequest {
        return ContentRestoreManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentRestoreManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRestoreManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to restore multiple contents */
export interface IContentRestoreManyRequest {
    /** IDs of the contents to restore. */
    contentIds: string[];
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
}

/** Request to update a content file */
export class ContentFileUpdateRequest extends DTOBase {
    /** ID of the file transfer to use to replace the content file. */
    fileTransferId!: string;

    constructor(data?: IContentFileUpdateRequest) {
        super(data);
        this.setProp("object", "string", "fileTransferId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentFileUpdateRequest {
        return ContentFileUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentFileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update a content file */
export interface IContentFileUpdateRequest {
    /** ID of the file transfer to use to replace the content file. */
    fileTransferId: string;
}

/** Request to update content metadata */
export class ContentMetadataUpdateRequest extends DTOBase {
    /** An optional list of IDs of the schemas that should be updated/replaced based on the options below and Metadata provided.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's a dictionary of dynamic metadata whose structure is defined in the Content schema identified by
the ContentSchemaId property. Updating the Content property is only possible for virtual items (contents
whose ContentType is ContentItem).
Update of content data will be done only if this attribute has any data, i.e. if it's not null or empty. */
    content?: DataDictionary | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property.
If there are no data for a specified LayerSchemaId, it is treated as empty. */
    metadata?: DataDictionary | undefined;
    /** Options to modify the behavior for updating the layers.
Merge: the content is updated so that the assigned layers to the content will be a merge of the ones specified in the LayerSchemaIds property
and the ones already existing; existing assigned layers not specified in the property are kept and missing layers are assigned.
Replace: the content is updated so that only the layers specified in the LayerSchemaIds property are assigned to the content;
existing assigned layers not specified in the property are removed and missing layers are assigned.
Defaults to Merge. */
    layerSchemasUpdateOptions!: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas.
Merge: the values specified in the Content and Metadata dictionaries are merged to the existing values of the corresponding
schema on the content.
Replace: the values specified in the Content and Metadata dictionaries entirely replace any existing value of the
corresponding schema on the content.
Defaults to Merge. */
    schemaFieldsUpdateOptions!: UpdateOption;

    constructor(data?: IContentMetadataUpdateRequest) {
        super(data);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "DataDictionary", "content", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("object", "DataDictionary", "metadata", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("object", "UpdateOption", "layerSchemasUpdateOptions", false);
        this.setProp("object", "UpdateOption", "schemaFieldsUpdateOptions", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentMetadataUpdateRequest {
        return ContentMetadataUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentMetadataUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update content metadata */
export interface IContentMetadataUpdateRequest {
    /** An optional list of IDs of the schemas that should be updated/replaced based on the options below and Metadata provided.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's a dictionary of dynamic metadata whose structure is defined in the Content schema identified by
the ContentSchemaId property. Updating the Content property is only possible for virtual items (contents
whose ContentType is ContentItem).
Update of content data will be done only if this attribute has any data, i.e. if it's not null or empty. */
    content?: IDataDictionary | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property.
If there are no data for a specified LayerSchemaId, it is treated as empty. */
    metadata?: IDataDictionary | undefined;
    /** Options to modify the behavior for updating the layers.
Merge: the content is updated so that the assigned layers to the content will be a merge of the ones specified in the LayerSchemaIds property
and the ones already existing; existing assigned layers not specified in the property are kept and missing layers are assigned.
Replace: the content is updated so that only the layers specified in the LayerSchemaIds property are assigned to the content;
existing assigned layers not specified in the property are removed and missing layers are assigned.
Defaults to Merge. */
    layerSchemasUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas.
Merge: the values specified in the Content and Metadata dictionaries are merged to the existing values of the corresponding
schema on the content.
Replace: the values specified in the Content and Metadata dictionaries entirely replace any existing value of the
corresponding schema on the content.
Defaults to Merge. */
    schemaFieldsUpdateOptions: UpdateOption;
}

/** Controls the update of metadata */
export enum UpdateOption {
    Merge = "Merge",
    Replace = "Replace",
}

/** Request to update the permissions of a content */
export class ContentPermissionsUpdateRequest extends DTOBase {
    /** A list of content permission set IDs which control content permissions that will be updated on the content.
These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IContentPermissionsUpdateRequest) {
        super(data);
        this.setProp("array", "string[]", "contentPermissionSetIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionsUpdateRequest {
        return ContentPermissionsUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update the permissions of a content */
export interface IContentPermissionsUpdateRequest {
    /** A list of content permission set IDs which control content permissions that will be updated on the content.
These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
}

/** Request to update many contents metadata */
export class ContentMetadataUpdateManyRequest extends DTOBase {
    /** Allows storing references to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Update items */
    items!: ContentMetadataUpdateItem[];

    constructor(data?: IContentMetadataUpdateManyRequest) {
        super(data);
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("array", "ContentMetadataUpdateItem[]", "items", true, (item: any) => ContentMetadataUpdateItem.fromJS(item));

        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentMetadataUpdateManyRequest {
        return ContentMetadataUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentMetadataUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to update many contents metadata */
export interface IContentMetadataUpdateManyRequest {
    /** Allows storing references to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Update items */
    items: ContentMetadataUpdateItem[];
}

/** Item to update content metadata */
export class ContentMetadataUpdateItem extends ContentMetadataUpdateRequest implements IContentMetadataUpdateItem {
    /** The ID of the content. */
    id!: string;

    constructor(data?: IContentMetadataUpdateItem) {
        super(data);
        this.setProp("object", "string", "id", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentMetadataUpdateItem {
        return ContentMetadataUpdateItem.fromJS(data);
     }

    static fromJS(data: any): ContentMetadataUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateItem();
        result.init(data);
        return result;
    }

}

/** Item to update content metadata */
export interface IContentMetadataUpdateItem extends IContentMetadataUpdateRequest {
    /** The ID of the content. */
    id: string;
}

/** Request to update multiple contents permissions */
export class ContentPermissionsUpdateManyRequest extends DTOBase {
    /** Content permissions update items */
    items!: ContentPermissionsUpdateItem[];

    constructor(data?: IContentPermissionsUpdateManyRequest) {
        super(data);
        this.setProp("array", "ContentPermissionsUpdateItem[]", "items", true, (item: any) => ContentPermissionsUpdateItem.fromJS(item));

        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionsUpdateManyRequest {
        return ContentPermissionsUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionsUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to update multiple contents permissions */
export interface IContentPermissionsUpdateManyRequest {
    /** Content permissions update items */
    items: ContentPermissionsUpdateItem[];
}

/** Content permissions update item */
export class ContentPermissionsUpdateItem extends ContentPermissionsUpdateRequest implements IContentPermissionsUpdateItem {
    /** ID of the content. */
    contentId!: string;

    constructor(data?: IContentPermissionsUpdateItem) {
        super(data);
        this.setProp("object", "string", "contentId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionsUpdateItem {
        return ContentPermissionsUpdateItem.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionsUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateItem();
        result.init(data);
        return result;
    }

}

/** Content permissions update item */
export interface IContentPermissionsUpdateItem extends IContentPermissionsUpdateRequest {
    /** ID of the content. */
    contentId: string;
}

/** Request to transfer the content ownership */
export class ContentOwnershipTransferRequest extends DTOBase {
    /** The ID of the user to whom the content ownership has to be transferred to. */
    transferUserId!: string;

    constructor(data?: IContentOwnershipTransferRequest) {
        super(data);
        this.setProp("object", "string", "transferUserId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentOwnershipTransferRequest {
        return ContentOwnershipTransferRequest.fromJS(data);
     }

    static fromJS(data: any): ContentOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferRequest();
        result.init(data);
        return result;
    }

}

/** Request to transfer the content ownership */
export interface IContentOwnershipTransferRequest {
    /** The ID of the user to whom the content ownership has to be transferred to. */
    transferUserId: string;
}

/** Request to transfer multiple contents ownerships */
export class ContentOwnershipTransferManyRequest extends DTOBase {
    /** List of Content Permissions ownership transfer items. */
    items!: ContentOwnershipTransferItem[];

    constructor(data?: IContentOwnershipTransferManyRequest) {
        super(data);
        this.setProp("array", "ContentOwnershipTransferItem[]", "items", true, (item: any) => ContentOwnershipTransferItem.fromJS(item));

        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentOwnershipTransferManyRequest {
        return ContentOwnershipTransferManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to transfer multiple contents ownerships */
export interface IContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer items. */
    items: ContentOwnershipTransferItem[];
}

/** Content ownership transfer item */
export class ContentOwnershipTransferItem extends ContentOwnershipTransferRequest implements IContentOwnershipTransferItem {
    /** The content ID. */
    contentId!: string;

    constructor(data?: IContentOwnershipTransferItem) {
        super(data);
        this.setProp("object", "string", "contentId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentOwnershipTransferItem {
        return ContentOwnershipTransferItem.fromJS(data);
     }

    static fromJS(data: any): ContentOwnershipTransferItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferItem();
        result.init(data);
        return result;
    }

}

/** Content ownership transfer item */
export interface IContentOwnershipTransferItem extends IContentOwnershipTransferRequest {
    /** The content ID. */
    contentId: string;
}

/** Base class for the content metadata batch requests. */
export abstract class MetadataValuesChangeRequestBase extends DTOBase {
    /** Changes that need to be applied to the existing content metadata. The same set of changes is applied to all contents. */
    changeCommands!: MetadataValuesChangeCommandBase[];
    /** Allows updating contents with references to list items or contents that do not exist in the system. */
    allowMissingDependencies!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress!: boolean;

    protected _kind: string;

    constructor(data?: IMetadataValuesChangeRequestBase) {
        super(data);
        this.setProp("array", "MetadataValuesChangeCommandBase[]", "changeCommands", true, (item: any) => MetadataValuesChangeCommandBase.fromJS(item));
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (!data) {
            this.changeCommands = [];
        }
        this._kind = "MetadataValuesChangeRequestBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesChangeRequestBase {
        return MetadataValuesChangeRequestBase.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesChangeRequestBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ContentFieldsBatchUpdateRequest") {
            let result = new ContentFieldsBatchUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFieldsBatchUpdateFilterRequest") {
            let result = new ContentFieldsBatchUpdateFilterRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeRequestBase' cannot be instantiated.");
    }

}

/** Base class for the content metadata batch requests. */
export interface IMetadataValuesChangeRequestBase {
    /** Changes that need to be applied to the existing content metadata. The same set of changes is applied to all contents. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allows updating contents with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Request to batch update contents' fields based on content IDs */
export class ContentFieldsBatchUpdateRequest extends MetadataValuesChangeRequestBase implements IContentFieldsBatchUpdateRequest {
    /** The IDs of the contents whose fields need to be updated. */
    contentIds!: string[];

    constructor(data?: IContentFieldsBatchUpdateRequest) {
        super(data);
        this.setProp("array", "string[]", "contentIds", false);

        if (!data) {
            this.contentIds = [];
        }
        this._kind = "ContentFieldsBatchUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentFieldsBatchUpdateRequest {
        return ContentFieldsBatchUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentFieldsBatchUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFieldsBatchUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to batch update contents' fields based on content IDs */
export interface IContentFieldsBatchUpdateRequest extends IMetadataValuesChangeRequestBase {
    /** The IDs of the contents whose fields need to be updated. */
    contentIds: string[];
}

/** The base class for metadata value change commands. */
export abstract class MetadataValuesChangeCommandBase extends DTOBase {
    /** The ID of the schema to which the operation scope is addressed. */
    schemaId!: string;

    protected _kind: string;

    constructor(data?: IMetadataValuesChangeCommandBase) {
        super(data);
        this.setProp("object", "string", "schemaId", false);

        this._kind = "MetadataValuesChangeCommandBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesChangeCommandBase {
        return MetadataValuesChangeCommandBase.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesChangeCommandBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "MetadataValuesSchemaUpdateCommand") {
            let result = new MetadataValuesSchemaUpdateCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaUpsertCommand") {
            let result = new MetadataValuesSchemaUpsertCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaRemoveCommand") {
            let result = new MetadataValuesSchemaRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaReplaceCommand") {
            let result = new MetadataValuesSchemaReplaceCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesFieldRemoveCommand") {
            let result = new MetadataValuesFieldRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemAddCommand") {
            let result = new MetadataValuesSchemaItemAddCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemRemoveCommand") {
            let result = new MetadataValuesSchemaItemRemoveCommand();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeCommandBase' cannot be instantiated.");
    }

}

/** The base class for metadata value change commands. */
export interface IMetadataValuesChangeCommandBase {
    /** The ID of the schema to which the operation scope is addressed. */
    schemaId: string;
}

/** Updates schema values */
export class MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpdateCommand {
    /** The dictionary containing the metadata values to add / update. */
    value!: DataDictionary;

    constructor(data?: IMetadataValuesSchemaUpdateCommand) {
        super(data);
        this.setProp("object", "DataDictionary", "value", true, (item: any) => DataDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.value = new DataDictionary();
        }
        this._kind = "MetadataValuesSchemaUpdateCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        return MetadataValuesSchemaUpdateCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaUpdateCommand();
        result.init(data);
        return result;
    }

}

/** Updates schema values */
export interface IMetadataValuesSchemaUpdateCommand extends IMetadataValuesChangeCommandBase {
    /** The dictionary containing the metadata values to add / update. */
    value: IDataDictionary;
}

/** Adds or updates schema values */
export class MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpsertCommand {
    /** The dictionary containing the metadata values to add / update. */
    value!: DataDictionary;

    constructor(data?: IMetadataValuesSchemaUpsertCommand) {
        super(data);
        this.setProp("object", "DataDictionary", "value", true, (item: any) => DataDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.value = new DataDictionary();
        }
        this._kind = "MetadataValuesSchemaUpsertCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        return MetadataValuesSchemaUpsertCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaUpsertCommand();
        result.init(data);
        return result;
    }

}

/** Adds or updates schema values */
export interface IMetadataValuesSchemaUpsertCommand extends IMetadataValuesChangeCommandBase {
    /** The dictionary containing the metadata values to add / update. */
    value: IDataDictionary;
}

/** Removes schema and all its values */
export class MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaRemoveCommand {

    constructor(data?: IMetadataValuesSchemaRemoveCommand) {
        super(data);

        this._kind = "MetadataValuesSchemaRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        return MetadataValuesSchemaRemoveCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaRemoveCommand();
        result.init(data);
        return result;
    }

}

/** Removes schema and all its values */
export interface IMetadataValuesSchemaRemoveCommand extends IMetadataValuesChangeCommandBase {
}

/** Replaces schema values */
export class MetadataValuesSchemaReplaceCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaReplaceCommand {
    /** The dictionary containing the metadata values for the schema. The existing dictionary will be entirely overwritten. */
    value!: DataDictionary;

    constructor(data?: IMetadataValuesSchemaReplaceCommand) {
        super(data);
        this.setProp("object", "DataDictionary", "value", true, (item: any) => DataDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.value = new DataDictionary();
        }
        this._kind = "MetadataValuesSchemaReplaceCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesSchemaReplaceCommand {
        return MetadataValuesSchemaReplaceCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesSchemaReplaceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaReplaceCommand();
        result.init(data);
        return result;
    }

}

/** Replaces schema values */
export interface IMetadataValuesSchemaReplaceCommand extends IMetadataValuesChangeCommandBase {
    /** The dictionary containing the metadata values for the schema. The existing dictionary will be entirely overwritten. */
    value: IDataDictionary;
}

/** Removes a field and its value from the values of the specified schema */
export class MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesFieldRemoveCommand {
    /** The path of the field to be removed within the specified schema (i.e. remove the street from the address of a person: fieldPath = "address.streetName", schemaId = "PersonLayer") */
    fieldPath!: string;

    constructor(data?: IMetadataValuesFieldRemoveCommand) {
        super(data);
        this.setProp("object", "string", "fieldPath", false);

        this._kind = "MetadataValuesFieldRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesFieldRemoveCommand {
        return MetadataValuesFieldRemoveCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesFieldRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesFieldRemoveCommand();
        result.init(data);
        return result;
    }

}

/** Removes a field and its value from the values of the specified schema */
export interface IMetadataValuesFieldRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field to be removed within the specified schema (i.e. remove the street from the address of a person: fieldPath = "address.streetName", schemaId = "PersonLayer") */
    fieldPath: string;
}

/** Adds a list item to a FieldMultiTagbox field */
export class MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemAddCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath!: string;
    /** The field namespace */
    fieldNamespace!: string;
    /** The ID of the list item to be added. */
    referenceId!: string;

    constructor(data?: IMetadataValuesSchemaItemAddCommand) {
        super(data);
        this.setProp("object", "string", "fieldPath", false);
        this.setProp("object", "string", "fieldNamespace", false);
        this.setProp("object", "string", "referenceId", false);

        this._kind = "MetadataValuesSchemaItemAddCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        return MetadataValuesSchemaItemAddCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaItemAddCommand();
        result.init(data);
        return result;
    }

}

/** Adds a list item to a FieldMultiTagbox field */
export interface IMetadataValuesSchemaItemAddCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath: string;
    /** The field namespace */
    fieldNamespace: string;
    /** The ID of the list item to be added. */
    referenceId: string;
}

/** Removes a list item from a FieldMultiTagbox field */
export class MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemRemoveCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath!: string;
    /** The field namespace. */
    fieldNamespace!: string;
    /** The ID of the list item to be removed. */
    referenceId!: string;

    constructor(data?: IMetadataValuesSchemaItemRemoveCommand) {
        super(data);
        this.setProp("object", "string", "fieldPath", false);
        this.setProp("object", "string", "fieldNamespace", false);
        this.setProp("object", "string", "referenceId", false);

        this._kind = "MetadataValuesSchemaItemRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        return MetadataValuesSchemaItemRemoveCommand.fromJS(data);
     }

    static fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaItemRemoveCommand();
        result.init(data);
        return result;
    }

}

/** Removes a list item from a FieldMultiTagbox field */
export interface IMetadataValuesSchemaItemRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath: string;
    /** The field namespace. */
    fieldNamespace: string;
    /** The ID of the list item to be removed. */
    referenceId: string;
}

/** Request to batch update contents' fields based on a filter */
export class ContentFieldsBatchUpdateFilterRequest extends MetadataValuesChangeRequestBase implements IContentFieldsBatchUpdateFilterRequest {
    /** Filters the contents on which the change commands must be applied. */
    filterRequest!: ContentFilterRequest;

    constructor(data?: IContentFieldsBatchUpdateFilterRequest) {
        super(data);
        this.setProp("object", "ContentFilterRequest", "filterRequest", true, (item: any) => ContentFilterRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.filterRequest = new ContentFilterRequest();
        }
        this._kind = "ContentFieldsBatchUpdateFilterRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentFieldsBatchUpdateFilterRequest {
        return ContentFieldsBatchUpdateFilterRequest.fromJS(data);
     }

    static fromJS(data: any): ContentFieldsBatchUpdateFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFieldsBatchUpdateFilterRequest();
        result.init(data);
        return result;
    }

}

/** Request to batch update contents' fields based on a filter */
export interface IContentFieldsBatchUpdateFilterRequest extends IMetadataValuesChangeRequestBase {
    /** Filters the contents on which the change commands must be applied. */
    filterRequest: IContentFilterRequest;
}

export abstract class PermissionSetDetailOfContentRight extends DTOBase {
    id!: string;
    names?: TranslatedStringDictionary | undefined;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive!: boolean;
    ownerTokenId!: string;

    constructor(data?: IPermissionSetDetailOfContentRight) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "PermissionUserRoleRightsOfContentRight[]", "userRolesRights", true, (item: any) => PermissionUserRoleRightsOfContentRight.fromJS(item));
        this.setProp("array", "PermissionUserRoleRightsOfPermissionSetRight[]", "userRolesPermissionSetRights", true, (item: any) => PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
        this.setProp("object", "boolean", "exclusive", false);
        this.setProp("object", "string", "ownerTokenId", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetDetailOfContentRight {
        return PermissionSetDetailOfContentRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetDetailOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetDetailOfContentRight' cannot be instantiated.");
    }

}

export interface IPermissionSetDetailOfContentRight {
    id: string;
    names?: ITranslatedStringDictionary | undefined;
    userRolesRights?: IPermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
    ownerTokenId: string;
}

/** Detail of a content permission set */
export class ContentPermissionSetDetail extends PermissionSetDetailOfContentRight implements IContentPermissionSetDetail {

    constructor(data?: IContentPermissionSetDetail) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionSetDetail {
        return ContentPermissionSetDetail.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionSetDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetDetail();
        result.init(data);
        return result;
    }

}

/** Detail of a content permission set */
export interface IContentPermissionSetDetail extends IPermissionSetDetailOfContentRight {
}

export class PermissionUserRoleRightsOfContentRight extends DTOBase {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfContentRight) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "ContentRight[]", "rights", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionUserRoleRightsOfContentRight {
        return PermissionUserRoleRightsOfContentRight.fromJS(data);
     }

    static fromJS(data: any): PermissionUserRoleRightsOfContentRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

}

export interface IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;
}

export class PermissionUserRoleRightsOfPermissionSetRight extends DTOBase {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfPermissionSetRight) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "PermissionSetRight[]", "rights", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionUserRoleRightsOfPermissionSetRight {
        return PermissionUserRoleRightsOfPermissionSetRight.fromJS(data);
     }

    static fromJS(data: any): PermissionUserRoleRightsOfPermissionSetRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

}

export interface IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;
}

/** Permission set rights */
export enum PermissionSetRight {
    Apply = "Apply",
    Manage = "Manage",
}

export abstract class PermissionSetCreateRequestOfContentRight extends DTOBase {
    names?: TranslatedStringDictionary | undefined;
    userRolesRights?: UserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive!: boolean;
    requestId?: string | undefined;

    constructor(data?: IPermissionSetCreateRequestOfContentRight) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "UserRoleRightsOfContentRight[]", "userRolesRights", true, (item: any) => UserRoleRightsOfContentRight.fromJS(item));
        this.setProp("array", "UserRoleRightsOfPermissionSetRight[]", "userRolesPermissionSetRights", true, (item: any) => UserRoleRightsOfPermissionSetRight.fromJS(item));
        this.setProp("object", "boolean", "exclusive", false);
        this.setProp("object", "string", "requestId", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetCreateRequestOfContentRight {
        return PermissionSetCreateRequestOfContentRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetCreateRequestOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetCreateRequestOfContentRight' cannot be instantiated.");
    }

}

export interface IPermissionSetCreateRequestOfContentRight {
    names?: ITranslatedStringDictionary | undefined;
    userRolesRights?: IUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
    requestId?: string | undefined;
}

export class ContentPermissionSetCreateRequest extends PermissionSetCreateRequestOfContentRight implements IContentPermissionSetCreateRequest {

    constructor(data?: IContentPermissionSetCreateRequest) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionSetCreateRequest {
        return ContentPermissionSetCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionSetCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetCreateRequest();
        result.init(data);
        return result;
    }

}

export interface IContentPermissionSetCreateRequest extends IPermissionSetCreateRequestOfContentRight {
}

export class UserRoleRightsOfContentRight extends DTOBase {
    userRoleId?: string | undefined;
    rights?: ContentRight[] | undefined;

    constructor(data?: IUserRoleRightsOfContentRight) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);
        this.setProp("array", "ContentRight[]", "rights", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleRightsOfContentRight {
        return UserRoleRightsOfContentRight.fromJS(data);
     }

    static fromJS(data: any): UserRoleRightsOfContentRight {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

}

export interface IUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    rights?: ContentRight[] | undefined;
}

export class UserRoleRightsOfPermissionSetRight extends DTOBase {
    userRoleId?: string | undefined;
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IUserRoleRightsOfPermissionSetRight) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);
        this.setProp("array", "PermissionSetRight[]", "rights", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleRightsOfPermissionSetRight {
        return UserRoleRightsOfPermissionSetRight.fromJS(data);
     }

    static fromJS(data: any): UserRoleRightsOfPermissionSetRight {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

}

export interface IUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    rights?: PermissionSetRight[] | undefined;
}

export abstract class PermissionSetUpdateRequestOfContentRight extends DTOBase {
    names?: TranslatedStringDictionary | undefined;
    userRolesRights?: UserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;

    constructor(data?: IPermissionSetUpdateRequestOfContentRight) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "UserRoleRightsOfContentRight[]", "userRolesRights", true, (item: any) => UserRoleRightsOfContentRight.fromJS(item));
        this.setProp("array", "UserRoleRightsOfPermissionSetRight[]", "userRolesPermissionSetRights", true, (item: any) => UserRoleRightsOfPermissionSetRight.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetUpdateRequestOfContentRight {
        return PermissionSetUpdateRequestOfContentRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetUpdateRequestOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestOfContentRight' cannot be instantiated.");
    }

}

export interface IPermissionSetUpdateRequestOfContentRight {
    names?: ITranslatedStringDictionary | undefined;
    userRolesRights?: IUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
}

/** Request to update a content permission set */
export class ContentPermissionSetUpdateRequest extends PermissionSetUpdateRequestOfContentRight implements IContentPermissionSetUpdateRequest {

    constructor(data?: IContentPermissionSetUpdateRequest) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionSetUpdateRequest {
        return ContentPermissionSetUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionSetUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update a content permission set */
export interface IContentPermissionSetUpdateRequest extends IPermissionSetUpdateRequestOfContentRight {
}

export class PermissionSetOwnershipTransferRequest extends DTOBase {
    /** The ID of the user to whom the permission set ownership should be transferred to. */
    transferUserId!: string;

    constructor(data?: IPermissionSetOwnershipTransferRequest) {
        super(data);
        this.setProp("object", "string", "transferUserId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetOwnershipTransferRequest {
        return PermissionSetOwnershipTransferRequest.fromJS(data);
     }

    static fromJS(data: any): PermissionSetOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetOwnershipTransferRequest();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetOwnershipTransferRequest {
    /** The ID of the user to whom the permission set ownership should be transferred to. */
    transferUserId: string;
}

/** Response to a bulk operation */
export class BulkResponse extends DTOBase {
    /** Rows of the bulk response. */
    rows?: BulkResponseRow[] | undefined;

    constructor(data?: IBulkResponse) {
        super(data);
        this.setProp("array", "BulkResponseRow[]", "rows", true, (item: any) => BulkResponseRow.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BulkResponse {
        return BulkResponse.fromJS(data);
     }

    static fromJS(data: any): BulkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResponse();
        result.init(data);
        return result;
    }

}

/** Response to a bulk operation */
export interface IBulkResponse {
    /** Rows of the bulk response. */
    rows?: IBulkResponseRow[] | undefined;
}

/** Row information of a bulk response */
export class BulkResponseRow extends DTOBase {
    /** ID of the document. */
    id!: string;
    /** Version of the document. */
    version!: number;
    /** Eventual error. */
    error?: string | undefined;
    /** True if item successfully saved. False otherwise. */
    succeeded!: boolean;
    /** Returned status code. */
    status!: number;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;

    constructor(data?: IBulkResponseRow) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "number", "version", false);
        this.setProp("object", "string", "error", false);
        this.setProp("object", "boolean", "succeeded", false);
        this.setProp("object", "number", "status", false);
        this.setProp("object", "string", "requestId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BulkResponseRow {
        return BulkResponseRow.fromJS(data);
     }

    static fromJS(data: any): BulkResponseRow {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResponseRow();
        result.init(data);
        return result;
    }

}

/** Row information of a bulk response */
export interface IBulkResponseRow {
    /** ID of the document. */
    id: string;
    /** Version of the document. */
    version: number;
    /** Eventual error. */
    error?: string | undefined;
    /** True if item successfully saved. False otherwise. */
    succeeded: boolean;
    /** Returned status code. */
    status: number;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;
}

export class ContentPermissionSetCreateManyRequest extends DTOBase {
    items?: ContentPermissionSetCreateRequest[] | undefined;

    constructor(data?: IContentPermissionSetCreateManyRequest) {
        super(data);
        this.setProp("array", "ContentPermissionSetCreateRequest[]", "items", true, (item: any) => ContentPermissionSetCreateRequest.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionSetCreateManyRequest {
        return ContentPermissionSetCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionSetCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetCreateManyRequest();
        result.init(data);
        return result;
    }

}

export interface IContentPermissionSetCreateManyRequest {
    items?: ContentPermissionSetCreateRequest[] | undefined;
}

/** Request to update multiple content permission sets */
export class ContentPermissionSetUpdateManyRequest extends DTOBase {
    /** Content permission sets update requests. */
    items?: ContentPermissionSetUpdateRequestItem[] | undefined;

    constructor(data?: IContentPermissionSetUpdateManyRequest) {
        super(data);
        this.setProp("array", "ContentPermissionSetUpdateRequestItem[]", "items", true, (item: any) => ContentPermissionSetUpdateRequestItem.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionSetUpdateManyRequest {
        return ContentPermissionSetUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionSetUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to update multiple content permission sets */
export interface IContentPermissionSetUpdateManyRequest {
    /** Content permission sets update requests. */
    items?: ContentPermissionSetUpdateRequestItem[] | undefined;
}

export abstract class PermissionSetUpdateRequestItemOfContentRight extends PermissionSetUpdateRequestOfContentRight implements IPermissionSetUpdateRequestItemOfContentRight {
    id!: string;

    constructor(data?: IPermissionSetUpdateRequestItemOfContentRight) {
        super(data);
        this.setProp("object", "string", "id", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetUpdateRequestItemOfContentRight {
        return PermissionSetUpdateRequestItemOfContentRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetUpdateRequestItemOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestItemOfContentRight' cannot be instantiated.");
    }

}

export interface IPermissionSetUpdateRequestItemOfContentRight extends IPermissionSetUpdateRequestOfContentRight {
    id: string;
}

/** Request to update a content permission set */
export class ContentPermissionSetUpdateRequestItem extends PermissionSetUpdateRequestItemOfContentRight implements IContentPermissionSetUpdateRequestItem {

    constructor(data?: IContentPermissionSetUpdateRequestItem) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentPermissionSetUpdateRequestItem {
        return ContentPermissionSetUpdateRequestItem.fromJS(data);
     }

    static fromJS(data: any): ContentPermissionSetUpdateRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUpdateRequestItem();
        result.init(data);
        return result;
    }

}

/** Request to update a content permission set */
export interface IContentPermissionSetUpdateRequestItem extends IPermissionSetUpdateRequestItemOfContentRight {
}

export class PermissionSetDeleteManyRequest extends DTOBase {
    permissionSetIds?: string[] | undefined;

    constructor(data?: IPermissionSetDeleteManyRequest) {
        super(data);
        this.setProp("array", "string[]", "permissionSetIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetDeleteManyRequest {
        return PermissionSetDeleteManyRequest.fromJS(data);
     }

    static fromJS(data: any): PermissionSetDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetDeleteManyRequest();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetDeleteManyRequest {
    permissionSetIds?: string[] | undefined;
}

export class PermissionSetOwnershipTransferManyRequest extends DTOBase {
    items?: PermissionSetOwnershipTransferItem[] | undefined;

    constructor(data?: IPermissionSetOwnershipTransferManyRequest) {
        super(data);
        this.setProp("array", "PermissionSetOwnershipTransferItem[]", "items", true, (item: any) => PermissionSetOwnershipTransferItem.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetOwnershipTransferManyRequest {
        return PermissionSetOwnershipTransferManyRequest.fromJS(data);
     }

    static fromJS(data: any): PermissionSetOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetOwnershipTransferManyRequest {
    items?: PermissionSetOwnershipTransferItem[] | undefined;
}

export class PermissionSetOwnershipTransferItem extends PermissionSetOwnershipTransferRequest implements IPermissionSetOwnershipTransferItem {
    /** The permission set ID. */
    permissionSetId?: string | undefined;

    constructor(data?: IPermissionSetOwnershipTransferItem) {
        super(data);
        this.setProp("object", "string", "permissionSetId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetOwnershipTransferItem {
        return PermissionSetOwnershipTransferItem.fromJS(data);
     }

    static fromJS(data: any): PermissionSetOwnershipTransferItem {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetOwnershipTransferItem();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetOwnershipTransferItem extends IPermissionSetOwnershipTransferRequest {
    /** The permission set ID. */
    permissionSetId?: string | undefined;
}

export class PermissionSetUserPermissionRights extends DTOBase {
    permissionSetId?: string | undefined;
    permissionSetRights?: PermissionSetRight[] | undefined;

    constructor(data?: IPermissionSetUserPermissionRights) {
        super(data);
        this.setProp("object", "string", "permissionSetId", false);
        this.setProp("array", "PermissionSetRight[]", "permissionSetRights", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetUserPermissionRights {
        return PermissionSetUserPermissionRights.fromJS(data);
     }

    static fromJS(data: any): PermissionSetUserPermissionRights {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetUserPermissionRights();
        result.init(data);
        return result;
    }

}

export interface IPermissionSetUserPermissionRights {
    permissionSetId?: string | undefined;
    permissionSetRights?: PermissionSetRight[] | undefined;
}

export class BaseResultOfPermissionSet extends DTOBase {
    totalResults!: number;
    results!: PermissionSet[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfPermissionSet) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "PermissionSet[]", "results", true, (item: any) => PermissionSet.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfPermissionSet {
        return BaseResultOfPermissionSet.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfPermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfPermissionSet {
    totalResults: number;
    results: IPermissionSet[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfPermissionSet extends BaseResultOfPermissionSet implements ISearchBehaviorBaseResultOfPermissionSet {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfPermissionSet) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfPermissionSet {
        return SearchBehaviorBaseResultOfPermissionSet.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfPermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfPermissionSet extends IBaseResultOfPermissionSet {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result of a permission set search operation */
export class PermissionSetSearchResult extends SearchBehaviorBaseResultOfPermissionSet implements IPermissionSetSearchResult {

    constructor(data?: IPermissionSetSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetSearchResult {
        return PermissionSetSearchResult.fromJS(data);
     }

    static fromJS(data: any): PermissionSetSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetSearchResult();
        result.init(data);
        return result;
    }

}

/** Result of a permission set search operation */
export interface IPermissionSetSearchResult extends ISearchBehaviorBaseResultOfPermissionSet {
}

/** Permission set */
export class PermissionSet extends DTOBase {
    /** The permission set ID. */
    id!: string;
    /** When true this permission set will derogate all other configured permission sets.
Cannot be changed after creation. */
    exclusive!: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;

    constructor(data?: IPermissionSet) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "boolean", "exclusive", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSet {
        return PermissionSet.fromJS(data);
     }

    static fromJS(data: any): PermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSet();
        result.init(data);
        return result;
    }

}

/** Permission set */
export interface IPermissionSet {
    /** The permission set ID. */
    id: string;
    /** When true this permission set will derogate all other configured permission sets.
Cannot be changed after creation. */
    exclusive: boolean;
    /** Language specific permission set names. */
    names?: ITranslatedStringDictionary | undefined;
}

/** Request to search permission sets */
export class PermissionSetSearchRequest extends DTOBase {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    filter?: FilterBase | undefined;
    /** Filters based on the PermissionSetRight of the user. */
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the result.
Warning! It severely affects performance. */
    debugMode!: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;

    constructor(data?: IPermissionSetSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "PermissionSetRight", "rightFilter", false);
        this.setProp("object", "boolean", "debugMode", false);
        this.setProp("array", "string[]", "searchLanguages", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetSearchRequest {
        return PermissionSetSearchRequest.fromJS(data);
     }

    static fromJS(data: any): PermissionSetSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search permission sets */
export interface IPermissionSetSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    filter?: FilterBase | undefined;
    /** Filters based on the PermissionSetRight of the user. */
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the result.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
}

export class BaseResultOfDocumentHistory extends DTOBase {
    totalResults!: number;
    results!: DocumentHistory[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfDocumentHistory) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "DocumentHistory[]", "results", true, (item: any) => DocumentHistory.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfDocumentHistory {
        return BaseResultOfDocumentHistory.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfDocumentHistory {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfDocumentHistory();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfDocumentHistory {
    totalResults: number;
    results: IDocumentHistory[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class DocumentHistorySearchResult extends BaseResultOfDocumentHistory implements IDocumentHistorySearchResult {

    constructor(data?: IDocumentHistorySearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentHistorySearchResult {
        return DocumentHistorySearchResult.fromJS(data);
     }

    static fromJS(data: any): DocumentHistorySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistorySearchResult();
        result.init(data);
        return result;
    }

}

export interface IDocumentHistorySearchResult extends IBaseResultOfDocumentHistory {
}

export class DocumentHistory extends DTOBase {
    documentId?: string | undefined;
    documentVersion!: number;
    documentType?: string | undefined;
    documentDate!: Date;
    document?: string | undefined;
    timestamp!: Date;
    audit?: UserAuditHistory | undefined;
    deleted!: boolean;
    action!: DocumentChangeAction;

    constructor(data?: IDocumentHistory) {
        super(data);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "number", "documentVersion", false);
        this.setProp("object", "string", "documentType", false);
        this.setProp("object", "Date", "documentDate", false);
        this.setProp("object", "string", "document", false);
        this.setProp("object", "Date", "timestamp", false);
        this.setProp("object", "UserAuditHistory", "audit", true, (item: any) => UserAuditHistory.fromJS(item));
        this.setProp("object", "boolean", "deleted", false);
        this.setProp("object", "DocumentChangeAction", "action", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentHistory {
        return DocumentHistory.fromJS(data);
     }

    static fromJS(data: any): DocumentHistory {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistory();
        result.init(data);
        return result;
    }

}

export interface IDocumentHistory {
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: IUserAuditHistory | undefined;
    deleted: boolean;
    action: DocumentChangeAction;
}

export class UserAuditHistory extends DTOBase {
    modificationDate!: Date;
    modifiedByUser?: string | undefined;

    constructor(data?: IUserAuditHistory) {
        super(data);
        this.setProp("object", "Date", "modificationDate", false);
        this.setProp("object", "string", "modifiedByUser", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserAuditHistory {
        return UserAuditHistory.fromJS(data);
     }

    static fromJS(data: any): UserAuditHistory {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuditHistory();
        result.init(data);
        return result;
    }

}

export interface IUserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string | undefined;
}

export enum DocumentChangeAction {
    Create = "Create",
    Update = "Update",
    Delete = "Delete",
    Activate = "Activate",
    Deactivate = "Deactivate",
}

export class DocumentHistorySearchRequest extends DTOBase {
    /** Limits the start date of the search request. By default no limitation set. */
    from!: Date;
    /** Limits the end date of the search request. By default no limitation set. */
    to!: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document ID. E.g. contentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion!: number;
    /** Limits the search to a specific document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;

    constructor(data?: IDocumentHistorySearchRequest) {
        super(data);
        this.setProp("object", "Date", "from", false);
        this.setProp("object", "Date", "to", false);
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "number", "documentVersion", false);
        this.setProp("object", "string", "documentType", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentHistorySearchRequest {
        return DocumentHistorySearchRequest.fromJS(data);
     }

    static fromJS(data: any): DocumentHistorySearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistorySearchRequest();
        result.init(data);
        return result;
    }

}

export interface IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. By default no limitation set. */
    from: Date;
    /** Limits the end date of the search request. By default no limitation set. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document ID. E.g. contentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specific document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
}

export class DocumentHistoryDifference extends DTOBase {
    documentId?: string | undefined;
    oldDocumentVersion!: number;
    newDocumentVersion!: number;
    /** Contains an RFC 6902 compatible patch that can be applied on the old document to get the new document.
Use a library like jsondiffpatch.net (https://github.com/wbish/jsondiffpatch.net)
or jsondiffpatch (https://github.com/benjamine/jsondiffpatch) to process this. */
    patch?: any | undefined;

    constructor(data?: IDocumentHistoryDifference) {
        super(data);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "number", "oldDocumentVersion", false);
        this.setProp("object", "number", "newDocumentVersion", false);
        this.setProp("object", "any", "patch", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentHistoryDifference {
        return DocumentHistoryDifference.fromJS(data);
     }

    static fromJS(data: any): DocumentHistoryDifference {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistoryDifference();
        result.init(data);
        return result;
    }

}

export interface IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    /** Contains an RFC 6902 compatible patch that can be applied on the old document to get the new document.
Use a library like jsondiffpatch.net (https://github.com/wbish/jsondiffpatch.net)
or jsondiffpatch (https://github.com/benjamine/jsondiffpatch) to process this. */
    patch?: any | undefined;
}

/** Customer configuration information */
export class CustomerInfo extends DTOBase {
    /** The customer ID. */
    customerId!: string;
    /** The name of the customer instance. */
    name!: string;
    /** Alias of the customer instance. */
    customerAlias!: string;
    /** The base url of identity server to authenticate the user using OpenID Connect. */
    identityServerUrl!: string;
    /** Information if the query details can be enabled when searching. For debug purposes only. */
    enableQueryDetails!: boolean;
    /** Configured languages of customer instance (system, metadata, default). */
    languageConfiguration!: LanguageConfiguration;
    /** Languages including translations for the configured system and metadata languages. */
    languages!: Language[];
    /** Configured rendering outputs including translations for the customer instance. */
    outputFormats!: OutputFormatInfo[];
    /** Boost levels that can be applied to a metadata field to boost the the significance of the field in a search operation. */
    boostValues!: number[];
    /** Apps registered for this customer */
    apps?: CustomerApp[] | undefined;
    modificationDate!: Date;

    constructor(data?: ICustomerInfo) {
        super(data);
        this.setProp("object", "string", "customerId", false);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "string", "customerAlias", false);
        this.setProp("object", "string", "identityServerUrl", false);
        this.setProp("object", "boolean", "enableQueryDetails", false);
        this.setProp("object", "LanguageConfiguration", "languageConfiguration", true, (item: any) => LanguageConfiguration.fromJS(item));
        this.setProp("array", "Language[]", "languages", true, (item: any) => Language.fromJS(item));
        this.setProp("array", "OutputFormatInfo[]", "outputFormats", true, (item: any) => OutputFormatInfo.fromJS(item));
        this.setProp("array", "number[]", "boostValues", false);
        this.setProp("array", "CustomerApp[]", "apps", true, (item: any) => CustomerApp.fromJS(item));
        this.setProp("object", "Date", "modificationDate", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.languageConfiguration = new LanguageConfiguration();
            this.languages = [];
            this.outputFormats = [];
            this.boostValues = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerInfo {
        return CustomerInfo.fromJS(data);
     }

    static fromJS(data: any): CustomerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInfo();
        result.init(data);
        return result;
    }

}

/** Customer configuration information */
export interface ICustomerInfo {
    /** The customer ID. */
    customerId: string;
    /** The name of the customer instance. */
    name: string;
    /** Alias of the customer instance. */
    customerAlias: string;
    /** The base url of identity server to authenticate the user using OpenID Connect. */
    identityServerUrl: string;
    /** Information if the query details can be enabled when searching. For debug purposes only. */
    enableQueryDetails: boolean;
    /** Configured languages of customer instance (system, metadata, default). */
    languageConfiguration: ILanguageConfiguration;
    /** Languages including translations for the configured system and metadata languages. */
    languages: ILanguage[];
    /** Configured rendering outputs including translations for the customer instance. */
    outputFormats: IOutputFormatInfo[];
    /** Boost levels that can be applied to a metadata field to boost the the significance of the field in a search operation. */
    boostValues: number[];
    /** Apps registered for this customer */
    apps?: ICustomerApp[] | undefined;
    modificationDate: Date;
}

export class LanguageConfiguration extends DTOBase {
    /** A list of languages serving as system languages. */
    systemLanguages?: string[] | undefined;
    /** A list of languages serving as metadata languages. */
    metadataLanguages?: string[] | undefined;
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage?: string | undefined;

    constructor(data?: ILanguageConfiguration) {
        super(data);
        this.setProp("array", "string[]", "systemLanguages", false);
        this.setProp("array", "string[]", "metadataLanguages", false);
        this.setProp("object", "string", "defaultLanguage", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LanguageConfiguration {
        return LanguageConfiguration.fromJS(data);
     }

    static fromJS(data: any): LanguageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageConfiguration();
        result.init(data);
        return result;
    }

}

export interface ILanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages?: string[] | undefined;
    /** A list of languages serving as metadata languages. */
    metadataLanguages?: string[] | undefined;
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage?: string | undefined;
}

export class Language extends DTOBase {
    /** Language translations. */
    name!: TranslatedStringDictionary;
    /** IETF language tag. E.g en, en-US, de. */
    ietf!: string;
    /** Two letter ISO language code. E.g. en, de. */
    twoLetterISOLanguageName?: string | undefined;
    /** Three letter ISO language code. E.g. eng, deu. */
    threeLetterISOLanguageName?: string | undefined;
    /** Region code of the language. E.g. US, DE, CH. */
    regionCode?: string | undefined;

    constructor(data?: ILanguage) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "name", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "ietf", false);
        this.setProp("object", "string", "twoLetterISOLanguageName", false);
        this.setProp("object", "string", "threeLetterISOLanguageName", false);
        this.setProp("object", "string", "regionCode", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.name = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Language {
        return Language.fromJS(data);
     }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

}

export interface ILanguage {
    /** Language translations. */
    name: ITranslatedStringDictionary;
    /** IETF language tag. E.g en, en-US, de. */
    ietf: string;
    /** Two letter ISO language code. E.g. en, de. */
    twoLetterISOLanguageName?: string | undefined;
    /** Three letter ISO language code. E.g. eng, deu. */
    threeLetterISOLanguageName?: string | undefined;
    /** Region code of the language. E.g. US, DE, CH. */
    regionCode?: string | undefined;
}

export class OutputFormatInfo extends DTOBase {
    /** Output ID. */
    id!: string;
    /** Output translations. */
    names!: TranslatedStringDictionary;

    constructor(data?: IOutputFormatInfo) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatInfo {
        return OutputFormatInfo.fromJS(data);
     }

    static fromJS(data: any): OutputFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatInfo();
        result.init(data);
        return result;
    }

}

export interface IOutputFormatInfo {
    /** Output ID. */
    id: string;
    /** Output translations. */
    names: ITranslatedStringDictionary;
}

export class CustomerApp extends DTOBase {
    appId?: string | undefined;
    name?: TranslatedStringDictionary | undefined;
    description?: TranslatedStringDictionary | undefined;
    icon?: string | undefined;

    constructor(data?: ICustomerApp) {
        super(data);
        this.setProp("object", "string", "appId", false);
        this.setProp("object", "TranslatedStringDictionary", "name", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "description", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "icon", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerApp {
        return CustomerApp.fromJS(data);
     }

    static fromJS(data: any): CustomerApp {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApp();
        result.init(data);
        return result;
    }

}

export interface ICustomerApp {
    appId?: string | undefined;
    name?: ITranslatedStringDictionary | undefined;
    description?: ITranslatedStringDictionary | undefined;
    icon?: string | undefined;
}

/** The version view item for the environment. */
export class VersionInfo extends DTOBase {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string | undefined;

    constructor(data?: IVersionInfo) {
        super(data);
        this.setProp("object", "string", "fileVersion", false);
        this.setProp("object", "string", "fileProductVersion", false);
        this.setProp("object", "string", "contractVersion", false);
        this.setProp("object", "string", "release", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): VersionInfo {
        return VersionInfo.fromJS(data);
     }

    static fromJS(data: any): VersionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VersionInfo();
        result.init(data);
        return result;
    }

}

/** The version view item for the environment. */
export interface IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string | undefined;
}

/** The detail view item for the list item. */
export class ListItemDetail extends DTOBase {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit | undefined;

    constructor(data?: IListItemDetail) {
        super(data);
        this.setProp("object", "any", "content", false);
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("object", "DisplayValueDictionary", "displayValues", true, (item: any) => DisplayValueDictionary.fromJS(item));
        this.setProp("object", "string", "id", false);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemDetail {
        return ListItemDetail.fromJS(data);
     }

    static fromJS(data: any): ListItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDetail();
        result.init(data);
        return result;
    }

}

/** The detail view item for the list item. */
export interface IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;
    /** Audit data with information regarding document creation and modification. */
    audit?: IUserAudit | undefined;
}

export enum ListItemResolveBehavior {
    Content = "Content",
    LinkedListItems = "LinkedListItems",
    InnerDisplayValueThumbnail = "InnerDisplayValueThumbnail",
    InnerDisplayValueList = "InnerDisplayValueList",
    InnerDisplayValueDetail = "InnerDisplayValueDetail",
    InnerDisplayValueName = "InnerDisplayValueName",
    OuterDisplayValueThumbnail = "OuterDisplayValueThumbnail",
    OuterDisplayValueList = "OuterDisplayValueList",
    OuterDisplayValueDetail = "OuterDisplayValueDetail",
    OuterDisplayValueName = "OuterDisplayValueName",
}

export class BaseResultOfListItem extends DTOBase {
    totalResults!: number;
    results!: ListItem[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfListItem) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "ListItem[]", "results", true, (item: any) => ListItem.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfListItem {
        return BaseResultOfListItem.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfListItem {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfListItem();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfListItem {
    totalResults: number;
    results: IListItem[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Encapsulates the result of a list item search. */
export class ListItemSearchResult extends BaseResultOfListItem implements IListItemSearchResult {

    constructor(data?: IListItemSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemSearchResult {
        return ListItemSearchResult.fromJS(data);
     }

    static fromJS(data: any): ListItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSearchResult();
        result.init(data);
        return result;
    }

}

/** Encapsulates the result of a list item search. */
export interface IListItemSearchResult extends IBaseResultOfListItem {
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export class ListItem extends DTOBase {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit | undefined;

    constructor(data?: IListItem) {
        super(data);
        this.setProp("object", "any", "content", false);
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("object", "DisplayValueDictionary", "displayValues", true, (item: any) => DisplayValueDictionary.fromJS(item));
        this.setProp("object", "string", "id", false);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItem {
        return ListItem.fromJS(data);
     }

    static fromJS(data: any): ListItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListItem();
        result.init(data);
        return result;
    }

}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export interface IListItem {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;
    /** Audit data with information regarding document creation and modification. */
    audit?: IUserAudit | undefined;
}

/** Request to search list items */
export class ListItemSearchRequest extends DTOBase {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren!: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ListItemSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;
    /** Limits the search to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;
    /** List of enums that control which parts of the list item are resolved and returned. */
    resolveBehaviors?: ListItemResolveBehavior[] | undefined;

    constructor(data?: IListItemSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "includeAllSchemaChildren", false);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("object", "BrokenDependenciesFilter", "brokenDependenciesFilter", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "boolean", "debugMode", false);
        this.setProp("object", "LifeCycleFilter", "lifeCycleFilter", false);
        this.setProp("array", "ListItemResolveBehavior[]", "resolveBehaviors", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemSearchRequest {
        return ListItemSearchRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search list items */
export interface IListItemSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ListItemSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** Limits the search to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** List of enums that control which parts of the list item are resolved and returned. */
    resolveBehaviors?: ListItemResolveBehavior[] | undefined;
}

/** Request to aggregate list items */
export class ListItemAggregationRequest extends DTOBase {
    /** The string used to query the list items to aggregate. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional filter to limit the list items to aggregate on. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the list item should be aggregated. */
    aggregators!: AggregatorBase[];
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren!: boolean;
    /** Limits the aggregation to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the aggregation to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;

    constructor(data?: IListItemAggregationRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("array", "AggregationFilter[]", "aggregationFilters", true, (item: any) => AggregationFilter.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregators", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("object", "boolean", "includeAllSchemaChildren", false);
        this.setProp("object", "BrokenDependenciesFilter", "brokenDependenciesFilter", false);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "LifeCycleFilter", "lifeCycleFilter", false);

        if (!data) {
            this.aggregators = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemAggregationRequest {
        return ListItemAggregationRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemAggregationRequest();
        result.init(data);
        return result;
    }

}

/** Request to aggregate list items */
export interface IListItemAggregationRequest {
    /** The string used to query the list items to aggregate. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional filter to limit the list items to aggregate on. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the list item should be aggregated. */
    aggregators: AggregatorBase[];
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the aggregation to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** A request structure for creating a list item document. */
export class ListItemCreateRequest extends DTOBase {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IListItemCreateRequest) {
        super(data);
        this.setProp("object", "any", "content", false);
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("object", "string", "requestId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemCreateRequest {
        return ListItemCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCreateRequest();
        result.init(data);
        return result;
    }

}

/** A request structure for creating a list item document. */
export interface IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** A request structure for creating multiple list items. */
export class ListItemCreateManyRequest extends DTOBase {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies!: boolean;
    /** Create items */
    items?: ListItemCreateRequest[] | undefined;

    constructor(data?: IListItemCreateManyRequest) {
        super(data);
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("array", "ListItemCreateRequest[]", "items", true, (item: any) => ListItemCreateRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemCreateManyRequest {
        return ListItemCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCreateManyRequest();
        result.init(data);
        return result;
    }

}

/** A request structure for creating multiple list items. */
export interface IListItemCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create items */
    items?: IListItemCreateRequest[] | undefined;
}

/** A request structure for updating a list item. */
export class ListItemUpdateRequest extends DTOBase {
    /** The content data of the list item. */
    content?: any | undefined;

    constructor(data?: IListItemUpdateRequest) {
        super(data);
        this.setProp("object", "any", "content", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemUpdateRequest {
        return ListItemUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateRequest();
        result.init(data);
        return result;
    }

}

/** A request structure for updating a list item. */
export interface IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
}

/** A request structure for updating multiple list items. */
export class ListItemUpdateManyRequest extends DTOBase {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies!: boolean;
    /** Update items */
    items?: ListItemUpdateItem[] | undefined;

    constructor(data?: IListItemUpdateManyRequest) {
        super(data);
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("array", "ListItemUpdateItem[]", "items", true, (item: any) => ListItemUpdateItem.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemUpdateManyRequest {
        return ListItemUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** A request structure for updating multiple list items. */
export interface IListItemUpdateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Update items */
    items?: ListItemUpdateItem[] | undefined;
}

export class ListItemUpdateItem extends ListItemUpdateRequest implements IListItemUpdateItem {
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemUpdateItem) {
        super(data);
        this.setProp("object", "string", "id", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemUpdateItem {
        return ListItemUpdateItem.fromJS(data);
     }

    static fromJS(data: any): ListItemUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateItem();
        result.init(data);
        return result;
    }

}

export interface IListItemUpdateItem extends IListItemUpdateRequest {
    /** The list item id. */
    id?: string | undefined;
}

/** Request to delete multiple list items */
export class ListItemDeleteManyRequest extends DTOBase {
    /** IDs of the list items to delete. */
    listItemIds!: string[];
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IListItemDeleteManyRequest) {
        super(data);
        this.setProp("array", "string[]", "listItemIds", false);
        this.setProp("object", "boolean", "forceReferenceRemoval", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (!data) {
            this.listItemIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemDeleteManyRequest {
        return ListItemDeleteManyRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDeleteManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to delete multiple list items */
export interface IListItemDeleteManyRequest {
    /** IDs of the list items to delete. */
    listItemIds: string[];
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to delete multiple list items based on a provided filter */
export class ListItemDeleteManyFilterRequest extends DTOBase {
    /** Filters the list items that need to be deleted. */
    filterRequest!: ListItemFilterRequest;
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IListItemDeleteManyFilterRequest) {
        super(data);
        this.setProp("object", "ListItemFilterRequest", "filterRequest", true, (item: any) => ListItemFilterRequest.fromJS(item));
        this.setProp("object", "boolean", "forceReferenceRemoval", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.filterRequest = new ListItemFilterRequest();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemDeleteManyFilterRequest {
        return ListItemDeleteManyFilterRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemDeleteManyFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDeleteManyFilterRequest();
        result.init(data);
        return result;
    }

}

/** Request to delete multiple list items based on a provided filter */
export interface IListItemDeleteManyFilterRequest {
    /** Filters the list items that need to be deleted. */
    filterRequest: IListItemFilterRequest;
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to filter list items */
export class ListItemFilterRequest extends DTOBase {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren!: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;

    constructor(data?: IListItemFilterRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "includeAllSchemaChildren", false);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "BrokenDependenciesFilter", "brokenDependenciesFilter", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemFilterRequest {
        return ListItemFilterRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFilterRequest();
        result.init(data);
        return result;
    }

}

/** Request to filter list items */
export interface IListItemFilterRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
}

/** Request to restore multiple deleted list items */
export class ListItemRestoreManyRequest extends DTOBase {
    /** The IDs of the list items to restore. */
    listItemIds!: string[];
    /** Allows restoring list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;

    constructor(data?: IListItemRestoreManyRequest) {
        super(data);
        this.setProp("array", "string[]", "listItemIds", false);
        this.setProp("object", "boolean", "allowMissingDependencies", false);

        if (!data) {
            this.listItemIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemRestoreManyRequest {
        return ListItemRestoreManyRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemRestoreManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemRestoreManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to restore multiple deleted list items */
export interface IListItemRestoreManyRequest {
    /** The IDs of the list items to restore. */
    listItemIds: string[];
    /** Allows restoring list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
}

/** Request to batch update list items' fields based on list item IDs */
export class ListItemFieldsBatchUpdateRequest extends DTOBase {
    /** The ids of the list items whose fields need to be updated. */
    listItemIds!: string[];
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands!: MetadataValuesChangeCommandBase[];
    /** Allows updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress!: boolean;

    constructor(data?: IListItemFieldsBatchUpdateRequest) {
        super(data);
        this.setProp("array", "string[]", "listItemIds", false);
        this.setProp("array", "MetadataValuesChangeCommandBase[]", "changeCommands", true, (item: any) => MetadataValuesChangeCommandBase.fromJS(item));
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (!data) {
            this.listItemIds = [];
            this.changeCommands = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemFieldsBatchUpdateRequest {
        return ListItemFieldsBatchUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemFieldsBatchUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFieldsBatchUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to batch update list items' fields based on list item IDs */
export interface IListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated. */
    listItemIds: string[];
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allows updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Request to batch update list items' fields based on a filter */
export class ListItemFieldsBatchUpdateFilterRequest extends DTOBase {
    /** Filters the list items on which the change commands must be applied. */
    filterRequest!: ListItemFilterRequest;
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands!: MetadataValuesChangeCommandBase[];
    /** Allow updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress!: boolean;

    constructor(data?: IListItemFieldsBatchUpdateFilterRequest) {
        super(data);
        this.setProp("object", "ListItemFilterRequest", "filterRequest", true, (item: any) => ListItemFilterRequest.fromJS(item));
        this.setProp("array", "MetadataValuesChangeCommandBase[]", "changeCommands", true, (item: any) => MetadataValuesChangeCommandBase.fromJS(item));
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("object", "boolean", "notifyProgress", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.filterRequest = new ListItemFilterRequest();
            this.changeCommands = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemFieldsBatchUpdateFilterRequest {
        return ListItemFieldsBatchUpdateFilterRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemFieldsBatchUpdateFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFieldsBatchUpdateFilterRequest();
        result.init(data);
        return result;
    }

}

/** Request to batch update list items' fields based on a filter */
export interface IListItemFieldsBatchUpdateFilterRequest {
    /** Filters the list items on which the change commands must be applied. */
    filterRequest: IListItemFilterRequest;
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allow updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Result from getting references to list items. */
export class ListItemReferencesResult extends DTOBase {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: MetadataReferenceResult | undefined;

    constructor(data?: IListItemReferencesResult) {
        super(data);
        this.setProp("object", "MetadataReferenceResult", "metadataReferences", true, (item: any) => MetadataReferenceResult.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemReferencesResult {
        return ListItemReferencesResult.fromJS(data);
     }

    static fromJS(data: any): ListItemReferencesResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemReferencesResult();
        result.init(data);
        return result;
    }

}

/** Result from getting references to list items. */
export interface IListItemReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: IMetadataReferenceResult | undefined;
}

/** Request to get the references to a list item */
export class ListItemReferencesRequest extends DTOBase {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;

    constructor(data?: IListItemReferencesRequest) {
        super(data);
        this.setProp("object", "MetadataReferencesPagingRequest", "references", true, (item: any) => MetadataReferencesPagingRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemReferencesRequest {
        return ListItemReferencesRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemReferencesRequest();
        result.init(data);
        return result;
    }

}

/** Request to get the references to a list item */
export interface IListItemReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
}

/** Request to get the references to multiple list items */
export class ListItemManyReferencesRequest extends DTOBase {
    /** The IDs of the list items whose references need to be retrieved. */
    listItemIds!: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;

    constructor(data?: IListItemManyReferencesRequest) {
        super(data);
        this.setProp("array", "string[]", "listItemIds", false);
        this.setProp("object", "MetadataReferencesPagingRequest", "references", true, (item: any) => MetadataReferencesPagingRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.listItemIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListItemManyReferencesRequest {
        return ListItemManyReferencesRequest.fromJS(data);
     }

    static fromJS(data: any): ListItemManyReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemManyReferencesRequest();
        result.init(data);
        return result;
    }

}

/** Request to get the references to multiple list items */
export interface IListItemManyReferencesRequest {
    /** The IDs of the list items whose references need to be retrieved. */
    listItemIds: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
}

export abstract class Message extends DTOBase {
    id?: string | undefined;
    maximumRetryCount!: number;
    retries!: number;
    priority!: number;
    deduplicate!: boolean;

    protected _kind: string;

    constructor(data?: IMessage) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "number", "maximumRetryCount", false);
        this.setProp("object", "number", "retries", false);
        this.setProp("object", "number", "priority", false);
        this.setProp("object", "boolean", "deduplicate", false);

        this._kind = "Message";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Message {
        return Message.fromJS(data);
     }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "LiveStreamMessage") {
            let result = new LiveStreamMessage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConsoleMessage") {
            let result = new ConsoleMessage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NodeInfoMessage") {
            let result = new NodeInfoMessage();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Message' cannot be instantiated.");
    }

}

export interface IMessage {
    id?: string | undefined;
    maximumRetryCount: number;
    retries: number;
    priority: number;
    deduplicate: boolean;
}

export class LiveStreamMessage extends Message implements ILiveStreamMessage {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    timestamp!: Date;
    scope?: string | undefined;
    documentChange?: DocumentChange | undefined;
    applicationEvent?: ApplicationEvent | undefined;

    constructor(data?: ILiveStreamMessage) {
        super(data);
        this.setProp("object", "string", "customerId", false);
        this.setProp("object", "string", "customerAlias", false);
        this.setProp("object", "Date", "timestamp", false);
        this.setProp("object", "string", "scope", false);
        this.setProp("object", "DocumentChange", "documentChange", true, (item: any) => DocumentChange.fromJS(item));
        this.setProp("object", "ApplicationEvent", "applicationEvent", true, (item: any) => ApplicationEvent.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "LiveStreamMessage";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LiveStreamMessage {
        return LiveStreamMessage.fromJS(data);
     }

    static fromJS(data: any): LiveStreamMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamMessage();
        result.init(data);
        return result;
    }

}

export interface ILiveStreamMessage extends IMessage {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    timestamp: Date;
    scope?: string | undefined;
    documentChange?: IDocumentChange | undefined;
    applicationEvent?: ApplicationEvent | undefined;
}

export class DocumentChange extends DTOBase {
    documentName?: string | undefined;
    documentId?: string | undefined;
    version!: number;
    action?: string | undefined;
    timeStamp!: Date;

    constructor(data?: IDocumentChange) {
        super(data);
        this.setProp("object", "string", "documentName", false);
        this.setProp("object", "string", "documentId", false);
        this.setProp("object", "number", "version", false);
        this.setProp("object", "string", "action", false);
        this.setProp("object", "Date", "timeStamp", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentChange {
        return DocumentChange.fromJS(data);
     }

    static fromJS(data: any): DocumentChange {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentChange();
        result.init(data);
        return result;
    }

}

export interface IDocumentChange {
    documentName?: string | undefined;
    documentId?: string | undefined;
    version: number;
    action?: string | undefined;
    timeStamp: Date;
}

export class ApplicationEvent extends DTOBase {
    timestamp!: Date;

    protected _kind: string;

    constructor(data?: IApplicationEvent) {
        super(data);
        this.setProp("object", "Date", "timestamp", false);

        this._kind = "ApplicationEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ApplicationEvent {
        return ApplicationEvent.fromJS(data);
     }

    static fromJS(data: any): ApplicationEvent {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TransferEvent") {
            let result = new TransferEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReindexEvent") {
            let result = new ReindexEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentDetailViewEvent") {
            let result = new ContentDetailViewEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentDownloadEvent") {
            let result = new ContentDownloadEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SessionRenewalEvent") {
            let result = new SessionRenewalEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SharePageViewEvent") {
            let result = new SharePageViewEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ApiStatisticsEvent") {
            let result = new ApiStatisticsEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEvent") {
            let result = new BusinessProcessEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputRenderedEvent") {
            let result = new OutputRenderedEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConfigurationChangeEvent") {
            let result = new ConfigurationChangeEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerChangeEvent") {
            let result = new CustomerChangeEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchReindexCompletedEvent") {
            let result = new SearchReindexCompletedEvent();
            result.init(data);
            return result;
        }
        let result = new ApplicationEvent();
        result.init(data);
        return result;
    }

}

export interface IApplicationEvent {
    timestamp: Date;
}

export class TransferEvent extends ApplicationEvent implements ITransferEvent {
    transferId?: string | undefined;
    state!: TransferState;

    constructor(data?: ITransferEvent) {
        super(data);
        this.setProp("object", "string", "transferId", false);
        this.setProp("object", "TransferState", "state", false);

        this._kind = "TransferEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferEvent {
        return TransferEvent.fromJS(data);
     }

    static fromJS(data: any): TransferEvent {
        data = typeof data === 'object' ? data : {};
        let result = new TransferEvent();
        result.init(data);
        return result;
    }

}

export interface ITransferEvent extends IApplicationEvent {
    transferId?: string | undefined;
    state: TransferState;
}

/** Transfer states */
export enum TransferState {
    Draft = "Draft",
    UploadInProgress = "UploadInProgress",
    UploadCompleted = "UploadCompleted",
    ImportInProgress = "ImportInProgress",
    ImportCompleted = "ImportCompleted",
    UploadCancelled = "UploadCancelled",
    ImportCancelled = "ImportCancelled",
    ImportFailed = "ImportFailed",
    Created = "Created",
    Deleted = "Deleted",
    TransferReady = "TransferReady",
    FileDeleteInProgress = "FileDeleteInProgress",
    TransferCleanup = "TransferCleanup",
    ImportCompletedWithErrors = "ImportCompletedWithErrors",
    UploadCompletedWithErrors = "UploadCompletedWithErrors",
    UploadCancellationInProgress = "UploadCancellationInProgress",
}

export class ReindexEvent extends ApplicationEvent implements IReindexEvent {
    indexId?: string | undefined;
    state!: IndexState;

    constructor(data?: IReindexEvent) {
        super(data);
        this.setProp("object", "string", "indexId", false);
        this.setProp("object", "IndexState", "state", false);

        this._kind = "ReindexEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ReindexEvent {
        return ReindexEvent.fromJS(data);
     }

    static fromJS(data: any): ReindexEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ReindexEvent();
        result.init(data);
        return result;
    }

}

export interface IReindexEvent extends IApplicationEvent {
    indexId?: string | undefined;
    state: IndexState;
}

export enum IndexState {
    Draft = "Draft",
    Create = "Create",
    Inactive = "Inactive",
    Active = "Active",
    Closed = "Closed",
    ReindexInProgress = "ReindexInProgress",
    Cancelled = "Cancelled",
}

export class ContentDetailViewEvent extends ApplicationEvent implements IContentDetailViewEvent {
    contentIds?: string[] | undefined;

    constructor(data?: IContentDetailViewEvent) {
        super(data);
        this.setProp("array", "string[]", "contentIds", false);

        this._kind = "ContentDetailViewEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDetailViewEvent {
        return ContentDetailViewEvent.fromJS(data);
     }

    static fromJS(data: any): ContentDetailViewEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetailViewEvent();
        result.init(data);
        return result;
    }

}

export interface IContentDetailViewEvent extends IApplicationEvent {
    contentIds?: string[] | undefined;
}

export class ContentDownloadEvent extends ApplicationEvent implements IContentDownloadEvent {
    downloadInfos?: DownloadTrackingInfo[] | undefined;
    fileSize!: number;
    shareToken?: string | undefined;
    range?: string | undefined;

    constructor(data?: IContentDownloadEvent) {
        super(data);
        this.setProp("array", "DownloadTrackingInfo[]", "downloadInfos", true, (item: any) => DownloadTrackingInfo.fromJS(item));
        this.setProp("object", "number", "fileSize", false);
        this.setProp("object", "string", "shareToken", false);
        this.setProp("object", "string", "range", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "ContentDownloadEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ContentDownloadEvent {
        return ContentDownloadEvent.fromJS(data);
     }

    static fromJS(data: any): ContentDownloadEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadEvent();
        result.init(data);
        return result;
    }

}

export interface IContentDownloadEvent extends IApplicationEvent {
    downloadInfos?: IDownloadTrackingInfo[] | undefined;
    fileSize: number;
    shareToken?: string | undefined;
    range?: string | undefined;
}

export class DownloadTrackingInfo extends DTOBase {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    contentDisposition!: ContentDisposition;

    constructor(data?: IDownloadTrackingInfo) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "ContentDisposition", "contentDisposition", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DownloadTrackingInfo {
        return DownloadTrackingInfo.fromJS(data);
     }

    static fromJS(data: any): DownloadTrackingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadTrackingInfo();
        result.init(data);
        return result;
    }

}

export interface IDownloadTrackingInfo {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    contentDisposition: ContentDisposition;
}

export enum ContentDisposition {
    Attachment = "Attachment",
    Inline = "Inline",
}

export class SessionRenewalEvent extends ApplicationEvent implements ISessionRenewalEvent {
    authorizationState!: AuthorizationState;

    constructor(data?: ISessionRenewalEvent) {
        super(data);
        this.setProp("object", "AuthorizationState", "authorizationState", false);

        this._kind = "SessionRenewalEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SessionRenewalEvent {
        return SessionRenewalEvent.fromJS(data);
     }

    static fromJS(data: any): SessionRenewalEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SessionRenewalEvent();
        result.init(data);
        return result;
    }

}

export interface ISessionRenewalEvent extends IApplicationEvent {
    authorizationState: AuthorizationState;
}

/** User authorization state. */
export enum AuthorizationState {
    Reviewed = "Reviewed",
    ToBeReviewed = "ToBeReviewed",
    Invited = "Invited",
    UserTriggeredDeactivation = "UserTriggeredDeactivation",
}

export class SharePageViewEvent extends ApplicationEvent implements ISharePageViewEvent {
    shareToken?: string | undefined;

    constructor(data?: ISharePageViewEvent) {
        super(data);
        this.setProp("object", "string", "shareToken", false);

        this._kind = "SharePageViewEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SharePageViewEvent {
        return SharePageViewEvent.fromJS(data);
     }

    static fromJS(data: any): SharePageViewEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SharePageViewEvent();
        result.init(data);
        return result;
    }

}

export interface ISharePageViewEvent extends IApplicationEvent {
    shareToken?: string | undefined;
}

export class ApiStatisticsEvent extends ApplicationEvent implements IApiStatisticsEvent {
    requestsPerClient?: { [key: string] : number; } | undefined;

    constructor(data?: IApiStatisticsEvent) {
        super(data);
        this.setProp("dictionary", "{ [key: string] : number; }", "requestsPerClient", false);

        this._kind = "ApiStatisticsEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ApiStatisticsEvent {
        return ApiStatisticsEvent.fromJS(data);
     }

    static fromJS(data: any): ApiStatisticsEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ApiStatisticsEvent();
        result.init(data);
        return result;
    }

}

export interface IApiStatisticsEvent extends IApplicationEvent {
    requestsPerClient?: { [key: string] : number; } | undefined;
}

export class BusinessProcessEvent extends ApplicationEvent implements IBusinessProcessEvent {
    businessProcessId?: string | undefined;
    lifeCycle?: BusinessProcessLifeCycle | undefined;
    state?: string | undefined;

    constructor(data?: IBusinessProcessEvent) {
        super(data);
        this.setProp("object", "string", "businessProcessId", false);
        this.setProp("object", "BusinessProcessLifeCycle", "lifeCycle", false);
        this.setProp("object", "string", "state", false);

        this._kind = "BusinessProcessEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BusinessProcessEvent {
        return BusinessProcessEvent.fromJS(data);
     }

    static fromJS(data: any): BusinessProcessEvent {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessEvent();
        result.init(data);
        return result;
    }

}

export interface IBusinessProcessEvent extends IApplicationEvent {
    businessProcessId?: string | undefined;
    lifeCycle?: BusinessProcessLifeCycle | undefined;
    state?: string | undefined;
}

export class OutputRenderedEvent extends ApplicationEvent implements IOutputRenderedEvent {
    outputId?: string | undefined;
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    renderingState!: OutputRenderingState;

    constructor(data?: IOutputRenderedEvent) {
        super(data);
        this.setProp("object", "string", "outputId", false);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);
        this.setProp("object", "OutputRenderingState", "renderingState", false);

        this._kind = "OutputRenderedEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputRenderedEvent {
        return OutputRenderedEvent.fromJS(data);
     }

    static fromJS(data: any): OutputRenderedEvent {
        data = typeof data === 'object' ? data : {};
        let result = new OutputRenderedEvent();
        result.init(data);
        return result;
    }

}

export interface IOutputRenderedEvent extends IApplicationEvent {
    outputId?: string | undefined;
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    renderingState: OutputRenderingState;
}

export class ConfigurationChangeEvent extends ApplicationEvent implements IConfigurationChangeEvent {
    documentType?: string | undefined;

    constructor(data?: IConfigurationChangeEvent) {
        super(data);
        this.setProp("object", "string", "documentType", false);

        this._kind = "ConfigurationChangeEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ConfigurationChangeEvent {
        return ConfigurationChangeEvent.fromJS(data);
     }

    static fromJS(data: any): ConfigurationChangeEvent {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CustomerChangeEvent") {
            let result = new CustomerChangeEvent();
            result.init(data);
            return result;
        }
        let result = new ConfigurationChangeEvent();
        result.init(data);
        return result;
    }

}

export interface IConfigurationChangeEvent extends IApplicationEvent {
    documentType?: string | undefined;
}

export class CustomerChangeEvent extends ConfigurationChangeEvent implements ICustomerChangeEvent {
    lifeCycle!: LifeCycle;

    constructor(data?: ICustomerChangeEvent) {
        super(data);
        this.setProp("object", "LifeCycle", "lifeCycle", false);

        this._kind = "CustomerChangeEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CustomerChangeEvent {
        return CustomerChangeEvent.fromJS(data);
     }

    static fromJS(data: any): CustomerChangeEvent {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerChangeEvent();
        result.init(data);
        return result;
    }

}

export interface ICustomerChangeEvent extends IConfigurationChangeEvent {
    lifeCycle: LifeCycle;
}

export class SearchReindexCompletedEvent extends ApplicationEvent implements ISearchReindexCompletedEvent {
    searchIndex!: SearchIndexType;
    items!: number;
    duration!: string;

    constructor(data?: ISearchReindexCompletedEvent) {
        super(data);
        this.setProp("object", "SearchIndexType", "searchIndex", false);
        this.setProp("object", "number", "items", false);
        this.setProp("object", "string", "duration", false);

        this._kind = "SearchReindexCompletedEvent";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchReindexCompletedEvent {
        return SearchReindexCompletedEvent.fromJS(data);
     }

    static fromJS(data: any): SearchReindexCompletedEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SearchReindexCompletedEvent();
        result.init(data);
        return result;
    }

}

export interface ISearchReindexCompletedEvent extends IApplicationEvent {
    searchIndex: SearchIndexType;
    items: number;
    duration: string;
}

export enum SearchIndexType {
    Content = "Content",
    ListItem = "ListItem",
}

export class ConsoleMessage extends Message implements IConsoleMessage {
    command?: string | undefined;
    arguments?: TupleOfStringAndString[] | undefined;
    targetQueue?: string | undefined;

    constructor(data?: IConsoleMessage) {
        super(data);
        this.setProp("object", "string", "command", false);
        this.setProp("array", "TupleOfStringAndString[]", "arguments", true, (item: any) => TupleOfStringAndString.fromJS(item));
        this.setProp("object", "string", "targetQueue", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "ConsoleMessage";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ConsoleMessage {
        return ConsoleMessage.fromJS(data);
     }

    static fromJS(data: any): ConsoleMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ConsoleMessage();
        result.init(data);
        return result;
    }

}

export interface IConsoleMessage extends IMessage {
    command?: string | undefined;
    arguments?: ITupleOfStringAndString[] | undefined;
    targetQueue?: string | undefined;
}

export class TupleOfStringAndString extends DTOBase {
    item1?: string | undefined;
    item2?: string | undefined;

    constructor(data?: ITupleOfStringAndString) {
        super(data);
        this.setProp("object", "string", "item1", false);
        this.setProp("object", "string", "item2", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TupleOfStringAndString {
        return TupleOfStringAndString.fromJS(data);
     }

    static fromJS(data: any): TupleOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfStringAndString();
        result.init(data);
        return result;
    }

}

export interface ITupleOfStringAndString {
    item1?: string | undefined;
    item2?: string | undefined;
}

export class NodeInfoMessage extends Message implements INodeInfoMessage {
    nodeId?: string | undefined;
    hostName?: string | undefined;
    lastResponseTime!: Date;
    serviceName?: string | undefined;
    fileVersion?: string | undefined;
    productVersion?: string | undefined;
    release?: string | undefined;
    logLevel?: string | undefined;

    constructor(data?: INodeInfoMessage) {
        super(data);
        this.setProp("object", "string", "nodeId", false);
        this.setProp("object", "string", "hostName", false);
        this.setProp("object", "Date", "lastResponseTime", false);
        this.setProp("object", "string", "serviceName", false);
        this.setProp("object", "string", "fileVersion", false);
        this.setProp("object", "string", "productVersion", false);
        this.setProp("object", "string", "release", false);
        this.setProp("object", "string", "logLevel", false);

        this._kind = "NodeInfoMessage";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NodeInfoMessage {
        return NodeInfoMessage.fromJS(data);
     }

    static fromJS(data: any): NodeInfoMessage {
        data = typeof data === 'object' ? data : {};
        let result = new NodeInfoMessage();
        result.init(data);
        return result;
    }

}

export interface INodeInfoMessage extends IMessage {
    nodeId?: string | undefined;
    hostName?: string | undefined;
    lastResponseTime: Date;
    serviceName?: string | undefined;
    fileVersion?: string | undefined;
    productVersion?: string | undefined;
    release?: string | undefined;
    logLevel?: string | undefined;
}

export class BaseResultOfLiveStream extends DTOBase {
    totalResults!: number;
    results!: LiveStream[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfLiveStream) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "LiveStream[]", "results", true, (item: any) => LiveStream.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfLiveStream {
        return BaseResultOfLiveStream.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfLiveStream {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfLiveStream();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfLiveStream {
    totalResults: number;
    results: ILiveStream[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Results of live stream search. */
export class LiveStreamSearchResult extends BaseResultOfLiveStream implements ILiveStreamSearchResult {

    constructor(data?: ILiveStreamSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LiveStreamSearchResult {
        return LiveStreamSearchResult.fromJS(data);
     }

    static fromJS(data: any): LiveStreamSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamSearchResult();
        result.init(data);
        return result;
    }

}

/** Results of live stream search. */
export interface ILiveStreamSearchResult extends IBaseResultOfLiveStream {
}

export class LiveStream extends DTOBase {
    id?: string | undefined;
    document?: string | undefined;
    scopeType?: string | undefined;
    timestamp!: Date;
    traceJob?: LiveStreamTraceJob | undefined;
    audit?: UserAudit | undefined;

    constructor(data?: ILiveStream) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "document", false);
        this.setProp("object", "string", "scopeType", false);
        this.setProp("object", "Date", "timestamp", false);
        this.setProp("object", "LiveStreamTraceJob", "traceJob", true, (item: any) => LiveStreamTraceJob.fromJS(item));
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LiveStream {
        return LiveStream.fromJS(data);
     }

    static fromJS(data: any): LiveStream {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStream();
        result.init(data);
        return result;
    }

}

export interface ILiveStream {
    id?: string | undefined;
    document?: string | undefined;
    scopeType?: string | undefined;
    timestamp: Date;
    traceJob?: ILiveStreamTraceJob | undefined;
    audit?: IUserAudit | undefined;
}

export class LiveStreamTraceJob extends DTOBase {
    traceJobId?: string | undefined;
    ipAddress?: string | undefined;
    userId?: string | undefined;
    apiClientId?: string | undefined;

    constructor(data?: ILiveStreamTraceJob) {
        super(data);
        this.setProp("object", "string", "traceJobId", false);
        this.setProp("object", "string", "ipAddress", false);
        this.setProp("object", "string", "userId", false);
        this.setProp("object", "string", "apiClientId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LiveStreamTraceJob {
        return LiveStreamTraceJob.fromJS(data);
     }

    static fromJS(data: any): LiveStreamTraceJob {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamTraceJob();
        result.init(data);
        return result;
    }

}

export interface ILiveStreamTraceJob {
    traceJobId?: string | undefined;
    ipAddress?: string | undefined;
    userId?: string | undefined;
    apiClientId?: string | undefined;
}

export class LiveStreamSearchRequest extends DTOBase {
    /** Sets the start date and time for results based on Timestamp attribute. */
    from!: Date;
    /** Sets the end date and time for results based on Timestamp attribute. */
    to!: Date;
    /** Optionally limits the result to only the specified scope type. */
    scopeType?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;

    constructor(data?: ILiveStreamSearchRequest) {
        super(data);
        this.setProp("object", "Date", "from", false);
        this.setProp("object", "Date", "to", false);
        this.setProp("object", "string", "scopeType", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LiveStreamSearchRequest {
        return LiveStreamSearchRequest.fromJS(data);
     }

    static fromJS(data: any): LiveStreamSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamSearchRequest();
        result.init(data);
        return result;
    }

}

export interface ILiveStreamSearchRequest {
    /** Sets the start date and time for results based on Timestamp attribute. */
    from: Date;
    /** Sets the end date and time for results based on Timestamp attribute. */
    to: Date;
    /** Optionally limits the result to only the specified scope type. */
    scopeType?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
}

export class BaseResultOfOutput extends DTOBase {
    totalResults!: number;
    results!: Output[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfOutput) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "Output[]", "results", true, (item: any) => Output.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfOutput {
        return BaseResultOfOutput.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfOutput();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfOutput {
    totalResults: number;
    results: Output[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class OutputSearchResult extends BaseResultOfOutput implements IOutputSearchResult {

    constructor(data?: IOutputSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputSearchResult {
        return OutputSearchResult.fromJS(data);
     }

    static fromJS(data: any): OutputSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OutputSearchResult();
        result.init(data);
        return result;
    }

}

export interface IOutputSearchResult extends IBaseResultOfOutput {
}

export class OutputSearchRequest extends DTOBase {
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[] | undefined;
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[] | undefined;
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[] | undefined;
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[] | undefined;

    constructor(data?: IOutputSearchRequest) {
        super(data);
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("array", "string[]", "contentIds", false);
        this.setProp("array", "OutputRenderingState[]", "renderingStates", false);
        this.setProp("array", "string[]", "fileExtensions", false);
        this.setProp("array", "string[]", "outputFormatIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputSearchRequest {
        return OutputSearchRequest.fromJS(data);
     }

    static fromJS(data: any): OutputSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputSearchRequest();
        result.init(data);
        return result;
    }

}

export interface IOutputSearchRequest {
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[] | undefined;
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[] | undefined;
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[] | undefined;
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[] | undefined;
}

export class OutputResetRetryAttemptsRequest extends DTOBase {
    /** List of output IDs you want to filter on. If this field is not empty, the other will be ignored. */
    outputIds?: string[] | undefined;
    /** List of Content IDs you want to filter on. */
    contentIds?: string[] | undefined;
    /** The file extension of the outputs you want to filter on. */
    fileExtensions?: string[] | undefined;
    /** The IDs of the output formats you want to filter on. */
    outputFormatIds?: string[] | undefined;
    /** Should the successful filter results also be reset (and subsequently re-rendered)? */
    includeCompleted!: boolean;

    constructor(data?: IOutputResetRetryAttemptsRequest) {
        super(data);
        this.setProp("array", "string[]", "outputIds", false);
        this.setProp("array", "string[]", "contentIds", false);
        this.setProp("array", "string[]", "fileExtensions", false);
        this.setProp("array", "string[]", "outputFormatIds", false);
        this.setProp("object", "boolean", "includeCompleted", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputResetRetryAttemptsRequest {
        return OutputResetRetryAttemptsRequest.fromJS(data);
     }

    static fromJS(data: any): OutputResetRetryAttemptsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputResetRetryAttemptsRequest();
        result.init(data);
        return result;
    }

}

export interface IOutputResetRetryAttemptsRequest {
    /** List of output IDs you want to filter on. If this field is not empty, the other will be ignored. */
    outputIds?: string[] | undefined;
    /** List of Content IDs you want to filter on. */
    contentIds?: string[] | undefined;
    /** The file extension of the outputs you want to filter on. */
    fileExtensions?: string[] | undefined;
    /** The IDs of the output formats you want to filter on. */
    outputFormatIds?: string[] | undefined;
    /** Should the successful filter results also be reset (and subsequently re-rendered)? */
    includeCompleted: boolean;
}

/** Represents the editable part of the output format. */
export class OutputFormatEditable extends DTOBase {
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    /** Which output format should be used as a source of data. */
    sourceOutputFormats?: SourceOutputFormats | undefined;
    /** Information about the technical format of the data, e.g. JPEG, AAC or video still. */
    format?: FormatBase | undefined;
    /** How long should the dynamic outputs created from this format be kept. */
    retentionTime!: string;

    constructor(data?: IOutputFormatEditable) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "SourceOutputFormats", "sourceOutputFormats", true, (item: any) => SourceOutputFormats.fromJS(item));
        this.setProp("object", "FormatBase", "format", true, (item: any) => FormatBase.fromJS(item));
        this.setProp("object", "string", "retentionTime", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatEditable {
        return OutputFormatEditable.fromJS(data);
     }

    static fromJS(data: any): OutputFormatEditable {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatEditable();
        result.init(data);
        return result;
    }

}

/** Represents the editable part of the output format. */
export interface IOutputFormatEditable {
    /** Language specific names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Which output format should be used as a source of data. */
    sourceOutputFormats?: ISourceOutputFormats | undefined;
    /** Information about the technical format of the data, e.g. JPEG, AAC or video still. */
    format?: FormatBase | undefined;
    /** How long should the dynamic outputs created from this format be kept. */
    retentionTime: string;
}

/** Represents an output format. */
export class OutputFormat extends OutputFormatEditable implements IOutputFormat {
    /** Output format ID. */
    id?: string | undefined;
    /** Marks if this is a system output format. */
    system!: boolean;
    /** A dynamic output format is not rendered automatically, but only on demand. */
    dynamic!: boolean;
    /** Specifies if output format should be taken into account during data extraction. */
    dataExtraction!: boolean;
    /** Temporary outputs will not be backed up. */
    temporary!: boolean;

    constructor(data?: IOutputFormat) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "boolean", "system", false);
        this.setProp("object", "boolean", "dynamic", false);
        this.setProp("object", "boolean", "dataExtraction", false);
        this.setProp("object", "boolean", "temporary", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormat {
        return OutputFormat.fromJS(data);
     }

    static fromJS(data: any): OutputFormat {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormat();
        result.init(data);
        return result;
    }

}

/** Represents an output format. */
export interface IOutputFormat extends IOutputFormatEditable {
    /** Output format ID. */
    id?: string | undefined;
    /** Marks if this is a system output format. */
    system: boolean;
    /** A dynamic output format is not rendered automatically, but only on demand. */
    dynamic: boolean;
    /** Specifies if output format should be taken into account during data extraction. */
    dataExtraction: boolean;
    /** Temporary outputs will not be backed up. */
    temporary: boolean;
}

export class SourceOutputFormats extends DTOBase {
    image?: string | undefined;
    video?: string | undefined;
    document?: string | undefined;
    audio?: string | undefined;

    constructor(data?: ISourceOutputFormats) {
        super(data);
        this.setProp("object", "string", "image", false);
        this.setProp("object", "string", "video", false);
        this.setProp("object", "string", "document", false);
        this.setProp("object", "string", "audio", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SourceOutputFormats {
        return SourceOutputFormats.fromJS(data);
     }

    static fromJS(data: any): SourceOutputFormats {
        data = typeof data === 'object' ? data : {};
        let result = new SourceOutputFormats();
        result.init(data);
        return result;
    }

}

export interface ISourceOutputFormats {
    image?: string | undefined;
    video?: string | undefined;
    document?: string | undefined;
    audio?: string | undefined;
}

export abstract class FormatBase extends DTOBase {

    protected _kind: string;

    constructor(data?: IFormatBase) {
        super(data);

        this._kind = "FormatBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FormatBase {
        return FormatBase.fromJS(data);
     }

    static fromJS(data: any): FormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ImageFormatBase") {
            throw new Error("The abstract class 'ImageFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "OriginalFormat") {
            let result = new OriginalFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "JpegFormat") {
            let result = new JpegFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PngFormat") {
            let result = new PngFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TiffFormat") {
            let result = new TiffFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoFormatBase") {
            throw new Error("The abstract class 'VideoFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "AudioFormatBase") {
            throw new Error("The abstract class 'AudioFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "Mp4VideoFormat") {
            let result = new Mp4VideoFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoSpriteFormat") {
            let result = new VideoSpriteFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoStillFormat") {
            let result = new VideoStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AacAudioFormat") {
            let result = new AacAudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AudioStillFormat") {
            let result = new AudioStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "Mp3AudioFormat") {
            let result = new Mp3AudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentFormatBase") {
            throw new Error("The abstract class 'DocumentFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "DocumentStillFormat") {
            let result = new DocumentStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PdfFormat") {
            let result = new PdfFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FormatBase' cannot be instantiated.");
    }

}

export interface IFormatBase {
}

export abstract class ImageFormatBase extends FormatBase implements IImageFormatBase {
    colorProfile?: ColorProfile | undefined;
    colorTransformationIntent!: ColorTransformationIntent;
    horizontalResolution?: number | undefined;
    verticalResolution?: number | undefined;
    renderFirstFrameOnly!: boolean;
    keepClippingPath!: boolean;
    cloneExif!: boolean;
    cloneIptc!: boolean;
    cloneAdobeResources!: boolean;
    cloneXmp!: boolean;
    resizeAction?: ResizeAction | undefined;
    actions?: ImageActionBase[] | undefined;

    constructor(data?: IImageFormatBase) {
        super(data);
        this.setProp("object", "ColorProfile", "colorProfile", false);
        this.setProp("object", "ColorTransformationIntent", "colorTransformationIntent", false);
        this.setProp("object", "number", "horizontalResolution", false);
        this.setProp("object", "number", "verticalResolution", false);
        this.setProp("object", "boolean", "renderFirstFrameOnly", false);
        this.setProp("object", "boolean", "keepClippingPath", false);
        this.setProp("object", "boolean", "cloneExif", false);
        this.setProp("object", "boolean", "cloneIptc", false);
        this.setProp("object", "boolean", "cloneAdobeResources", false);
        this.setProp("object", "boolean", "cloneXmp", false);
        this.setProp("object", "ResizeAction", "resizeAction", true, (item: any) => ResizeAction.fromJS(item));
        this.setProp("array", "ImageActionBase[]", "actions", true, (item: any) => ImageActionBase.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "ImageFormatBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ImageFormatBase {
        return ImageFormatBase.fromJS(data);
     }

    static fromJS(data: any): ImageFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "JpegFormat") {
            let result = new JpegFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PngFormat") {
            let result = new PngFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TiffFormat") {
            let result = new TiffFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ImageFormatBase' cannot be instantiated.");
    }

}

export interface IImageFormatBase extends IFormatBase {
    colorProfile?: ColorProfile | undefined;
    colorTransformationIntent: ColorTransformationIntent;
    horizontalResolution?: number | undefined;
    verticalResolution?: number | undefined;
    renderFirstFrameOnly: boolean;
    keepClippingPath: boolean;
    cloneExif: boolean;
    cloneIptc: boolean;
    cloneAdobeResources: boolean;
    cloneXmp: boolean;
    resizeAction?: IResizeAction | undefined;
    actions?: ImageActionBase[] | undefined;
}

export enum ColorProfile {
    AdobeRgb1998 = "AdobeRgb1998",
    AppleRgb = "AppleRgb",
    ColorMatchRgb = "ColorMatchRgb",
    EciRgbV1 = "EciRgbV1",
    EciRgbV2 = "EciRgbV2",
    Srgb = "Srgb",
    SrgbColorSpaceProfile = "SrgbColorSpaceProfile",
    EuropeIsoCoatedFogra27 = "EuropeIsoCoatedFogra27",
    EuroscaleCoated = "EuroscaleCoated",
    EuroscaleUncoated = "EuroscaleUncoated",
    IsoCoated = "IsoCoated",
    IsoCoatedEciV2 = "IsoCoatedEciV2",
    JapanColor2001Coated = "JapanColor2001Coated",
    JapanColor2001Uncoated = "JapanColor2001Uncoated",
    JapanColor2002Newspaper = "JapanColor2002Newspaper",
    JapanWebCoated = "JapanWebCoated",
    UsSheetfedCoated = "UsSheetfedCoated",
    UsSheetfedUncoated = "UsSheetfedUncoated",
    UsWebCoatedSwop = "UsWebCoatedSwop",
    UsWebUncoated = "UsWebUncoated",
    IsoCoatedV2Grey1cBas = "IsoCoatedV2Grey1cBas",
    IsoCoated300EciV2 = "IsoCoated300EciV2",
    CoatedFogra27 = "CoatedFogra27",
    CoatedFogra39 = "CoatedFogra39",
    UncoatedFogra29 = "UncoatedFogra29",
    WebCoatedFogra28 = "WebCoatedFogra28",
    WebCoatedSwop2006Grade3 = "WebCoatedSwop2006Grade3",
    WebCoatedSwop2006Grade5 = "WebCoatedSwop2006Grade5",
    Isonewspaper26v4 = "Isonewspaper26v4",
    Isonewspaper26v4Grey = "Isonewspaper26v4Grey",
}

export enum ColorTransformationIntent {
    RelativeColorimetricBpc = "RelativeColorimetricBpc",
    AbsoluteColorimetric = "AbsoluteColorimetric",
    Perceptual = "Perceptual",
    RelativeColorimetric = "RelativeColorimetric",
    Saturation = "Saturation",
}

/** Does not implement the IImageAction interface. The ResizeAction is directly exposed within ImageFormat. */
export class ResizeAction extends DTOBase {
    width!: number;
    height!: number;
    resizeMode!: ResizeMode;

    constructor(data?: IResizeAction) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "ResizeMode", "resizeMode", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ResizeAction {
        return ResizeAction.fromJS(data);
     }

    static fromJS(data: any): ResizeAction {
        data = typeof data === 'object' ? data : {};
        let result = new ResizeAction();
        result.init(data);
        return result;
    }

}

/** Does not implement the IImageAction interface. The ResizeAction is directly exposed within ImageFormat. */
export interface IResizeAction {
    width: number;
    height: number;
    resizeMode: ResizeMode;
}

export enum ResizeMode {
    Fit = "Fit",
    Shrink = "Shrink",
    Resize = "Resize",
}

export abstract class ImageActionBase extends DTOBase {

    protected _kind: string;

    constructor(data?: IImageActionBase) {
        super(data);

        this._kind = "ImageActionBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ImageActionBase {
        return ImageActionBase.fromJS(data);
     }

    static fromJS(data: any): ImageActionBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AlphaHandlingAction") {
            let result = new AlphaHandlingAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CropAction") {
            let result = new CropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsharpenMaskAction") {
            let result = new UnsharpenMaskAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WatermarkAction") {
            let result = new WatermarkAction();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ImageActionBase' cannot be instantiated.");
    }

}

export interface IImageActionBase {
}

export class AlphaHandlingAction extends ImageActionBase implements IAlphaHandlingAction {
    alphaHandling!: AlphaHandling;
    replacementRgbColorHexCode?: string | undefined;

    constructor(data?: IAlphaHandlingAction) {
        super(data);
        this.setProp("object", "AlphaHandling", "alphaHandling", false);
        this.setProp("object", "string", "replacementRgbColorHexCode", false);

        this._kind = "AlphaHandlingAction";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AlphaHandlingAction {
        return AlphaHandlingAction.fromJS(data);
     }

    static fromJS(data: any): AlphaHandlingAction {
        data = typeof data === 'object' ? data : {};
        let result = new AlphaHandlingAction();
        result.init(data);
        return result;
    }

}

export interface IAlphaHandlingAction extends IImageActionBase {
    alphaHandling: AlphaHandling;
    replacementRgbColorHexCode?: string | undefined;
}

export enum AlphaHandling {
    DiscardAlpha = "DiscardAlpha",
    ReplaceAlpha = "ReplaceAlpha",
    ReplaceInvertedAlpha = "ReplaceInvertedAlpha",
}

export class CropAction extends ImageActionBase implements ICropAction {
    x!: number;
    y!: number;
    width!: number;
    height!: number;

    constructor(data?: ICropAction) {
        super(data);
        this.setProp("object", "number", "x", false);
        this.setProp("object", "number", "y", false);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);

        this._kind = "CropAction";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CropAction {
        return CropAction.fromJS(data);
     }

    static fromJS(data: any): CropAction {
        data = typeof data === 'object' ? data : {};
        let result = new CropAction();
        result.init(data);
        return result;
    }

}

export interface ICropAction extends IImageActionBase {
    x: number;
    y: number;
    width: number;
    height: number;
}

export class UnsharpenMaskAction extends ImageActionBase implements IUnsharpenMaskAction {
    amount!: number;
    radius!: number;
    threshold!: number;

    constructor(data?: IUnsharpenMaskAction) {
        super(data);
        this.setProp("object", "number", "amount", false);
        this.setProp("object", "number", "radius", false);
        this.setProp("object", "number", "threshold", false);

        this._kind = "UnsharpenMaskAction";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UnsharpenMaskAction {
        return UnsharpenMaskAction.fromJS(data);
     }

    static fromJS(data: any): UnsharpenMaskAction {
        data = typeof data === 'object' ? data : {};
        let result = new UnsharpenMaskAction();
        result.init(data);
        return result;
    }

}

export interface IUnsharpenMaskAction extends IImageActionBase {
    amount: number;
    radius: number;
    threshold: number;
}

export class WatermarkAction extends ImageActionBase implements IWatermarkAction {
    watermarkFilePath?: string | undefined;
    watermarkText?: string | undefined;
    marginLeft?: number | undefined;
    marginTop?: number | undefined;
    marginRight?: number | undefined;
    marginBottom?: number | undefined;
    opacity!: number;
    widthRatio!: number;
    heightRatio!: number;

    constructor(data?: IWatermarkAction) {
        super(data);
        this.setProp("object", "string", "watermarkFilePath", false);
        this.setProp("object", "string", "watermarkText", false);
        this.setProp("object", "number", "marginLeft", false);
        this.setProp("object", "number", "marginTop", false);
        this.setProp("object", "number", "marginRight", false);
        this.setProp("object", "number", "marginBottom", false);
        this.setProp("object", "number", "opacity", false);
        this.setProp("object", "number", "widthRatio", false);
        this.setProp("object", "number", "heightRatio", false);

        this._kind = "WatermarkAction";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): WatermarkAction {
        return WatermarkAction.fromJS(data);
     }

    static fromJS(data: any): WatermarkAction {
        data = typeof data === 'object' ? data : {};
        let result = new WatermarkAction();
        result.init(data);
        return result;
    }

}

export interface IWatermarkAction extends IImageActionBase {
    watermarkFilePath?: string | undefined;
    watermarkText?: string | undefined;
    marginLeft?: number | undefined;
    marginTop?: number | undefined;
    marginRight?: number | undefined;
    marginBottom?: number | undefined;
    opacity: number;
    widthRatio: number;
    heightRatio: number;
}

export class OriginalFormat extends FormatBase implements IOriginalFormat {
    extension?: string | undefined;

    constructor(data?: IOriginalFormat) {
        super(data);
        this.setProp("object", "string", "extension", false);

        this._kind = "OriginalFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OriginalFormat {
        return OriginalFormat.fromJS(data);
     }

    static fromJS(data: any): OriginalFormat {
        data = typeof data === 'object' ? data : {};
        let result = new OriginalFormat();
        result.init(data);
        return result;
    }

}

export interface IOriginalFormat extends IFormatBase {
    extension?: string | undefined;
}

export class JpegFormat extends ImageFormatBase implements IJpegFormat {
    quality!: number;
    isProgressive!: boolean;
    chromaSubsamplingEnabled!: boolean;
    extension?: string | undefined;

    constructor(data?: IJpegFormat) {
        super(data);
        this.setProp("object", "number", "quality", false);
        this.setProp("object", "boolean", "isProgressive", false);
        this.setProp("object", "boolean", "chromaSubsamplingEnabled", false);
        this.setProp("object", "string", "extension", false);

        this._kind = "JpegFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): JpegFormat {
        return JpegFormat.fromJS(data);
     }

    static fromJS(data: any): JpegFormat {
        data = typeof data === 'object' ? data : {};
        let result = new JpegFormat();
        result.init(data);
        return result;
    }

}

export interface IJpegFormat extends IImageFormatBase {
    quality: number;
    isProgressive: boolean;
    chromaSubsamplingEnabled: boolean;
    extension?: string | undefined;
}

export class PngFormat extends ImageFormatBase implements IPngFormat {
    interlaced!: boolean;
    extension?: string | undefined;

    constructor(data?: IPngFormat) {
        super(data);
        this.setProp("object", "boolean", "interlaced", false);
        this.setProp("object", "string", "extension", false);

        this._kind = "PngFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PngFormat {
        return PngFormat.fromJS(data);
     }

    static fromJS(data: any): PngFormat {
        data = typeof data === 'object' ? data : {};
        let result = new PngFormat();
        result.init(data);
        return result;
    }

}

export interface IPngFormat extends IImageFormatBase {
    interlaced: boolean;
    extension?: string | undefined;
}

export class TiffFormat extends ImageFormatBase implements ITiffFormat {
    alphaPremultiplied!: boolean;
    compressionType!: CompressionType;
    includeUnspecifiedTiffExtraChannels!: boolean;
    extension?: string | undefined;

    constructor(data?: ITiffFormat) {
        super(data);
        this.setProp("object", "boolean", "alphaPremultiplied", false);
        this.setProp("object", "CompressionType", "compressionType", false);
        this.setProp("object", "boolean", "includeUnspecifiedTiffExtraChannels", false);
        this.setProp("object", "string", "extension", false);

        this._kind = "TiffFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TiffFormat {
        return TiffFormat.fromJS(data);
     }

    static fromJS(data: any): TiffFormat {
        data = typeof data === 'object' ? data : {};
        let result = new TiffFormat();
        result.init(data);
        return result;
    }

}

export interface ITiffFormat extends IImageFormatBase {
    alphaPremultiplied: boolean;
    compressionType: CompressionType;
    includeUnspecifiedTiffExtraChannels: boolean;
    extension?: string | undefined;
}

export enum CompressionType {
    None = "None",
    Lzw = "Lzw",
    Rle = "Rle",
    Zip = "Zip",
}

export abstract class VideoFormatBase extends FormatBase implements IVideoFormatBase {

    constructor(data?: IVideoFormatBase) {
        super(data);

        this._kind = "VideoFormatBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): VideoFormatBase {
        return VideoFormatBase.fromJS(data);
     }

    static fromJS(data: any): VideoFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "Mp4VideoFormat") {
            let result = new Mp4VideoFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoSpriteFormat") {
            let result = new VideoSpriteFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoStillFormat") {
            let result = new VideoStillFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'VideoFormatBase' cannot be instantiated.");
    }

}

export interface IVideoFormatBase extends IFormatBase {
}

export class Mp4VideoFormat extends VideoFormatBase implements IMp4VideoFormat {
    resizeAction?: ResizeAction2 | undefined;
    /** Gets or sets the encoding audio codec. */
    audioCodec?: AudioFormatBase | undefined;
    /** Gets or sets the encoding codec preset. */
    preset!: Preset;
    extension?: string | undefined;

    constructor(data?: IMp4VideoFormat) {
        super(data);
        this.setProp("object", "ResizeAction2", "resizeAction", true, (item: any) => ResizeAction2.fromJS(item));
        this.setProp("object", "AudioFormatBase", "audioCodec", true, (item: any) => AudioFormatBase.fromJS(item));
        this.setProp("object", "Preset", "preset", false);
        this.setProp("object", "string", "extension", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "Mp4VideoFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Mp4VideoFormat {
        return Mp4VideoFormat.fromJS(data);
     }

    static fromJS(data: any): Mp4VideoFormat {
        data = typeof data === 'object' ? data : {};
        let result = new Mp4VideoFormat();
        result.init(data);
        return result;
    }

}

export interface IMp4VideoFormat extends IVideoFormatBase {
    resizeAction?: IResizeAction2 | undefined;
    /** Gets or sets the encoding audio codec. */
    audioCodec?: AudioFormatBase | undefined;
    /** Gets or sets the encoding codec preset. */
    preset: Preset;
    extension?: string | undefined;
}

export class ResizeAction2 extends DTOBase {
    width!: number;
    height!: number;
    resizeMode!: ResizeMode;

    constructor(data?: IResizeAction2) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "ResizeMode", "resizeMode", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ResizeAction2 {
        return ResizeAction2.fromJS(data);
     }

    static fromJS(data: any): ResizeAction2 {
        data = typeof data === 'object' ? data : {};
        let result = new ResizeAction2();
        result.init(data);
        return result;
    }

}

export interface IResizeAction2 {
    width: number;
    height: number;
    resizeMode: ResizeMode;
}

export abstract class AudioFormatBase extends FormatBase implements IAudioFormatBase {

    constructor(data?: IAudioFormatBase) {
        super(data);

        this._kind = "AudioFormatBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AudioFormatBase {
        return AudioFormatBase.fromJS(data);
     }

    static fromJS(data: any): AudioFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AacAudioFormat") {
            let result = new AacAudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AudioStillFormat") {
            let result = new AudioStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "Mp3AudioFormat") {
            let result = new Mp3AudioFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AudioFormatBase' cannot be instantiated.");
    }

}

export interface IAudioFormatBase extends IFormatBase {
}

export enum Preset {
    Ultrafast = "ultrafast",
    Superfast = "superfast",
    Veryfast = "veryfast",
    Faster = "faster",
    Fast = "fast",
    Medium = "medium",
    Slow = "slow",
    Slower = "slower",
}

export class VideoSpriteFormat extends VideoFormatBase implements IVideoSpriteFormat {
    spriteResizeAction?: ResizeAction2 | undefined;
    maxNumberOfSprites!: number;
    quality!: number;
    extension?: string | undefined;

    constructor(data?: IVideoSpriteFormat) {
        super(data);
        this.setProp("object", "ResizeAction2", "spriteResizeAction", true, (item: any) => ResizeAction2.fromJS(item));
        this.setProp("object", "number", "maxNumberOfSprites", false);
        this.setProp("object", "number", "quality", false);
        this.setProp("object", "string", "extension", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "VideoSpriteFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): VideoSpriteFormat {
        return VideoSpriteFormat.fromJS(data);
     }

    static fromJS(data: any): VideoSpriteFormat {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSpriteFormat();
        result.init(data);
        return result;
    }

}

export interface IVideoSpriteFormat extends IVideoFormatBase {
    spriteResizeAction?: IResizeAction2 | undefined;
    maxNumberOfSprites: number;
    quality: number;
    extension?: string | undefined;
}

export class VideoStillFormat extends VideoFormatBase implements IVideoStillFormat {
    extension?: string | undefined;
    positionInSeconds!: number;

    constructor(data?: IVideoStillFormat) {
        super(data);
        this.setProp("object", "string", "extension", false);
        this.setProp("object", "number", "positionInSeconds", false);

        this._kind = "VideoStillFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): VideoStillFormat {
        return VideoStillFormat.fromJS(data);
     }

    static fromJS(data: any): VideoStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new VideoStillFormat();
        result.init(data);
        return result;
    }

}

export interface IVideoStillFormat extends IVideoFormatBase {
    extension?: string | undefined;
    positionInSeconds: number;
}

export class AacAudioFormat extends AudioFormatBase implements IAacAudioFormat {
    extension?: string | undefined;
    /** Gets or sets the encoding profile. */
    profile!: Profile;
    /** Gets or sets the encoding coder. */
    coder!: Coder;
    /** Gets or sets the bitrate of the encoding. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding variable bit rate (VBR) - 1 is lowest quality and 5 is highest quality. */
    variableBitRate?: number | undefined;

    constructor(data?: IAacAudioFormat) {
        super(data);
        this.setProp("object", "string", "extension", false);
        this.setProp("object", "Profile", "profile", false);
        this.setProp("object", "Coder", "coder", false);
        this.setProp("object", "number", "bitrate", false);
        this.setProp("object", "number", "variableBitRate", false);

        this._kind = "AacAudioFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AacAudioFormat {
        return AacAudioFormat.fromJS(data);
     }

    static fromJS(data: any): AacAudioFormat {
        data = typeof data === 'object' ? data : {};
        let result = new AacAudioFormat();
        result.init(data);
        return result;
    }

}

export interface IAacAudioFormat extends IAudioFormatBase {
    extension?: string | undefined;
    /** Gets or sets the encoding profile. */
    profile: Profile;
    /** Gets or sets the encoding coder. */
    coder: Coder;
    /** Gets or sets the bitrate of the encoding. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding variable bit rate (VBR) - 1 is lowest quality and 5 is highest quality. */
    variableBitRate?: number | undefined;
}

export enum Profile {
    Aac_low = "aac_low",
    Mpeg2_aac_low = "mpeg2_aac_low",
    Aac_ltp = "aac_ltp",
    Aac_main = "aac_main",
}

export enum Coder {
    Twoloop = "twoloop",
    Anmr = "anmr",
    Fast = "fast",
}

export class AudioStillFormat extends AudioFormatBase implements IAudioStillFormat {
    extension?: string | undefined;

    constructor(data?: IAudioStillFormat) {
        super(data);
        this.setProp("object", "string", "extension", false);

        this._kind = "AudioStillFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AudioStillFormat {
        return AudioStillFormat.fromJS(data);
     }

    static fromJS(data: any): AudioStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new AudioStillFormat();
        result.init(data);
        return result;
    }

}

export interface IAudioStillFormat extends IAudioFormatBase {
    extension?: string | undefined;
}

export class Mp3AudioFormat extends AudioFormatBase implements IMp3AudioFormat {
    extension?: string | undefined;
    /** Gets or sets the encoding bitrate. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding quality.
Values can be set it range of 0 to 9, where a lower value is a higher quality. */
    quality?: number | undefined;

    constructor(data?: IMp3AudioFormat) {
        super(data);
        this.setProp("object", "string", "extension", false);
        this.setProp("object", "number", "bitrate", false);
        this.setProp("object", "number", "quality", false);

        this._kind = "Mp3AudioFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Mp3AudioFormat {
        return Mp3AudioFormat.fromJS(data);
     }

    static fromJS(data: any): Mp3AudioFormat {
        data = typeof data === 'object' ? data : {};
        let result = new Mp3AudioFormat();
        result.init(data);
        return result;
    }

}

export interface IMp3AudioFormat extends IAudioFormatBase {
    extension?: string | undefined;
    /** Gets or sets the encoding bitrate. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding quality.
Values can be set it range of 0 to 9, where a lower value is a higher quality. */
    quality?: number | undefined;
}

export abstract class DocumentFormatBase extends FormatBase implements IDocumentFormatBase {

    constructor(data?: IDocumentFormatBase) {
        super(data);

        this._kind = "DocumentFormatBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentFormatBase {
        return DocumentFormatBase.fromJS(data);
     }

    static fromJS(data: any): DocumentFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentStillFormat") {
            let result = new DocumentStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PdfFormat") {
            let result = new PdfFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DocumentFormatBase' cannot be instantiated.");
    }

}

export interface IDocumentFormatBase extends IFormatBase {
}

export class DocumentStillFormat extends DocumentFormatBase implements IDocumentStillFormat {
    extension?: string | undefined;

    constructor(data?: IDocumentStillFormat) {
        super(data);
        this.setProp("object", "string", "extension", false);

        this._kind = "DocumentStillFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentStillFormat {
        return DocumentStillFormat.fromJS(data);
     }

    static fromJS(data: any): DocumentStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStillFormat();
        result.init(data);
        return result;
    }

}

export interface IDocumentStillFormat extends IDocumentFormatBase {
    extension?: string | undefined;
}

export class PdfFormat extends DocumentFormatBase implements IPdfFormat {
    /** JpegQuality parameter value must be between 0 and 100. */
    jpegQuality!: number;
    fastWebView!: boolean;
    reduceFileSize!: boolean;
    extension?: string | undefined;
    extractFullText!: boolean;

    constructor(data?: IPdfFormat) {
        super(data);
        this.setProp("object", "number", "jpegQuality", false);
        this.setProp("object", "boolean", "fastWebView", false);
        this.setProp("object", "boolean", "reduceFileSize", false);
        this.setProp("object", "string", "extension", false);
        this.setProp("object", "boolean", "extractFullText", false);

        this._kind = "PdfFormat";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PdfFormat {
        return PdfFormat.fromJS(data);
     }

    static fromJS(data: any): PdfFormat {
        data = typeof data === 'object' ? data : {};
        let result = new PdfFormat();
        result.init(data);
        return result;
    }

}

export interface IPdfFormat extends IDocumentFormatBase {
    /** JpegQuality parameter value must be between 0 and 100. */
    jpegQuality: number;
    fastWebView: boolean;
    reduceFileSize: boolean;
    extension?: string | undefined;
    extractFullText: boolean;
}

/** Used to create multiple new output formats at once. */
export class OutputFormatCreateManyRequest extends DTOBase {
    /** Output format items to be created. */
    items?: OutputFormat[] | undefined;

    constructor(data?: IOutputFormatCreateManyRequest) {
        super(data);
        this.setProp("array", "OutputFormat[]", "items", true, (item: any) => OutputFormat.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatCreateManyRequest {
        return OutputFormatCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): OutputFormatCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatCreateManyRequest();
        result.init(data);
        return result;
    }

}

/** Used to create multiple new output formats at once. */
export interface IOutputFormatCreateManyRequest {
    /** Output format items to be created. */
    items?: OutputFormat[] | undefined;
}

/** Used to modify multiple output formats at once. */
export class OutputFormatUpdateManyRequest extends DTOBase {
    /** Output format items to be modified. */
    items?: OutputFormatUpdateManyRequestItem[] | undefined;

    constructor(data?: IOutputFormatUpdateManyRequest) {
        super(data);
        this.setProp("array", "OutputFormatUpdateManyRequestItem[]", "items", true, (item: any) => OutputFormatUpdateManyRequestItem.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatUpdateManyRequest {
        return OutputFormatUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): OutputFormatUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** Used to modify multiple output formats at once. */
export interface IOutputFormatUpdateManyRequest {
    /** Output format items to be modified. */
    items?: OutputFormatUpdateManyRequestItem[] | undefined;
}

/** Represents one item to be modified in a bulk update operation on output formats. */
export class OutputFormatUpdateManyRequestItem extends OutputFormatEditable implements IOutputFormatUpdateManyRequestItem {
    /** ID of the output format to modify. */
    id?: string | undefined;

    constructor(data?: IOutputFormatUpdateManyRequestItem) {
        super(data);
        this.setProp("object", "string", "id", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatUpdateManyRequestItem {
        return OutputFormatUpdateManyRequestItem.fromJS(data);
     }

    static fromJS(data: any): OutputFormatUpdateManyRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatUpdateManyRequestItem();
        result.init(data);
        return result;
    }

}

/** Represents one item to be modified in a bulk update operation on output formats. */
export interface IOutputFormatUpdateManyRequestItem extends IOutputFormatEditable {
    /** ID of the output format to modify. */
    id?: string | undefined;
}

/** Used to remove multiple output formats at once. */
export class OutputFormatDeleteManyRequest extends DTOBase {
    /** List of IDs of output formats to remove. */
    ids?: string[] | undefined;

    constructor(data?: IOutputFormatDeleteManyRequest) {
        super(data);
        this.setProp("array", "string[]", "ids", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OutputFormatDeleteManyRequest {
        return OutputFormatDeleteManyRequest.fromJS(data);
     }

    static fromJS(data: any): OutputFormatDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatDeleteManyRequest();
        result.init(data);
        return result;
    }

}

/** Used to remove multiple output formats at once. */
export interface IOutputFormatDeleteManyRequest {
    /** List of IDs of output formats to remove. */
    ids?: string[] | undefined;
}

/** User profile. */
export class UserProfile extends DTOBase {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: UserAddress | undefined;
    /** Authorization state. */
    authorizationState!: AuthorizationState;
    /** Indicates if the user is locked. */
    isLocked!: boolean;
    /** A list of user rights assigned to the user. */
    userRights?: UserRight[] | undefined;
    /** A list of user role IDs assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Indicates if the user has not accepted the latest terms of consent. */
    termsConsentExpired!: boolean;
    /** A list of system user roles assigned to the user. */
    systemUserRoles?: SystemUserRole[] | undefined;
    /** Indicates if the user has the developer flag set. */
    isDeveloper!: boolean;

    constructor(data?: IUserProfile) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "emailAddress", false);
        this.setProp("object", "string", "firstName", false);
        this.setProp("object", "string", "lastName", false);
        this.setProp("object", "string", "languageCode", false);
        this.setProp("object", "UserAddress", "address", true, (item: any) => UserAddress.fromJS(item));
        this.setProp("object", "AuthorizationState", "authorizationState", false);
        this.setProp("object", "boolean", "isLocked", false);
        this.setProp("array", "UserRight[]", "userRights", false);
        this.setProp("array", "string[]", "userRoleIds", false);
        this.setProp("object", "boolean", "termsConsentExpired", false);
        this.setProp("array", "SystemUserRole[]", "systemUserRoles", false);
        this.setProp("object", "boolean", "isDeveloper", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserProfile {
        return UserProfile.fromJS(data);
     }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

}

/** User profile. */
export interface IUserProfile {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: IUserAddress | undefined;
    /** Authorization state. */
    authorizationState: AuthorizationState;
    /** Indicates if the user is locked. */
    isLocked: boolean;
    /** A list of user rights assigned to the user. */
    userRights?: UserRight[] | undefined;
    /** A list of user role IDs assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Indicates if the user has not accepted the latest terms of consent. */
    termsConsentExpired: boolean;
    /** A list of system user roles assigned to the user. */
    systemUserRoles?: SystemUserRole[] | undefined;
    /** Indicates if the user has the developer flag set. */
    isDeveloper: boolean;
}

/** User's address */
export class UserAddress extends DTOBase {
    /** Company address line */
    company?: string | undefined;
    /** Company department. */
    department?: string | undefined;
    /** Street and house number. */
    address?: string | undefined;
    /** Additional address line. */
    alternativeAddress?: string | undefined;
    /** ZIP code. */
    zip?: string | undefined;
    /** City or town. */
    city?: string | undefined;
    /** Phone number. */
    phone?: string | undefined;
    /** Country code. */
    countryCode?: string | undefined;

    constructor(data?: IUserAddress) {
        super(data);
        this.setProp("object", "string", "company", false);
        this.setProp("object", "string", "department", false);
        this.setProp("object", "string", "address", false);
        this.setProp("object", "string", "alternativeAddress", false);
        this.setProp("object", "string", "zip", false);
        this.setProp("object", "string", "city", false);
        this.setProp("object", "string", "phone", false);
        this.setProp("object", "string", "countryCode", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserAddress {
        return UserAddress.fromJS(data);
     }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

}

/** User's address */
export interface IUserAddress {
    /** Company address line */
    company?: string | undefined;
    /** Company department. */
    department?: string | undefined;
    /** Street and house number. */
    address?: string | undefined;
    /** Additional address line. */
    alternativeAddress?: string | undefined;
    /** ZIP code. */
    zip?: string | undefined;
    /** City or town. */
    city?: string | undefined;
    /** Phone number. */
    phone?: string | undefined;
    /** Country code. */
    countryCode?: string | undefined;
}

/** System user roles. */
export enum SystemUserRole {
    Administrator = "Administrator",
}

/** Request to update a user profile. */
export class UserProfileUpdateRequest extends DTOBase {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: UserAddress | undefined;

    constructor(data?: IUserProfileUpdateRequest) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "emailAddress", false);
        this.setProp("object", "string", "firstName", false);
        this.setProp("object", "string", "lastName", false);
        this.setProp("object", "string", "languageCode", false);
        this.setProp("object", "UserAddress", "address", true, (item: any) => UserAddress.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserProfileUpdateRequest {
        return UserProfileUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): UserProfileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update a user profile. */
export interface IUserProfileUpdateRequest {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: IUserAddress | undefined;
}

/** The details of a schema */
export class SchemaDetail extends DTOBase {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id!: string;
    /** System generated schema namespace. It contains the full schema hierarchy up to the root schema (i.e. [RootSchemaId].[ParentSchemaId].[SchemaId]). */
    schemaNamespace!: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types!: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns!: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system!: boolean;
    /** The owner token ID. Defines the schema owner. */
    ownerTokenId!: string;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll!: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** The complete list of all descendant schema IDs. */
    descendantSchemaIds?: string[] | undefined;
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** The number of fields generated by the schema in the search index for filtering, searching and sorting. */
    searchFieldCount?: SearchFieldCount | undefined;

    constructor(data?: ISchemaDetail) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "schemaNamespace", false);
        this.setProp("object", "string", "parentSchemaId", false);
        this.setProp("array", "SchemaType[]", "types", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "descriptions", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("array", "DisplayPattern[]", "displayPatterns", true, (item: any) => DisplayPattern.fromJS(item));
        this.setProp("array", "FieldBase[]", "fields", true, (item: any) => FieldBase.fromJS(item));
        this.setProp("array", "FieldOverwriteBase[]", "fieldsOverwrite", true, (item: any) => FieldOverwriteBase.fromJS(item));
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregations", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("object", "boolean", "system", false);
        this.setProp("object", "string", "ownerTokenId", false);
        this.setProp("object", "boolean", "viewForAll", false);
        this.setProp("array", "string[]", "schemaPermissionSetIds", false);
        this.setProp("array", "string[]", "referencedInContentSchemaIds", false);
        this.setProp("array", "string[]", "descendantSchemaIds", false);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "SearchFieldCount", "searchFieldCount", true, (item: any) => SearchFieldCount.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.types = [];
            this.displayPatterns = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaDetail {
        return SchemaDetail.fromJS(data);
     }

    static fromJS(data: any): SchemaDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaDetail();
        result.init(data);
        return result;
    }

}

/** The details of a schema */
export interface ISchemaDetail {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id: string;
    /** System generated schema namespace. It contains the full schema hierarchy up to the root schema (i.e. [RootSchemaId].[ParentSchemaId].[SchemaId]). */
    schemaNamespace: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types: SchemaType[];
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns: IDisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: ISortInfo[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system: boolean;
    /** The owner token ID. Defines the schema owner. */
    ownerTokenId: string;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** The complete list of all descendant schema IDs. */
    descendantSchemaIds?: string[] | undefined;
    /** Audit information. */
    audit?: IUserAudit | undefined;
    /** The number of fields generated by the schema in the search index for filtering, searching and sorting. */
    searchFieldCount?: ISearchFieldCount | undefined;
}

/** Represent the template whose value will be resolved based on the actual content. */
export class DisplayPattern extends DTOBase {
    /** The template engine used for parsing the display patterns. */
    templateEngine!: TemplateEngine;
    /** The display pattern type. */
    displayPatternType!: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary | undefined;

    constructor(data?: IDisplayPattern) {
        super(data);
        this.setProp("object", "TemplateEngine", "templateEngine", false);
        this.setProp("object", "DisplayPatternType", "displayPatternType", false);
        this.setProp("object", "TranslatedStringDictionary", "templates", true, (item: any) => TranslatedStringDictionary.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DisplayPattern {
        return DisplayPattern.fromJS(data);
     }

    static fromJS(data: any): DisplayPattern {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayPattern();
        result.init(data);
        return result;
    }

}

/** Represent the template whose value will be resolved based on the actual content. */
export interface IDisplayPattern {
    /** The template engine used for parsing the display patterns. */
    templateEngine: TemplateEngine;
    /** The display pattern type. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: ITranslatedStringDictionary | undefined;
}

/** The template engine used for parsing the display patterns */
export enum TemplateEngine {
    DotLiquid = "DotLiquid",
}

/** The field base class */
export abstract class FieldBase extends DTOBase {
    /** The field ID. It can be a slug; it must be unique within the schema hierarchy (ancestors / descendants); it must be begin with lower case. */
    id!: string;
    /** The index ID is auto generated by the system. */
    indexId?: string | undefined;
    /** The field namespace is auto generated by the system: it carries the hierarchy information. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required!: boolean;
    /** Defines if the field can be edited or not. */
    fixed!: boolean;
    /** Field is stored for filtering. */
    index!: boolean;
    /** Field is stored for simple search. */
    simpleSearch!: boolean;
    /** Field is stored for sorting. */
    sortable!: boolean;

    protected _kind: string;

    constructor(data?: IFieldBase) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "indexId", false);
        this.setProp("object", "string", "fieldNamespace", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "descriptions", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "boolean", "required", false);
        this.setProp("object", "boolean", "fixed", false);
        this.setProp("object", "boolean", "index", false);
        this.setProp("object", "boolean", "simpleSearch", false);
        this.setProp("object", "boolean", "sortable", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "FieldBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldBase {
        return FieldBase.fromJS(data);
     }

    static fromJS(data: any): FieldBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldBoolean") {
            let result = new FieldBoolean();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDate") {
            let result = new FieldDate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTime") {
            let result = new FieldDateTime();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDecimal") {
            let result = new FieldDecimal();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionary") {
            let result = new FieldDictionary();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldGeoPoint") {
            let result = new FieldGeoPoint();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLong") {
            let result = new FieldLong();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleFieldset") {
            let result = new FieldSingleFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiFieldset") {
            let result = new FieldMultiFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleTagbox") {
            let result = new FieldSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiTagbox") {
            let result = new FieldMultiTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldString") {
            let result = new FieldString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldTranslatedString") {
            let result = new FieldTranslatedString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleRelation") {
            let result = new FieldSingleRelation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiRelation") {
            let result = new FieldMultiRelation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldBase' cannot be instantiated.");
    }

}

/** The field base class */
export interface IFieldBase {
    /** The field ID. It can be a slug; it must be unique within the schema hierarchy (ancestors / descendants); it must be begin with lower case. */
    id: string;
    /** The index ID is auto generated by the system. */
    indexId?: string | undefined;
    /** The field namespace is auto generated by the system: it carries the hierarchy information. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Field is stored for filtering. */
    index: boolean;
    /** Field is stored for simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
}

/** The field used to store a boolean */
export class FieldBoolean extends FieldBase implements IFieldBoolean {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldBoolean) {
        super(data);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldBoolean";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldBoolean {
        return FieldBoolean.fromJS(data);
     }

    static fromJS(data: any): FieldBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldBoolean();
        result.init(data);
        return result;
    }

}

/** The field used to store a boolean */
export interface IFieldBoolean extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store a date */
export class FieldDate extends FieldBase implements IFieldDate {
    /** The date format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldDate) {
        super(data);
        this.setProp("object", "string", "format", false);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldDate";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldDate {
        return FieldDate.fromJS(data);
     }

    static fromJS(data: any): FieldDate {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDate();
        result.init(data);
        return result;
    }

}

/** The field used to store a date */
export interface IFieldDate extends IFieldBase {
    /** The date format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store a date time */
export class FieldDateTime extends FieldBase implements IFieldDateTime {
    /** The date time format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldDateTime) {
        super(data);
        this.setProp("object", "string", "format", false);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldDateTime";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldDateTime {
        return FieldDateTime.fromJS(data);
     }

    static fromJS(data: any): FieldDateTime {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        let result = new FieldDateTime();
        result.init(data);
        return result;
    }

}

/** The field used to store a date time */
export interface IFieldDateTime extends IFieldBase {
    /** The date time format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store multiple date time values */
export class FieldDateTimeArray extends FieldDateTime implements IFieldDateTimeArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldDateTimeArray) {
        super(data);
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);

        this._kind = "FieldDateTimeArray";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldDateTimeArray {
        return FieldDateTimeArray.fromJS(data);
     }

    static fromJS(data: any): FieldDateTimeArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDateTimeArray();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple date time values */
export interface IFieldDateTimeArray extends IFieldDateTime {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a decimal value */
export class FieldDecimal extends FieldBase implements IFieldDecimal {
    /** The decimal pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldDecimal) {
        super(data);
        this.setProp("object", "string", "pattern", false);
        this.setProp("object", "number", "minimum", false);
        this.setProp("object", "number", "maximum", false);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldDecimal";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldDecimal {
        return FieldDecimal.fromJS(data);
     }

    static fromJS(data: any): FieldDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDecimal();
        result.init(data);
        return result;
    }

}

/** The field used to store a decimal value */
export interface IFieldDecimal extends IFieldBase {
    /** The decimal pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store a dictionary of values */
export class FieldDictionary extends FieldBase implements IFieldDictionary {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldDictionary) {
        super(data);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldDictionary";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldDictionary {
        return FieldDictionary.fromJS(data);
     }

    static fromJS(data: any): FieldDictionary {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        let result = new FieldDictionary();
        result.init(data);
        return result;
    }

}

/** The field used to store a dictionary of values */
export interface IFieldDictionary extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store multiple dictionaries' values */
export class FieldDictionaryArray extends FieldDictionary implements IFieldDictionaryArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldDictionaryArray) {
        super(data);
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);

        this._kind = "FieldDictionaryArray";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldDictionaryArray {
        return FieldDictionaryArray.fromJS(data);
     }

    static fromJS(data: any): FieldDictionaryArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDictionaryArray();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple dictionaries' values */
export interface IFieldDictionaryArray extends IFieldDictionary {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a geo point */
export class FieldGeoPoint extends FieldBase implements IFieldGeoPoint {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldGeoPoint) {
        super(data);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldGeoPoint";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldGeoPoint {
        return FieldGeoPoint.fromJS(data);
     }

    static fromJS(data: any): FieldGeoPoint {
        data = typeof data === 'object' ? data : {};
        let result = new FieldGeoPoint();
        result.init(data);
        return result;
    }

}

/** The field used to store a geo point */
export interface IFieldGeoPoint extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store a long value */
export class FieldLong extends FieldBase implements IFieldLong {
    /** The long pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldLong) {
        super(data);
        this.setProp("object", "string", "pattern", false);
        this.setProp("object", "number", "minimum", false);
        this.setProp("object", "number", "maximum", false);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldLong";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldLong {
        return FieldLong.fromJS(data);
     }

    static fromJS(data: any): FieldLong {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        let result = new FieldLong();
        result.init(data);
        return result;
    }

}

/** The field used to store a long value */
export interface IFieldLong extends IFieldBase {
    /** The long pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store multiple long values */
export class FieldLongArray extends FieldLong implements IFieldLongArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldLongArray) {
        super(data);
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);

        this._kind = "FieldLongArray";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldLongArray {
        return FieldLongArray.fromJS(data);
     }

    static fromJS(data: any): FieldLongArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLongArray();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple long values */
export interface IFieldLongArray extends IFieldLong {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a single fieldset */
export class FieldSingleFieldset extends FieldBase implements IFieldSingleFieldset {
    /** The ID of the schema to be used as fieldset (it must be of type Struct). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldSingleFieldset) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "SchemaIndexingInfo", "schemaIndexingInfo", true, (item: any) => SchemaIndexingInfo.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "FieldSingleFieldset";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldSingleFieldset {
        return FieldSingleFieldset.fromJS(data);
     }

    static fromJS(data: any): FieldSingleFieldset {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleFieldset();
        result.init(data);
        return result;
    }

}

/** The field used to store a single fieldset */
export interface IFieldSingleFieldset extends IFieldBase {
    /** The ID of the schema to be used as fieldset (it must be of type Struct). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
}

/** Indexing information for a schema */
export class SchemaIndexingInfo extends DTOBase {
    /** A collection of indexing information for the fields of a schema */
    fields?: FieldIndexingInfo[] | undefined;

    constructor(data?: ISchemaIndexingInfo) {
        super(data);
        this.setProp("array", "FieldIndexingInfo[]", "fields", true, (item: any) => FieldIndexingInfo.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaIndexingInfo {
        return SchemaIndexingInfo.fromJS(data);
     }

    static fromJS(data: any): SchemaIndexingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIndexingInfo();
        result.init(data);
        return result;
    }

}

/** Indexing information for a schema */
export interface ISchemaIndexingInfo {
    /** A collection of indexing information for the fields of a schema */
    fields?: IFieldIndexingInfo[] | undefined;
}

/** Indexing information for a field of a schema */
export class FieldIndexingInfo extends DTOBase {
    /** The field ID. */
    id!: string;
    /** Field is stored for filtering. */
    index!: boolean;
    /** Field is stored for simple search. */
    simpleSearch!: boolean;
    /** Field is stored for sorting. */
    sortable!: boolean;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;
    /** Indexing information of schema's fields related to this field (if existing). */
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldIndexingInfo) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "boolean", "index", false);
        this.setProp("object", "boolean", "simpleSearch", false);
        this.setProp("object", "boolean", "sortable", false);
        this.setProp("object", "number", "boost", false);
        this.setProp("object", "SchemaIndexingInfo", "relatedSchemaIndexing", true, (item: any) => SchemaIndexingInfo.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldIndexingInfo {
        return FieldIndexingInfo.fromJS(data);
     }

    static fromJS(data: any): FieldIndexingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldIndexingInfo();
        result.init(data);
        return result;
    }

}

/** Indexing information for a field of a schema */
export interface IFieldIndexingInfo {
    /** The field ID. */
    id: string;
    /** Field is stored for filtering. */
    index: boolean;
    /** Field is stored for simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
    /** Indexing information of schema's fields related to this field (if existing). */
    relatedSchemaIndexing?: ISchemaIndexingInfo | undefined;
}

/** The field used to store multiple fieldsets */
export class FieldMultiFieldset extends FieldBase implements IFieldMultiFieldset {
    /** The ID of the schema to be used as fieldset (it must be of type Struct, and it cannot be a system schema). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiFieldset) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "SchemaIndexingInfo", "schemaIndexingInfo", true, (item: any) => SchemaIndexingInfo.fromJS(item));
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "FieldMultiFieldset";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldMultiFieldset {
        return FieldMultiFieldset.fromJS(data);
     }

    static fromJS(data: any): FieldMultiFieldset {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiFieldset();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple fieldsets */
export interface IFieldMultiFieldset extends IFieldBase {
    /** The ID of the schema to be used as fieldset (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a single tagbox */
export class FieldSingleTagbox extends FieldBase implements IFieldSingleTagbox {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType!: DisplayPatternType;

    constructor(data?: IFieldSingleTagbox) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "SchemaIndexingInfo", "schemaIndexingInfo", true, (item: any) => SchemaIndexingInfo.fromJS(item));
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "string", "listItemCreateTemplate", false);
        this.setProp("object", "DisplayPatternType", "viewModeDisplayPatternType", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "FieldSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldSingleTagbox {
        return FieldSingleTagbox.fromJS(data);
     }

    static fromJS(data: any): FieldSingleTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleTagbox();
        result.init(data);
        return result;
    }

}

/** The field used to store a single tagbox */
export interface IFieldSingleTagbox extends IFieldBase {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType: DisplayPatternType;
}

/** The field used to store multiple tagboxes */
export class FieldMultiTagbox extends FieldBase implements IFieldMultiTagbox {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** An optional filter to limit the returned list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType!: DisplayPatternType;

    constructor(data?: IFieldMultiTagbox) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "SchemaIndexingInfo", "schemaIndexingInfo", true, (item: any) => SchemaIndexingInfo.fromJS(item));
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "string", "listItemCreateTemplate", false);
        this.setProp("object", "DisplayPatternType", "viewModeDisplayPatternType", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "FieldMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldMultiTagbox {
        return FieldMultiTagbox.fromJS(data);
     }

    static fromJS(data: any): FieldMultiTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiTagbox();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple tagboxes */
export interface IFieldMultiTagbox extends IFieldBase {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** An optional filter to limit the returned list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType: DisplayPatternType;
}

/** The field used to store a string value */
export class FieldString extends FieldBase implements IFieldString {
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template. */
    template?: string | undefined;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's lenght. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine!: boolean;
    /** If values are stored in this list, field values are limited to these ones. */
    grantedValues?: string[] | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldString) {
        super(data);
        this.setProp("object", "string", "template", false);
        this.setProp("object", "string", "pattern", false);
        this.setProp("object", "number", "minimumLength", false);
        this.setProp("object", "number", "maximumLength", false);
        this.setProp("array", "AnalyzerBase[]", "indexAnalyzers", true, (item: any) => AnalyzerBase.fromJS(item));
        this.setProp("array", "AnalyzerBase[]", "simpleSearchAnalyzers", true, (item: any) => AnalyzerBase.fromJS(item));
        this.setProp("object", "boolean", "multiLine", false);
        this.setProp("array", "string[]", "grantedValues", false);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldString";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldString {
        return FieldString.fromJS(data);
     }

    static fromJS(data: any): FieldString {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        let result = new FieldString();
        result.init(data);
        return result;
    }

}

/** The field used to store a string value */
export interface IFieldString extends IFieldBase {
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template. */
    template?: string | undefined;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's lenght. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine: boolean;
    /** If values are stored in this list, field values are limited to these ones. */
    grantedValues?: string[] | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The analyzer base class */
export abstract class AnalyzerBase extends DTOBase {

    protected _kind: string;

    constructor(data?: IAnalyzerBase) {
        super(data);

        this._kind = "AnalyzerBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AnalyzerBase {
        return AnalyzerBase.fromJS(data);
     }

    static fromJS(data: any): AnalyzerBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "EdgeNGramAnalyzer") {
            let result = new EdgeNGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageAnalyzer") {
            let result = new LanguageAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NGramAnalyzer") {
            let result = new NGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PathHierarchyAnalyzer") {
            let result = new PathHierarchyAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SimpleAnalyzer") {
            let result = new SimpleAnalyzer();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AnalyzerBase' cannot be instantiated.");
    }

}

/** The analyzer base class */
export interface IAnalyzerBase {
}

/** An analyzer using the ElasticSearch's EdgeNGram tokenizer */
export class EdgeNGramAnalyzer extends AnalyzerBase implements IEdgeNGramAnalyzer {
    /** The analyzer type: EdgeNGram */
    type!: Analyzer;
    /** The suffix for the analyzed field: edgengram. */
    fieldSuffix?: string | undefined;

    constructor(data?: IEdgeNGramAnalyzer) {
        super(data);
        this.setProp("object", "Analyzer", "type", false);
        this.setProp("object", "string", "fieldSuffix", false);

        this._kind = "EdgeNGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EdgeNGramAnalyzer {
        return EdgeNGramAnalyzer.fromJS(data);
     }

    static fromJS(data: any): EdgeNGramAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new EdgeNGramAnalyzer();
        result.init(data);
        return result;
    }

}

/** An analyzer using the ElasticSearch's EdgeNGram tokenizer */
export interface IEdgeNGramAnalyzer extends IAnalyzerBase {
    /** The analyzer type: EdgeNGram */
    type: Analyzer;
    /** The suffix for the analyzed field: edgengram. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using an ElasticSearch's language tokenizer */
export class LanguageAnalyzer extends AnalyzerBase implements ILanguageAnalyzer {
    /** The analyzer type: Language */
    type!: Analyzer;
    /** The suffix for the analyzed field: language. */
    fieldSuffix?: string | undefined;

    constructor(data?: ILanguageAnalyzer) {
        super(data);
        this.setProp("object", "Analyzer", "type", false);
        this.setProp("object", "string", "fieldSuffix", false);

        this._kind = "LanguageAnalyzer";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): LanguageAnalyzer {
        return LanguageAnalyzer.fromJS(data);
     }

    static fromJS(data: any): LanguageAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageAnalyzer();
        result.init(data);
        return result;
    }

}

/** An analyzer using an ElasticSearch's language tokenizer */
export interface ILanguageAnalyzer extends IAnalyzerBase {
    /** The analyzer type: Language */
    type: Analyzer;
    /** The suffix for the analyzed field: language. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using the ElasticSearch's NGram tokenizer */
export class NGramAnalyzer extends AnalyzerBase implements INGramAnalyzer {
    /** The analyzer type: NGram */
    type!: Analyzer;
    /** The suffix for the analyzed field: ngram. */
    fieldSuffix?: string | undefined;

    constructor(data?: INGramAnalyzer) {
        super(data);
        this.setProp("object", "Analyzer", "type", false);
        this.setProp("object", "string", "fieldSuffix", false);

        this._kind = "NGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): NGramAnalyzer {
        return NGramAnalyzer.fromJS(data);
     }

    static fromJS(data: any): NGramAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new NGramAnalyzer();
        result.init(data);
        return result;
    }

}

/** An analyzer using the ElasticSearch's NGram tokenizer */
export interface INGramAnalyzer extends IAnalyzerBase {
    /** The analyzer type: NGram */
    type: Analyzer;
    /** The suffix for the analyzed field: ngram. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using the ElasticSearch's path hierarchy tokenizer */
export class PathHierarchyAnalyzer extends AnalyzerBase implements IPathHierarchyAnalyzer {
    /** The analyzer type: PathHierarchy */
    type!: Analyzer;
    /** The suffix for the analyzed field: pathhierarchy. */
    fieldSuffix?: string | undefined;

    constructor(data?: IPathHierarchyAnalyzer) {
        super(data);
        this.setProp("object", "Analyzer", "type", false);
        this.setProp("object", "string", "fieldSuffix", false);

        this._kind = "PathHierarchyAnalyzer";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PathHierarchyAnalyzer {
        return PathHierarchyAnalyzer.fromJS(data);
     }

    static fromJS(data: any): PathHierarchyAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new PathHierarchyAnalyzer();
        result.init(data);
        return result;
    }

}

/** An analyzer using the ElasticSearch's path hierarchy tokenizer */
export interface IPathHierarchyAnalyzer extends IAnalyzerBase {
    /** The analyzer type: PathHierarchy */
    type: Analyzer;
    /** The suffix for the analyzed field: pathhierarchy. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer */
export class SimpleAnalyzer extends AnalyzerBase implements ISimpleAnalyzer {
    /** The analyzer type: Simple */
    type!: Analyzer;
    /** The suffix for the analyzed field: simple. */
    fieldSuffix?: string | undefined;

    constructor(data?: ISimpleAnalyzer) {
        super(data);
        this.setProp("object", "Analyzer", "type", false);
        this.setProp("object", "string", "fieldSuffix", false);

        this._kind = "SimpleAnalyzer";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SimpleAnalyzer {
        return SimpleAnalyzer.fromJS(data);
     }

    static fromJS(data: any): SimpleAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleAnalyzer();
        result.init(data);
        return result;
    }

}

/** An analyzer using a custom pattern tokenizer */
export interface ISimpleAnalyzer extends IAnalyzerBase {
    /** The analyzer type: Simple */
    type: Analyzer;
    /** The suffix for the analyzed field: simple. */
    fieldSuffix?: string | undefined;
}

/** The field used to store multiple string values */
export class FieldStringArray extends FieldString implements IFieldStringArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldStringArray) {
        super(data);
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);

        this._kind = "FieldStringArray";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldStringArray {
        return FieldStringArray.fromJS(data);
     }

    static fromJS(data: any): FieldStringArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldStringArray();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple string values */
export interface IFieldStringArray extends IFieldString {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a translated string values */
export class FieldTranslatedString extends FieldBase implements IFieldTranslatedString {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's lenght. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine!: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory. */
    requiredMetadataLanguages?: string[] | undefined;
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template.
             */
    template?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;

    constructor(data?: IFieldTranslatedString) {
        super(data);
        this.setProp("object", "string", "pattern", false);
        this.setProp("object", "number", "minimumLength", false);
        this.setProp("object", "number", "maximumLength", false);
        this.setProp("array", "AnalyzerBase[]", "indexAnalyzers", true, (item: any) => AnalyzerBase.fromJS(item));
        this.setProp("array", "AnalyzerBase[]", "simpleSearchAnalyzers", true, (item: any) => AnalyzerBase.fromJS(item));
        this.setProp("object", "boolean", "multiLine", false);
        this.setProp("array", "string[]", "requiredMetadataLanguages", false);
        this.setProp("object", "string", "template", false);
        this.setProp("object", "number", "boost", false);

        this._kind = "FieldTranslatedString";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldTranslatedString {
        return FieldTranslatedString.fromJS(data);
     }

    static fromJS(data: any): FieldTranslatedString {
        data = typeof data === 'object' ? data : {};
        let result = new FieldTranslatedString();
        result.init(data);
        return result;
    }

}

/** The field used to store a translated string values */
export interface IFieldTranslatedString extends IFieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's lenght. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory. */
    requiredMetadataLanguages?: string[] | undefined;
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template.
             */
    template?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
}

/** The field used to store a single relation */
export class FieldSingleRelation extends FieldBase implements IFieldSingleRelation {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Defines the allowed elation types. */
    relationTypes!: RelationType[];

    constructor(data?: IFieldSingleRelation) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "SchemaIndexingInfo", "schemaIndexingInfo", true, (item: any) => SchemaIndexingInfo.fromJS(item));
        this.setProp("array", "RelationType[]", "relationTypes", true, (item: any) => RelationType.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.relationTypes = [];
        }
        this._kind = "FieldSingleRelation";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldSingleRelation {
        return FieldSingleRelation.fromJS(data);
     }

    static fromJS(data: any): FieldSingleRelation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleRelation();
        result.init(data);
        return result;
    }

}

/** The field used to store a single relation */
export interface IFieldSingleRelation extends IFieldBase {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** Defines the allowed elation types. */
    relationTypes: IRelationType[];
}

/** Defines a relation */
export class RelationType extends DTOBase {
    /** The ID of the relation type. */
    id!: string;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines the type of the document target of the relation. Currently supported: Content, ListItem. */
    targetDocType!: string;
    /** An optional filter to limit the documents of type TargetDocType. */
    filter?: FilterBase | undefined;

    constructor(data?: IRelationType) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "targetDocType", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): RelationType {
        return RelationType.fromJS(data);
     }

    static fromJS(data: any): RelationType {
        data = typeof data === 'object' ? data : {};
        let result = new RelationType();
        result.init(data);
        return result;
    }

}

/** Defines a relation */
export interface IRelationType {
    /** The ID of the relation type. */
    id: string;
    /** Language specific relation names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Defines the type of the document target of the relation. Currently supported: Content, ListItem. */
    targetDocType: string;
    /** An optional filter to limit the documents of type TargetDocType. */
    filter?: FilterBase | undefined;
}

/** The field used to store multiple relations */
export class FieldMultiRelation extends FieldBase implements IFieldMultiRelation {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The relation types supported by the field. */
    relationTypes!: RelationType[];
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiRelation) {
        super(data);
        this.setProp("object", "string", "schemaId", false);
        this.setProp("object", "SchemaIndexingInfo", "schemaIndexingInfo", true, (item: any) => SchemaIndexingInfo.fromJS(item));
        this.setProp("array", "RelationType[]", "relationTypes", true, (item: any) => RelationType.fromJS(item));
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "number", "minimumItems", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.relationTypes = [];
        }
        this._kind = "FieldMultiRelation";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldMultiRelation {
        return FieldMultiRelation.fromJS(data);
     }

    static fromJS(data: any): FieldMultiRelation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiRelation();
        result.init(data);
        return result;
    }

}

/** The field used to store multiple relations */
export interface IFieldMultiRelation extends IFieldBase {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** The relation types supported by the field. */
    relationTypes: IRelationType[];
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** Base class to overwrite field's information */
export abstract class FieldOverwriteBase extends DTOBase {
    /** The field's ID whose information need to be overwritten. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not: this value will overwrite the existing Required value specified in the parent schema  if
OverwriteRequired is set to true. */
    required!: boolean;
    /** Enable the overwriting of the Required property of the field specified by the Id property. */
    overwriteRequired!: boolean;

    protected _kind: string;

    constructor(data?: IFieldOverwriteBase) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "boolean", "required", false);
        this.setProp("object", "boolean", "overwriteRequired", false);

        this._kind = "FieldOverwriteBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldOverwriteBase {
        return FieldOverwriteBase.fromJS(data);
     }

    static fromJS(data: any): FieldOverwriteBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldOverwriteSingleTagbox") {
            let result = new FieldOverwriteSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldOverwriteMultiTagbox") {
            let result = new FieldOverwriteMultiTagbox();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldOverwriteBase' cannot be instantiated.");
    }

}

/** Base class to overwrite field's information */
export interface IFieldOverwriteBase {
    /** The field's ID whose information need to be overwritten. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not: this value will overwrite the existing Required value specified in the parent schema  if
OverwriteRequired is set to true. */
    required: boolean;
    /** Enable the overwriting of the Required property of the field specified by the Id property. */
    overwriteRequired: boolean;
}

/** Overwritten information for FieldSingleTagbox */
export class FieldOverwriteSingleTagbox extends FieldOverwriteBase implements IFieldOverwriteSingleTagbox {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema  if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter!: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema  if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate!: boolean;

    constructor(data?: IFieldOverwriteSingleTagbox) {
        super(data);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "overwriteFilter", false);
        this.setProp("object", "string", "listItemCreateTemplate", false);
        this.setProp("object", "boolean", "overwriteListItemCreateTemplate", false);

        this._kind = "FieldOverwriteSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldOverwriteSingleTagbox {
        return FieldOverwriteSingleTagbox.fromJS(data);
     }

    static fromJS(data: any): FieldOverwriteSingleTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOverwriteSingleTagbox();
        result.init(data);
        return result;
    }

}

/** Overwritten information for FieldSingleTagbox */
export interface IFieldOverwriteSingleTagbox extends IFieldOverwriteBase {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema  if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema  if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate: boolean;
}

/** Overwritten information for FieldMultiTagbox */
export class FieldOverwriteMultiTagbox extends FieldOverwriteBase implements IFieldOverwriteMultiTagbox {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter!: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate!: boolean;
    /** The maximum number of items that can be stored: this value will overwrite the existing MaximumItems value specified in the parent schema if
OverwriteMaximumItems is set to true. */
    maximumItems?: number | undefined;
    /** Enable the overwriting of the MaximumItems property of the field specified by the Id property. */
    overwriteMaximumItems!: boolean;
    /** The minimum number of items that must be stored: this value will overwrite the existing MinimumItems value specified in the parent schema if
OverwriteMinimumItems is set to true. */
    minimumItems?: number | undefined;
    /** Enable the overwriting of the MinimumItems property of the field specified by the Id property. */
    overwriteMinimumItems!: boolean;

    constructor(data?: IFieldOverwriteMultiTagbox) {
        super(data);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "overwriteFilter", false);
        this.setProp("object", "string", "listItemCreateTemplate", false);
        this.setProp("object", "boolean", "overwriteListItemCreateTemplate", false);
        this.setProp("object", "number", "maximumItems", false);
        this.setProp("object", "boolean", "overwriteMaximumItems", false);
        this.setProp("object", "number", "minimumItems", false);
        this.setProp("object", "boolean", "overwriteMinimumItems", false);

        this._kind = "FieldOverwriteMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldOverwriteMultiTagbox {
        return FieldOverwriteMultiTagbox.fromJS(data);
     }

    static fromJS(data: any): FieldOverwriteMultiTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOverwriteMultiTagbox();
        result.init(data);
        return result;
    }

}

/** Overwritten information for FieldMultiTagbox */
export interface IFieldOverwriteMultiTagbox extends IFieldOverwriteBase {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate: boolean;
    /** The maximum number of items that can be stored: this value will overwrite the existing MaximumItems value specified in the parent schema if
OverwriteMaximumItems is set to true. */
    maximumItems?: number | undefined;
    /** Enable the overwriting of the MaximumItems property of the field specified by the Id property. */
    overwriteMaximumItems: boolean;
    /** The minimum number of items that must be stored: this value will overwrite the existing MinimumItems value specified in the parent schema if
OverwriteMinimumItems is set to true. */
    minimumItems?: number | undefined;
    /** Enable the overwriting of the MinimumItems property of the field specified by the Id property. */
    overwriteMinimumItems: boolean;
}

/** Count information of fields in the search index for filtering, searching and sorting */
export class SearchFieldCount extends DTOBase {
    /** The number of fields created in the search index to store filter information for a schema. */
    indexedField!: number;
    /** The number of fields created in the search index to store search information for a schema. */
    simpleSearchField!: number;
    /** The number of fields created in the search index to store sorting information for a schema. */
    sortableField!: number;

    constructor(data?: ISearchFieldCount) {
        super(data);
        this.setProp("object", "number", "indexedField", false);
        this.setProp("object", "number", "simpleSearchField", false);
        this.setProp("object", "number", "sortableField", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchFieldCount {
        return SearchFieldCount.fromJS(data);
     }

    static fromJS(data: any): SearchFieldCount {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFieldCount();
        result.init(data);
        return result;
    }

}

/** Count information of fields in the search index for filtering, searching and sorting */
export interface ISearchFieldCount {
    /** The number of fields created in the search index to store filter information for a schema. */
    indexedField: number;
    /** The number of fields created in the search index to store search information for a schema. */
    simpleSearchField: number;
    /** The number of fields created in the search index to store sorting information for a schema. */
    sortableField: number;
}

export class BaseResultOfSchema extends DTOBase {
    totalResults!: number;
    results!: Schema[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfSchema) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "Schema[]", "results", true, (item: any) => Schema.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfSchema {
        return BaseResultOfSchema.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfSchema();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfSchema {
    totalResults: number;
    results: ISchema[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfSchema extends BaseResultOfSchema implements ISearchBehaviorBaseResultOfSchema {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfSchema) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfSchema {
        return SearchBehaviorBaseResultOfSchema.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfSchema();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfSchema extends IBaseResultOfSchema {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result for schema search operation */
export class SchemaSearchResult extends SearchBehaviorBaseResultOfSchema implements ISchemaSearchResult {

    constructor(data?: ISchemaSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaSearchResult {
        return SchemaSearchResult.fromJS(data);
     }

    static fromJS(data: any): SchemaSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSearchResult();
        result.init(data);
        return result;
    }

}

/** Result for schema search operation */
export interface ISchemaSearchResult extends ISearchBehaviorBaseResultOfSchema {
}

/** A schema */
export class Schema extends DTOBase {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount!: number;
    /** The count of all schema descendants with an immediate inheritance. */
    childCount!: number;
    /** The descendant depth of the schema. */
    level!: number;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system!: boolean;

    constructor(data?: ISchema) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "parentSchemaId", false);
        this.setProp("array", "SchemaType[]", "types", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "descriptions", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "number", "fieldCount", false);
        this.setProp("object", "number", "childCount", false);
        this.setProp("object", "number", "level", false);
        this.setProp("object", "boolean", "system", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Schema {
        return Schema.fromJS(data);
     }

    static fromJS(data: any): Schema {
        data = typeof data === 'object' ? data : {};
        let result = new Schema();
        result.init(data);
        return result;
    }

}

/** A schema */
export interface ISchema {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with an immediate inheritance. */
    childCount: number;
    /** The descendant depth of the schema. */
    level: number;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system: boolean;
}

/** Request to search schemas */
export class SchemaSearchRequest extends DTOBase {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Currently only sorting on the Names property is allowed. */
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the schemas. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the SchemaSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the schemas to the ones the user has the specified MetadataRights. */
    rightsFilter?: MetadataRight[] | undefined;

    constructor(data?: ISchemaSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "debugMode", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("array", "MetadataRight[]", "rightsFilter", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaSearchRequest {
        return SchemaSearchRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search schemas */
export interface ISchemaSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Currently only sorting on the Names property is allowed. */
    sort?: ISortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the schemas. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the SchemaSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the schemas to the ones the user has the specified MetadataRights. */
    rightsFilter?: MetadataRight[] | undefined;
}

/** Contains compiled field information. */
export class IndexField extends DTOBase {
    id?: string | undefined;
    /** The field id. */
    fieldId?: string | undefined;
    /** The field's type name. */
    type?: string | undefined;
    /** Contains all index field name variants of the field. */
    indexFields?: { [key in keyof typeof Analyzer] : string; } | undefined;
    /** Contains all simple search field name variants of the field.
The amount of simple search fields can be equal or less to the amount of IndexFields, but never more. */
    simpleSearchFields?: { [key in keyof typeof Analyzer] : string; } | undefined;
    /** Contains the fields boost value. */
    boost!: number;
    /** Not to be returned for search query, but only used for mapping purposes */
    ignoreForSearch!: boolean;
    /** The path of the Nested document this property belongs to. If set to null, it means that there is no Nested document */
    nestedPath?: string | undefined;
    /** Path to the sorting information in the DataSortValuesField sort index. */
    sortField?: string | undefined;

    constructor(data?: IIndexField) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "fieldId", false);
        this.setProp("object", "string", "type", false);
        this.setProp("dictionary", "{ [key in keyof typeof Analyzer] : string; }", "indexFields", false);
        this.setProp("dictionary", "{ [key in keyof typeof Analyzer] : string; }", "simpleSearchFields", false);
        this.setProp("object", "number", "boost", false);
        this.setProp("object", "boolean", "ignoreForSearch", false);
        this.setProp("object", "string", "nestedPath", false);
        this.setProp("object", "string", "sortField", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IndexField {
        return IndexField.fromJS(data);
     }

    static fromJS(data: any): IndexField {
        data = typeof data === 'object' ? data : {};
        let result = new IndexField();
        result.init(data);
        return result;
    }

}

/** Contains compiled field information. */
export interface IIndexField {
    id?: string | undefined;
    /** The field id. */
    fieldId?: string | undefined;
    /** The field's type name. */
    type?: string | undefined;
    /** Contains all index field name variants of the field. */
    indexFields?: { [key in keyof typeof Analyzer] : string; } | undefined;
    /** Contains all simple search field name variants of the field.
The amount of simple search fields can be equal or less to the amount of IndexFields, but never more. */
    simpleSearchFields?: { [key in keyof typeof Analyzer] : string; } | undefined;
    /** Contains the fields boost value. */
    boost: number;
    /** Not to be returned for search query, but only used for mapping purposes */
    ignoreForSearch: boolean;
    /** The path of the Nested document this property belongs to. If set to null, it means that there is no Nested document */
    nestedPath?: string | undefined;
    /** Path to the sorting information in the DataSortValuesField sort index. */
    sortField?: string | undefined;
}

/** Request to search indexed fields of specific schemas */
export class IndexFieldsSearchBySchemaIdsRequest extends DTOBase {
    /** The IDs of the schemas for which the indexed fields should be returned. */
    schemaIds?: string[] | undefined;
    /** Controls how the search works which schemas should be considered in the search.
AllDescendantsFieldsOnRootSchema: All indexed fields from descendant schemas of root ones will be returned. Schemas that are not root schemas will be ignored.
SchemaAndParentFieldsOnly: Indexed fields of the requested schema and its parents will be returned. */
    searchMode!: IndexFieldsSearchMode;

    constructor(data?: IIndexFieldsSearchBySchemaIdsRequest) {
        super(data);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("object", "IndexFieldsSearchMode", "searchMode", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): IndexFieldsSearchBySchemaIdsRequest {
        return IndexFieldsSearchBySchemaIdsRequest.fromJS(data);
     }

    static fromJS(data: any): IndexFieldsSearchBySchemaIdsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IndexFieldsSearchBySchemaIdsRequest();
        result.init(data);
        return result;
    }

}

/** Request to search indexed fields of specific schemas */
export interface IIndexFieldsSearchBySchemaIdsRequest {
    /** The IDs of the schemas for which the indexed fields should be returned. */
    schemaIds?: string[] | undefined;
    /** Controls how the search works which schemas should be considered in the search.
AllDescendantsFieldsOnRootSchema: All indexed fields from descendant schemas of root ones will be returned. Schemas that are not root schemas will be ignored.
SchemaAndParentFieldsOnly: Indexed fields of the requested schema and its parents will be returned. */
    searchMode: IndexFieldsSearchMode;
}

/** How the index field search works */
export enum IndexFieldsSearchMode {
    AllDescendantsFieldsOnRootSchema = "AllDescendantsFieldsOnRootSchema",
    SchemaAndParentFieldsOnly = "SchemaAndParentFieldsOnly",
}

/** Exists response */
export class SchemaExistsResponse extends DTOBase {
    /** It indicates if it exists. */
    exists!: boolean;

    constructor(data?: ISchemaExistsResponse) {
        super(data);
        this.setProp("object", "boolean", "exists", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaExistsResponse {
        return SchemaExistsResponse.fromJS(data);
     }

    static fromJS(data: any): SchemaExistsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaExistsResponse();
        result.init(data);
        return result;
    }

}

/** Exists response */
export interface ISchemaExistsResponse {
    /** It indicates if it exists. */
    exists: boolean;
}

/** Response for a query if a field exists */
export class FieldExistsResponse extends DTOBase {
    /** Indicates if a field with the specified ID currently exists. */
    exists!: boolean;
    /** Indicates if a field with the specified ID was previously used.
A field ID that was previously in use cannot be used again. */
    previouslyUsed!: boolean;
    /** If the field does already exist or has already existed, this will contain the ID
of the schema containing it. It case of parent-child schemas, a field ID
has to be unique across the schema hierarchy. */
    schemaId?: string | undefined;

    constructor(data?: IFieldExistsResponse) {
        super(data);
        this.setProp("object", "boolean", "exists", false);
        this.setProp("object", "boolean", "previouslyUsed", false);
        this.setProp("object", "string", "schemaId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FieldExistsResponse {
        return FieldExistsResponse.fromJS(data);
     }

    static fromJS(data: any): FieldExistsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FieldExistsResponse();
        result.init(data);
        return result;
    }

}

/** Response for a query if a field exists */
export interface IFieldExistsResponse {
    /** Indicates if a field with the specified ID currently exists. */
    exists: boolean;
    /** Indicates if a field with the specified ID was previously used.
A field ID that was previously in use cannot be used again. */
    previouslyUsed: boolean;
    /** If the field does already exist or has already existed, this will contain the ID
of the schema containing it. It case of parent-child schemas, a field ID
has to be unique across the schema hierarchy. */
    schemaId?: string | undefined;
}

export class SchemaOwnershipTransferRequest extends DTOBase {
    /** The id of the user to whom the schema has to be transfered to. */
    transferUserId?: string | undefined;

    constructor(data?: ISchemaOwnershipTransferRequest) {
        super(data);
        this.setProp("object", "string", "transferUserId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaOwnershipTransferRequest {
        return SchemaOwnershipTransferRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaOwnershipTransferRequest();
        result.init(data);
        return result;
    }

}

export interface ISchemaOwnershipTransferRequest {
    /** The id of the user to whom the schema has to be transfered to. */
    transferUserId?: string | undefined;
}

/** Result of a schema create operation */
export class SchemaCreateResult extends DTOBase {
    /** The details of the created schema. */
    schema?: SchemaDetail | undefined;

    constructor(data?: ISchemaCreateResult) {
        super(data);
        this.setProp("object", "SchemaDetail", "schema", true, (item: any) => SchemaDetail.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaCreateResult {
        return SchemaCreateResult.fromJS(data);
     }

    static fromJS(data: any): SchemaCreateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateResult();
        result.init(data);
        return result;
    }

}

/** Result of a schema create operation */
export interface ISchemaCreateResult {
    /** The details of the created schema. */
    schema?: ISchemaDetail | undefined;
}

/** Request to create a schema */
export class SchemaCreateRequest extends DTOBase {
    /** The schema ID. It can be a slug, but must be unique throughout the whole customer setup. */
    id!: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns!: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll!: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaCreateRequest) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "parentSchemaId", false);
        this.setProp("array", "SchemaType[]", "types", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "descriptions", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "DisplayPattern[]", "displayPatterns", true, (item: any) => DisplayPattern.fromJS(item));
        this.setProp("array", "FieldBase[]", "fields", true, (item: any) => FieldBase.fromJS(item));
        this.setProp("array", "FieldOverwriteBase[]", "fieldsOverwrite", true, (item: any) => FieldOverwriteBase.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregations", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "boolean", "viewForAll", false);
        this.setProp("array", "string[]", "schemaPermissionSetIds", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("array", "string[]", "referencedInContentSchemaIds", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.displayPatterns = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaCreateRequest {
        return SchemaCreateRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateRequest();
        result.init(data);
        return result;
    }

}

/** Request to create a schema */
export interface ISchemaCreateRequest {
    /** The schema ID. It can be a slug, but must be unique throughout the whole customer setup. */
    id: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns: IDisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: ISortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

/** Request to create multiple schemas */
export class SchemaCreateManyRequest extends DTOBase {
    /** The schemas to create. Cyclic dependencies between schemas are supported, if the
are all in the same request. */
    schemas!: SchemaCreateRequest[];

    constructor(data?: ISchemaCreateManyRequest) {
        super(data);
        this.setProp("array", "SchemaCreateRequest[]", "schemas", true, (item: any) => SchemaCreateRequest.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.schemas = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaCreateManyRequest {
        return SchemaCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to create multiple schemas */
export interface ISchemaCreateManyRequest {
    /** The schemas to create. Cyclic dependencies between schemas are supported, if the
are all in the same request. */
    schemas: ISchemaCreateRequest[];
}

/** Result of a schema update operation */
export class SchemaUpdateResult extends DTOBase {
    /** The details of the updated schema. */
    schema?: SchemaDetail | undefined;

    constructor(data?: ISchemaUpdateResult) {
        super(data);
        this.setProp("object", "SchemaDetail", "schema", true, (item: any) => SchemaDetail.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaUpdateResult {
        return SchemaUpdateResult.fromJS(data);
     }

    static fromJS(data: any): SchemaUpdateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateResult();
        result.init(data);
        return result;
    }

}

/** Result of a schema update operation */
export interface ISchemaUpdateResult {
    /** The details of the updated schema. */
    schema?: ISchemaDetail | undefined;
}

/** Request to update an existing schema */
export class SchemaUpdateRequest extends DTOBase {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll!: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaUpdateRequest) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "descriptions", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "DisplayPattern[]", "displayPatterns", true, (item: any) => DisplayPattern.fromJS(item));
        this.setProp("array", "FieldBase[]", "fields", true, (item: any) => FieldBase.fromJS(item));
        this.setProp("array", "FieldOverwriteBase[]", "fieldsOverwrite", true, (item: any) => FieldOverwriteBase.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregations", true, (item: any) => AggregatorBase.fromJS(item));
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "boolean", "viewForAll", false);
        this.setProp("array", "string[]", "schemaPermissionSetIds", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("array", "string[]", "referencedInContentSchemaIds", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaUpdateRequest {
        return SchemaUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update an existing schema */
export interface ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: ISortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

/** Result of a schema delete operation */
export class SchemaDeleteResult extends DTOBase {

    constructor(data?: ISchemaDeleteResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaDeleteResult {
        return SchemaDeleteResult.fromJS(data);
     }

    static fromJS(data: any): SchemaDeleteResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaDeleteResult();
        result.init(data);
        return result;
    }

}

/** Result of a schema delete operation */
export interface ISchemaDeleteResult {
}

export class SchemaOwnershipTransferManyRequest extends DTOBase {
    /** The schema ids. */
    schemaIds?: string[] | undefined;
    /** The id of user to whom the schemas have to be transfered to. */
    transferUserId?: string | undefined;

    constructor(data?: ISchemaOwnershipTransferManyRequest) {
        super(data);
        this.setProp("array", "string[]", "schemaIds", false);
        this.setProp("object", "string", "transferUserId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaOwnershipTransferManyRequest {
        return SchemaOwnershipTransferManyRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

}

export interface ISchemaOwnershipTransferManyRequest {
    /** The schema ids. */
    schemaIds?: string[] | undefined;
    /** The id of user to whom the schemas have to be transfered to. */
    transferUserId?: string | undefined;
}

export abstract class PermissionSetDetailOfMetadataRight extends DTOBase {
    id!: string;
    names?: TranslatedStringDictionary | undefined;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive!: boolean;
    ownerTokenId!: string;

    constructor(data?: IPermissionSetDetailOfMetadataRight) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "PermissionUserRoleRightsOfMetadataRight[]", "userRolesRights", true, (item: any) => PermissionUserRoleRightsOfMetadataRight.fromJS(item));
        this.setProp("array", "PermissionUserRoleRightsOfPermissionSetRight[]", "userRolesPermissionSetRights", true, (item: any) => PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
        this.setProp("object", "boolean", "exclusive", false);
        this.setProp("object", "string", "ownerTokenId", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetDetailOfMetadataRight {
        return PermissionSetDetailOfMetadataRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetDetailOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetDetailOfMetadataRight' cannot be instantiated.");
    }

}

export interface IPermissionSetDetailOfMetadataRight {
    id: string;
    names?: ITranslatedStringDictionary | undefined;
    userRolesRights?: IPermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
    ownerTokenId: string;
}

/** Detail of a schema permission set */
export class SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight implements ISchemaPermissionSetDetail {

    constructor(data?: ISchemaPermissionSetDetail) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionSetDetail {
        return SchemaPermissionSetDetail.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionSetDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetDetail();
        result.init(data);
        return result;
    }

}

/** Detail of a schema permission set */
export interface ISchemaPermissionSetDetail extends IPermissionSetDetailOfMetadataRight {
}

export class PermissionUserRoleRightsOfMetadataRight extends DTOBase {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfMetadataRight) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "MetadataRight[]", "rights", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionUserRoleRightsOfMetadataRight {
        return PermissionUserRoleRightsOfMetadataRight.fromJS(data);
     }

    static fromJS(data: any): PermissionUserRoleRightsOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

}

export interface IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;
}

export abstract class PermissionSetCreateRequestOfMetadataRight extends DTOBase {
    names?: TranslatedStringDictionary | undefined;
    userRolesRights?: UserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive!: boolean;
    requestId?: string | undefined;

    constructor(data?: IPermissionSetCreateRequestOfMetadataRight) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "UserRoleRightsOfMetadataRight[]", "userRolesRights", true, (item: any) => UserRoleRightsOfMetadataRight.fromJS(item));
        this.setProp("array", "UserRoleRightsOfPermissionSetRight[]", "userRolesPermissionSetRights", true, (item: any) => UserRoleRightsOfPermissionSetRight.fromJS(item));
        this.setProp("object", "boolean", "exclusive", false);
        this.setProp("object", "string", "requestId", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetCreateRequestOfMetadataRight {
        return PermissionSetCreateRequestOfMetadataRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetCreateRequestOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetCreateRequestOfMetadataRight' cannot be instantiated.");
    }

}

export interface IPermissionSetCreateRequestOfMetadataRight {
    names?: ITranslatedStringDictionary | undefined;
    userRolesRights?: IUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
    requestId?: string | undefined;
}

export class SchemaPermissionSetCreateRequest extends PermissionSetCreateRequestOfMetadataRight implements ISchemaPermissionSetCreateRequest {

    constructor(data?: ISchemaPermissionSetCreateRequest) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionSetCreateRequest {
        return SchemaPermissionSetCreateRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionSetCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetCreateRequest();
        result.init(data);
        return result;
    }

}

export interface ISchemaPermissionSetCreateRequest extends IPermissionSetCreateRequestOfMetadataRight {
}

export class UserRoleRightsOfMetadataRight extends DTOBase {
    userRoleId?: string | undefined;
    rights?: MetadataRight[] | undefined;

    constructor(data?: IUserRoleRightsOfMetadataRight) {
        super(data);
        this.setProp("object", "string", "userRoleId", false);
        this.setProp("array", "MetadataRight[]", "rights", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleRightsOfMetadataRight {
        return UserRoleRightsOfMetadataRight.fromJS(data);
     }

    static fromJS(data: any): UserRoleRightsOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

}

export interface IUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    rights?: MetadataRight[] | undefined;
}

export abstract class PermissionSetUpdateRequestOfMetadataRight extends DTOBase {
    names?: TranslatedStringDictionary | undefined;
    userRolesRights?: UserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;

    constructor(data?: IPermissionSetUpdateRequestOfMetadataRight) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "UserRoleRightsOfMetadataRight[]", "userRolesRights", true, (item: any) => UserRoleRightsOfMetadataRight.fromJS(item));
        this.setProp("array", "UserRoleRightsOfPermissionSetRight[]", "userRolesPermissionSetRights", true, (item: any) => UserRoleRightsOfPermissionSetRight.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetUpdateRequestOfMetadataRight {
        return PermissionSetUpdateRequestOfMetadataRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetUpdateRequestOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestOfMetadataRight' cannot be instantiated.");
    }

}

export interface IPermissionSetUpdateRequestOfMetadataRight {
    names?: ITranslatedStringDictionary | undefined;
    userRolesRights?: IUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
}

/** Request to update a schema permission set */
export class SchemaPermissionSetUpdateRequest extends PermissionSetUpdateRequestOfMetadataRight implements ISchemaPermissionSetUpdateRequest {

    constructor(data?: ISchemaPermissionSetUpdateRequest) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionSetUpdateRequest {
        return SchemaPermissionSetUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionSetUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Request to update a schema permission set */
export interface ISchemaPermissionSetUpdateRequest extends IPermissionSetUpdateRequestOfMetadataRight {
}

export class SchemaPermissionSetCreateManyRequest extends DTOBase {
    items?: SchemaPermissionSetCreateRequest[] | undefined;

    constructor(data?: ISchemaPermissionSetCreateManyRequest) {
        super(data);
        this.setProp("array", "SchemaPermissionSetCreateRequest[]", "items", true, (item: any) => SchemaPermissionSetCreateRequest.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionSetCreateManyRequest {
        return SchemaPermissionSetCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionSetCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetCreateManyRequest();
        result.init(data);
        return result;
    }

}

export interface ISchemaPermissionSetCreateManyRequest {
    items?: SchemaPermissionSetCreateRequest[] | undefined;
}

/** Request to update multiple schema permissions sets */
export class SchemaPermissionSetUpdateManyRequest extends DTOBase {
    /** Schema permission sets update requests. */
    items?: SchemaPermissionSetUpdateRequestItem[] | undefined;

    constructor(data?: ISchemaPermissionSetUpdateManyRequest) {
        super(data);
        this.setProp("array", "SchemaPermissionSetUpdateRequestItem[]", "items", true, (item: any) => SchemaPermissionSetUpdateRequestItem.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionSetUpdateManyRequest {
        return SchemaPermissionSetUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionSetUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** Request to update multiple schema permissions sets */
export interface ISchemaPermissionSetUpdateManyRequest {
    /** Schema permission sets update requests. */
    items?: SchemaPermissionSetUpdateRequestItem[] | undefined;
}

export abstract class PermissionSetUpdateRequestItemOfMetadataRight extends PermissionSetUpdateRequestOfMetadataRight implements IPermissionSetUpdateRequestItemOfMetadataRight {
    id!: string;

    constructor(data?: IPermissionSetUpdateRequestItemOfMetadataRight) {
        super(data);
        this.setProp("object", "string", "id", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): PermissionSetUpdateRequestItemOfMetadataRight {
        return PermissionSetUpdateRequestItemOfMetadataRight.fromJS(data);
     }

    static fromJS(data: any): PermissionSetUpdateRequestItemOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestItemOfMetadataRight' cannot be instantiated.");
    }

}

export interface IPermissionSetUpdateRequestItemOfMetadataRight extends IPermissionSetUpdateRequestOfMetadataRight {
    id: string;
}

/** Request to update a schema permission set */
export class SchemaPermissionSetUpdateRequestItem extends PermissionSetUpdateRequestItemOfMetadataRight implements ISchemaPermissionSetUpdateRequestItem {

    constructor(data?: ISchemaPermissionSetUpdateRequestItem) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaPermissionSetUpdateRequestItem {
        return SchemaPermissionSetUpdateRequestItem.fromJS(data);
     }

    static fromJS(data: any): SchemaPermissionSetUpdateRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetUpdateRequestItem();
        result.init(data);
        return result;
    }

}

/** Request to update a schema permission set */
export interface ISchemaPermissionSetUpdateRequestItem extends IPermissionSetUpdateRequestItemOfMetadataRight {
}

/** Represents a transfer. */
export class Transfer extends DTOBase {
    /** ID of transfer. */
    id!: string;
    /** Name of transfer. */
    name!: string;
    /** State of transfer. */
    state!: TransferState;
    /** Type of transfer. */
    transferType!: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string | undefined;
    /** Number of files in transfer. */
    fileTransferCount!: number;
    /** ID of collection created from transfer. */
    collectionId?: string | undefined;

    constructor(data?: ITransfer) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "TransferState", "state", false);
        this.setProp("object", "TransferType", "transferType", false);
        this.setProp("object", "string", "businessProcessId", false);
        this.setProp("object", "number", "fileTransferCount", false);
        this.setProp("object", "string", "collectionId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Transfer {
        return Transfer.fromJS(data);
     }

    static fromJS(data: any): Transfer {
        data = typeof data === 'object' ? data : {};
        let result = new Transfer();
        result.init(data);
        return result;
    }

}

/** Represents a transfer. */
export interface ITransfer {
    /** ID of transfer. */
    id: string;
    /** Name of transfer. */
    name: string;
    /** State of transfer. */
    state: TransferState;
    /** Type of transfer. */
    transferType: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string | undefined;
    /** Number of files in transfer. */
    fileTransferCount: number;
    /** ID of collection created from transfer. */
    collectionId?: string | undefined;
}

/** Request to import schemas and list items */
export class SchemaImportRequest extends DTOBase {
    /** ID of the file transfer identifying the file previously uploaded. */
    fileTransferId!: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Import the list items belonging to the schema. */
    importListItems!: boolean;

    constructor(data?: ISchemaImportRequest) {
        super(data);
        this.setProp("object", "string", "fileTransferId", false);
        this.setProp("object", "boolean", "allowMissingDependencies", false);
        this.setProp("object", "boolean", "importListItems", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SchemaImportRequest {
        return SchemaImportRequest.fromJS(data);
     }

    static fromJS(data: any): SchemaImportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportRequest();
        result.init(data);
        return result;
    }

}

/** Request to import schemas and list items */
export interface ISchemaImportRequest {
    /** ID of the file transfer identifying the file previously uploaded. */
    fileTransferId: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Import the list items belonging to the schema. */
    importListItems: boolean;
}

/** Share detail */
export class ShareDetail extends DTOBase {
    /** Share ID. */
    id!: string;
    /** Name of share. */
    name!: string;
    /** Description of share entered by user. */
    description?: string | undefined;
    /** Creator of share. */
    creator!: ShareUser;
    /** Audit information. */
    audit!: UserAudit;
    /** Detailed information about contents in the share. */
    contentSelections!: ShareContentDetail[];
    /** List of shared layers. */
    layerSchemaIds?: string[] | undefined;
    /** Detail of share. */
    data?: ShareDataBase | undefined;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Info if share is already expired. */
    expired!: boolean;
    /** Configuration for template to use on the share detail page. */
    template?: TemplateBase | undefined;
    /** Defined access for contents in share. */
    outputAccess!: OutputAccess;
    /** Type of share. */
    shareType!: ShareType;

    constructor(data?: IShareDetail) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "string", "description", false);
        this.setProp("object", "ShareUser", "creator", true, (item: any) => ShareUser.fromJS(item));
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("array", "ShareContentDetail[]", "contentSelections", true, (item: any) => ShareContentDetail.fromJS(item));
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "ShareDataBase", "data", true, (item: any) => ShareDataBase.fromJS(item));
        this.setProp("object", "Date", "expirationDate", false);
        this.setProp("object", "boolean", "expired", false);
        this.setProp("object", "TemplateBase", "template", true, (item: any) => TemplateBase.fromJS(item));
        this.setProp("object", "OutputAccess", "outputAccess", false);
        this.setProp("object", "ShareType", "shareType", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.creator = new ShareUser();
            this.audit = new UserAudit();
            this.contentSelections = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareDetail {
        return ShareDetail.fromJS(data);
     }

    static fromJS(data: any): ShareDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDetail();
        result.init(data);
        return result;
    }

}

/** Share detail */
export interface IShareDetail {
    /** Share ID. */
    id: string;
    /** Name of share. */
    name: string;
    /** Description of share entered by user. */
    description?: string | undefined;
    /** Creator of share. */
    creator: IShareUser;
    /** Audit information. */
    audit: IUserAudit;
    /** Detailed information about contents in the share. */
    contentSelections: IShareContentDetail[];
    /** List of shared layers. */
    layerSchemaIds?: string[] | undefined;
    /** Detail of share. */
    data?: ShareDataBase | undefined;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Info if share is already expired. */
    expired: boolean;
    /** Configuration for template to use on the share detail page. */
    template?: TemplateBase | undefined;
    /** Defined access for contents in share. */
    outputAccess: OutputAccess;
    /** Type of share. */
    shareType: ShareType;
}

/** Reduced set of user information used for shares */
export class ShareUser extends DTOBase {
    /** Name of user */
    displayName!: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash!: string;

    constructor(data?: IShareUser) {
        super(data);
        this.setProp("object", "string", "displayName", false);
        this.setProp("object", "string", "emailHash", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareUser {
        return ShareUser.fromJS(data);
     }

    static fromJS(data: any): ShareUser {
        data = typeof data === 'object' ? data : {};
        let result = new ShareUser();
        result.init(data);
        return result;
    }

}

/** Reduced set of user information used for shares */
export interface IShareUser {
    /** Name of user */
    displayName: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash: string;
}

/** Detail of shared content */
export class ShareContentDetail extends DTOBase {
    /** The id of the schema with schema type content. */
    contentSchemaId!: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data. */
    content!: DataDictionary;
    /** The metadata dictionary. */
    metadata?: DataDictionary | undefined;
    /** Content ID. */
    id!: string;
    /** List of shared outputs for this content. */
    outputs!: ShareOutputBase[];
    /** The type of content */
    contentType!: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues!: DisplayValueDictionary;
    /** Contains an URL that can be used to retrieve the icon corresponding to the file type. */
    iconUrl?: string | undefined;

    constructor(data?: IShareContentDetail) {
        super(data);
        this.setProp("object", "string", "contentSchemaId", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "DataDictionary", "content", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("object", "DataDictionary", "metadata", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("object", "string", "id", false);
        this.setProp("array", "ShareOutputBase[]", "outputs", true, (item: any) => ShareOutputBase.fromJS(item));
        this.setProp("object", "ContentType", "contentType", false);
        this.setProp("object", "DisplayValueDictionary", "displayValues", true, (item: any) => DisplayValueDictionary.fromJS(item));
        this.setProp("object", "string", "iconUrl", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.content = new DataDictionary();
            this.outputs = [];
            this.displayValues = new DisplayValueDictionary();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareContentDetail {
        return ShareContentDetail.fromJS(data);
     }

    static fromJS(data: any): ShareContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContentDetail();
        result.init(data);
        return result;
    }

}

/** Detail of shared content */
export interface IShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data. */
    content: IDataDictionary;
    /** The metadata dictionary. */
    metadata?: IDataDictionary | undefined;
    /** Content ID. */
    id: string;
    /** List of shared outputs for this content. */
    outputs: ShareOutputBase[];
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues: IDisplayValueDictionary;
    /** Contains an URL that can be used to retrieve the icon corresponding to the file type. */
    iconUrl?: string | undefined;
}

/** Base of shared output */
export abstract class ShareOutputBase extends DTOBase {
    /** Content ID. */
    contentId!: string;
    /** Output format ID. */
    outputFormatId!: string;
    /** Url to directly view output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    viewUrl?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    downloadUrl?: string | undefined;
    /** Output details. */
    detail?: OutputDataBase | undefined;

    protected _kind: string;

    constructor(data?: IShareOutputBase) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("object", "string", "outputFormatId", false);
        this.setProp("object", "string", "viewUrl", false);
        this.setProp("object", "string", "downloadUrl", false);
        this.setProp("object", "OutputDataBase", "detail", true, (item: any) => OutputDataBase.fromJS(item));

        this._kind = "ShareOutputBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareOutputBase {
        return ShareOutputBase.fromJS(data);
     }

    static fromJS(data: any): ShareOutputBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareOutputBasic") {
            let result = new ShareOutputBasic();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputEmbed") {
            let result = new ShareOutputEmbed();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareOutputBase' cannot be instantiated.");
    }

}

/** Base of shared output */
export interface IShareOutputBase {
    /** Content ID. */
    contentId: string;
    /** Output format ID. */
    outputFormatId: string;
    /** Url to directly view output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    viewUrl?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    downloadUrl?: string | undefined;
    /** Output details. */
    detail?: OutputDataBase | undefined;
}

/** Shared output for basic share */
export class ShareOutputBasic extends ShareOutputBase implements IShareOutputBasic {

    constructor(data?: IShareOutputBasic) {
        super(data);

        this._kind = "ShareOutputBasic";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareOutputBasic {
        return ShareOutputBasic.fromJS(data);
     }

    static fromJS(data: any): ShareOutputBasic {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputBasic();
        result.init(data);
        return result;
    }

}

/** Shared output for basic share */
export interface IShareOutputBasic extends IShareOutputBase {
}

/** Shared output for embed share */
export class ShareOutputEmbed extends ShareOutputBase implements IShareOutputEmbed {
    /** Share token for the shared output. */
    token?: string | undefined;

    constructor(data?: IShareOutputEmbed) {
        super(data);
        this.setProp("object", "string", "token", false);

        this._kind = "ShareOutputEmbed";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareOutputEmbed {
        return ShareOutputEmbed.fromJS(data);
     }

    static fromJS(data: any): ShareOutputEmbed {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputEmbed();
        result.init(data);
        return result;
    }

}

/** Shared output for embed share */
export interface IShareOutputEmbed extends IShareOutputBase {
    /** Share token for the shared output. */
    token?: string | undefined;
}

/** Base of share data */
export abstract class ShareDataBase extends DTOBase {
    /** The URL to access the share. */
    url!: string;

    protected _kind: string;

    constructor(data?: IShareDataBase) {
        super(data);
        this.setProp("object", "string", "url", false);

        this._kind = "ShareDataBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareDataBase {
        return ShareDataBase.fromJS(data);
     }

    static fromJS(data: any): ShareDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareDataEmbed") {
            let result = new ShareDataEmbed();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareDataBasic") {
            let result = new ShareDataBasic();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareDataBase' cannot be instantiated.");
    }

}

/** Base of share data */
export interface IShareDataBase {
    /** The URL to access the share. */
    url: string;
}

/** Embed share data */
export class ShareDataEmbed extends ShareDataBase implements IShareDataEmbed {
    /** Token for the embed share. */
    token!: string;

    constructor(data?: IShareDataEmbed) {
        super(data);
        this.setProp("object", "string", "token", false);

        this._kind = "ShareDataEmbed";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareDataEmbed {
        return ShareDataEmbed.fromJS(data);
     }

    static fromJS(data: any): ShareDataEmbed {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDataEmbed();
        result.init(data);
        return result;
    }

}

/** Embed share data */
export interface IShareDataEmbed extends IShareDataBase {
    /** Token for the embed share. */
    token: string;
}

/** Basic share data */
export class ShareDataBasic extends ShareDataBase implements IShareDataBasic {
    /** List of recipients added using email address */
    mailRecipients!: MailRecipient[];
    /** List of recipients that exist in Picturepark. */
    internalRecipients!: InternalRecipient[];
    /** Language of share. */
    languageCode?: string | undefined;

    constructor(data?: IShareDataBasic) {
        super(data);
        this.setProp("array", "MailRecipient[]", "mailRecipients", true, (item: any) => MailRecipient.fromJS(item));
        this.setProp("array", "InternalRecipient[]", "internalRecipients", true, (item: any) => InternalRecipient.fromJS(item));
        this.setProp("object", "string", "languageCode", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.mailRecipients = [];
            this.internalRecipients = [];
        }
        this._kind = "ShareDataBasic";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareDataBasic {
        return ShareDataBasic.fromJS(data);
     }

    static fromJS(data: any): ShareDataBasic {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDataBasic();
        result.init(data);
        return result;
    }

}

/** Basic share data */
export interface IShareDataBasic extends IShareDataBase {
    /** List of recipients added using email address */
    mailRecipients: IMailRecipient[];
    /** List of recipients that exist in Picturepark. */
    internalRecipients: IInternalRecipient[];
    /** Language of share. */
    languageCode?: string | undefined;
}

/** Share mail recipient */
export class MailRecipient extends DTOBase {
    /** User information including email. */
    userEmail!: UserEmail;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;

    constructor(data?: IMailRecipient) {
        super(data);
        this.setProp("object", "UserEmail", "userEmail", true, (item: any) => UserEmail.fromJS(item));
        this.setProp("object", "string", "token", false);
        this.setProp("object", "string", "url", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.userEmail = new UserEmail();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): MailRecipient {
        return MailRecipient.fromJS(data);
     }

    static fromJS(data: any): MailRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new MailRecipient();
        result.init(data);
        return result;
    }

}

/** Share mail recipient */
export interface IMailRecipient {
    /** User information including email. */
    userEmail: IUserEmail;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;
}

export class UserEmail extends DTOBase {
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Email address */
    emailAddress!: string;

    constructor(data?: IUserEmail) {
        super(data);
        this.setProp("object", "string", "firstName", false);
        this.setProp("object", "string", "lastName", false);
        this.setProp("object", "string", "emailAddress", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserEmail {
        return UserEmail.fromJS(data);
     }

    static fromJS(data: any): UserEmail {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmail();
        result.init(data);
        return result;
    }

}

export interface IUserEmail {
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Email address */
    emailAddress: string;
}

/** Internal share recipient */
export class InternalRecipient extends DTOBase {
    /** User information of recipient. */
    recipient!: User;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;

    constructor(data?: IInternalRecipient) {
        super(data);
        this.setProp("object", "User", "recipient", true, (item: any) => User.fromJS(item));
        this.setProp("object", "string", "token", false);
        this.setProp("object", "string", "url", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.recipient = new User();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): InternalRecipient {
        return InternalRecipient.fromJS(data);
     }

    static fromJS(data: any): InternalRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new InternalRecipient();
        result.init(data);
        return result;
    }

}

/** Internal share recipient */
export interface IInternalRecipient {
    /** User information of recipient. */
    recipient: IUser;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;
}

export abstract class TemplateBase extends DTOBase {
    width?: number | undefined;
    height?: number | undefined;

    protected _kind: string;

    constructor(data?: ITemplateBase) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);

        this._kind = "TemplateBase";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TemplateBase {
        return TemplateBase.fromJS(data);
     }

    static fromJS(data: any): TemplateBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CardTemplate") {
            let result = new CardTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListTemplate") {
            let result = new ListTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BasicTemplate") {
            let result = new BasicTemplate();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TemplateBase' cannot be instantiated.");
    }

}

export interface ITemplateBase {
    width?: number | undefined;
    height?: number | undefined;
}

export class CardTemplate extends TemplateBase implements ICardTemplate {
    showNavigation!: boolean;
    showOverlay!: boolean;
    showLogo!: boolean;
    showFooter!: boolean;

    constructor(data?: ICardTemplate) {
        super(data);
        this.setProp("object", "boolean", "showNavigation", false);
        this.setProp("object", "boolean", "showOverlay", false);
        this.setProp("object", "boolean", "showLogo", false);
        this.setProp("object", "boolean", "showFooter", false);

        this._kind = "CardTemplate";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CardTemplate {
        return CardTemplate.fromJS(data);
     }

    static fromJS(data: any): CardTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new CardTemplate();
        result.init(data);
        return result;
    }

}

export interface ICardTemplate extends ITemplateBase {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;
}

export class ListTemplate extends TemplateBase implements IListTemplate {

    constructor(data?: IListTemplate) {
        super(data);

        this._kind = "ListTemplate";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ListTemplate {
        return ListTemplate.fromJS(data);
     }

    static fromJS(data: any): ListTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new ListTemplate();
        result.init(data);
        return result;
    }

}

export interface IListTemplate extends ITemplateBase {
}

export class BasicTemplate extends TemplateBase implements IBasicTemplate {

    constructor(data?: IBasicTemplate) {
        super(data);

        this._kind = "BasicTemplate";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BasicTemplate {
        return BasicTemplate.fromJS(data);
     }

    static fromJS(data: any): BasicTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new BasicTemplate();
        result.init(data);
        return result;
    }

}

export interface IBasicTemplate extends ITemplateBase {
}

export enum OutputAccess {
    Full = "Full",
    Preview = "Preview",
    None = "None",
}

export class BaseResultOfShare extends DTOBase {
    totalResults!: number;
    results!: Share[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfShare) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "Share[]", "results", true, (item: any) => Share.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfShare {
        return BaseResultOfShare.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfShare();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfShare {
    totalResults: number;
    results: IShare[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfShare extends BaseResultOfShare implements ISearchBehaviorBaseResultOfShare {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfShare) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfShare {
        return SearchBehaviorBaseResultOfShare.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfShare();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfShare extends IBaseResultOfShare {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result for share search operation */
export class ShareSearchResult extends SearchBehaviorBaseResultOfShare implements IShareSearchResult {

    constructor(data?: IShareSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareSearchResult {
        return ShareSearchResult.fromJS(data);
     }

    static fromJS(data: any): ShareSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSearchResult();
        result.init(data);
        return result;
    }

}

/** Result for share search operation */
export interface IShareSearchResult extends ISearchBehaviorBaseResultOfShare {
}

/** Share */
export class Share extends DTOBase {
    /** Share ID. */
    id!: string;
    /** Name of share. */
    name?: string | undefined;
    /** List of shared content IDs. */
    contentIds!: string[];
    /** Audit information. */
    audit!: UserAudit;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Type of share. */
    shareType!: ShareType;
    /** Share is readonly if the current user is not the creator but only the recipient. */
    isReadOnly!: boolean;

    constructor(data?: IShare) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "name", false);
        this.setProp("array", "string[]", "contentIds", false);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "Date", "expirationDate", false);
        this.setProp("object", "ShareType", "shareType", false);
        this.setProp("object", "boolean", "isReadOnly", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.contentIds = [];
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Share {
        return Share.fromJS(data);
     }

    static fromJS(data: any): Share {
        data = typeof data === 'object' ? data : {};
        let result = new Share();
        result.init(data);
        return result;
    }

}

/** Share */
export interface IShare {
    /** Share ID. */
    id: string;
    /** Name of share. */
    name?: string | undefined;
    /** List of shared content IDs. */
    contentIds: string[];
    /** Audit information. */
    audit: IUserAudit;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Type of share. */
    shareType: ShareType;
    /** Share is readonly if the current user is not the creator but only the recipient. */
    isReadOnly: boolean;
}

/** Request to search shares */
export class ShareSearchRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: IShareSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "debugMode", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareSearchRequest {
        return ShareSearchRequest.fromJS(data);
     }

    static fromJS(data: any): ShareSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search shares */
export interface IShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

/** Request to aggregate shares based on the specified aggregators */
export class ShareAggregationRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the list item should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;

    constructor(data?: IShareAggregationRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("array", "AggregationFilter[]", "aggregationFilters", true, (item: any) => AggregationFilter.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregators", true, (item: any) => AggregatorBase.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareAggregationRequest {
        return ShareAggregationRequest.fromJS(data);
     }

    static fromJS(data: any): ShareAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareAggregationRequest();
        result.init(data);
        return result;
    }

}

/** Request to aggregate shares based on the specified aggregators */
export interface IShareAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the list item should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Result of share creation */
export class CreateShareResult extends DTOBase {
    /** Share ID. */
    shareId?: string | undefined;

    constructor(data?: ICreateShareResult) {
        super(data);
        this.setProp("object", "string", "shareId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CreateShareResult {
        return CreateShareResult.fromJS(data);
     }

    static fromJS(data: any): CreateShareResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShareResult();
        result.init(data);
        return result;
    }

}

/** Result of share creation */
export interface ICreateShareResult {
    /** Share ID. */
    shareId?: string | undefined;
}

/** Base create request for share */
export abstract class ShareBaseCreateRequest extends DTOBase {
    /** Name of share. */
    name!: string;
    /** Optional description of share. */
    description?: string | undefined;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** List of contents including outputs to share. */
    contents!: ShareContent[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Configuration for template to use on the share detail page. */
    template?: TemplateBase | undefined;
    /** Access for content outputs in share. */
    outputAccess!: OutputAccess;

    protected _kind: string;

    constructor(data?: IShareBaseCreateRequest) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "string", "description", false);
        this.setProp("object", "Date", "expirationDate", false);
        this.setProp("array", "ShareContent[]", "contents", true, (item: any) => ShareContent.fromJS(item));
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "TemplateBase", "template", true, (item: any) => TemplateBase.fromJS(item));
        this.setProp("object", "OutputAccess", "outputAccess", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.contents = [];
        }
        this._kind = "ShareBaseCreateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareBaseCreateRequest {
        return ShareBaseCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ShareBaseCreateRequest {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareBasicCreateRequest") {
            let result = new ShareBasicCreateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedCreateRequest") {
            let result = new ShareEmbedCreateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseCreateRequest' cannot be instantiated.");
    }

}

/** Base create request for share */
export interface IShareBaseCreateRequest {
    /** Name of share. */
    name: string;
    /** Optional description of share. */
    description?: string | undefined;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** List of contents including outputs to share. */
    contents: IShareContent[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Configuration for template to use on the share detail page. */
    template?: TemplateBase | undefined;
    /** Access for content outputs in share. */
    outputAccess: OutputAccess;
}

export class ShareContent extends DTOBase {
    /** Content ID to share. */
    contentId!: string;
    /** List of output formats for this content to share. If not specified outer OutputAccess is used. */
    outputFormatIds?: string[] | undefined;

    constructor(data?: IShareContent) {
        super(data);
        this.setProp("object", "string", "contentId", false);
        this.setProp("array", "string[]", "outputFormatIds", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareContent {
        return ShareContent.fromJS(data);
     }

    static fromJS(data: any): ShareContent {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContent();
        result.init(data);
        return result;
    }

}

export interface IShareContent {
    /** Content ID to share. */
    contentId: string;
    /** List of output formats for this content to share. If not specified outer OutputAccess is used. */
    outputFormatIds?: string[] | undefined;
}

export class ShareBasicCreateRequest extends ShareBaseCreateRequest implements IShareBasicCreateRequest {
    /** List of external mail recipients which are no Picturepark users. */
    recipientsEmail?: UserEmail[] | undefined;
    /** List of internal recipients which are Picturepark users. */
    recipientsUser?: User[] | undefined;
    /** List of user roles. All assignees of these roles receive the share. */
    recipientsGroup?: UserRole[] | undefined;
    /** System language used for share (mail and detail page). en or de. */
    languageCode!: string;

    constructor(data?: IShareBasicCreateRequest) {
        super(data);
        this.setProp("array", "UserEmail[]", "recipientsEmail", true, (item: any) => UserEmail.fromJS(item));
        this.setProp("array", "User[]", "recipientsUser", true, (item: any) => User.fromJS(item));
        this.setProp("array", "UserRole[]", "recipientsGroup", true, (item: any) => UserRole.fromJS(item));
        this.setProp("object", "string", "languageCode", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "ShareBasicCreateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareBasicCreateRequest {
        return ShareBasicCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ShareBasicCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBasicCreateRequest();
        result.init(data);
        return result;
    }

}

export interface IShareBasicCreateRequest extends IShareBaseCreateRequest {
    /** List of external mail recipients which are no Picturepark users. */
    recipientsEmail?: IUserEmail[] | undefined;
    /** List of internal recipients which are Picturepark users. */
    recipientsUser?: IUser[] | undefined;
    /** List of user roles. All assignees of these roles receive the share. */
    recipientsGroup?: UserRole[] | undefined;
    /** System language used for share (mail and detail page). en or de. */
    languageCode: string;
}

/** Represents a user role, which associates users with user rights. */
export class UserRoleEditable extends DTOBase {
    /** Language specific user role names. */
    names!: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights!: UserRight[];

    constructor(data?: IUserRoleEditable) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("array", "UserRight[]", "userRights", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRights = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleEditable {
        return UserRoleEditable.fromJS(data);
     }

    static fromJS(data: any): UserRoleEditable {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleEditable();
        result.init(data);
        return result;
    }

}

/** Represents a user role, which associates users with user rights. */
export interface IUserRoleEditable {
    /** Language specific user role names. */
    names: ITranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights: UserRight[];
}

/** Represents a user role, which associates users with user rights. */
export class UserRole extends UserRoleEditable implements IUserRole {
    /** User role ID. */
    id?: string | undefined;

    constructor(data?: IUserRole) {
        super(data);
        this.setProp("object", "string", "id", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRole {
        return UserRole.fromJS(data);
     }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

}

/** Represents a user role, which associates users with user rights. */
export interface IUserRole extends IUserRoleEditable {
    /** User role ID. */
    id?: string | undefined;
}

/** Create request for embed share */
export class ShareEmbedCreateRequest extends ShareBaseCreateRequest implements IShareEmbedCreateRequest {

    constructor(data?: IShareEmbedCreateRequest) {
        super(data);

        this._kind = "ShareEmbedCreateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareEmbedCreateRequest {
        return ShareEmbedCreateRequest.fromJS(data);
     }

    static fromJS(data: any): ShareEmbedCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareEmbedCreateRequest();
        result.init(data);
        return result;
    }

}

/** Create request for embed share */
export interface IShareEmbedCreateRequest extends IShareBaseCreateRequest {
}

/** Base of update request for share */
export abstract class ShareBaseUpdateRequest extends DTOBase {
    /** Name of share. */
    name!: string;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Optional description of share. */
    description?: string | undefined;
    /** List of contents including outputs. Existing items needs to be sent again, otherwise they will be removed. */
    contents!: ShareContent[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Configuration for template to use on the share detail page. */
    template?: TemplateBase | undefined;
    /** Access for content outputs in share. */
    outputAccess!: OutputAccess;

    protected _kind: string;

    constructor(data?: IShareBaseUpdateRequest) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "Date", "expirationDate", false);
        this.setProp("object", "string", "description", false);
        this.setProp("array", "ShareContent[]", "contents", true, (item: any) => ShareContent.fromJS(item));
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "TemplateBase", "template", true, (item: any) => TemplateBase.fromJS(item));
        this.setProp("object", "OutputAccess", "outputAccess", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.contents = [];
        }
        this._kind = "ShareBaseUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareBaseUpdateRequest {
        return ShareBaseUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ShareBaseUpdateRequest {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareBasicUpdateRequest") {
            let result = new ShareBasicUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedUpdateRequest") {
            let result = new ShareEmbedUpdateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseUpdateRequest' cannot be instantiated.");
    }

}

/** Base of update request for share */
export interface IShareBaseUpdateRequest {
    /** Name of share. */
    name: string;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Optional description of share. */
    description?: string | undefined;
    /** List of contents including outputs. Existing items needs to be sent again, otherwise they will be removed. */
    contents: IShareContent[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Configuration for template to use on the share detail page. */
    template?: TemplateBase | undefined;
    /** Access for content outputs in share. */
    outputAccess: OutputAccess;
}

/** Update request for basic share */
export class ShareBasicUpdateRequest extends ShareBaseUpdateRequest implements IShareBasicUpdateRequest {

    constructor(data?: IShareBasicUpdateRequest) {
        super(data);

        this._kind = "ShareBasicUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareBasicUpdateRequest {
        return ShareBasicUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ShareBasicUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBasicUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Update request for basic share */
export interface IShareBasicUpdateRequest extends IShareBaseUpdateRequest {
}

/** Update request for embed share */
export class ShareEmbedUpdateRequest extends ShareBaseUpdateRequest implements IShareEmbedUpdateRequest {

    constructor(data?: IShareEmbedUpdateRequest) {
        super(data);

        this._kind = "ShareEmbedUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareEmbedUpdateRequest {
        return ShareEmbedUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): ShareEmbedUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareEmbedUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Update request for embed share */
export interface IShareEmbedUpdateRequest extends IShareBaseUpdateRequest {
}

export class ShareDeleteManyRequest extends DTOBase {
    /** IDs of shares to delete. */
    ids!: string[];

    constructor(data?: IShareDeleteManyRequest) {
        super(data);
        this.setProp("array", "string[]", "ids", false);

        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ShareDeleteManyRequest {
        return ShareDeleteManyRequest.fromJS(data);
     }

    static fromJS(data: any): ShareDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDeleteManyRequest();
        result.init(data);
        return result;
    }

}

export interface IShareDeleteManyRequest {
    /** IDs of shares to delete. */
    ids: string[];
}

/** Represents a transfer and includes detailed information. */
export class TransferDetail extends Transfer implements ITransferDetail {
    /** Audit information. */
    audit!: UserAudit;
    /** Number of items processed. */
    itemProgress!: number;
    /** Total number of items. */
    itemCount!: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount!: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount!: number;
    /** Number of items failed. */
    itemsFailed!: number;
    /** Number of items cancelled. */
    itemsCancelled!: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressTimeStamp?: Date | undefined;
    /** Time stamp of last progress update from upload. */
    lastFileUploadProgressTimeStamp?: Date | undefined;

    constructor(data?: ITransferDetail) {
        super(data);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "number", "itemProgress", false);
        this.setProp("object", "number", "itemCount", false);
        this.setProp("object", "number", "fileUploadInProgressCount", false);
        this.setProp("object", "number", "dataExtractionInProgressCount", false);
        this.setProp("object", "number", "itemsFailed", false);
        this.setProp("object", "number", "itemsCancelled", false);
        this.setProp("object", "Date", "lastDataExtractionProgressTimeStamp", false);
        this.setProp("object", "Date", "lastFileUploadProgressTimeStamp", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferDetail {
        return TransferDetail.fromJS(data);
     }

    static fromJS(data: any): TransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TransferDetail();
        result.init(data);
        return result;
    }

}

/** Represents a transfer and includes detailed information. */
export interface ITransferDetail extends ITransfer {
    /** Audit information. */
    audit: IUserAudit;
    /** Number of items processed. */
    itemProgress: number;
    /** Total number of items. */
    itemCount: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount: number;
    /** Number of items failed. */
    itemsFailed: number;
    /** Number of items cancelled. */
    itemsCancelled: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressTimeStamp?: Date | undefined;
    /** Time stamp of last progress update from upload. */
    lastFileUploadProgressTimeStamp?: Date | undefined;
}

export class BaseResultOfTransfer extends DTOBase {
    totalResults!: number;
    results!: Transfer[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfTransfer) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "Transfer[]", "results", true, (item: any) => Transfer.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfTransfer {
        return BaseResultOfTransfer.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfTransfer();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfTransfer {
    totalResults: number;
    results: ITransfer[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfTransfer extends BaseResultOfTransfer implements ISearchBehaviorBaseResultOfTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfTransfer) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfTransfer {
        return SearchBehaviorBaseResultOfTransfer.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfTransfer();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfTransfer extends IBaseResultOfTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result from a search for transfers. */
export class TransferSearchResult extends SearchBehaviorBaseResultOfTransfer implements ITransferSearchResult {

    constructor(data?: ITransferSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferSearchResult {
        return TransferSearchResult.fromJS(data);
     }

    static fromJS(data: any): TransferSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TransferSearchResult();
        result.init(data);
        return result;
    }

}

/** Result from a search for transfers. */
export interface ITransferSearchResult extends ISearchBehaviorBaseResultOfTransfer {
}

/** Request to search for transfers. */
export class TransferSearchRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the TransferSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: ITransferSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "debugMode", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferSearchRequest {
        return TransferSearchRequest.fromJS(data);
     }

    static fromJS(data: any): TransferSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransferSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search for transfers. */
export interface ITransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the TransferSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

/** Creates a transfer. */
export class CreateTransferRequest extends DTOBase {
    /** Name of transfer. */
    name!: string;
    /** Type of transfer. */
    transferType!: TransferType;
    /** Files uploaded in transfer. */
    files?: TransferUploadFile[] | undefined;
    /** Weblinks downloaded in transfer. */
    webLinks?: TransferWebLink[] | undefined;
    /** Name of collection created after transfer. */
    collectionName?: string | undefined;
    /** A value indicating whether to create a Collection after importing the transfer. */
    createCollection!: boolean;

    constructor(data?: ICreateTransferRequest) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "TransferType", "transferType", false);
        this.setProp("array", "TransferUploadFile[]", "files", true, (item: any) => TransferUploadFile.fromJS(item));
        this.setProp("array", "TransferWebLink[]", "webLinks", true, (item: any) => TransferWebLink.fromJS(item));
        this.setProp("object", "string", "collectionName", false);
        this.setProp("object", "boolean", "createCollection", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): CreateTransferRequest {
        return CreateTransferRequest.fromJS(data);
     }

    static fromJS(data: any): CreateTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransferRequest();
        result.init(data);
        return result;
    }

}

/** Creates a transfer. */
export interface ICreateTransferRequest {
    /** Name of transfer. */
    name: string;
    /** Type of transfer. */
    transferType: TransferType;
    /** Files uploaded in transfer. */
    files?: TransferUploadFile[] | undefined;
    /** Weblinks downloaded in transfer. */
    webLinks?: TransferWebLink[] | undefined;
    /** Name of collection created after transfer. */
    collectionName?: string | undefined;
    /** A value indicating whether to create a Collection after importing the transfer. */
    createCollection: boolean;
}

/** Represents the base class for transfer items. */
export abstract class TransferFile extends DTOBase {
    /** Replaced in favor of RequestId. Client generated identifier of the item. */
    identifier?: string | undefined;
    /** Client generated identifier of the item. */
    requestId?: string | undefined;

    constructor(data?: ITransferFile) {
        super(data);
        this.setProp("object", "string", "identifier", false);
        this.setProp("object", "string", "requestId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferFile {
        return TransferFile.fromJS(data);
     }

    static fromJS(data: any): TransferFile {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'TransferFile' cannot be instantiated.");
    }

}

/** Represents the base class for transfer items. */
export interface ITransferFile {
    /** Replaced in favor of RequestId. Client generated identifier of the item. */
    identifier?: string | undefined;
    /** Client generated identifier of the item. */
    requestId?: string | undefined;
}

/** Represents a file being uploaded in a transfer. */
export class TransferUploadFile extends TransferFile implements ITransferUploadFile {
    /** Target filename of file. */
    fileName!: string;

    constructor(data?: ITransferUploadFile) {
        super(data);
        this.setProp("object", "string", "fileName", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferUploadFile {
        return TransferUploadFile.fromJS(data);
     }

    static fromJS(data: any): TransferUploadFile {
        data = typeof data === 'object' ? data : {};
        let result = new TransferUploadFile();
        result.init(data);
        return result;
    }

}

/** Represents a file being uploaded in a transfer. */
export interface ITransferUploadFile extends ITransferFile {
    /** Target filename of file. */
    fileName: string;
}

/** Represents an item being downloaded by URL in a transfer. */
export class TransferWebLink extends TransferFile implements ITransferWebLink {
    /** URL of the item. */
    url!: string;

    constructor(data?: ITransferWebLink) {
        super(data);
        this.setProp("object", "string", "url", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): TransferWebLink {
        return TransferWebLink.fromJS(data);
     }

    static fromJS(data: any): TransferWebLink {
        data = typeof data === 'object' ? data : {};
        let result = new TransferWebLink();
        result.init(data);
        return result;
    }

}

/** Represents an item being downloaded by URL in a transfer. */
export interface ITransferWebLink extends ITransferFile {
    /** URL of the item. */
    url: string;
}

/** Representation of a file transfer. */
export class FileTransfer extends DTOBase {
    /** ID of file transfer. */
    id!: string;
    /** Name of file transfer. */
    name!: string;
    /** Replaced in favor of RequestId. Client provided identifier. */
    identifier?: string | undefined;
    /** Client provided identifier. */
    requestId!: string;
    /** ID of transfer. */
    transferId!: string;
    /** State of file transfer. */
    state!: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string | undefined;

    constructor(data?: IFileTransfer) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "string", "identifier", false);
        this.setProp("object", "string", "requestId", false);
        this.setProp("object", "string", "transferId", false);
        this.setProp("object", "FileTransferState", "state", false);
        this.setProp("object", "string", "contentId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransfer {
        return FileTransfer.fromJS(data);
     }

    static fromJS(data: any): FileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransfer();
        result.init(data);
        return result;
    }

}

/** Representation of a file transfer. */
export interface IFileTransfer {
    /** ID of file transfer. */
    id: string;
    /** Name of file transfer. */
    name: string;
    /** Replaced in favor of RequestId. Client provided identifier. */
    identifier?: string | undefined;
    /** Client provided identifier. */
    requestId: string;
    /** ID of transfer. */
    transferId: string;
    /** State of file transfer. */
    state: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string | undefined;
}

/** Detailed representation of file transfer. */
export class FileTransferDetail extends FileTransfer implements IFileTransferDetail {
    /** Audit information. */
    audit!: UserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata | undefined;
    /** Outputs rendered during data extraction phase. */
    outputItems?: FileTransferOutput[] | undefined;

    constructor(data?: IFileTransferDetail) {
        super(data);
        this.setProp("object", "UserAudit", "audit", true, (item: any) => UserAudit.fromJS(item));
        this.setProp("object", "FileMetadata", "fileMetadata", true, (item: any) => FileMetadata.fromJS(item));
        this.setProp("array", "FileTransferOutput[]", "outputItems", true, (item: any) => FileTransferOutput.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.audit = new UserAudit();
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferDetail {
        return FileTransferDetail.fromJS(data);
     }

    static fromJS(data: any): FileTransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferDetail();
        result.init(data);
        return result;
    }

}

/** Detailed representation of file transfer. */
export interface IFileTransferDetail extends IFileTransfer {
    /** Audit information. */
    audit: IUserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata | undefined;
    /** Outputs rendered during data extraction phase. */
    outputItems?: IFileTransferOutput[] | undefined;
}

export class FileMetadata extends DTOBase {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: any | undefined;
    exifMetadata?: any | undefined;
    language?: string | undefined;

    protected _kind: string;

    constructor(data?: IFileMetadata) {
        super(data);
        this.setProp("object", "TranslatedStringDictionary", "names", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "TranslatedStringDictionary", "descriptions", true, (item: any) => TranslatedStringDictionary.fromJS(item));
        this.setProp("object", "string", "fileExtension", false);
        this.setProp("object", "string", "fileName", false);
        this.setProp("object", "string", "filePath", false);
        this.setProp("object", "number", "fileSizeInBytes", false);
        this.setProp("object", "string", "sha1Hash", false);
        this.setProp("object", "any", "xmpMetadata", false);
        this.setProp("object", "any", "exifMetadata", false);
        this.setProp("object", "string", "language", false);

        if (data) {
            this.construct(data);
        }
        this._kind = "FileMetadata";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileMetadata {
        return FileMetadata.fromJS(data);
     }

    static fromJS(data: any): FileMetadata {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AudioMetadata") {
            let result = new AudioMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentMetadata") {
            let result = new DocumentMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageMetadata") {
            let result = new ImageMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoMetadata") {
            let result = new VideoMetadata();
            result.init(data);
            return result;
        }
        let result = new FileMetadata();
        result.init(data);
        return result;
    }

}

export interface IFileMetadata {
    names?: ITranslatedStringDictionary | undefined;
    descriptions?: ITranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: any | undefined;
    exifMetadata?: any | undefined;
    language?: string | undefined;
}

export class AudioMetadata extends FileMetadata implements IAudioMetadata {
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IAudioMetadata) {
        super(data);
        this.setProp("array", "AudioStream[]", "audioStreams", true, (item: any) => AudioStream.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "AudioMetadata";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AudioMetadata {
        return AudioMetadata.fromJS(data);
     }

    static fromJS(data: any): AudioMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new AudioMetadata();
        result.init(data);
        return result;
    }

}

export interface IAudioMetadata extends IFileMetadata {
    audioStreams?: IAudioStream[] | undefined;
}

export class AudioStream extends DTOBase {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;

    constructor(data?: IAudioStream) {
        super(data);
        this.setProp("object", "string", "bitRate", false);
        this.setProp("object", "string", "bitRateMode", false);
        this.setProp("object", "string", "channels", false);
        this.setProp("object", "string", "channelPositions", false);
        this.setProp("object", "string", "codec", false);
        this.setProp("object", "number", "durationInSeconds", false);
        this.setProp("object", "string", "format", false);
        this.setProp("object", "string", "language", false);
        this.setProp("object", "number", "resolution", false);
        this.setProp("object", "number", "samplingRate", false);
        this.setProp("object", "number", "streamSize", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): AudioStream {
        return AudioStream.fromJS(data);
     }

    static fromJS(data: any): AudioStream {
        data = typeof data === 'object' ? data : {};
        let result = new AudioStream();
        result.init(data);
        return result;
    }

}

export interface IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export class DocumentMetadata extends FileMetadata implements IDocumentMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount!: number;
    characterCountWithSpaces!: number;
    lineCount!: number;
    pageCount!: number;
    slideCount!: number;
    paragraphCount!: number;
    revisionNumber!: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;

    constructor(data?: IDocumentMetadata) {
        super(data);
        this.setProp("object", "string", "applicationName", false);
        this.setProp("object", "string", "applicationVersion", false);
        this.setProp("object", "string", "author", false);
        this.setProp("object", "string", "creator", false);
        this.setProp("object", "string", "publisher", false);
        this.setProp("object", "string", "company", false);
        this.setProp("object", "string", "documentTitle", false);
        this.setProp("object", "number", "characterCount", false);
        this.setProp("object", "number", "characterCountWithSpaces", false);
        this.setProp("object", "number", "lineCount", false);
        this.setProp("object", "number", "pageCount", false);
        this.setProp("object", "number", "slideCount", false);
        this.setProp("object", "number", "paragraphCount", false);
        this.setProp("object", "number", "revisionNumber", false);
        this.setProp("array", "string[]", "titles", false);
        this.setProp("array", "string[]", "imageTitles", false);
        this.setProp("object", "EpsMetadata", "epsInfo", true, (item: any) => EpsMetadata.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "DocumentMetadata";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): DocumentMetadata {
        return DocumentMetadata.fromJS(data);
     }

    static fromJS(data: any): DocumentMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentMetadata();
        result.init(data);
        return result;
    }

}

export interface IDocumentMetadata extends IFileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: IEpsMetadata | undefined;
}

export class EpsMetadata extends DTOBase {
    isRasterized!: boolean;
    widthInPoints!: number;
    heightInPoints!: number;

    constructor(data?: IEpsMetadata) {
        super(data);
        this.setProp("object", "boolean", "isRasterized", false);
        this.setProp("object", "number", "widthInPoints", false);
        this.setProp("object", "number", "heightInPoints", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): EpsMetadata {
        return EpsMetadata.fromJS(data);
     }

    static fromJS(data: any): EpsMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new EpsMetadata();
        result.init(data);
        return result;
    }

}

export interface IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export class ImageMetadata extends FileMetadata implements IImageMetadata {
    width!: number;
    height!: number;
    widthInInch!: number;
    heightInInch!: number;
    widthInCm!: number;
    heightInCm!: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel!: number;
    bitsPerChannel!: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha!: boolean;
    isIndexed!: boolean;
    isExtended!: boolean;
    horizontalResolution!: number;
    verticalResolution!: number;
    totalFrames!: number;
    totalUnspecifiedTiffExtraChannels!: number;
    hasExifData!: boolean;
    hasIptcData!: boolean;
    hasAdobeResourceData!: boolean;
    hasXmpData!: boolean;
    uncompressedSizeInBytes!: number;

    constructor(data?: IImageMetadata) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "number", "widthInInch", false);
        this.setProp("object", "number", "heightInInch", false);
        this.setProp("object", "number", "widthInCm", false);
        this.setProp("object", "number", "heightInCm", false);
        this.setProp("object", "string", "colorSpace", false);
        this.setProp("object", "string", "colorProfile", false);
        this.setProp("object", "number", "bitsPerPixel", false);
        this.setProp("object", "number", "bitsPerChannel", false);
        this.setProp("object", "string", "channels", false);
        this.setProp("object", "string", "pixelFormat", false);
        this.setProp("object", "boolean", "hasAlpha", false);
        this.setProp("object", "boolean", "isIndexed", false);
        this.setProp("object", "boolean", "isExtended", false);
        this.setProp("object", "number", "horizontalResolution", false);
        this.setProp("object", "number", "verticalResolution", false);
        this.setProp("object", "number", "totalFrames", false);
        this.setProp("object", "number", "totalUnspecifiedTiffExtraChannels", false);
        this.setProp("object", "boolean", "hasExifData", false);
        this.setProp("object", "boolean", "hasIptcData", false);
        this.setProp("object", "boolean", "hasAdobeResourceData", false);
        this.setProp("object", "boolean", "hasXmpData", false);
        this.setProp("object", "number", "uncompressedSizeInBytes", false);

        this._kind = "ImageMetadata";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ImageMetadata {
        return ImageMetadata.fromJS(data);
     }

    static fromJS(data: any): ImageMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ImageMetadata();
        result.init(data);
        return result;
    }

}

export interface IImageMetadata extends IFileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export class VideoMetadata extends FileMetadata implements IVideoMetadata {
    width!: number;
    height!: number;
    durationInSeconds!: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IVideoMetadata) {
        super(data);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "number", "durationInSeconds", false);
        this.setProp("object", "string", "format", false);
        this.setProp("object", "string", "codec", false);
        this.setProp("object", "number", "overallBitrate", false);
        this.setProp("array", "VideoStream[]", "videoStreams", true, (item: any) => VideoStream.fromJS(item));
        this.setProp("array", "AudioStream[]", "audioStreams", true, (item: any) => AudioStream.fromJS(item));

        if (data) {
            this.construct(data);
        }
        this._kind = "VideoMetadata";
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): VideoMetadata {
        return VideoMetadata.fromJS(data);
     }

    static fromJS(data: any): VideoMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new VideoMetadata();
        result.init(data);
        return result;
    }

}

export interface IVideoMetadata extends IFileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: IVideoStream[] | undefined;
    audioStreams?: IAudioStream[] | undefined;
}

export class VideoStream extends DTOBase {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds!: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;

    constructor(data?: IVideoStream) {
        super(data);
        this.setProp("object", "string", "bitRate", false);
        this.setProp("object", "string", "codec", false);
        this.setProp("object", "string", "displayAspectRatio", false);
        this.setProp("object", "number", "durationInSeconds", false);
        this.setProp("object", "string", "format", false);
        this.setProp("object", "number", "frameCount", false);
        this.setProp("object", "number", "frameRate", false);
        this.setProp("object", "number", "height", false);
        this.setProp("object", "string", "language", false);
        this.setProp("object", "number", "pixelAspectRatio", false);
        this.setProp("object", "number", "resolution", false);
        this.setProp("object", "number", "streamSize", false);
        this.setProp("object", "number", "width", false);
        this.setProp("object", "number", "rotation", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): VideoStream {
        return VideoStream.fromJS(data);
     }

    static fromJS(data: any): VideoStream {
        data = typeof data === 'object' ? data : {};
        let result = new VideoStream();
        result.init(data);
        return result;
    }

}

export interface IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export class FileTransferOutput extends DTOBase {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource!: OutputSource;

    constructor(data?: IFileTransferOutput) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "filePath", false);
        this.setProp("object", "OutputSource", "outputSource", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferOutput {
        return FileTransferOutput.fromJS(data);
     }

    static fromJS(data: any): FileTransferOutput {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferOutput();
        result.init(data);
        return result;
    }

}

export interface IFileTransferOutput {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = "Rendered",
    Embedded = "Embedded",
}

export enum FileTransferState {
    Draft = "Draft",
    UploadInProgress = "UploadInProgress",
    UploadCompleted = "UploadCompleted",
    DataExtractionInProgress = "DataExtractionInProgress",
    DataExtractionDone = "DataExtractionDone",
    ImportInProgress = "ImportInProgress",
    ImportCompleted = "ImportCompleted",
    UploadCancelled = "UploadCancelled",
    ImportCancelled = "ImportCancelled",
    UploadFailed = "UploadFailed",
    ImportFailed = "ImportFailed",
    DeleteInProgress = "DeleteInProgress",
    Deleted = "Deleted",
    CleanupInProgress = "CleanupInProgress",
    CleanupCompleted = "CleanupCompleted",
}

export class BaseResultOfFileTransfer extends DTOBase {
    totalResults!: number;
    results!: FileTransfer[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfFileTransfer) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "FileTransfer[]", "results", true, (item: any) => FileTransfer.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfFileTransfer {
        return BaseResultOfFileTransfer.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfFileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfFileTransfer {
    totalResults: number;
    results: IFileTransfer[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfFileTransfer extends BaseResultOfFileTransfer implements ISearchBehaviorBaseResultOfFileTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfFileTransfer) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfFileTransfer {
        return SearchBehaviorBaseResultOfFileTransfer.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfFileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfFileTransfer extends IBaseResultOfFileTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Result from a search for file transfers. */
export class FileTransferSearchResult extends SearchBehaviorBaseResultOfFileTransfer implements IFileTransferSearchResult {

    constructor(data?: IFileTransferSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferSearchResult {
        return FileTransferSearchResult.fromJS(data);
     }

    static fromJS(data: any): FileTransferSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferSearchResult();
        result.init(data);
        return result;
    }

}

/** Result from a search for file transfers. */
export interface IFileTransferSearchResult extends ISearchBehaviorBaseResultOfFileTransfer {
}

/** Request to search for file transfers. */
export class FileTransferSearchRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFileTransferSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferSearchRequest {
        return FileTransferSearchRequest.fromJS(data);
     }

    static fromJS(data: any): FileTransferSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferSearchRequest();
        result.init(data);
        return result;
    }

}

/** Request to search for file transfers. */
export interface IFileTransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
}

/** Blacklist containing file name patterns skipped when uploading. */
export class Blacklist extends DTOBase {
    /** Blacklist entries. */
    items!: BlacklistItem[];

    constructor(data?: IBlacklist) {
        super(data);
        this.setProp("array", "BlacklistItem[]", "items", true, (item: any) => BlacklistItem.fromJS(item));

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): Blacklist {
        return Blacklist.fromJS(data);
     }

    static fromJS(data: any): Blacklist {
        data = typeof data === 'object' ? data : {};
        let result = new Blacklist();
        result.init(data);
        return result;
    }

}

/** Blacklist containing file name patterns skipped when uploading. */
export interface IBlacklist {
    /** Blacklist entries. */
    items: IBlacklistItem[];
}

/** Entry in the Blacklist. */
export class BlacklistItem extends DTOBase {
    /** Friendly name of item. */
    name!: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match!: string;

    constructor(data?: IBlacklistItem) {
        super(data);
        this.setProp("object", "string", "name", false);
        this.setProp("object", "string", "match", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BlacklistItem {
        return BlacklistItem.fromJS(data);
     }

    static fromJS(data: any): BlacklistItem {
        data = typeof data === 'object' ? data : {};
        let result = new BlacklistItem();
        result.init(data);
        return result;
    }

}

/** Entry in the Blacklist. */
export interface IBlacklistItem {
    /** Friendly name of item. */
    name: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match: string;
}

/** Deletes files from transfer. */
export class FileTransferDeleteRequest extends DTOBase {
    /** ID of transfer. */
    transferId!: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds!: string[];

    constructor(data?: IFileTransferDeleteRequest) {
        super(data);
        this.setProp("object", "string", "transferId", false);
        this.setProp("array", "string[]", "fileTransferIds", false);

        if (!data) {
            this.fileTransferIds = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferDeleteRequest {
        return FileTransferDeleteRequest.fromJS(data);
     }

    static fromJS(data: any): FileTransferDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferDeleteRequest();
        result.init(data);
        return result;
    }

}

/** Deletes files from transfer. */
export interface IFileTransferDeleteRequest {
    /** ID of transfer. */
    transferId: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds: string[];
}

export class ImportTransferRequest extends DTOBase {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IImportTransferRequest) {
        super(data);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "DataDictionary", "metadata", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("array", "string[]", "contentPermissionSetIds", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ImportTransferRequest {
        return ImportTransferRequest.fromJS(data);
     }

    static fromJS(data: any): ImportTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTransferRequest();
        result.init(data);
        return result;
    }

}

export interface IImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: IDataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class ImportTransferPartialRequest extends DTOBase {
    items?: FileTransferCreateItem[] | undefined;

    constructor(data?: IImportTransferPartialRequest) {
        super(data);
        this.setProp("array", "FileTransferCreateItem[]", "items", true, (item: any) => FileTransferCreateItem.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): ImportTransferPartialRequest {
        return ImportTransferPartialRequest.fromJS(data);
     }

    static fromJS(data: any): ImportTransferPartialRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTransferPartialRequest();
        result.init(data);
        return result;
    }

}

export interface IImportTransferPartialRequest {
    items?: IFileTransferCreateItem[] | undefined;
}

export class FileTransferCreateItem extends DTOBase {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransferCreateItem) {
        super(data);
        this.setProp("object", "string", "fileId", false);
        this.setProp("array", "string[]", "layerSchemaIds", false);
        this.setProp("object", "DataDictionary", "metadata", true, (item: any) => DataDictionary.fromJS(item));
        this.setProp("array", "string[]", "contentPermissionSetIds", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): FileTransferCreateItem {
        return FileTransferCreateItem.fromJS(data);
     }

    static fromJS(data: any): FileTransferCreateItem {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferCreateItem();
        result.init(data);
        return result;
    }

}

export interface IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: IDataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

/** Represents the updateable fields of the user. */
export class UserUpdateRequest extends User implements IUserUpdateRequest {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: UserRole[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** User's address. */
    address?: UserAddress | undefined;

    constructor(data?: IUserUpdateRequest) {
        super(data);
        this.setProp("array", "UserRole[]", "userRoles", true, (item: any) => UserRole.fromJS(item));
        this.setProp("object", "string", "comment", false);
        this.setProp("object", "string", "languageCode", false);
        this.setProp("object", "UserAddress", "address", true, (item: any) => UserAddress.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserUpdateRequest {
        return UserUpdateRequest.fromJS(data);
     }

    static fromJS(data: any): UserUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateRequest();
        result.init(data);
        return result;
    }

}

/** Represents the updateable fields of the user. */
export interface IUserUpdateRequest extends IUser {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: UserRole[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** User's address. */
    address?: IUserAddress | undefined;
}

/** Detail information about a user. */
export class UserDetail extends UserUpdateRequest implements IUserDetail {
    /** Owner tokens referencing the user. */
    ownerTokens?: OwnerToken[] | undefined;
    /** Authorization state the user is currently in. */
    authorizationState!: AuthorizationState;
    /** Locked users are unable to log in and use the system. */
    isLocked!: boolean;
    /** Life cycle state the user is currently in. */
    lifeCycle!: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser!: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly!: boolean;

    constructor(data?: IUserDetail) {
        super(data);
        this.setProp("array", "OwnerToken[]", "ownerTokens", true, (item: any) => OwnerToken.fromJS(item));
        this.setProp("object", "AuthorizationState", "authorizationState", false);
        this.setProp("object", "boolean", "isLocked", false);
        this.setProp("object", "LifeCycle", "lifeCycle", false);
        this.setProp("object", "boolean", "isSupportUser", false);
        this.setProp("object", "boolean", "isReadOnly", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserDetail {
        return UserDetail.fromJS(data);
     }

    static fromJS(data: any): UserDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetail();
        result.init(data);
        return result;
    }

}

/** Detail information about a user. */
export interface IUserDetail extends IUserUpdateRequest {
    /** Owner tokens referencing the user. */
    ownerTokens?: IOwnerToken[] | undefined;
    /** Authorization state the user is currently in. */
    authorizationState: AuthorizationState;
    /** Locked users are unable to log in and use the system. */
    isLocked: boolean;
    /** Life cycle state the user is currently in. */
    lifeCycle: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly: boolean;
}

export class OwnerToken extends DTOBase {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;

    constructor(data?: IOwnerToken) {
        super(data);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "userId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): OwnerToken {
        return OwnerToken.fromJS(data);
     }

    static fromJS(data: any): OwnerToken {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerToken();
        result.init(data);
        return result;
    }

}

export interface IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;
}

/** Holds information needed for user creation. */
export class UserCreateRequest extends DTOBase {
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress!: string;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** IDs of user roles the user is assigned to. */
    userRoleIds?: string[] | undefined;
    /** User address. */
    address?: UserAddress | undefined;

    constructor(data?: IUserCreateRequest) {
        super(data);
        this.setProp("object", "string", "firstName", false);
        this.setProp("object", "string", "lastName", false);
        this.setProp("object", "string", "emailAddress", false);
        this.setProp("object", "string", "languageCode", false);
        this.setProp("array", "string[]", "userRoleIds", false);
        this.setProp("object", "UserAddress", "address", true, (item: any) => UserAddress.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserCreateRequest {
        return UserCreateRequest.fromJS(data);
     }

    static fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

}

/** Holds information needed for user creation. */
export interface IUserCreateRequest {
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** IDs of user roles the user is assigned to. */
    userRoleIds?: string[] | undefined;
    /** User address. */
    address?: IUserAddress | undefined;
}

export class BaseResultOfUserWithRoles extends DTOBase {
    totalResults!: number;
    results!: UserWithRoles[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfUserWithRoles) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "UserWithRoles[]", "results", true, (item: any) => UserWithRoles.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (data) {
            this.construct(data);
        }
        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfUserWithRoles {
        return BaseResultOfUserWithRoles.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfUserWithRoles {
    totalResults: number;
    results: IUserWithRoles[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfUserWithRoles extends BaseResultOfUserWithRoles implements ISearchBehaviorBaseResultOfUserWithRoles {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfUserWithRoles) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfUserWithRoles {
        return SearchBehaviorBaseResultOfUserWithRoles.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfUserWithRoles extends IBaseResultOfUserWithRoles {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Holds results of the user search. */
export class UserSearchResult extends SearchBehaviorBaseResultOfUserWithRoles implements IUserSearchResult {

    constructor(data?: IUserSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserSearchResult {
        return UserSearchResult.fromJS(data);
     }

    static fromJS(data: any): UserSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

}

/** Holds results of the user search. */
export interface IUserSearchResult extends ISearchBehaviorBaseResultOfUserWithRoles {
}

/** User information retrieved via search */
export class UserWithRoles extends DTOBase {
    /** IDs of user roles user is assigned to */
    userRoleIds?: string[] | undefined;
    /** User's Picturepark ID. */
    id?: string | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress!: string;
    /** Authorization state the user is currently in. */
    authorizationState!: AuthorizationState;
    /** Life cycle state the user is currently in. */
    lifeCycle!: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser!: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly!: boolean;

    constructor(data?: IUserWithRoles) {
        super(data);
        this.setProp("array", "string[]", "userRoleIds", false);
        this.setProp("object", "string", "id", false);
        this.setProp("object", "string", "firstName", false);
        this.setProp("object", "string", "lastName", false);
        this.setProp("object", "string", "emailAddress", false);
        this.setProp("object", "AuthorizationState", "authorizationState", false);
        this.setProp("object", "LifeCycle", "lifeCycle", false);
        this.setProp("object", "boolean", "isSupportUser", false);
        this.setProp("object", "boolean", "isReadOnly", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserWithRoles {
        return UserWithRoles.fromJS(data);
     }

    static fromJS(data: any): UserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRoles();
        result.init(data);
        return result;
    }

}

/** User information retrieved via search */
export interface IUserWithRoles {
    /** IDs of user roles user is assigned to */
    userRoleIds?: string[] | undefined;
    /** User's Picturepark ID. */
    id?: string | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Authorization state the user is currently in. */
    authorizationState: AuthorizationState;
    /** Life cycle state the user is currently in. */
    lifeCycle: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly: boolean;
}

/** Represents user search request. */
export class UserSearchRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to users. */
    filter?: FilterBase | undefined;
    /** Return only users in certain life cycle state(s). */
    lifeCycleFilter!: LifeCycleFilter;
    /** Return only users with certain user rights. */
    userRightsFilter?: UserRight[] | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode!: boolean;
    includeServiceUser!: boolean;

    constructor(data?: IUserSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "LifeCycleFilter", "lifeCycleFilter", false);
        this.setProp("array", "UserRight[]", "userRightsFilter", false);
        this.setProp("object", "boolean", "debugMode", false);
        this.setProp("object", "boolean", "includeServiceUser", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserSearchRequest {
        return UserSearchRequest.fromJS(data);
     }

    static fromJS(data: any): UserSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchRequest();
        result.init(data);
        return result;
    }

}

/** Represents user search request. */
export interface IUserSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to users. */
    filter?: FilterBase | undefined;
    /** Return only users in certain life cycle state(s). */
    lifeCycleFilter: LifeCycleFilter;
    /** Return only users with certain user rights. */
    userRightsFilter?: UserRight[] | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode: boolean;
    includeServiceUser: boolean;
}

/** Represents an aggregation request over users. */
export class UserAggregationRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators used while evaluating the request. */
    aggregators?: AggregatorBase[] | undefined;

    constructor(data?: IUserAggregationRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("array", "AggregationFilter[]", "aggregationFilters", true, (item: any) => AggregationFilter.fromJS(item));
        this.setProp("array", "AggregatorBase[]", "aggregators", true, (item: any) => AggregatorBase.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserAggregationRequest {
        return UserAggregationRequest.fromJS(data);
     }

    static fromJS(data: any): UserAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserAggregationRequest();
        result.init(data);
        return result;
    }

}

/** Represents an aggregation request over users. */
export interface IUserAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: ISortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down the aggregations' values on specific conditions. The behavior is different when
filtering an aggregation that matches the same AggregationName or another aggregation.
In the first case, the filter is put in "or" with (eventual) other existing filters. In the second case it is put in "and". */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators used while evaluating the request. */
    aggregators?: AggregatorBase[] | undefined;
}

export class UserLockRequest extends DTOBase {
    /** Indicates the requested lock state of the user.
If _true_ was specified, the user will be _locked_. _False_ will unlock the previously _locked_ user. */
    lock!: boolean;

    constructor(data?: IUserLockRequest) {
        super(data);
        this.setProp("object", "boolean", "lock", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserLockRequest {
        return UserLockRequest.fromJS(data);
     }

    static fromJS(data: any): UserLockRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockRequest();
        result.init(data);
        return result;
    }

}

export interface IUserLockRequest {
    /** Indicates the requested lock state of the user.
If _true_ was specified, the user will be _locked_. _False_ will unlock the previously _locked_ user. */
    lock: boolean;
}

/** Holds additional information for user review. */
export class UserReviewRequest extends DTOBase {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed!: boolean;

    constructor(data?: IUserReviewRequest) {
        super(data);
        this.setProp("object", "boolean", "reviewed", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserReviewRequest {
        return UserReviewRequest.fromJS(data);
     }

    static fromJS(data: any): UserReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserReviewRequest();
        result.init(data);
        return result;
    }

}

/** Holds additional information for user review. */
export interface IUserReviewRequest {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed: boolean;
}

/** Details of the user deletion. */
export class UserDeleteRequest extends DTOBase {
    /** User ID of user who will take over the ownership of the content currently owned by the deleted user. */
    ownerTokenTransferUserId?: string | undefined;

    constructor(data?: IUserDeleteRequest) {
        super(data);
        this.setProp("object", "string", "ownerTokenTransferUserId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserDeleteRequest {
        return UserDeleteRequest.fromJS(data);
     }

    static fromJS(data: any): UserDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserDeleteRequest();
        result.init(data);
        return result;
    }

}

/** Details of the user deletion. */
export interface IUserDeleteRequest {
    /** User ID of user who will take over the ownership of the content currently owned by the deleted user. */
    ownerTokenTransferUserId?: string | undefined;
}

export class BaseResultOfUserRole extends DTOBase {
    totalResults!: number;
    results!: UserRole[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfUserRole) {
        super(data);
        this.setProp("object", "number", "totalResults", false);
        this.setProp("array", "UserRole[]", "results", true, (item: any) => UserRole.fromJS(item));
        this.setProp("object", "number", "elapsedMilliseconds", false);
        this.setProp("object", "string", "pageToken", false);

        if (!data) {
            this.results = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): BaseResultOfUserRole {
        return BaseResultOfUserRole.fromJS(data);
     }

    static fromJS(data: any): BaseResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUserRole();
        result.init(data);
        return result;
    }

}

export interface IBaseResultOfUserRole {
    totalResults: number;
    results: UserRole[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfUserRole extends BaseResultOfUserRole implements ISearchBehaviorBaseResultOfUserRole {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfUserRole) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("object", "boolean", "isSearchStringRewritten", false);
        this.setProp("object", "QueryDebugInformation", "queryDebugInformation", true, (item: any) => QueryDebugInformation.fromJS(item));

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): SearchBehaviorBaseResultOfUserRole {
        return SearchBehaviorBaseResultOfUserRole.fromJS(data);
     }

    static fromJS(data: any): SearchBehaviorBaseResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfUserRole();
        result.init(data);
        return result;
    }

}

export interface ISearchBehaviorBaseResultOfUserRole extends IBaseResultOfUserRole {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Holds results of the user role search. */
export class UserRoleSearchResult extends SearchBehaviorBaseResultOfUserRole implements IUserRoleSearchResult {

    constructor(data?: IUserRoleSearchResult) {
        super(data);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleSearchResult {
        return UserRoleSearchResult.fromJS(data);
     }

    static fromJS(data: any): UserRoleSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleSearchResult();
        result.init(data);
        return result;
    }

}

/** Holds results of the user role search. */
export interface IUserRoleSearchResult extends ISearchBehaviorBaseResultOfUserRole {
}

export class UserRoleSearchRequest extends DTOBase {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to user roles. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode!: boolean;
    /** Which languages to search against when using the search string. */
    searchLanguages?: string[] | undefined;
    /** Defines if the user roles with system user role Administrator is returned. */
    includeAdministratorSystemUserRole!: boolean;

    constructor(data?: IUserRoleSearchRequest) {
        super(data);
        this.setProp("object", "string", "searchString", false);
        this.setProp("array", "SearchBehavior[]", "searchBehaviors", false);
        this.setProp("array", "SortInfo[]", "sort", true, (item: any) => SortInfo.fromJS(item));
        this.setProp("object", "number", "limit", false);
        this.setProp("object", "string", "pageToken", false);
        this.setProp("object", "FilterBase", "filter", true, (item: any) => FilterBase.fromJS(item));
        this.setProp("object", "boolean", "debugMode", false);
        this.setProp("array", "string[]", "searchLanguages", false);
        this.setProp("object", "boolean", "includeAdministratorSystemUserRole", false);

        if (data) {
            this.construct(data);
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleSearchRequest {
        return UserRoleSearchRequest.fromJS(data);
     }

    static fromJS(data: any): UserRoleSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleSearchRequest();
        result.init(data);
        return result;
    }

}

export interface IUserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to user roles. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Which languages to search against when using the search string. */
    searchLanguages?: string[] | undefined;
    /** Defines if the user roles with system user role Administrator is returned. */
    includeAdministratorSystemUserRole: boolean;
}

/** Holds information needed for user role creation. */
export class UserRoleCreateRequest extends UserRoleEditable implements IUserRoleCreateRequest {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IUserRoleCreateRequest) {
        super(data);
        this.setProp("object", "string", "requestId", false);

    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleCreateRequest {
        return UserRoleCreateRequest.fromJS(data);
     }

    static fromJS(data: any): UserRoleCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleCreateRequest();
        result.init(data);
        return result;
    }

}

/** Holds information needed for user role creation. */
export interface IUserRoleCreateRequest extends IUserRoleEditable {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Holds information needed to create multiple user roles. */
export class UserRoleCreateManyRequest extends DTOBase {
    /** Multiple user creation requests. */
    items!: UserRoleCreateRequest[];

    constructor(data?: IUserRoleCreateManyRequest) {
        super(data);
        this.setProp("array", "UserRoleCreateRequest[]", "items", true, (item: any) => UserRoleCreateRequest.fromJS(item));

        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleCreateManyRequest {
        return UserRoleCreateManyRequest.fromJS(data);
     }

    static fromJS(data: any): UserRoleCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleCreateManyRequest();
        result.init(data);
        return result;
    }

}

/** Holds information needed to create multiple user roles. */
export interface IUserRoleCreateManyRequest {
    /** Multiple user creation requests. */
    items: UserRoleCreateRequest[];
}

/** Holds information about which user roles and how are requested to be updated. */
export class UserRoleUpdateManyRequest extends DTOBase {
    /** New value for user roles with specified IDs. */
    items!: UserRole[];

    constructor(data?: IUserRoleUpdateManyRequest) {
        super(data);
        this.setProp("array", "UserRole[]", "items", true, (item: any) => UserRole.fromJS(item));

        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleUpdateManyRequest {
        return UserRoleUpdateManyRequest.fromJS(data);
     }

    static fromJS(data: any): UserRoleUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleUpdateManyRequest();
        result.init(data);
        return result;
    }

}

/** Holds information about which user roles and how are requested to be updated. */
export interface IUserRoleUpdateManyRequest {
    /** New value for user roles with specified IDs. */
    items: UserRole[];
}

/** Holds information about which user roles are requested to be deleted. */
export class UserRoleDeleteManyRequest extends DTOBase {
    /** IDs of the user roles to delete. */
    ids!: string[];

    constructor(data?: IUserRoleDeleteManyRequest) {
        super(data);
        this.setProp("array", "string[]", "ids", false);

        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        super.init(data);
    }

     fromJS(data: any): UserRoleDeleteManyRequest {
        return UserRoleDeleteManyRequest.fromJS(data);
     }

    static fromJS(data: any): UserRoleDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDeleteManyRequest();
        result.init(data);
        return result;
    }

}

/** Holds information about which user roles are requested to be deleted. */
export interface IUserRoleDeleteManyRequest {
    /** IDs of the user roles to delete. */
    ids: string[];
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}

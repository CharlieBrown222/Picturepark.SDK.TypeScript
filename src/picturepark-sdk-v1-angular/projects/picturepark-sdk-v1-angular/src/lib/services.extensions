import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core'; // ignore
import { Observable } from 'rxjs/Observable'; // ignore
import { PICTUREPARK_API_URL, ThumbnailSize, FileResponse } from './services'; // ignore

import { PictureparkServiceBase } from './base.service';
import * as generated from './services';

export abstract class DTOBase {
    // tslint:disable-next-line: variable-name
    private _fields: {
        type: 'object' | 'array' | 'dictionary';
        propertyName: string;
        supportsConstructorConversion: boolean;
        builder?: (item: any) => any;
    }[] = [];

    constructor(data?: any) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property)) {
                    (this)[property] = (data)[property];
                }
            }
        }
    }

    init(data?: any) {
        this._fields.forEach(field => {
            switch(field.type) {
                case "array":
                    if (Array.isArray(data[field.propertyName])) {
                        this[field.propertyName] = [] as any;
                        for (let item of data[field.propertyName]) {
                            if(field.supportsConstructorConversion === true) {
                                this[field.propertyName].push(field.builder!(item));
                            } else {
                                this[field.propertyName].push(item);
                            }
                        }
                    }
                    break;
                case "object":
                        if(field.supportsConstructorConversion === true) {
                            this[field.propertyName] = data[field.propertyName] ? field.builder!(data[field.propertyName]) : <any>undefined;
                        } else {
                            this[field.propertyName] = data[field.propertyName];
                        }
                    break;
                case "dictionary":
                    if (data[field.propertyName]) {
                        this[field.propertyName] = {} as any;
                        for (let key in data[field.propertyName]) {
                            if (data[field.propertyName].hasOwnProperty(key))
                                this[field.propertyName][key] = data[field.propertyName][key];
                        }
                    }
                    break;
            }
        });
    }

    construct(data?: any): void {
        this._fields.forEach(field => {
            if (!field.supportsConstructorConversion) {
                return;
            }

            switch (field.type) {
                case 'array':
                    this.constructArray(data, field.propertyName, field.builder);
                    break;
                case 'dictionary':
                    this.constructDict(data, field.propertyName, field.builder);
                    break;
                case 'object':
                    this.constructObject(data, field.propertyName, field.builder);
                    break;
            }
        });
    }

    setProp(
        type: 'object' | 'array' | 'dictionary',
        propertyName: string,
        supportsConstructorConversion: boolean,
        builder?: (item: any) => any
    ): void {
        this._fields.push({type, supportsConstructorConversion, propertyName, builder});
    }

    constructArray<T>(data: any, propertyName: string, builder?: (item: any) => T): void {
        if (data[propertyName]) {
            this[propertyName] = [];
            for (let i = 0; i < data[propertyName].length; i++) {
                const item = data[propertyName][i];
                this[propertyName][i] = item && !(item as any).toJSON  && builder ? builder(item) : item as T;
            }
        }
    }

    constructDict<T>(data: any, propertyName: string, builder?: (item: any) => T): void {
        if (data[propertyName]) {
            this[propertyName] = {};
            for (const key in data[propertyName]) {
                if (data[propertyName].hasOwnProperty(key)) {
                    const item = data[propertyName][key];
                    this[propertyName][key] = item && !(item as any).toJSON && builder ? builder(item) : item as T;
                }
            }
        }
    }

    constructObject<T>(data: any, propertyName: string, builder?: (item: any) => T): void {
        this[propertyName] = data[propertyName] && !(data[propertyName] as any).toJSON && builder
            ? builder(data[propertyName]) : this[propertyName] as T;
    }
}

class TranslatedStringDictionary extends generated.TranslatedStringDictionary {
    translate(locale: string) {
        const language = locale.split('-')[0];
        return this[language] ? this[language] : this[Object.keys(this)[0]];
    }
}

class FilterBase extends generated.FilterBase {
    getDisplayName(locale: string): string | null {
        return null;
    }
}

class DateRangeFilter extends generated.DateRangeFilter {
    getDisplayName(locale: string) {
        return this.range && this.range.names ? this.range.names.translate(locale) : 'n/a';
    }
}

class AggregationResultItem extends generated.AggregationResultItem {    
    getDisplayName(locale: string) {
        let displayName;

        // remove guid and show only owner name. example: name: "534e5b3763f242629eca53e764d713bf/cp support"
        if (this.filter && this.filter.aggregationName === 'ownerTokenId') {
          displayName = this.name.split("/").pop() || null;
        } else {
          displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null;
        }
        
        return displayName ? displayName : this.name;
    }
}

export abstract class AuthService {
    private _pictureparkApiUrl: string;

    constructor(pictureparkApiUrl: string) {
        this._pictureparkApiUrl = pictureparkApiUrl;
    }

    get apiServer() {
        return this._pictureparkApiUrl;
    }

    abstract get isAuthenticated(): boolean;
    abstract transformHttpRequestOptions(options: any): Promise<any>;
}
